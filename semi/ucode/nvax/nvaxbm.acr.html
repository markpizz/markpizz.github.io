;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    1
;			     Table of Contents									      /REV=
;
; 1	EBM.MIC -- Conditional Assembly Switches for the behavioral Model
; 2	Revision 1.0
; 28		Revision History
; 34		Conditional Assembly Switches
; 46	REV.MIC -- Microcode Revision Number
; 47	Revision 3.0
; 73		Revision History
; 89		Definition for Microcode Revision Number
; 126		Default for Microcode Patch Number
; 150	DEFINE.MIC -- Microword Definitions for NVAX Microcode
; 151	Revision 1.4
; 189		Revision History
; 279		Defaults for Conditional Assembly Switches
; 301		Introduction
; 315		Microword Formats
; 359		Standard Microinstruction Format
; 1031		Special Microinstruction Format
; 1119		Microsequencer Control Fields
; 1207		Simulation and Assembly Control Fields
; 1371		Validity Checks
; 1414	MACRO.MIC -- Macro Definitions
; 1415	Revision 1.1
; 1441		Revision History
; 1480		ALU Macros
; 1737		MEMREQ Macros
; 1770		SHIFT Macros
; 1873		SPECIAL Macros
; 1890		Q, L, V Field Macros
; 1898		MISC Field Macros
; 1921		Microsequencer Control Macros
; 1934		A/B Select Macros
; 1940		Error Macros
; 1953		Simulator Control Macros
; 1978	ALIGN.MIC -- Hardware Entry Point Assignments
; 1979	Revision 1.0
; 2005		Revision History
; 2061		Exception Dispatches
; 2094		Instruction Dispatches
; 2201	POWERUP.MIC -- Powerup Initialization
; 2202	Revision 1.5
; 2228		Revision History
; 2305		Powerup Initialization
; 2386		Powerup Entry Point
; 2429		Console Halt Entry Point
; 2683	INTEXC.MIC -- Interrupts and Exceptions
; 2684	Revision 1.6
; 2710		Revision History
; 3081		Instruction Dispatch Stall
; 3113		Branch Mispredict Microtrap
; 3157		FPD -- PSL<fpd> Set
; 3400		Double Parameter Exceptions -- Memory Management Fault
; 3738		Single Parameter Exceptions -- Arithmetic Traps and Faults
; 3904		Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV
; 4090		Hardware Error
; 4152		Machine Check Exception
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    2
;			     Table of Contents									      /REV=
;
; 4374		Interrupts
; 4820		Interrupt and Exception Handling Subroutines
; 5052		CPU Cleanup Subroutine
; 5257	INTLOGADR.MIC -- Integer, Logical, and Address Class Instructions
; 5258	Revision 1.0
; 5284		Revision History
; 5436		TSTx
; 5477		INCx, DECx
; 5535		CLRx
; 5590		CMPx, BITx
; 5648		ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC
; 5859		MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx, MNEGx
; 5987		ADAWI
; 6077		CVTBW, CVTBL, CVTWL
; 6135		CVTWB, CVTLB, CVTLW
; 6218		ROTL
; 6264		ASHL
; 6390		ASHQ
; 6593	VFIELD.MIC -- Variable-Length Bit Field Instructions
; 6594	Revision 1.1
; 6620		Revision History
; 6713		FFS, FFC, CMPV, CMPZV, EXTV, EXTZV
; 7241		INSV
; 7627	CTRL.MIC -- Control Instructions
; 7628	Revision 1.0
; 7654		Revision History
; 7739		BRx, Bxx, JMP
; 7836		BSBB, BSBW, JSB
; 7904		RSB
; 7945		CASEx
; 8061		SOBGTR, SOBGEQ
; 8111		AOBLSS, AOBLEQ
; 8167		ACBx
; 8275		BBx, BBxS, BBxC, BBxxI
; 8617		BLBx
; 8663	MULDIV.MIC -- Multiply and Divide Instructions
; 8664	Revision 1.2
; 8690		Revision History
; 8795		MULBn, MULWn, MULLn
; 8967		EMUL
; 9112		DIVBn, DIVWn, DIVLn
; 9359		EDIV
; 9864	CALLRET.MIC -- Procedure Call Instructions
; 9865	Revision 1.1
; 9891		Revision History
; 9981		CALLG, CALLS
; 10429 	RET
; 10740 MISC.MIC -- Miscellaneous Instructions
; 10741 Revision 1.0
; 10767 	Revision History
; 10822 	BPT, XFC
; 10894 	HALT
; 10959 	NOP
; 10998 	INDEX
; 11165 	BICPSW, BISPSW
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    3
;			     Table of Contents									      /REV=
;
; 11241 	MOVPSL
; 11283 	POPR
; 11516 	PUSHR
; 11738 QUEUE.MIC -- Queue Instructions
; 11739 Revision 1.1
; 11765 	Revision History
; 11859 	INSQUE
; 11952 	REMQUE
; 12069 	INSQxI
; 12605 	REMQxI
; 12967 OPSYS.MIC -- Operating System Support Instructions
; 12968 Revision 1.6
; 12994 	Revision History
; 13175 	CHMx
; 13568 	REI
; 14186 	LDPCTX
; 14545 	SVPCTX
; 14789 	PROBEx
; 15053 	MTPR, MFPR
; 17019 CSTRING.MIC -- Character String Instructions
; 17020 Revision 1.0
; 17046 	Revision History
; 17144 	MOVC3, MOVC5
; 18073 	CMPC3, CMPC5
; 18464 	SCANC, SPANC
; 18695 	LOCC, SKPC
; 18890 	String Packup Routine
; 19054 	String Unpack Routine
; 19277 FPOINT.MIC -- Floating Point Instructions
; 19278 Revision 1.0
; 19305 	Revision History
; 19410 	Floating Point Instructions With Single Bus Operand Transfer
; 19411 		MOVF, MNEGF, CVTFi, CVTiF
; 19412 		CVTiD, CVTFD, CVTiG, CVTFG
; 19473 	Floating Point Instructions With Single Bus Operand Transfer, No Destination Write
; 19474 		TSTF
; 19509 	Floating Point Instructions With Double Bus Operand Transfer
; 19510 		MOVD, MOVG, MNEGD, MNEGG
; 19511 		CVTDi, CVTDF, CVTGi, CVTGF
; 19512 		ADDFx, SUBFx, MULFx, DIVFx
; 19587 	Floating Point Instructions With Double Bus Operand Transfer, No Destination Write
; 19588 		CMPF, TSTD, TSTG
; 19627 	Floating Point Instructions With Quadruple Bus Operand Transfer
; 19628 		ADDDx, SUBDx, MULDx, DIVDx, ADDGx, SUBGx, MULGx, DIVGx, CMPD, CMPG
; 19682 	Floating Point Instructions With Quadruple Bus Operand Transfer -- No destination
; 19683 		CMPD, CMPG
; 19720 VECTOR.MIC -- VAX Vector Instructions
; 19721 Revision 1.0
; 19747 	Revision History
; 19900 	Vector Load Instructions
; 19955 	Vector Store Instructions
; 20010 	Vector Gather Instructions
; 20057 	Vector Scatter Instructions
; 20104 	MFVP
; 20147 	MTVP
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    4
;			     Table of Contents									      /REV=
;
; 20184 	VSYNC
; 20222 	Vector - Vector Operate Instructions
; 20284 	Longword Vector - Scalar Operate Instructions
; 20333 	Quadword Vector - Scalar Operate Instructions
; 20379 	Vector - Vector Compare Instructions
; 20419 	Longword Vector - Scalar Compare Instructions
; 20458 	Quadword Vector - Scalar Compare Instructions
; 20497 	IOTA
; 20535 EMULATE.MIC -- Emulation Support
; 20536 Revision 1.1
; 20562 	Revision History
; 20703 	Normal Emulation (FPD Clear)
; 21075 	Special Emulation (FPD Set)
; 21174 EBMCODE.MIC -- Behavioral Model Support
; 21175 Revision 1.2
; 21201 	Revision History
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    5
;	EBM.MIC 	     EBM.MIC -- Conditional Assembly Switches for the behavioral Model			      /REV=
;
				;1	.TOC	"EBM.MIC -- Conditional Assembly Switches for the behavioral Model"
				;2	.TOC	"Revision 1.0"
				;3
				;4	;	Shawn Persels
				;5
;6	.nobin
;7	;****************************************************************************
;8	;*									    *
;9	;*  COPYRIGHT (c) 1988, 1989, 1990, 1991, 1992 BY			    *
;10	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;11	;*  ALL RIGHTS RESERVED.						    *
;12	;*									    *
;13	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;14	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;15	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;16	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;17	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;18	;*  TRANSFERRED.							    *
;19	;*									    *
;20	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;21	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;22	;*  CORPORATION.							    *
;23	;*									    *
;24	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;25	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;26	;*									    *
;27	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    6
;	EBM.MIC 	     Revision History									      /REV=
;
;28	.TOC	"	Revision History"
;29
;30	; Edit	  Date	 Who	     Description
;31	; ---- --------- ---	---------------------
;32	; (1)1 17-Jul-90 GMU	Initial production microcode.
;33	; (0)0 16-Aug-88 SDP	Trial microcode.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    7
;	EBM.MIC 	     Conditional Assembly Switches							      /REV=
;
;34	.TOC	"	Conditional Assembly Switches"
;35
;36
;37	; The following assignments are used as conditional assembly switches during
;38	; microcode assembly.
;39
;40	.SET/PERF.MODEL=	0		; 1 = include special hooks for the performance model
;41
;42	.SET/BEH.MODEL= 	1		; 1 = include special hooks for the behavioral model
;43
;44
				;45	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    8
;	REV.MIC 	     REV.MIC -- Microcode Revision Number						      /REV=
;
				;46	.TOC	"REV.MIC -- Microcode Revision Number"
				;47	.TOC	"Revision 3.0"
				;48
				;49	;	Mike Uhler
				;50
;51	.nobin
;52	;****************************************************************************
;53	;*									    *
;54	;*  COPYRIGHT (c) 1990, 1991, 1992 BY					    *
;55	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;56	;*  ALL RIGHTS RESERVED.						    *
;57	;*									    *
;58	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;59	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;60	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;61	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;62	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;63	;*  TRANSFERRED.							    *
;64	;*									    *
;65	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;66	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;67	;*  CORPORATION.							    *
;68	;*									    *
;69	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;70	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;71	;*									    *
;72	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page    9
;	REV.MIC 	     Revision History									      /REV=
;
;73	.TOC	"	Revision History"
;74
;75	; Edit	  Date	 Who	     Description
;76	; ---- --------- ---	---------------------
;77	; (3)0 06-Jun-91 GMU	Increment revision number to 3 to reflect pass 3 changes.
;78	;    1 01-Feb-91 GMU	Symptom: No mechanism for including a non-standard
;79	;				 patch flag in the source.
;80	;			Cure:	 Default the value MICROCODE.NONSTANDARD to zero
;81	;				 in this module.
;82	; (2)0 21-Jan-91 GMU	Increment revision number to 2 to reflect pass 2 changes.
;83	;
;84	;    1 28-Nov-90 GMU	Symptom: No mechanism for including a microcode
;85	;				 patch number in the source.
;86	;			Cure:	 Default the value of MICROCODE.PATCH
;87	;				 to zero in this module.
;88	; (1)0 17-Jul-90 GMU	Initial production microcode.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   10
;	REV.MIC 	     Definition for Microcode Revision Number						      /REV=
;
;89	.TOC	"	Definition for Microcode Revision Number"
;90
;91
;92	;	The constant MICROCODE.REVISION is the number returned in bits
;93	;	<7:0> of the SID IPR.  At present, this constant is defined as having
;94	;	the following fields:
;95	;
;96	;		 07 06 05 04 03 02 01
;97	;		+--+--+--+--+--+--+--+
;98	;		|DP|	Edit Number  |
;99	;		+--+--+--+--+--+--+--+
;100	;
;101	;	where:
;102	;
;103	;		DP		= Development/Production flag:
;104	;					0 = Production microcode.
;105	;					1 = Development microcode.
;106	;		Edit Number	= Edit number of the microcode.
;107	;
;108	;	For development microcode, the edit number should be incremented any
;109	;	time a change is made that requires a corresponding model change.
;110	;
;111	;	For production microcode, the edit number should be incremented
;112	;	when any change is made to the microcode.
;113
;114
;115	;	Define the two parts of the microcode revision number.
;116
;117	.SET/MICROCODE.DP.FLAG=0		; development/production flag
;118
;119	.SET/MICROCODE.EDIT.NUMBER=3		; microcode edit number
;120
;121
;122	;	Post-process into the final value
;123
;124	.SET/MICROCODE.REVISION=<.OR[	<.SHIFT[<MICROCODE.DP.FLAG>,7]>,
;125					<MICROCODE.EDIT.NUMBER> 	]>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   11
;	REV.MIC 	     Default for Microcode Patch Number 						      /REV=
;
;126	.TOC	"	Default for Microcode Patch Number"
;127
;128
;129	;	The constant MICROCODE.PATCH is the number of the last required
;130	;	microcode patch.  It can be thought of as a modifier to the
;131	;	microcode revision number.  The constant MICROCODE.PATCH is
;132	;	defaulted to 0 in this module and may be redefined by assembling
;133	;	the microcode with the REV_PATCH.MIC module.
;134	;
;135	;	The constant MICROCODE.NONSTANDARD is a boolean flag that indicates
;136	;	whether this microcode patch is a normal functional patch
;137	;	release or a non-standard (e.g., performance monitoring) patch.
;138	;	The constant is defaulted to 0 in this module and may be
;139	;	redefined by assembling the microcode with the REV_PATCH.MIC
;140	;	module.
;141
;142	;	Default the microcode patch number and the non-standard
;143	;	patch flag to 0.
;144
;145	.DEFAULT/MICROCODE.PATCH=0
;146
;147	.DEFAULT/MICROCODE.NONSTANDARD=0
;148
				;149	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   12
;    DEFINE.MIC 	     DEFINE.MIC -- Microword Definitions for NVAX Microcode				      /REV=
;
				;150	.TOC	"DEFINE.MIC -- Microword Definitions for NVAX Microcode"
				;151	.TOC	"Revision 1.4"
				;152
				;153	;	Bob Supnik, Mike Uhler
				;154
				;155	;	Assembly directives
				;156
				;157	.ecode
				;158	.hexadecimal
				;159	.rtol
				;160	.allmemfields
				;161	.random
				;162	.width/80				; FAKE machine microword length
				;163	; .width/61				; REAL machine microword length
				;164
;165	.nobin
;166	.nocref
;167
;168	;****************************************************************************
;169	;*									    *
;170	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;171	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;172	;*  ALL RIGHTS RESERVED.						    *
;173	;*									    *
;174	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;175	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;176	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;177	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;178	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;179	;*  TRANSFERRED.							    *
;180	;*									    *
;181	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;182	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;183	;*  CORPORATION.							    *
;184	;*									    *
;185	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;186	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;187	;*									    *
;188	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   13
;    DEFINE.MIC 	     Revision History									      /REV=
;
;189	.TOC	"	Revision History"
;190
;191	; Edit	  Date	 Who	     Description
;192	; ---- --------- ---	---------------------
;193	;    4 24-Jul-91 JFB	Symptom: No symbolic constant defined for PCSTS
;194	;			Cure:	 Add IPR.PCSTS
;195	;    3 20-Feb-91 GMU	Symptom: No symbolic constant defined for P1BR and P1LR
;196	;				 bias values.
;197	;			Cure:	 Add P1BR.BIAS, P1LR.BIAS.SHIFTED, P1LR.BIAS.UNSHIFTED.
;198	;    2 28-Jan-91 GMU	Symptom: No symbolic definition for PCSCR PCS enable bit.
;199	;			Cure:	 Add PCSCR.PCS.ENB.
;200	;			Symptom: There is no easy way to extract the microcode
;201	;				 non-standard patch flag from the .ULD/.ULA file.
;202	;			Cure:	 Include the UCODE.NONSTANDARD value in the CONST
;203	;				 field and equate it to the MICROCODE.NONSTANDARD
;204	;				 constant.
;205	;    1 28-Nov-90 GMU	Symptom: There is no easy way to extract the microcode
;206	;				 revision number and the microcode
;207	;				 patch number from the .ULD/.ULA file.
;208	;			Cure:	 Include the UCODE.REVISION and UCODE.PATCH
;209	;				 values in the CONST field and equate them
;210	;				 to the MICROCODE.REVISION and MICROCODE.PATCH
;211	;				 constants.  This allows a program to find the
;212	;				 values by parsing the symbol table at the
;213	;				 end of the .ULD/.ULA.
;214	; (1)0 31-Jul-90 GMU	Initial production microcode.
;215	;
;216	; Begin version 1.0 here
;217	;   48 31-Jul-90 JFB	Add test pins to SEQ.COND/VECTOR field,
;218	;			and create SEQ.COND/TEST_PINS synonym.
;219	;   47 01-Jul-90 GMU	Add MCHK.PMF.CONFIG, SCB.PMF.BASE, ECR bit definitions.
;220	;   46 25-Jun-90 GMU	PCSCR turned out to be read/write after all, so back out
;221	;			edit 41.
;222	;   45 11-Jun-90 GMU	Renumber CPUSTATE registers in A and DST field to match
;223	;			implementation.
;224	;   44 11-Jun-90 GMU	Add MISC/INCR.PERF.COUNT decode.
;225	;   43 06-Jun-90 GMU	More of edit 42.
;226	;   42 05-Jun-90 GMU	Reorder SEQ.COND decodes for implementation.
;227	;   41 08-May-90 GMU	Remove PCSCR as a source in the A field (it is a write-
;228	;			only register).
;229	;   40 01-May-90 GMU	Note that last machine check code is included in ASTLVL.
;230	;   39 23-Apr-90 GMU	Remove artifact for an external vector unit interface.
;231	;   38 12-Apr-90 GMU	Add performance monitoring facility decodes.
;232	;   37 30-Mar-90 GMU	Add validity checks to restrict use of DST field
;233	;			for read-type MRQ commands.
;234	;   36 18-Mar-90 GMU	Rename JTAGCR to PCSCR.
;235	;   35 28-Feb-90 GMU	Remove FBOX.FAULT.CODE.
;236	;   34 23-Feb-90 GMU	Add new CONST.10 constants for MxPR rewrite, remove MXPR
;237	;			constant decodes on the A bus.
;238	;   33 20-Feb-90 GMU	Remove obsolete ALU, MISC, MISC1, and SEQ.COND decodes.
;239	;   32 12-Feb-90 GMU	Add MISC/SIM.IE.INTEXC directive for use in the behavioral
;240	;			model.
;241	;   31 19-Jan-90 GMU	Change definition of K.MXPR.0.31 definition to include
;242	;			bit for CPUID IPR.
;243	;   30 19-Jan-90 GMU	Add IPR.CEFSTS and CEFSTS.RDLK definitions.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   14
;    DEFINE.MIC 	     Revision History									      /REV=
;
;244	;   29 19-Jan-90 GMU	Remove VMPSL, add CPUID to ASTLVL comment.
;245	;   28 18-Jan-90 GMU	Add SEQ.COND/FBOX.FAULT.CODE.
;246	;   27 16-Jan-90 DGM	Change SEQ.COND field queue decode.  Update comments.
;247	;   26 15-Jan-90 GMU	Add MISC/CLR.VECT.RDY decode.
;248	;   25 09-Jan-90 GMU	Add ISR bit definitions.
;249	;   24 02-Jan-90 GMU	Remove bogus vector opcode and status decodes.
;250	;   23 21-Dec-89 GMU	Add IPR.CACHE definition.
;251	;   22 06-Dec-89 GMU	Continue cleanup.
;252	;   21 01-Dec-89 GMU	Add IPR.ICCS to CONST.10 field.
;253	;   20 17-Nov-89 GMU	Cleanup comments, remove obsolte decodes, note those
;254	;			that should be removed in the future.
;255	;   19 16-Nov-89 GMU	Add ALU/A.MINUS.B.MINUS.1 and B/K.FFFF; remove
;256	;			A/TEMP and DST/TEMP.
;257	;   18 07-Nov-89 GMU	Add new machine check codes.
;258	;   17 03-Nov-89 GMU	Add PSL.TP constant.
;259	;   16 23-Oct-89 GMU	Add PTE.M constant.
;260	;   15 18-Oct-89 GMU	Include validity check in use of FLUSH.PAQ to require
;261	;			MRQ request.
;262	;   14 21-Sep-89 GMU	Add PSL.B0 to DST field.
;263	;   13 11-Sep-89 GMU	Add JTAGCR to A and DST fields; add PROBE.V.RCHK.NOFILL
;264	;			to MRQ field.
;265	;   12 31-Aug-89 GMU	Update Cbox IPR assignments.
;266	;   11 23-Aug-89 GMU	Combine Fbox operand valid decodes into one decode.
;267	;   10 22-Aug-89 GMU	Add TB.TAG.FILL and TB.PTE.FILL commands to MRQ field.
;268	;    9 16-Aug-89 GMU	Remove CLEAR.WRITE.BUFFERS and READ.INT.VECTOR from
;269	;			MRQ field.
;270	;    8 14-Aug-89 GMU	Add new K.MXPR.x constants, rename old ones.
;271	;    7 26-Jul-89 GMU	Change Ibox IPR constant definitions from Cx to Dx.
;272	;    6 19-Jul-89 GMU	Add ECR, ESR to DST, A fields.
;273	;    5 12-Jul-89 GMU	Updated IPR encodings.
;274	;    4 30-Jun-89 DGM	Added FBOX.DISABLED microbranch condition
;275	;    3 08-Feb-89 GMU	Remove C bit.
;276	;    2 22-Nov-88 DB	Add MISC3/F.DEST.CHECK
;277	;    1 23-Aug-88 GMU	Add PM hooks for CASEx.
;278	; (0)0 27-Aug-87 RMS	Trial microcode.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   15
;    DEFINE.MIC 	     Defaults for Conditional Assembly Switches 					      /REV=
;
;279	.TOC	"	Defaults for Conditional Assembly Switches"
;280
				;281	.bin
				;282
				;283	;	The following assignments specify conditional assembly switches for the
				;284	;	microcode assembly.  They are specified as defaults here, and may be
				;285	;	redefined earlier in the assembly (in Exx.MIC) with explicit
				;286	;	.SET directives.
				;287
				;288	.DEFAULT/PERF.MODEL=	0	; 1 = include special hooks for the performance model
				;289					; 0 = exclude special hooks for the performance model
				;290
				;291	.DEFAULT/BEH.MODEL=	0	; 1 = include special hooks for the behavioral model
				;292					; 0 = exclude special hooks for the behavioral model
				;293
				;294	;	The following definitions post process those above and should never be
				;295	;	changed alone.
				;296
				;297	.SET/NOT.PERF.MODEL=<.NOT[ <PERF.MODEL>]> ; logical complement for use in validity checks
				;298	.SET/NOT.BEH.MODEL=<.NOT[ <BEH.MODEL>]>   ; logical complement for use in validity checks
				;299
;300	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   16
;    DEFINE.MIC 	     Introduction									      /REV=
;
;301	.TOC	"	Introduction"
;302
;303	;	The NVAX microword consists of 61 bits divided into two major sections.
;304	;	Bits <60:15> control the data path and are encoded into two formats.
;305	;	Bits <14:0> control the microsequencer and are encoded into two formats.
;306	;
;307	;	In addition to the bits in the real microword, there are additional
;308	;	bits defined which provide assembly-time validity checking for the
;309	;	microcode, plus support for data-dependent decisions in the performance
;310	;	model.	The additional bits are stripped out by the allocator during
;311	;	pass 3 of the allocation process.
;312	;
;313	;	The formats are defined in the Microinstruction Formats Chapter of the NVAX
;314	;	CPU Functional Specification.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   17
;    DEFINE.MIC 	     Microword Formats									      /REV=
;
;315	.TOC	"	Microword Formats"
;316
;317	;	The microword formats on this page represent the final microword after
;318	;	post-processing by the allocator.
;319	;
;320	;	Data path control, standard format
;321	;
;322	;	 6|5 5 5 5|5 5 5 5|5 5 4 4|4 4 4 4|4 4 4 4|3 3 3 3|3 3 3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1
;323	;	 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5
;324	;	+-+---------+---------+-+-----+-+---------+---------+-+-+-+-----------+-----------+---------+
;325	;	|0|   ALU   |	MRQ   |Q| SHF |0|   VAL   |    B    |L|W|V|    DST    |     A	  |  MISC   |
;326	;	+-+---------+---------+-+-----+-+---------+---------+-+-+-+-----------+-----------+---------+
;327	;				      |1|POS|	 CONST	    | MISC not equal CONST.10
;328	;				      +-+---+---------------+
;329	;				      |1|     CONST.10	    | MISC equal CONST.10
;330	;				      +-+-------------------+
;331	;
;332	;	Data path control, special format
;333	;
;334	;	 6|5 5 5 5|5 5 5 5|5 5 4 4|4 4 4 4|4 4 4 4|3 3 3 3|3 3 3 3|3 3 2 2|2 2 2 2|2 2 2 2|1 1 1 1|1
;335	;	 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0|9 8 7 6|5
;336	;	+-+---------+---------+-------+-+-------+-+---------+-+-+-+-----------+-----------+---------+
;337	;	|1|   ALU   |	MRQ   | MISC1 |0| MISC2 |D|    B    |L|W|V|    DST    |     A	  |  MISC   |
;338	;	+-+---------+---------+-------+-+-------+-+---------+-+-+-+-----------+-----------+---------+
;339	;				      |1|POS|	 CONST	    | MISC not equal CONST.10
;340	;				      +-+---+---------------+
;341	;				      |1|     CONST.10	    | MISC equal CONST.10
;342	;				      +-+-------------------+
;343	;
;344	;	Microsequencer control, jump format
;345	;
;346	;	 1 1 1|1 1    |       |
;347	;	 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
;348	;	+-+-+---+---------------------+
;349	;	|0|S|MUX|	   J	      |
;350	;	+-+-+---+---------------------+
;351	;
;352	;	Microsequencer control, branch format
;353	;
;354	;	 1 1 1|1 1    |       |
;355	;	 4 3 2|1 0 9 8|7 6 5 4|3 2 1 0
;356	;	+-+-+---------+---------------+
;357	;	|1|S|SEQ.COND |    BR.OFF     |
;358	;	+-+-+---------+---------------+
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   18
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;359	.TOC	"	Standard Microinstruction Format"
;360
;361	;	The fields for the standard microinstruction are:
;362	;
;363	;	FORMAT/ 	STANDARD
;364	;	ALU/		ALU operation
;365	;	MRQ/		Mbox request
;366	;	Q/		Q latch update control
;367	;	SHF/		Shift operation
;368	;	LIT/		B operand control, as follows:
;369	;	    LIT/0:
;370	;		VAL/	Shift count value
;371	;		B/	B port select
;372	;	    LIT/1:
;373	;		POS/	Contant position	\ If MISC field does not
;374	;		CONST/	8-bit constant value	/ contain CONST.10.BIT
;375	;		CONST.10/ 10-bit constant value   If MISC field contains CONST.10.BIT
;376	;	L/		Length control
;377	;	W/		Wbus driver control
;378	;	V/		VA latch update control
;379	;	DST/		Wbus destination
;380	;	A/		ALU A port select
;381	;	MISC/		Miscellaneous
;382
;383	;	This field defines foramt of the current microinstruction.
;384
;385	FORMAT/=<60>,.DEFAULT=<FORMAT/STANDARD>
;386
;387		STANDARD		=  0	; select the standard format
;388		SPECIAL 		=  1	; select the special format
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   19
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;389
;390	;	Standard microinstruction format, continued.
;391
;392	;	This field defines the ALU operation.  Inputs to the ALU are selected by the A and B field decodes.
;393	;	The output of the ALU can drive the VA (based on V control) and/or the Wbus (based on W control).
;394	;	The ALU condition codes are length dependent (based on DL and L control) and can drive the PSL logic
;395	;	(based on W control).
;396
;397	ALU/=<59:55>,.DEFAULT=<ALU/0>
;398
;399	;		Function	  Val		Operation			  Comments and restrictions
;400	;	-----------------------  ----	---------------------------	----------------------------------------------------
;401		PASS.A			=  00	; A
;402		PASS.B			=  01	; B
;403	;				=  02
;404	;				=  03
;405	;				=  04
;406	;				=  05
;407	;				=  06
;408	;				=  07
;409		A.AND.B 		=  08	; A .AND. B
;410		A.AND.NOT.B		=  09	; A .AND. (.NOT. B)
;411		A.OR.B			=  0A	; A .OR. B
;412	;				=  0B
;413		A.XOR.B 		=  0C	; A .XOR. B
;414		NOT.A.AND.B		=  0D	; (.NOT. A) AND B
;415	;				=  0E
;416		A.MINUS.B.MINUS.1	=  0F	; A - B - 1			A + (.NOT. B)
;417
;418		A.PLUS.1		=  10	; A + 1
;419		A.PLUS.B		=  11	; A + B
;420		A.PLUS.B.PLUS.1 	=  12	; A + B + 1
;421	;				=  13
;422		B.MINUS.A		=  14	; B - A 			B + (.NOT. A) + 1
;423		A.MINUS.B		=  15	; A - B 			A + (.NOT. B) + 1
;424		A.MINUS.1		=  16	; A - 1
;425	;				=  17
;426		A.PLUS.4		=  18	; A + 4
;427		A.MINUS.4		=  19	; A - 4
;428		NEG.B			=  1A	; -B
;429		NOT.B			=  1B	; ~B
;430		SMUL.STEP		=  1C	; signed multiply step
;431		UDIV.STEP		=  1D	; unsigned divide step
;432	;				=  1E
;433	;				=  1F
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   20
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;434
;435	;	Standard microinstruction format, continued.
;436
;437	;	This field defines the memory request function.  The address source is either the VA register, or if VA
;438	;	is updated from the ALU output, the ALU.  On reads, the DST field supplies the destination (must be
;439	;	a working register or a general register).  On writes, the shifter supplies the write data.
;440
;441	MRQ/=<54:50>,.DEFAULT=<MRQ/NOP>
;442
;443	;	       Command		 Val	Validity checks 	Description		Type	Check	Mode
;444	;	-----------------------  --- -------------------------- -----------------------+-------+-------+---------
;445		NOP			= 00				; no op 		none	none	none
;446		SYNC.BDISP		= 01				; no op to Mbox 	none	none	none
;447									; S4: stall if branch queue entry not valid
;448		SYNC.BDISP.RETIRE	= 02,.VALIDITY=<MUX.LAST>	; no op to Mbox 	none	none	none
;449									; S4: stall if branch queue entry not valid
;450									; S5: retire branch queue entry
;451		SYNC.BDISP.TEST.PRED	= 03,.VALIDITY=<MUX.LAST>	; no op to Mbox 	none	none	none
;452									; S4: stall if branch queue entry not valid
;453									; S5: retire branch queue entry, evaluate branch
;454									;     prediction, trap if incorrect
;455		TB.INVALIDATE.SINGLE	= 04				; TB invalidate single
;456		TB.INVALIDATE.PROCESS	= 05				; TB invalidate process
;457		TB.INVALIDATE.ALL	= 06				; TB invalidate all
;458	;				= 07
;459
;460		SYNC.MBOX		= 08				; synchronize with previous M-box command
;461		LOAD.PC 		= 09				; Send new PC to Ibox via Mbox
;462		TB.TAG.FILL		= 0A				; Send new TB tag to Mbox
;463		TB.PTE.FILL		= 0B				; Send new TB PTE to Mbox
;464
;465	;				= 0C
;466	;				= 0D
;467	;				= 0E
;468	;				= 0F
;469
;470		READ.V.RCHK		= 10,.VALIDITY=<DST.WN.OR.RN>	; read			virt	read	current
;471		READ.V.WCHK		= 11,.VALIDITY=<DST.WN.OR.RN>	; read with write check virt	write	current
;472		READ.V.NOCHK		= 12,.VALIDITY=<DST.WN.OR.RN>	; read with no check	virt	none	none
;473		READ.V.LOCK		= 13,.VALIDITY=<DST.WN> 	; read lock		virt	write	current
;474		READ.P			= 14,.VALIDITY=<DST.WN.OR.RN>	; read physical 	phys	none	none
;475		READ.PR 		= 15,.VALIDITY=<DST.WN> 	; read PR		phys	none	none
;476		PROBE.V.RCHK.NOFILL	= 16,.VALIDITY=<DST.WN> 	; read probe no fill	virt	read	mode
;477		PROBE.V.RCHK		= 17,.VALIDITY=<DST.WN> 	; read probe byte	virt	read	mode
;478
;479		WCHK			= 18				; write check		virt	write	current
;480		WRITE.V.WCHK		= 19				; write 		virt	write	current
;481		WRITE.V.NOCHK		= 1A				; write with no check	virt	none	none
;482		WRITE.V.UNLOCK		= 1B				; write unlock		virt	write	current
;483		WRITE.P 		= 1C				; write physical	phys	none	none
;484		WRITE.PR		= 1D				; write PR		phys	none	none
;485	;				= 1E
;486		PROBE.V.WCHK		= 1F,.VALIDITY=<DST.WN.OR.RN>	; write probe byte	virt	write	mode
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   21
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;487
;488	;	Standard microinstruction format, continued.
;489	;
;490	;	These field defines the shift operation.  Inputs to the shifter are selected by the A and B field
;491	;	decodes.  If the B port selects a literal, the shift count is supplied by SC;  otherwise, it can
;492	;	be supplied either by SC or the count field.  The output of the shifter can drive the Wbus (based
;493	;	on W control); based on Q control, it is conditionally latched in the Q (shift output) register.
;494	;	The shifter condition codes are always longword and can drive the PSL logic (based on W control).
;495
;496	Q/=<49>,.DEFAULT=<Q/HOLD.Q>
;497
;498		HOLD.Q			=  0	; maintain current value of Q
;499		UPDATE.Q		=  1	; update Q from shifter output
;500
;501	SHF/=<48:46>,.DEFAULT=<SHF/NOP>
;502
;503	;		Function	  Val		Operation			  Comments and restrictions
;504	;	-----------------------  ----	---------------------------	----------------------------------------------------
;505		NOP			=  0	; none				SHIFT.SIGN is preserved
;506		PASS.A			=  1	; output = A
;507		PASS.B			=  2	; output = B
;508		PASS.Z			=  3	; output = 0
;509		LEFT.DOUBLE		=  4	; output = A'B lsh count
;510		LEFT.SINGLE		=  5	; output = A'0 lsh count
;511		RIGHT.DOUBLE		=  6	; output = A'B rsh count
;512		RIGHT.SINGLE		=  7	; output = 0'B rsh count
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   22
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;513
;514	;	Standard microinstruction format, continued.
;515
;516	;	This field specifies the B port select.  The B port select can either be a literal constant
;517	;	(in which case the shift count is always supplied by SC), or a register select (in which
;518	;	case the shift count can be supplied either by SC or by the shift value field).
;519
;520	LIT/=<45>,.DEFAULT=<LIT/BREG>
;521
;522		BREG			=  0	; B port select is a B field register
;523		LIT			=  1	; B port select is a literal constant
;524
;525	;	When LIT specifies a literal constant, this field, along with the MISC/CONST.10.BIT decode
;526	;	selects the position of the constant.  If the MISC field does not contain the MISC/CONST.10.BIT
;527	;	decode, the POS field selects the byte position within the longword of the 8-bit constant
;528	;	specified by the CONST field.  If the MISC field contains the MISC/CONST.10.BIT decode,
;529	;	the POS and CONST fields are concatenated to supply a 10-bit constant which is placed in
;530	;	bits <9:0> of the B bus.  In either case, all remaining bits of the longword are forced to zero.
;531
;532	POS/=<44:43>,.DEFAULT=<POS/0>
;533
;534	;	Selection		  Val	    Resulting constant
;535	;	---------		 ----	-------------------------
;536		BYTE0			=  00	; 000000cc  (bits <7:0>)
;537		BYTE1			=  01	; 0000cc00  (bits <15:8>)
;538		BYTE2			=  02	; 00cc0000  (bits <23:16>)
;539		BYTE3			=  03	; cc000000  (bits <31:24>)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   23
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;540
;541	;	Standard microinstruction format, continued.
;542
;543	;	When LIT specifies a literal constant and the MISC field does not contain the
;544	;	MISC/CONST.10.BIT decode, this field supplies the 8-bit constant value.
;545
;546	CONST/=<42:35>,.DEFAULT=<CONST/0>
;547
;548	;	    Constant		  Val		Interpretation or use
;549	;	-----------------------  ----	-----------------------------------------------
;550	;	System ID.
;551
;552		NVAX.SID		= 19.	; system ID (byte 3)
;553
;554	;	Revision constants (here so that they appear in the .ULD/.ULA symbol table)
;555
;556		UCODE.REVISION		= <MICROCODE.REVISION> ; Microcode revision number
;557		UCODE.PATCH		= <MICROCODE.PATCH> ; Microcode patch number
;558		UCODE.NONSTANDARD	= <MICROCODE.NONSTANDARD> ; Microcode non-standard patch
;559
;560	;	SCB offsets.
;561
;562		SCB.MACHCHK		= 004	; SCB vector, machine check
;563		SCB.KSNV		= 008	; SCB vector, kernel stack not valid
;564		SCB.PWRFL		= 00C	; SCB vector, power fail
;565		SCB.RESPRIV		= 010	; SCB vector, reserved/priv instruction
;566		SCB.XFC 		= 014	; SCB vector, XFC instruction
;567		SCB.RESOP		= 018	; SCB vector, reserved operand
;568		SCB.RESADD		= 01C	; SCB vector, reserved addressing mode
;569		SCB.ACV 		= 020	; SCB vector, access control violation
;570		SCB.TNV 		= 024	; SCB vector, translation not valid
;571		SCB.TP			= 028	; SCB vector, trace pending
;572		SCB.BPT 		= 02C	; SCB vector, breakpoint trace
;573		SCB.ARITH		= 034	; SCB vector, arithmetic fault
;574		SCB.VM			= 038	; SCB vector, VM trap
;575		SCB.MODIFY		= 03C	; SCB vector, modify fault
;576		SCB.CHMK		= 040	; SCB vector, change mode to kernel
;577		SCB.CHME		= 044	; SCB vector, change mode to executive
;578		SCB.CHMS		= 048	; SCB vector, change mode to supervisor
;579		SCB.CHMU		= 04C	; SCB vector, change mode to user
;580		SCB.SERR		= 054	; SCB vector, soft error interrupt
;581		SCB.PMF.BASE		= 058	; SCB vector, physical address of performance monitoring facility block
;582		SCB.HERR		= 060	; SCB vector, hard error interrupt
;583		SCB.VECT.DISABLED	= 068	; SCB vector, vector unit disabled exception
;584		SCB.IPLSOFT		= 080	; SCB vector, software interrupts
;585		SCB.INTTIM		= 0C0	; SCB vector, interval timer interrupt
;586		SCB.EMULATE		= 0C8	; SCB vector, emulation
;587		SCB.EMULFPD		= 0CC	; SCB vector, emulation with FPD set
;588
;589	;	Arithmetic trap and fault codes.
;590
;591		ARITH.TRAP.INTOVF	=  01	; integer overflow
;592		ARITH.TRAP.INTDIV	=  02	; integer divide-by-zero
;593		ARITH.TRAP.SUBRNG	=  07	; subscript range
;594		ARITH.FAULT.FLTOVF	=  08	; floating overflow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   24
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;595		ARITH.FAULT.FLTDIV	=  09	; floating divide-by-zero
;596		ARITH.FAULT.FLTUND	=  0A	; floating underflow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   25
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;597
;598	;	Standard microinstruction format, continued.
;599	;	CONST field, continued.
;600
;601	;	    Constant		  Val		Interpretation or use
;602	;	-----------------------  ----	-----------------------------------------------
;603	;	Console halt codes.
;604
;605		ERR.HLTPIN		=  02	; HALT_L pin asserted
;606		ERR.PWRUP		=  03	; initial power up
;607		ERR.INTSTK		=  04	; interrupt stack not valid
;608		ERR.DOUBLE		=  05	; machine check during exception processing
;609		ERR.HLTINS		=  06	; HALT instruction in kernel mode
;610		ERR.ILLVEC		=  07	; illegal SCB vector (bits <1:0> = 11)
;611		ERR.WCSVEC		=  08	; WCS SCB vector (bits <1:0> = 10)
;612		ERR.CHMFI		=  0A	; CHMx on interrupt stack
;613		ERR.IE0 		=  10	; ACV/TNV during machine check processing
;614		ERR.IE1 		=  11	; ACV/TNV during kernel-stack-not-valid processing
;615		ERR.IE2 		=  12	; machine check during machine check processing
;616		ERR.IE3 		=  13	; machine check during kernel-stack-not-valid processing
;617		ERR.IE.PSL.26-24.101	=  19	; PSL<26:24> = 101 during interrupt or exception
;618		ERR.IE.PSL.26-24.110	=  1A	; PSL<26:24> = 110 during interrupt or exception
;619		ERR.IE.PSL.26-24.111	=  1B	; PSL<26:24> = 111 during interrupt or exception
;620		ERR.REI.PSL.26-24.101	=  1D	; PSL<26:24> = 101 during REI
;621		ERR.REI.PSL.26-24.110	=  1E	; PSL<26:24> = 110 during REI
;622		ERR.REI.PSL.26-24.111	=  1F	; PSL<26:24> = 111 during REI
;623
;624	;	Machine check codes.
;625
;626		MCHK.UNKNOWN.MSTATUS	=  01	; unknown memory management status
;627		MCHK.INT.ID.VALUE	=  02	; unknown interrupt id
;628		MCHK.CANT.GET.HERE	=  03	; unknown microcode dispatch
;629		MCHK.MOVC.STATUS	=  04	; unknown MOVCx status
;630		MCHK.ASYNC.ERROR	=  05	; async HW error microtrap
;631		MCHK.SYNC.ERROR 	=  06	; sync HW error microtrap
;632		MCHK.PMF.CONFIG 	=  07	; performance monitoring facility incorrectly configured
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   26
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;633
;634	;	Standard microinstruction format, continued.
;635	;	CONST field, continued.
;636
;637	;	    Constant		  Val		Interpretation or use
;638	;	-----------------------  ----	-----------------------------------------------
;639	;	PTE bits
;640
;641		PTE.M			=  04	; PTE<M> (byte 3)
;642
;643	;	PSL bits
;644
;645		PSL.TP			=  40	; PSL<TP> (byte 3)
;646
;647	;	ISR bit definitions
;648
;649		ISR.HALT		=  80	; ISR bit to clear HALT_L flop (byte 3)
;650		ISR.SERR		=  08	; ISR bit to clear SERR_L flop (byte 3)
;651		ISR.PMF 		=  10	; ISR bit to clear PMF flop (byte 3)
;652		ISR.INT_TIM		=  01	; ISR bit to clear INT_TIM_L flop (byte 3)
;653		ISR.CLEAR.ALL		=  0F9	; ISR mask to clear all interrupt requests and ICCS<6> (byte 3)
;654
;655	;	ECR bit definitions
;656
;657		ECR.ICCS.EXT		=  80	; ECR bit that indicates external ICCS (byte 0)
;658		ECR.PMF.ENABLE		=  01	; ECR bit that enables the PMF (byte 2)
;659		ECR.PMF.CLEAR		=  80	; virtual ECR bit that clears the PMF counters (byte 3)
;660
;661	;	PCSCR bit definitions
;662
;663		PCSCR.PCS.ENB		= 02	; PCSCR bit that indicates that PCS is enabled (byte 1)
;664
;665	;	CEFSTS bit definitions
;666
;667		CEFSTS.RDLK		=  01	; CEFSTS bit to clear RDLK error (byte 0)
;668
;669	;	PCCTL bit definitions
;670
;671		PCCTL.FORCE.HIT 	=  07	; Force hit+I enable+D enable (byte 0)
;672
;673	;	IPR mask bits and right-justified encodings
;674
;675		IPR.CACHE		=  01	; Bit in byte 3 which differentiates cache IPRs from normal IPRs.
;676		IPR.EBOX.BLOCK		=  78	; First of 8 special-cased Ebox IPRs
;677		IPR.VECTOR.BLOCK	=  90	; First of 8 special-cased vector IPRs
;678
;679	;	P1BR bias constant
;680
;681		P1BR.BIAS		=  80	; P1BR bias constant (byte 2)
;682		P1LR.BIAS.SHIFTED	=  40	; P1LR bias constant (byte 3 of shifted value)
;683		P1LR.BIAS.UNSHIFTED	=  20	; P1LR bias constant (byte 2 of unshifted value)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   27
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;684
;685	;	Standard microinstruction format, continued.
;686	;	CONST.10 field
;687
;688	;	When LIT specifies a literal constant and the MISC field contains the
;689	;	MISC/CONST.10.BIT decode, this field supplies the 10-bit constant value.
;690	;	Note that this field overlaps the POS and CONST fields, and is only
;691	;	used when the MISC field contains the MISC/CONST.10.BIT decode.
;692
;693	CONST.10/=<44:35>
;694
;695	;	    Constant		  Val		Interpretation or use
;696	;	-----------------------  ----	-----------------------------------------------
;697	;	Internal processor registers.  These values are pre-shifted by 2 bits to
;698	;	position then into bits <9:2> rather than <7:0>.
;699
;700		IPR.ICCS		= <.SHIFT[<018>,2]> ; External ICCS register
;701
;702		IPR.IAK.BASE		= <.SHIFT[<.DIFF[<040>,<014>]>,2]>
;703							    ; interrupt IAK base (IPR.IAK.BASE+[IPL*4] = IPR.IAK1x)
;704		IPR.CWB 		= <.SHIFT[<044>,2]> ; Clear write buffers
;705
;706		IPR.CEFSTS		= <.SHIFT[<0AC>,2]> ; Cbox CEFSTS register address
;707
;708
;709		IPR.BPCR		= <.SHIFT[<0D4>,2]> ; Ibox branch prediction control register
;710		IPR.BPC 		= <.SHIFT[<0D6>,2]> ; Ibox backup PC
;711		IPR.BPC.UNWIND		= <.SHIFT[<0D7>,2]> ; Ibox backup PC with RLOG unwind
;712
;713		IPR.MP0BR		= <.SHIFT[<0E0>,2]> ; Mbox P0 base register
;714		IPR.MP0LR		= <.SHIFT[<0E1>,2]> ; Mbox P0 length register
;715		IPR.MP1BR		= <.SHIFT[<0E2>,2]> ; Mbox P1 base register
;716		IPR.MP1LR		= <.SHIFT[<0E3>,2]> ; Mbox P1 length register
;717		IPR.MSBR		= <.SHIFT[<0E4>,2]> ; Mbox system base register
;718		IPR.MSLR		= <.SHIFT[<0E5>,2]> ; Mbox system length register
;719		IPR.MMAPEN		= <.SHIFT[<0E6>,2]> ; Mbox memory management enable
;720		IPR.PAMODE		= <.SHIFT[<0E7>,2]> ; Mbox physical address mode
;721		IPR.MMEADR		= <.SHIFT[<0E8>,2]> ; Mbox MME address
;722		IPR.MMEPTE		= <.SHIFT[<0E9>,2]> ; Mbox MME PTE address
;723		IPR.MMESTS		= <.SHIFT[<0EA>,2]> ; Mbox MME status
;724		IPR.PCSTS		= <.SHIFT[<0F4>,2]> ; Mbox Pcache status
;725		IPR.PCCTL		= <.SHIFT[<0F8>,2]> ; Mbox Pcache control
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   28
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;726
;727	;	Standard microinstruction format, continued.
;728
;729	;	When the LIT field specifies a B register and shift value, the shift count is
;730	;	taken from this field.	A zero value specifies a shift by SC.
;731
;732	VAL/=<44:40>,.DEFAULT=<VAL/0>
;733
;734	;	When the LIT field specifies a B register and shift value, this field supplies the
;735	;	B port decode.
;736
;737	B/=<39:35>,.DEFAULT=<B/NONE>
;738
;739	;		Function	  Val		     Operation				    Comments
;740	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;741		NONE			=  00	; No source
;742		W0			=  01	; working register 0
;743		W1			=  02	; working register 1
;744		W2			=  03	; working register 2
;745		W3			=  04	; working register 3
;746		W4			=  05	; working register 4
;747		W5			=  06	; working register 5
;748	;				=  07
;749
;750		S1			=  08	; top of specifier queue		advance specifier queue by 1 entry
;751		S2			=  09,.VALIDITY=<A.S1>
;752						; second entry in specifier queue	advance specifier queue by 2 entries
;753		Q			=  0A	; shifter output latch
;754	;				=  0B	;					VA in A field
;755	;				=  0C	;					PSL in A, DST fields
;756	;				=  0D	;
;757		K.FFFF			=  0E	; Constant 0000FFFF (hex)
;758		RN.MODE.OPCODE		=  0F	; Rn (bits <31:28>)'CUR_MOD (bits <25:24>)'opcode (bits <23:16>)'
;759						; VAX Restart bit (bit<7>), 0 (bits <27:26,15:8,6:0>)
;760
;761		R0			=  10	; R0
;762		R1			=  11	; R1
;763		R2			=  12	; R2
;764		R3			=  13	; R3
;765		R4			=  14	; R4
;766		R5			=  15	; R5
;767		R6			=  16	; R6
;768		R7			=  17	; R7
;769		R8			=  18	; R8
;770		R9			=  19	; R9
;771		R10			=  1A	; R10
;772		R11			=  1B	; R11
;773		R12			=  1C	; R12
;774			AP		=  1C	;  argument pointer
;775		R13			=  1D	; R13
;776			FP		=  1D	;  frame pointer
;777		SP			=  1E	; R14 = stack pointer
;778	;				=  1F
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   29
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;779
;780	;	Standard microinstruction format, continued.
;781
;782	;	This field controls whether the following are done as longwords or according to the
;783	;	prevailing data length:
;784	;		1. calculation of alu cc's
;785	;		2. zero extending of Wbus result
;786	;		3. size of memory operation
;787
;788	L/=<34>,.DEFAULT=<L/LONG>
;789
;790		LONG			=   0	; alu cc's, Wbus, memory operation are longword
;791		LEN(DL) 		=   1	; alu cc's, Wbus, memory operation are specified by DL
;792
;793	;	This field determines whether the ALU or the shifter drives the Wbus, and
;794	;	whether the ALU or shifter cc's are the input to the PSL condition code logic.
;795
;796	W/=<33>,.DEFAULT=<W/ALU>
;797
;798		ALU			=   0	; alu drives Wbus, alu cc's drive psl cc's
;799		SHF			=   1	; shifter drives Wbus, shifter cc's drive psl cc's
;800
;801	;	This field determines whether the VA register is updated from the ALU output.
;802
;803	V/=<32>,.DEFAULT=<V/HOLD.VA>
;804
;805		HOLD.VA 		=   0	; maintain current value of VA
;806		UPDATE.VA		=   1	; update VA from ALU output
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   30
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;807
;808	;	Standard microinstruction format, continued.
;809
;810	;	This field defines the destination control.
;811
;812	;	The order and numbering of the values in the DST and A fields are identical.  If you change these values check
;813	;	the other field for a corresponding change.
;814
;815	DST/=<31:26>,.DEFAULT=<DST/WBUS>
;816
;817	;		Function	  Val		     Operation				    Comments
;818	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;819		NONE			=  00	; No destination			No W-bus request is made
;820		W0			=  01	; working register 0
;821		W1			=  02	; working register 1
;822		W2			=  03	; working register 2
;823		W3			=  04	; working register 3
;824		W4			=  05	; working register 4
;825		W5			=  06	; working register 5
;826	;				=  07
;827
;828		WBUS			=  08	; W-bus 				Drive W-bus, S1 in A, B fields
;829		DST			=  09,.VALIDITY=<MRQ.NOP>
;830						; top of destination specifier queue	S2 in A, B field
;831	;				=  0A	;					Q in A, B fields
;832	;				=  0B	;					VA in A field
;833		PSL			=  0C	; PSL					writable as long only
;834		PSL.B0			=  0D	; PSL<7:0>				FBOX.FAULT.CODE in B field
;835	;				=  0E
;836	;				=  0F	;					RN.MODE.OPCODE in B field
;837
;838		R0			=  10	; R0
;839		R1			=  11	; R1
;840		R2			=  12	; R2
;841		R3			=  13	; R3
;842		R4			=  14	; R4
;843		R5			=  15	; R5
;844		R6			=  16	; R6
;845		R7			=  17	; R7
;846		R8			=  18	; R8
;847		R9			=  19	; R9
;848		R10			=  1A	; R10
;849		R11			=  1B	; R11
;850		R12			=  1C	; R12
;851			AP		=  1C	;  argument pointer
;852		R13			=  1D	; R13
;853			FP		=  1D	;  frame pointer
;854		SP			=  1E	; R14 = stack pointer
;855	;				=  1F	;
;856
;857		KSP			=  20	; kernel stack pointer
;858		ESP			=  21	; executive stack pointer
;859		SSP			=  22	; supervisor stack pointer
;860		USP			=  23	; user stack pointer
;861		ISP			=  24	; interrupt stack pointer
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   31
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;862		ASTLVL			=  25	; ASTLVL value in bits <31:29>, machine check code in bits <23:16>,
;863						; CPUID in bits <7:0>
;864		SCBB			=  26	; system control block base register
;865		PCBB			=  27	; process control block base register
;866		SAVEPC			=  28	; console saved PC (also BPC after call to IE.CLEANUP.CPU)
;867		SAVEPSL 		=  29	; console saved PSL
;868	;				=  2A
;869	;				=  2B
;870	;				=  2C
;871	;				=  2D
;872	;				=  2E
;873	;				=  2F
;874
;875		INT.SYS 		=  30	; hw flops (bits <31:29,27,24>)'sisr<15:1> (bits<15:1>'iccs<6> (bit<0>)
;876	;				=  31	;					K0 in A field
;877	;				=  32	;					K1 in A field
;878	;				=  33	;
;879	;				=  34	;
;880		SC			=  35	; shift count
;881		MMGT.MODE		=  36	; mode for probing from <3:2>
;882	;				=  37	;					S+PSW_EX in A field
;883	;				=  38	;					POP.COUNT in A field
;884	;				=  39	;					SHIFT.SIGN in A field
;885		ECR			=  3A	; Ebox control register
;886	;				=  3B	;					PERF.COUNT in A field
;887		PCSCR			=  3C	; Patchable control store control register
;888	;				=  3D
;889	;				=  3E
;890	;				=  3F
;891	;				=  3F
;892	;				=  3F
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   32
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;893
;894	;	Standard microinstruction format, continued.
;895
;896	;	This field defines the A port select.
;897
;898	;	The order and numbering of the values in the DST and A fields are identical.  If you change these values check
;899	;	the other field for a corresponding change.
;900
;901	A/=<25:20>,.DEFAULT=<A/NONE>
;902
;903	;		Function	  Val		     Operation				    Comments
;904	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;905		NONE			=  00
;906		W0			=  01	; working register 0
;907		W1			=  02	; working register 1
;908		W2			=  03	; working register 2
;909		W3			=  04	; working register 3
;910		W4			=  05	; working register 4
;911		W5			=  06	; working register 5
;912	;				=  07
;913
;914		S1			=  08	; top of source specifier queue 	advance specifier queue by 1 entry
;915		S2			=  09,.VALIDITY=<B.S1>
;916						; top of destination specifier queue	advance specifier queue by 2 entries
;917		Q			=  0A	; shift result latch
;918		VA			=  0B	; virtual address register
;919		PSL			=  0C	; PSL register
;920	;				=  0D	;					FBOX.FAULT.CODE in B field
;921	;				=  0E
;922	;				=  0F
;923
;924		R0			=  10	; R0
;925		R1			=  11	; R1
;926		R2			=  12	; R2
;927		R3			=  13	; R3
;928		R4			=  14	; R4
;929		R5			=  15	; R5
;930		R6			=  16	; R6
;931		R7			=  17	; R7
;932		R8			=  18	; R8
;933		R9			=  19	; R9
;934		R10			=  1A	; R10
;935		R11			=  1B	; R11
;936		R12			=  1C	; R12
;937			AP		=  1C	;  argument pointer
;938		R13			=  1D	; R13
;939			FP		=  1D	;  frame pointer
;940		SP			=  1E	; R14 = stack pointer
;941	;				=  1F	;
;942
;943		KSP			=  20	; kernel stack pointer
;944		ESP			=  21	; executive stack pointer
;945		SSP			=  22	; supervisor stack pointer
;946		USP			=  23	; user stack pointer
;947		ISP			=  24	; interrupt stack pointer
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   33
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;948		ASTLVL			=  25	; ASTLVL value in bits <31:29>, machine check code in bits <23:16>,
;949						; CPUID in bits <7:0>
;950		SCBB			=  26	; system control block base register
;951		PCBB			=  27	; process control block base register
;952		SAVEPC			=  28	; console saved PC
;953		SAVEPSL 		=  29	; console saved PSL
;954	;				=  2A
;955	;				=  2B
;956	;				=  2C
;957	;				=  2D
;958	;				=  2E
;959	;				=  2F
;960
;961		INT.SYS 		=  30	; 0 (bits<31:21>)'int.id (bits<20:16>)'sisr<15:1> (bits<15:1>'iccs<6> (bit<0>)
;962		K0			=  31	; constant 0
;963		K1			=  32	; constant 1
;964	;				=  33
;965	;				=  34
;966	;				=  35
;967	;				=  36
;968		S+PSW_EX		=  37	; opcode<0> in <29>'PSW<7:5> in <7:5>, else 0
;969		POP.COUNT		=  38	; mask bits set in mask processing unit
;970		SHIFT.SIGN		=  39	; shifter sign
;971		ECR			=  3A	; Ebox control register
;972		PERF.COUNT		=  3B	; Performance monitoring facility counters.  PMCTR0 in <31:16>,
;973						; PMCTR1 in <15:0>
;974		PCSCR			=  3C	; Patchable control store control register
;975	;				=  3D
;976	;				=  3E
;977	;				=  3F
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   34
;    DEFINE.MIC 	     Standard Microinstruction Format							      /REV=
;
;978
;979	;	Standard microinstruction format, continued.
;980
;981	;	This field is decoded to provide miscellaneous function control.
;982
;983	MISC/=<19:15>,.DEFAULT=<MISC/NOP>
;984
;985	;		Function	  Val		     Operation				    Comments
;986	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;987		NOP			=  00	; no operation
;988		MULL			=  01	; Identifies an Fbox instruction as MULL
;989		CONST.10.BIT		=  02,.VALIDITY=<LIT.LIT>
;990						; Selects 10-bit B-bus constant from CONST.10 field
;991	;				=  03
;992		DL.BYTE 		=  04	; DL <-- byte				S3: change effects next microword
;993		DL.WORD 		=  05	; DL <-- word				S3: change effects next microword
;994		DL.LONG 		=  06	; DL <-- long				S3: change effects next microword
;995	;				=  07
;996		RESTART.IBOX		=  08	; restart I-box 			S5: prefetch and specifier processing
;997		RESTART.MBOX		=  09	; restart M-box 			S5: operand processing
;998	;				=  0A
;999	;				=  0B
;1000		RESET.CPU		=  0C	; reset I-box, M-box, F-box		S5: reset I-box and stop prefetch
;1001						;					S6: reset M-box and F-box,
;1002						;					    init register file valid bits
;1003	;				=  0D
;1004		CLR.PERF.COUNT		=  0E	; clear perf monitoring counters	S5: clear counters
;1005		INCR.PERF.COUNT 	=  0F	; increment perf monitoring counters	S5: increment counters
;1006
;1007		CLR.STATE.3-0		=  10	; clear flags<3:0>			S3: change effects next microword
;1008		SET.STATE.0		=  11	; set flag<0>				S3: change effects next microword
;1009		SET.STATE.1		=  12	; set flag<1>				S3: change effects next microword
;1010		SET.STATE.2		=  13	; set flag<2>				S3: change effects next microword
;1011		LOAD.SC.FROM.A		=  14	; SC <-- Abus
;1012		LOAD.MPU.FROM.B 	=  15	; MPU <-- Bbus<29:16>			S4: change effects microword+2
;1013	;				=  16
;1014	;				=  17
;1015		LOAD.PSL.CC.IIIP	=  18	; load PSL CCs with map IIIP		PSL.NZV  <--  WBUS.NZV
;1016						;					PSL.C	 <--  PSL.C (Unchanged)
;1017		LOAD.PSL.CC.JIZJ	=  19	; load PSL CCs with map JIZJ		PSL.N	 <--  WBUS.N XOR WBUS.V
;1018						;					PSL.Z	 <--  WBUS.Z
;1019						;					PSL.V	 <--  0
;1020						;					PSL.C	 <-- ~WBUS.C
;1021		LOAD.PSL.CC.IIII	=  1A	; load PSL CCs with map IIII		PSL.NZVC <--  WBUS.NZVC
;1022		LOAD.PSL.CC.IIIJ	=  1B	; load PSL CCs with map IIIJ		PSL.NZV  <--  WBUS.NZV
;1023						;					PSL.C	 <-- ~WBUS.C
;1024		LOAD.PSL.CC.IIIP.QUAD	= 1C	; load PSL CCs with map IIIP.quad	PSL.NV	 <--  WBUS.NV
;1025						;					PSL.Z	 <--  PSL.Z AND WBUS.Z
;1026						;					PSL.C	 <--  PSL.C (Unchanged)
;1027		LOAD.PSL.CC.PPJP	=  1D	; load PSL CCs with map PPJP		PSL.NZC  <--  PSL.NZC (unchanged)
;1028						;					PSL.V	 <--  not WBUS.Z
;1029			SIM.IE.INTEXC	=  1E	; IE.INTERRUPT/IE.EXCEPTION called	Simulator only; not in real hardware
;1030			SIM.HALT	=  1F	; stop simulator			Simulator only; not in real hardware
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   35
;    DEFINE.MIC 	     Special Microinstruction Format							      /REV=
;
;1031	.TOC	"	Special Microinstruction Format"
;1032
;1033	;	The fields for the special microinstruction are:
;1034	;
;1035	;	FORMAT/ 	SPECIAL
;1036	;	ALU/		ALU operation
;1037	;	MRQ/		Mbox request
;1038	;	MISC1/		Special miscellaneous 1
;1039	;	LIT/		B operand control, as follows:
;1040	;	    LIT/0:
;1041	;		MISC2/	Special miscellaneous 2
;1042	;		DISABLE.RETIRE/ Disable retire of instruction on LAST CYCLE
;1043	;		B/	B port select
;1044	;	    LIT/1:
;1045	;		POS/	Constant position	\ If MISC field does not
;1046	;		CONST/	8-bit constant value	/ contain CONST.10.BIT
;1047	;		CONST.10/ 10-bit constant value   If MISC field contains CONST.10.BIT
;1048	;	L/		Length control
;1049	;	W/		Wbus driver control
;1050	;	V/		VA latch update control
;1051	;	DST/		Wbus destination
;1052	;	A/		ALU A port select
;1053	;	MISC/		Miscellaneous
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   36
;    DEFINE.MIC 	     Special Microinstruction Format							      /REV=
;
;1054
;1055	;	Special microinstruction format, continued.
;1056
;1057	;	This field is the first miscellaneous function field.
;1058
;1059	MISC1/=<49:46>,.DEFAULT=<MISC1/NOP>
;1060
;1061	;		Function	  Val		     Operation				    Comments
;1062	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;1063		NOP			=  00	; no operation
;1064		RETIRE.INSTRUCTION	=  01	; retire current instruction
;1065	;				=  02
;1066		FLUSH.VIC		=  03	; flush virtual instruction cache	S5: flush VIC.	REQUIRES A LOAD PC
;1067						;					BEFORE RESTARTING THE IBOX
;1068		FLUSH.BPC		=  04	; flush branch prediction table 	S5: flush branch prediction table
;1069		CLR.STATE.5-4		=  05	; state<5:4> <-- 0
;1070		SET.STATE.3		=  06	; state<3> <-- 1
;1071		SET.STATE.4		=  07	; state<4> <-- 1
;1072		SET.STATE.5		=  08	; state<5> <-- 1
;1073		FOP.VALID		=  09,.VALIDITY=<B.NOT.S1>
;1074						; F-box operand valid on FA/FB bus
;1075	;				=  09
;1076	;				=  0A
;1077	;				=  0B
;1078		FLUSH.PCQ		=  0C	; Flush Ibox PC queue
;1079	;				=  0D
;1080	;				=  0E
;1081	;				=  0F
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   37
;    DEFINE.MIC 	     Special Microinstruction Format							      /REV=
;
;1082
;1083	;	Special microinstruction format, continued.
;1084
;1085	;	This field is the second miscellaneous function field.
;1086
;1087	MISC2/=<44:41>,.DEFAULT=<MISC2/NOP>
;1088
;1089	;		Function	  Val		     Operation				    Comments
;1090	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;1091		NOP			=  00	; no operation
;1092		F.DEST.CHECK		=  01	; Udate the Fbox scoreboard from the Dest list
;1093		FLUSH.PAQ		=  02,.VALIDITY=<MRQ.REQ>
;1094						; Flush Mbox PA queue			Must be done with MRQ field request
;1095	;				=  03
;1096	;				=  04
;1097	;				=  05
;1098	;				=  06
;1099	;				=  07
;1100	;				=  08
;1101	;				=  09
;1102	;				=  0A
;1103	;				=  0B
;1104	;				=  0C
;1105	;				=  0D
;1106	;				=  0E
;1107	;				=  0F
;1108
;1109
;1110	;	This bit disables the retire of an instruction when LAST.CYCLE
;1111	;	is decoded from the SEQ.MUX field.
;1112
;1113	DISABLE.RETIRE/=<40>,.DEFAULT=<DISABLE.RETIRE/NO>
;1114
;1115	;		Function	  Val		     Operation				    Comments
;1116	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;1117		NO			=  0	; Do not diable retire of instruction (the normal thing)
;1118		YES			=  1	; Disable retire of instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   38
;    DEFINE.MIC 	     Microsequencer Control Fields							      /REV=
;
;1119	.TOC	"	Microsequencer Control Fields"
;1120
;1121	;	The microsequencer control fields supply the information necessary for the microsequencer
;1122	;	to calculate the address of the next microinstruction.	The basic computation done by
;1123	;	the microsequencer involves selecting a base address from one of several sources, and then
;1124	;	optionally modifying 3 bits of the base address to get the final next address.
;1125
;1126	;	This field defines the format of the microsequencer control fields.  The microsequencer uses
;1127	;	this bit to block the latch which contains bits <10:8> of the next address.  This means that
;1128	;	the destination of a BRANCH format microinstruction must be in the same 256-location page
;1129	;	as the branch itself.
;1130
;1131	SEQ.FMT/=<14>,.DEFAULT=<SEQ.FMT/JUMP>
;1132
;1133		JUMP			=   0	; format is JUMP
;1134		BRANCH			=   1	; format is BRANCH
;1135
;1136	;	This field controls whether the current micro-PC is pushed on the microsubroutine stack.
;1137
;1138	SEQ.CALL/=<13>,.DEFAULT=<SEQ.CALL/NOP>
;1139
;1140		NOP			=   0	; don't call subroutine
;1141		CALL			=   1	; call subroutine
;1142
;1143	;	For the jump format, this field controls the next-address selection via the NA mux.
;1144
;1145	SEQ.MUX/=<12:11>,.DEFAULT=<SEQ.MUX/J>
;1146
;1147	;		Select		  Val		  Address Source				    Comments
;1148	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;1149		J			=   0	; current microword			uword<10:0>
;1150		STACK			=   1	; microstack				pops top entry from microstack
;1151		LAST.CYCLE		=   2	; I-box 				new microflow
;1152		LAST.CYCLE.OVERFLOW	=   3	; I-box 				new microflow, enable int overflow trap
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   39
;    DEFINE.MIC 	     Microsequencer Control Fields							      /REV=
;
;1153
;1154	;	Microsequencer control fields, continued.
;1155
;1156	;	This field defines the microbranch condition used to modify base address bits <3:1> in a BRANCH format
;1157	;	microinstruction.  In the real microword format, this field occupies the bits specified by the SEQ.COND field.
;1158	;	In the fake microword format, this field is placed in the SEQ.COND.1 field so that a full 11-bit next-address
;1159	;	can be specified in all microwords, including BRANCH format microinstructions.	The SEQ.COND.1 field is moved
;1160	;	to the SEQ.COND field by the allocator to construct the final microword format.
;1161
;1162	SEQ.COND.1/=<65:61>,.DEFAULT=<SEQ.COND.1/0> ; 'Fake' microbranch condition
;1163
;1164	SEQ.COND/=<12:8>			; 'Real' microbranch condition
;1165
;1166	;	Note: AMUX tests on sign values (bits<31>, <15>, <7>) should affect the same NA bit.
;1167
;1168	;	       Select		  Val	Modifier bits for NA<3:1>			Comments
;1169	;	-----------------------  ----	--------------------------------------- --------------------------------------------
;1170		NOP			=  00	; No microbranch condition
;1171		ALU.NZV 		=  01	; alu<n>'alu<z>'alu<v>			set by microinstruction .-2
;1172		ALU.NZC 		=  02	; alu<n>'alu<z>'alu<c>			set by microinstruction .-2
;1173		B.2-0			=  03	; Bbus<2:0>				set by microinstruction .-1
;1174		B.5-3			=  04	; Bbus<5:3>				set by microinstruction .-1
;1175		A.7-5			=  05	; Abus<7:5>				set by microinstruction .-1
;1176		A.15-12 		=  06	; Abus<15>'Abus<14>'(Abus<13> OR Abus<12>) set by microinstruction .-1
;1177		A31.BQA.BNZ1		=  07	; Abus<31>'Bbus<2:0> = 0'(Bbus<15:8> NE 0) set by microinstruction .-1
;1178		MPU.0-6 		=  08	; mask proc unit output 		loaded by microinstruction .-2
;1179		MPU.7-13		=  09	; mask proc unit output 		loaded by microinstruction .-2
;1180		STATE.2-0		=  0A	; state<2:0>				set by microinstruction .-1
;1181		STATE.5-3		=  0B	; state<5:3>				set by microinstruction .-1
;1182		OPCODE.2-0		=  0C	; opcode<2:0>
;1183		PSL.26-24		=  0D	; PSL<26:24>
;1184		PSL.29.23-22		=  0E	; PSL<29,23:22>
;1185		SHF.NZ.INT		=  0F	; shf<n>'shf<z>'interrupt		set by microinstruction .-2
;1186
;1187		TEST.PINS		=  10	; vector present'test data'test strobe
;1188			VECTOR		=  10	; vector present'test data'test strobe
;1189		FBOX.CONDITION		=  11	; Priority encoded Fbox fault code<1:0>'Fbox disabled
;1190		FQ.VR			=  12	; 0'field queue not valid'field queue rmode
;1191						; 000 = valid,memory / 001 = valid,register
;1192						; 010 (not used)     / 011 = queue not valid
;1193	;				13..1F
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   40
;    DEFINE.MIC 	     Microsequencer Control Fields							      /REV=
;
;1194
;1195	;	Microsequencer control fields, continued.
;1196
;1197	;	This field gives the address of the next microinstruction if the current microinstruction is JUMP format.
;1198
;1199	J/=<10:0>,.NEXTADDRESS
;1200
;1201	;	This field gives the 8-bit page offset of the next microinstruction if the current microinstruction is BRANCH
;1202	;	format.  The remaining 3 bits of the 11-bit address are taken from the corresponding bits of the current microPC.
;1203	;	This field is never used by MICRO2.  The allocator selectively fills it in based on the format of the
;1204	;	microinstruction.
;1205
;1206	BR.OFF/=<7:0>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   41
;    DEFINE.MIC 	     Simulation and Assembly Control Fields						      /REV=
;
;1207	.TOC	"	Simulation and Assembly Control Fields"
;1208
;1209	;	The following field definitions are used to provide necessary information to the performance model.
;1210	;	They are removed from the microword by the allocator when the microcode is built for the behavioral
;1211	;	model or the actual chip.  They are retained by the allocator when the microcode is built for the
;1212	;	performance model.
;1213
;1214	;	This field selects which field contains performance model commands.
;1215	;
;1216	;	NOTE: PEBOX.PAS HAS INTIMATE KNOWLEDGE OF THESE DEFINITIONS.
;1217
;1218	SIM.CTRL/=<78>,.DEFAULT=<SIM.CTRL/NONE>
;1219
;1220		CMD			=  0	; Command in the SIM.ADDR field (CMD.xxx)
;1221		NONE			=  1	; No performance model command
;1222	;
;1223	;	When the SIM.CTRL field contains CMD, the following overlapping field contains the command.
;1224	;	This field overlaps with the SIM.COND field.  Therefore if the SIM.CTRL field selects CMD then
;1225	;	the SIM.COND and SIM.COND.SEL fields do not contain valid values.
;1226	;
;1227	SIM.CMD/=<68:66>
;1228	;
;1229	;	      Command		 Val			   Interpretation
;1230	;	----------------------	 ---	---------------------------------------------------
;1231		SIM.ERROR		= 00	; Illegal microword
;1232		EXCEPTION		= 01	; Microcode exception handler reached
;1233		RSVD.OPCODE		= 02	; Reserved opcode handler reached
;1234		EMULATE 		= 03	; Emulated instruction handler reached
;1235		VECTOR.FAULT		= 04	; Vector fault handler reached
;1236	;				= 05	;
;1237	;				= 06	;
;1238	;				= 07	;
;1239	;				= 08	;
;1240	;				= 09	;
;1241	;				= 0A	;
;1242	;				= 0B	;
;1243	;				= 0C	;
;1244	;				= 0D	;
;1245	;				= 0E	;
;1246	;				= 0F	;
;1247
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   42
;    DEFINE.MIC 	     Simulation and Assembly Control Fields						      /REV=
;
;1248
;1249	;	Simulation and assembly control fields, continued.
;1250
;1251	;	This field determines if the SIM.ADDR field alone contains the address source or if that value
;1252	;	is offset +/- a constant.
;1253	;
;1254	;	NOTE: PEBOX.PAS HAS INTIMATE KNOWLEDGE OF THESE DEFINITIONS.
;1255
;1256	SIM.ADDR.SEL/=<77>,.DEFAULT=<SIM.ADDR.SEL/ADDR.K>
;1257
;1258		ADDR			=  0	; Compute address from SIM.ADDR
;1259		ADDR.K			=  1	; Compute address from SIM.ADDR +/- constant
;1260
;1261	;	This field selects the address source for a memory reference.  It does not contain a valid address source
;1262	;	if the field contains NONE, or if the SIM.CTRL field contains CMD (in the latter case, this field
;1263	;	contains a simulator command instead).
;1264
;1265	SIM.ADDR/=<76:72>,.DEFAULT=<SIM.ADDR/NONE>
;1266
;1267	;	   Address Select	 Val			   Interpretation
;1268	;	----------------------	 ---	---------------------------------------------------
;1269		NONE			= 00	; No valid adress
;1270
;1271		K			= 01	; Constant from microword
;1272		EA.1			= 02	; Address of first operand specifier
;1273		EA.2			= 03	; Address of second operand specifier
;1274		EA.3			= 04	; Address of third operand specifier
;1275		SP			= 05	; Stack pointer
;1276		SP.2			= 06	; Second stack pointer value in trace
;1277		SP.EXTENT		= 07	; Farthest stack extent for CALLx, RET, PUSHR, POPR
;1278		CASE			= 08	; Address of CASE displacement
;1279		FIELD			= 09	; Aligned address of bit field
;1280		QUEUE.1 		= 0A	; First queue reference
;1281		QUEUE.2 		= 0B	; Second queue instruction
;1282		QUEUE.HDR		= 0C	; Queue header address
;1283		PCB			= 0D	; Process control block base address
;1284		SCB			= 0E	; System control block base address
;1285		PROBE			= 0F	; Probe extent address
;1286
;1287	;				= 10	;
;1288	;				= 11	;
;1289	;				= 12	;
;1290	;				= 13	;
;1291	;				= 14	;
;1292	;				= 15	;
;1293	;				= 16	;
;1294	;				= 17	;
;1295	;				= 18	;
;1296	;				= 19	;
;1297	;				= 1A	;
;1298	;				= 1B	;
;1299	;				= 1C	;
;1300	;				= 1D	;
;1301	;				= 1E	;
;1302	;				= 1F	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   43
;    DEFINE.MIC 	     Simulation and Assembly Control Fields						      /REV=
;
;1303
;1304	;	Simulation and assembly control fields, continued.
;1305
;1306	;	This field selects the microbranch recipe to be used to generate the next microword address for
;1307	;	a conditional branch instruction.  This field only has a valid value if the SIM.COND.SEL field
;1308	;	contains SIM.COND.FNC and the SIM.CTRL field selects NONE.
;1309	;
;1310	;	NOTE: PEBOX.PAS HAS INTIMATE KNOWLEDGE OF THESE DEFINITIONS.
;1311
;1312	SIM.COND/=<70:66>,.DEFAULT=<SIM.COND/NONE>
;1313
;1314	;	   Condition Select	 Val	     General Use		S3 condition		       S4 condition
;1315	;	-----------------------  ---	----------------------- ------------------------------- -------------------------------
;1316		NONE			= 00	; None			None				None
;1317
;1318		S3.V.PS 		= 01	; Vfield		pos<=31'size=0'size<=32 	None
;1319		S3.V.A			= 02	; Vfield		0'0'pos+size<32 		None
;1320		S3.SV			= 03	; ASHx			shift count<7:5>		None
;1321		S3.CALLX		= 04	; CALLx 		mask<15>'mask<14>'0		None
;1322		S3.ACBX 		= 05	; ACBx			Operand sign'0'0		None
;1323		S34.MASK14		= 06	; PUSHR/POPR		0'mask<14>'0			0'mask<14:0>=0'0
;1324		S34.IPR 		= 07	; MxPR			0'0'0				0'1'0
;1325		S34.QUEUE		= 08	; Queue conditions	0'1'0				0'0'0
;1326		S34.000 		= 09	; Miscellaneous 	0'0'0				0'0'0
;1327		S4.QUEUE.EMPTY		= 0A	; Queue instructions	None				0'PSL<V>=1'0
;1328		S4.QUEUE.SINGLE 	= 0B	; Queue instructions	None				0'queue_addr [2]=0'0
;1329		S4.CHAR.MATCH		= 0C	; STRING		None				0'character match'0'
;1330		S4.CASEX		= 0D	; CASEx 		None				0'0'case out of range
;1331	;				= 0E	;
;1332	;				= 0F	;
;1333
;1334	;				= 10	;
;1335	;				= 11	;
;1336	;				= 12	;
;1337	;				= 13	;
;1338	;				= 14	;
;1339	;				= 15	;
;1340	;				= 16	;
;1341	;				= 17	;
;1342	;				= 18	;
;1343	;				= 19	;
;1344	;				= 1A	;
;1345	;				= 1B	;
;1346	;				= 1C	;
;1347	;				= 1D	;
;1348	;				= 1E	;
;1349	;				= 1F	;
;1350	;
;1351	;	This field is used to select whether the condition is a constant or a function defined by the SIM.COND field.
;1352	;	If the condtion is a constant, the value is in the overlapping field SIM.COND.K.
;1353	;	This field does not contain a valid value if the SIM.CTRL field selects CMD.
;1354
;1355	SIM.COND.SEL/=<71>,.DEFAULT=<SIM.COND.SEL/FNC>
;1356
;1357		FNC			=  0	; Condition in SIM.COND field
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   44
;    DEFINE.MIC 	     Simulation and Assembly Control Fields						      /REV=
;
;1358		CONST			=  1	; S3/S4 constant condition in SIM.COND.K
;1359
;1360	;	This overlapping field determines which E-box pipe segment the constant simulation condition is for.
;1361	;	The value of this bit is unpredictable if the SIM.COND.SEL field is selecting SIM.COND.FNC.
;1362
;1363	SIM.COND.S3.S4/=<70>
;1364		S3			= 0	; constant condition is for S3
;1365		S4			= 1	; constant condition is for S4
;1366
;1367	;	This overlapping field is used to supply a 3-bit constant when the SIM.COND.SEL field contains SIM.COND.K
;1368
;1369	SIM.COND.K/=<68:66>
;1370
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   45
;    DEFINE.MIC 	     Validity Checks									      /REV=
;
;1371	.TOC	"	Validity Checks"
;1372
;1373
;1374	;	A field must contain reference to S1.
;1375	.SET/A.S1=<.EQL[<A/>,<A/S1>]>
;1376
;1377	;	B field must contain reference to S1.
;1378	.SET/B.S1=<.EQL[<B/>,<B/S1>]>
;1379
;1380	;	B field must not contain reference to S1
;1381	.SET/B.NOT.S1=<.NEQ[<B/>,<B/S1>]>
;1382
;1383	;	SEQ.MUX field must contain LAST CYCLE or LAST CYCLE OVERFLOW.
;1384	.SET/MUX.LAST=<.OR[<.EQL[<SEQ.MUX/>,<SEQ.MUX/LAST.CYCLE>]>,
;1385			   <.EQL[<SEQ.MUX/>,<SEQ.MUX/LAST.CYCLE.OVERFLOW>]>]>
;1386
;1387	;	MRQ field must contain effective NOP
;1388	.SET/MRQ.NOP=<.OR[<.EQL[<MRQ/>,<MRQ/NOP>]>,
;1389			  <.EQL[<MRQ/>,<MRQ/SYNC.BDISP>]>,
;1390			  <.EQL[<MRQ/>,<MRQ/SYNC.BDISP.RETIRE>]>,
;1391			  <.EQL[<MRQ/>,<MRQ/SYNC.BDISP.TEST.PRED>]>]>
;1392
;1393	;	MRQ field must not contain effective NOP
;1394	.SET/MRQ.REQ=<.AND[<.NEQ[<MRQ/>,<MRQ/NOP>]>,
;1395			   <.NEQ[<MRQ/>,<MRQ/SYNC.BDISP>]>,
;1396			   <.NEQ[<MRQ/>,<MRQ/SYNC.BDISP.RETIRE>]>,
;1397			   <.NEQ[<MRQ/>,<MRQ/SYNC.BDISP.TEST.PRED>]>]>
;1398
;1399	;	LIT field must contain LIT decode
;1400	.SET/LIT.LIT=<.EQL[<LIT/>,<LIT/LIT>]>
;1401
;1402	;	DST field must contain a working register
;1403	.SET/DST.WN=<.AND[<.GEQ[<DST/>,<DST/W0>]>,<.LEQ[<DST/>,<DST/W5>]>]>
;1404
;1405	;	DST field must contain a GPR
;1406	.SET/DST.RN=<.AND[<.GEQ[<DST/>,<DST/R0>]>,<.LEQ[<DST/>,<DST/SP>]>]>
;1407
;1408	;	DST field must contain a working register or a GPR
;1409	.SET/DST.WN.OR.RN=<.OR[<DST.WN>,<DST.RN>]>
;1410
;1411	.cref
				;1412	.bin
				;1413	.ecode
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   46
;     MACRO.MIC 	     MACRO.MIC -- Macro Definitions							      /REV=
;
				;1414	.TOC	"MACRO.MIC -- Macro Definitions"
				;1415	.TOC	"Revision 1.1"
				;1416
				;1417	;	Bob Supnik
				;1418
;1419	.nobin
;1420	;****************************************************************************
;1421	;*									    *
;1422	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;1423	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;1424	;*  ALL RIGHTS RESERVED.						    *
;1425	;*									    *
;1426	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;1427	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;1428	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;1429	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;1430	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;1431	;*  TRANSFERRED.							    *
;1432	;*									    *
;1433	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;1434	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;1435	;*  CORPORATION.							    *
;1436	;*									    *
;1437	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;1438	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;1439	;*									    *
;1440	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   47
;     MACRO.MIC 	     Revision History									      /REV=
;
;1441	.TOC	"	Revision History"
;1442
;1443	; Edit	  Date	 Who	     Description
;1444	; ---- --------- ---	---------------------
;1445	;    1 20-May-91 GMU	Symptom: No macro to invoke a console halt with
;1446	;				 no cleanup.
;1447	;			Cure:	 Add CONSOLE HALT NO CLEANUP []
;1448	; (1)0 17-Jul-90 GMU	Initial production microcode.
;1449	;
;1450	; Begin version 1.0 here
;1451	;   25 04-Jul-90 GMU	Add performance monitoring facility macros.
;1452	;   24 01-May-90 GMU	Change position of machine check code field in MACHINE CHECK
;1453	;			macro.
;1454	;   23 23-Feb-90 GMU	Add new macros for MxPr rewrite.
;1455	;   22 20-Feb-90 GMU	Remove macros that reference unused decodes.
;1456	;   21 12-Feb-90 GMU	Add sim ie.intexc macro.
;1457	;   20 19-JAN-90 GMU	FLUSH BRANCH PREDICTION CACHE -> FLUSH BRANCH PREDICTION TABLE.
;1458	;   19 12-Dec-89 GMU	Remove SYNC FBOX macro.
;1459	;   18 07-Dec-89 GMU	Move soon-to-be-obsolted macros to the end for easy
;1460	;			removal later.
;1461	;   17 06-Dec-89 GMU	Rename FLUSH BPC to FLUSH BRANCH PREDICTION CACHE.
;1462	;   16 30-Nov-89 GMU	Add [] - [] - 1 macro, remove ALU macros that use
;1463	;			PSL<C> carry-in.
;1464	;   15 17-Nov-89 GMU	Remove obsolete macros.
;1465	;   14 08-Nov-89 GMU	Remove edit 13.
;1466	;   13 04-Nov-89 GMU	Clear state<3:0> in CONSOLE HALT MACRO.
;1467	;   12 19-Oct-89 DGM	Add NODST macros for all ALU operations
;1468	;   11 18-OCT-89 GMU	Add PCB read/write macros.
;1469	;   10 28-Sep-89 GMU	Add new probe macro.
;1470	;    9 21-Sep-89 GMU	Add new macros.
;1471	;    8 20-Sep-89 GMU	Add macros for MRQ/TB.TAG.FILL and MRQ/TB.PTE.FILL.
;1472	;    7 11-Sep-89 GMU	Add .MODE to PROBE macros to emphasize mode is from register.
;1473	;    6 15-Aug-89 GMU	Turn CLEAR WRITE BUFFERS macro into MRQ/NOP for now.
;1474	;    5	2-Aug-89 DGM	Modified SMUL and UDIV macros to update Q
;1475	;    4 12-Jul-89 GMU	Added definitions to support CPU init on exception.
;1476	;    3 30-Jun-89 DGM	Added macros: SMUL ; NODST <-- PASSx ; MULL
;1477	;    2 28-Jun-89 GMU	Corrected error in retire branch queue macro.
;1478	;    1 22-Nov-88 DB	Add FBOX DEST CHECK
;1479	; (0)0 14-Sep-87 RMS	Trial microcode.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   48
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1480	.TOC	"	ALU Macros"
;1481
;1482	;	ALU macros with register operands that drive the Wbus.
;1483
;1484	[] <-- [] + []			"LIT/BREG,ALU/A.PLUS.B,DST/@1,A/@2,B/@3,W/ALU"
;1485	[] <-- [] + [] + 1		"LIT/BREG,ALU/A.PLUS.B.PLUS.1,DST/@1,A/@2,B/@3,W/ALU"
;1486	[] <-- [] - []			"LIT/BREG,ALU/A.MINUS.B,DST/@1,A/@2,B/@3,W/ALU"
;1487	[] <-- [] - [] - 1		"LIT/BREG,ALU/A.MINUS.B.MINUS.1,DST/@1,A/@2,B/@3,W/ALU"
;1488	[] <-- [] AND []		"LIT/BREG,ALU/A.AND.B,DST/@1,A/@2,B/@3,W/ALU"
;1489	[] <-- NOT [] AND []		"LIT/BREG,ALU/NOT.A.AND.B,DST/@1,A/@2,B/@3,W/ALU"
;1490	[] <-- [] ANDNOT []		"LIT/BREG,ALU/A.AND.NOT.B,DST/@1,A/@2,B/@3,W/ALU"
;1491	[] <-- [] OR [] 		"LIT/BREG,ALU/A.OR.B,DST/@1,A/@2,B/@3,W/ALU"
;1492	[] <-- [] XOR []		"LIT/BREG,ALU/A.XOR.B,DST/@1,A/@2,B/@3,W/ALU"
;1493	[] <-- (-[] + [])		"LIT/BREG,ALU/B.MINUS.A,DST/@1,A/@2,B/@3,W/ALU"
;1494	[] <-- [] UDIV []		"FORMAT/STANDARD,LIT/BREG,ALU/UDIV.STEP,SHF/NOP,DST/@1,A/@2,B/@3,W/ALU,Q/UPDATE.Q"
;1495	[] <-- [] SMUL []		"FORMAT/STANDARD,LIT/BREG,ALU/SMUL.STEP,SHF/NOP,DST/@1,A/@2,B/@3,W/ALU,Q/UPDATE.Q"
;1496
;1497	[] <-- []			"ALU/PASS.A,DST/@1,A/@2,W/ALU"
;1498	[] <-- [] + 1			"ALU/A.PLUS.1,DST/@1,A/@2,W/ALU"
;1499	[] <-- [] - 1			"ALU/A.MINUS.1,DST/@1,A/@2,W/ALU"
;1500	[] <-- [] + 4			"ALU/A.PLUS.4,DST/@1,A/@2,W/ALU"
;1501	[] <-- [] - 4			"ALU/A.MINUS.4,DST/@1,A/@2,W/ALU"
;1502	[] <-- -[]			"LIT/BREG,ALU/NEG.B,DST/@1,B/@2,W/ALU"
;1503	[] <-- NOT []			"LIT/BREG,ALU/NOT.B,DST/@1,B/@2,W/ALU"
;1504	[] <-- B []			"LIT/BREG,ALU/PASS.B,DST/@1,B/@2,W/ALU"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   49
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1505
;1506	;	ALU macros, continued.
;1507
;1508	;	ALU macros with register operands that drive VA.
;1509
;1510	VA <-- [] + []			"LIT/BREG,ALU/A.PLUS.B,A/@1,B/@2,V/UPDATE.VA"
;1511	VA <-- [] + [] + 1		"LIT/BREG,ALU/A.PLUS.B.PLUS.1,A/@1,B/@2,V/UPDATE.VA"
;1512	VA <-- [] - []			"LIT/BREG,ALU/A.MINUS.B,A/@1,B/@2,V/UPDATE.VA"
;1513	VA <-- [] AND []		"LIT/BREG,ALU/A.AND.B,A/@1,B/@2,V/UPDATE.VA"
;1514	VA <-- NOT [] AND []		"LIT/BREG,ALU/NOT.A.AND.B,A/@1,B/@2,V/UPDATE.VA"
;1515	VA <-- [] ANDNOT []		"LIT/BREG,ALU/A.AND.NOT.B,A/@1,B/@2,V/UPDATE.VA"
;1516	VA <-- [] OR [] 		"LIT/BREG,ALU/A.OR.B,A/@1,B/@2,V/UPDATE.VA"
;1517	VA <-- [] XOR []		"LIT/BREG,ALU/A.XOR.B,A/@1,B/@2,V/UPDATE.VA"
;1518	VA <-- (-[] + [])		"LIT/BREG,ALU/B.MINUS.A,A/@1,B/@2,V/UPDATE.VA"
;1519
;1520	VA <-- []			"ALU/PASS.A,A/@1,V/UPDATE.VA"
;1521	VA <-- [] + 1			"ALU/A.PLUS.1,A/@1,V/UPDATE.VA"
;1522	VA <-- [] - 1			"ALU/A.MINUS.1,A/@1,V/UPDATE.VA"
;1523	VA <-- [] + 4			"ALU/A.PLUS.4,A/@1,V/UPDATE.VA"
;1524	VA <-- [] - 4			"ALU/A.MINUS.4,A/@1,V/UPDATE.VA"
;1525	VA <-- -[]			"LIT/BREG,ALU/NEG.B,B/@1,V/UPDATE.VA"
;1526	VA <-- NOT []			"LIT/BREG,ALU/NOT.B,B/@1,V/UPDATE.VA"
;1527	VA <-- B []			"LIT/BREG,ALU/PASS.B,B/@1,V/UPDATE.VA"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   50
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1528
;1529	;	ALU macros, continued.
;1530
;1531	;	ALU macros with constant operand that drive the Wbus.
;1532
;1533	[] <-- [] + K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.PLUS.B,CONST.10/@3,DST/@1,A/@2,W/ALU"
;1534	[] <-- [] - K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.MINUS.B,CONST.10/@3,DST/@1,A/@2,W/ALU"
;1535	[] <-- K10.[] - []		"LIT/LIT,MISC/CONST.10.BIT,ALU/B.MINUS.A,CONST.10/@2,DST/@1,A/@3,W/ALU"
;1536	[] <-- [] AND K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.AND.B,CONST.10/@3,DST/@1,A/@2,W/ALU"
;1537	[] <-- [] OR K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.OR.B,CONST.10/@3,DST/@1,A/@2,W/ALU"
;1538	[] <-- [] ANDNOT K10.[] 	"LIT/LIT,MISC/CONST.10.BIT,ALU/A.AND.NOT.B,CONST.10/@3,DST/@1,A/@2,W/ALU"
;1539	[] <-- [] XOR K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.XOR.B,CONST.10/@3,DST/@1,A/@2,W/ALU"
;1540	[] <-- NOT K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/NOT.B,CONST.10/@2,DST/@1,W/ALU"
;1541	[] <-- -K10.[]			"LIT/LIT,MISC/CONST.10.BIT,ALU/NEG.B,CONST.10/@2,DST/@1,W/ALU"
;1542	[] <-- K10.[]			"LIT/LIT,MISC/CONST.10.BIT,ALU/PASS.B,CONST.10/@2,DST/@1,W/ALU"
;1543
;1544	[] <-- [] + 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.PLUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1545	[] <-- [] - 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.MINUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1546	[] <-- 000000[] - []		"LIT/LIT,POS/BYTE0,ALU/B.MINUS.A,CONST/@2,DST/@1,A/@3,W/ALU"
;1547	[] <-- [] AND 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.AND.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1548	[] <-- [] OR 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.OR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1549	[] <-- [] ANDNOT 000000[]	"LIT/LIT,POS/BYTE0,ALU/A.AND.NOT.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1550	[] <-- [] XOR 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.XOR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1551	[] <-- NOT 000000[]		"LIT/LIT,POS/BYTE0,ALU/NOT.B,CONST/@2,DST/@1,W/ALU"
;1552	[] <-- -000000[]		"LIT/LIT,POS/BYTE0,ALU/NEG.B,CONST/@2,DST/@1,W/ALU"
;1553	[] <-- 000000[] 		"LIT/LIT,POS/BYTE0,ALU/PASS.B,CONST/@2,DST/@1,W/ALU"
;1554
;1555	[] <-- [] + 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.PLUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1556	[] <-- [] - 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.MINUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1557	[] <-- 0000[]00 - []		"LIT/LIT,POS/BYTE1,ALU/B.MINUS.A,CONST/@2,DST/@1,A/@3,W/ALU"
;1558	[] <-- [] AND 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.AND.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1559	[] <-- [] OR 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.OR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1560	[] <-- [] ANDNOT 0000[]00	"LIT/LIT,POS/BYTE1,ALU/A.AND.NOT.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1561	[] <-- [] XOR 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.XOR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1562	[] <-- NOT 0000[]00		"LIT/LIT,POS/BYTE1,ALU/NOT.B,CONST/@2,DST/@1,W/ALU"
;1563	[] <-- -0000[]00		"LIT/LIT,POS/BYTE1,ALU/NEG.B,CONST/@2,DST/@1,W/ALU"
;1564	[] <-- 0000[]00 		"LIT/LIT,POS/BYTE1,ALU/PASS.B,CONST/@2,DST/@1,W/ALU"
;1565
;1566	[] <-- [] + 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.PLUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1567	[] <-- [] - 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.MINUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1568	[] <-- 00[]0000 - []		"LIT/LIT,POS/BYTE2,ALU/B.MINUS.A,CONST/@2,DST/@1,A/@3,W/ALU"
;1569	[] <-- [] AND 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.AND.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1570	[] <-- [] OR 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.OR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1571	[] <-- [] ANDNOT 00[]0000	"LIT/LIT,POS/BYTE2,ALU/A.AND.NOT.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1572	[] <-- [] XOR 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.XOR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1573	[] <-- NOT 00[]0000		"LIT/LIT,POS/BYTE2,ALU/NOT.B,CONST/@2,DST/@1,W/ALU"
;1574	[] <-- -00[]0000		"LIT/LIT,POS/BYTE2,ALU/NEG.B,CONST/@2,DST/@1,W/ALU"
;1575	[] <-- 00[]0000 		"LIT/LIT,POS/BYTE2,ALU/PASS.B,CONST/@2,DST/@1,W/ALU"
;1576
;1577	[] <-- [] + []000000		"LIT/LIT,POS/BYTE3,ALU/A.PLUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1578	[] <-- [] - []000000		"LIT/LIT,POS/BYTE3,ALU/A.MINUS.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1579	[] <-- []000000 - []		"LIT/LIT,POS/BYTE3,ALU/B.MINUS.A,CONST/@2,DST/@1,A/@3,W/ALU"
;1580	[] <-- [] AND []000000		"LIT/LIT,POS/BYTE3,ALU/A.AND.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1581	[] <-- [] OR []000000		"LIT/LIT,POS/BYTE3,ALU/A.OR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1582	[] <-- [] ANDNOT []000000	"LIT/LIT,POS/BYTE3,ALU/A.AND.NOT.B,CONST/@3,DST/@1,A/@2,W/ALU"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   51
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1583	[] <-- [] XOR []000000		"LIT/LIT,POS/BYTE3,ALU/A.XOR.B,CONST/@3,DST/@1,A/@2,W/ALU"
;1584	[] <-- NOT []000000		"LIT/LIT,POS/BYTE3,ALU/NOT.B,CONST/@2,DST/@1,W/ALU"
;1585	[] <-- -[]000000		"LIT/LIT,POS/BYTE3,ALU/NEG.B,CONST/@2,DST/@1,W/ALU"
;1586	[] <-- []000000 		"LIT/LIT,POS/BYTE3,ALU/PASS.B,CONST/@2,DST/@1,W/ALU"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   52
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1587
;1588	;	ALU macros, continued.
;1589
;1590	;	ALU macros with constant operand that drive VA.
;1591
;1592	VA <-- [] + K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.PLUS.B,CONST.10/@2,A/@1,V/UPDATE.VA"
;1593	VA <-- [] - K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.MINUS.B,CONST.10/@2,A/@1,V/UPDATE.VA"
;1594	VA <-- K10.[] - []		"LIT/LIT,MISC/CONST.10.BIT,ALU/B.MINUS.A,CONST.10/@1,A/@2,V/UPDATE.VA"
;1595	VA <-- [] AND K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.AND.B,CONST.10/@2,A/@1,V/UPDATE.VA"
;1596	VA <-- [] OR K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.OR.B,CONST.10/@2,A/@1,V/UPDATE.VA"
;1597	VA <-- [] ANDNOT K10.[] 	"LIT/LIT,MISC/CONST.10.BIT,ALU/A.AND.NOT.B,CONST.10/@2,A/@1,V/UPDATE.VA"
;1598	VA <-- [] XOR K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.XOR.B,CONST.10/@2,A/@1,V/UPDATE.VA"
;1599	VA <-- NOT K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/NOT.B,CONST.10/@1,V/UPDATE.VA"
;1600	VA <-- -K10.[]			"LIT/LIT,MISC/CONST.10.BIT,ALU/NEG.B,CONST.10/@1,V/UPDATE.VA"
;1601	VA <-- K10.[]			"LIT/LIT,MISC/CONST.10.BIT,ALU/PASS.B,CONST.10/@1,V/UPDATE.VA"
;1602
;1603	VA <-- [] + 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.PLUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1604	VA <-- [] - 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.MINUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1605	VA <-- 000000[] - []		"LIT/LIT,POS/BYTE0,ALU/B.MINUS.A,CONST/@1,A/@2,V/UPDATE.VA"
;1606	VA <-- [] AND 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.AND.B,CONST/@2,A/@1,V/UPDATE.VA"
;1607	VA <-- [] OR 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.OR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1608	VA <-- [] ANDNOT 000000[]	"LIT/LIT,POS/BYTE0,ALU/A.AND.NOT.B,CONST/@2,A/@1,V/UPDATE.VA"
;1609	VA <-- [] XOR 000000[]		"LIT/LIT,POS/BYTE0,ALU/A.XOR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1610	VA <-- NOT 000000[]		"LIT/LIT,POS/BYTE0,ALU/NOT.B,CONST/@1,V/UPDATE.VA"
;1611	VA <-- -000000[]		"LIT/LIT,POS/BYTE0,ALU/NEG.B,CONST/@1,V/UPDATE.VA"
;1612	VA <-- 000000[] 		"LIT/LIT,POS/BYTE0,ALU/PASS.B,CONST/@1,V/UPDATE.VA"
;1613
;1614	VA <-- [] + 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.PLUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1615	VA <-- [] - 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.MINUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1616	VA <-- 0000[]00 - []		"LIT/LIT,POS/BYTE1,ALU/B.MINUS.A,CONST/@1,A/@2,V/UPDATE.VA"
;1617	VA <-- [] AND 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.AND.B,CONST/@2,A/@1,V/UPDATE.VA"
;1618	VA <-- [] OR 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.OR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1619	VA <-- [] ANDNOT 0000[]00	"LIT/LIT,POS/BYTE1,ALU/A.AND.NOT.B,CONST/@2,A/@1,V/UPDATE.VA"
;1620	VA <-- [] XOR 0000[]00		"LIT/LIT,POS/BYTE1,ALU/A.XOR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1621	VA <-- NOT 0000[]00		"LIT/LIT,POS/BYTE1,ALU/NOT.B,CONST/@1,V/UPDATE.VA"
;1622	VA <-- -0000[]00		"LIT/LIT,POS/BYTE1,ALU/NEG.B,CONST/@1,V/UPDATE.VA"
;1623	VA <-- 0000[]00 		"LIT/LIT,POS/BYTE1,ALU/PASS.B,CONST/@1,V/UPDATE.VA"
;1624
;1625	VA <-- [] + 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.PLUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1626	VA <-- [] - 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.MINUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1627	VA <-- 00[]0000 - []		"LIT/LIT,POS/BYTE2,ALU/B.MINUS.A,CONST/@1,A/@2,V/UPDATE.VA"
;1628	VA <-- [] AND 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.AND.B,CONST/@2,A/@1,V/UPDATE.VA"
;1629	VA <-- [] OR 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.OR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1630	VA <-- [] ANDNOT 00[]0000	"LIT/LIT,POS/BYTE2,ALU/A.AND.NOT.B,CONST/@2,A/@1,V/UPDATE.VA"
;1631	VA <-- [] XOR 00[]0000		"LIT/LIT,POS/BYTE2,ALU/A.XOR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1632	VA <-- NOT 00[]0000		"LIT/LIT,POS/BYTE2,ALU/NOT.B,CONST/@1,V/UPDATE.VA"
;1633	VA <-- -00[]0000		"LIT/LIT,POS/BYTE2,ALU/NEG.B,CONST/@1,V/UPDATE.VA"
;1634	VA <-- 00[]0000 		"LIT/LIT,POS/BYTE2,ALU/PASS.B,CONST/@1,V/UPDATE.VA"
;1635
;1636	VA <-- [] + []000000		"LIT/LIT,POS/BYTE3,ALU/A.PLUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1637	VA <-- [] - []000000		"LIT/LIT,POS/BYTE3,ALU/A.MINUS.B,CONST/@2,A/@1,V/UPDATE.VA"
;1638	VA <-- []000000 - []		"LIT/LIT,POS/BYTE3,ALU/B.MINUS.A,CONST/@1,A/@2,V/UPDATE.VA"
;1639	VA <-- [] AND []000000		"LIT/LIT,POS/BYTE3,ALU/A.AND.B,CONST/@2,A/@1,V/UPDATE.VA"
;1640	VA <-- [] OR []000000		"LIT/LIT,POS/BYTE3,ALU/A.OR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1641	VA <-- [] ANDNOT []000000	"LIT/LIT,POS/BYTE3,ALU/A.AND.NOT.B,CONST/@2,A/@1,V/UPDATE.VA"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   53
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1642	VA <-- [] XOR []000000		"LIT/LIT,POS/BYTE3,ALU/A.XOR.B,CONST/@2,A/@1,V/UPDATE.VA"
;1643	VA <-- NOT []000000		"LIT/LIT,POS/BYTE3,ALU/NOT.B,CONST/@1,V/UPDATE.VA"
;1644	VA <-- -[]000000		"LIT/LIT,POS/BYTE3,ALU/NEG.B,CONST/@1,V/UPDATE.VA"
;1645	VA <-- []000000 		"LIT/LIT,POS/BYTE3,ALU/PASS.B,CONST/@1,V/UPDATE.VA"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   54
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1646
;1647	;	ALU macros, continued.
;1648
;1649	;	ALU macros with register operands that have no destination.
;1650
;1651	NODST <-- [] + []		"LIT/BREG,ALU/A.PLUS.B,A/@1,B/@2"
;1652	NODST <-- [] + [] + 1		"LIT/BREG,ALU/A.PLUS.B.PLUS.1,A/@1,B/@2"
;1653	NODST <-- [] - []		"LIT/BREG,ALU/A.MINUS.B,A/@1,B/@2"
;1654	NODST <-- [] AND []		"LIT/BREG,ALU/A.AND.B,A/@1,B/@2"
;1655	NODST <-- NOT [] AND [] 	"LIT/BREG,ALU/NOT.A.AND.B,A/@1,B/@2"
;1656	NODST <-- [] ANDNOT []		"LIT/BREG,ALU/A.AND.NOT.B,A/@1,B/@2"
;1657	NODST <-- [] OR []		"LIT/BREG,ALU/A.OR.B,A/@1,B/@2"
;1658	NODST <-- [] XOR []		"LIT/BREG,ALU/A.XOR.B,A/@1,B/@2"
;1659	NODST <-- (-[] + [])		"LIT/BREG,ALU/B.MINUS.A,A/@1,B/@2"
;1660
;1661	NODST <-- []			"ALU/PASS.A,A/@1"
;1662	NODST <-- [] + 1		"ALU/A.PLUS.1,A/@1"
;1663	NODST <-- [] - 1		"ALU/A.MINUS.1,A/@1"
;1664	NODST <-- [] + 4		"ALU/A.PLUS.4,A/@1"
;1665	NODST <-- [] - 4		"ALU/A.MINUS.4,A/@1"
;1666	NODST <-- -[]			"LIT/BREG,ALU/NEG.B,B/@1"
;1667	NODST <-- NOT []		"LIT/BREG,ALU/NOT.B,B/@1"
;1668	NODST <-- B []			"LIT/BREG,ALU/PASS.B,B/@1"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   55
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1669
;1670	;	ALU macros, continued.
;1671
;1672	;	ALU macros with constant operand that have no destination.
;1673
;1674	NODST <-- [] + K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.PLUS.B,CONST.10/@2,A/@1"
;1675	NODST <-- [] - K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.MINUS.B,CONST.10/@2,A/@1"
;1676	NODST <-- K10.[] - []		"LIT/LIT,MISC/CONST.10.BIT,ALU/B.MINUS.A,CONST.10/@1,A/@2"
;1677	NODST <-- [] AND K10.[] 	"LIT/LIT,MISC/CONST.10.BIT,ALU/A.AND.B,CONST.10/@2,A/@1"
;1678	NODST <-- [] OR K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/A.OR.B,CONST.10/@2,A/@1"
;1679	NODST <-- [] ANDNOT K10.[]	"LIT/LIT,MISC/CONST.10.BIT,ALU/A.AND.NOT.B,CONST.10/@2,A/@1"
;1680	NODST <-- [] XOR K10.[] 	"LIT/LIT,MISC/CONST.10.BIT,ALU/A.XOR.B,CONST.10/@2,A/@1"
;1681	NODST <-- NOT K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/NOT.B,CONST.10/@1"
;1682	NODST <-- -K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/NEG.B,CONST.10/@1"
;1683	NODST <-- K10.[]		"LIT/LIT,MISC/CONST.10.BIT,ALU/PASS.B,CONST.10/@1"
;1684
;1685	NODST <-- [] + 000000[] 	"LIT/LIT,POS/BYTE0,ALU/A.PLUS.B,CONST/@2,A/@1"
;1686	NODST <-- [] - 000000[] 	"LIT/LIT,POS/BYTE0,ALU/A.MINUS.B,CONST/@2,A/@1"
;1687	NODST <-- 000000[] - [] 	"LIT/LIT,POS/BYTE0,ALU/B.MINUS.A,CONST/@1,A/@2"
;1688	NODST <-- [] AND 000000[]	"LIT/LIT,POS/BYTE0,ALU/A.AND.B,CONST/@2,A/@1"
;1689	NODST <-- [] OR 000000[]	"LIT/LIT,POS/BYTE0,ALU/A.OR.B,CONST/@2,A/@1"
;1690	NODST <-- [] ANDNOT 000000[]	"LIT/LIT,POS/BYTE0,ALU/A.AND.NOT.B,CONST/@2,A/@1"
;1691	NODST <-- [] XOR 000000[]	"LIT/LIT,POS/BYTE0,ALU/A.XOR.B,CONST/@2,A/@1"
;1692	NODST <-- NOT 000000[]		"LIT/LIT,POS/BYTE0,ALU/NOT.B,CONST/@1"
;1693	NODST <-- -000000[]		"LIT/LIT,POS/BYTE0,ALU/NEG.B,CONST/@1"
;1694	NODST <-- 000000[]		"LIT/LIT,POS/BYTE0,ALU/PASS.B,CONST/@1"
;1695
;1696	NODST <-- [] + 0000[]00 	"LIT/LIT,POS/BYTE1,ALU/A.PLUS.B,CONST/@2,A/@1"
;1697	NODST <-- [] - 0000[]00 	"LIT/LIT,POS/BYTE1,ALU/A.MINUS.B,CONST/@2,A/@1"
;1698	NODST <-- 0000[]00 - [] 	"LIT/LIT,POS/BYTE1,ALU/B.MINUS.A,CONST/@1,A/@2"
;1699	NODST <-- [] AND 0000[]00	"LIT/LIT,POS/BYTE1,ALU/A.AND.B,CONST/@2,A/@1"
;1700	NODST <-- [] OR 0000[]00	"LIT/LIT,POS/BYTE1,ALU/A.OR.B,CONST/@2,A/@1"
;1701	NODST <-- [] ANDNOT 0000[]00	"LIT/LIT,POS/BYTE1,ALU/A.AND.NOT.B,CONST/@2,A/@1"
;1702	NODST <-- [] XOR 0000[]00	"LIT/LIT,POS/BYTE1,ALU/A.XOR.B,CONST/@2,A/@1"
;1703	NODST <-- NOT 0000[]00		"LIT/LIT,POS/BYTE1,ALU/NOT.B,CONST/@1"
;1704	NODST <-- -0000[]00		"LIT/LIT,POS/BYTE1,ALU/NEG.B,CONST/@1"
;1705	NODST <-- 0000[]00		"LIT/LIT,POS/BYTE1,ALU/PASS.B,CONST/@1"
;1706
;1707	NODST <-- [] + 00[]0000 	"LIT/LIT,POS/BYTE2,ALU/A.PLUS.B,CONST/@2,A/@1"
;1708	NODST <-- [] - 00[]0000 	"LIT/LIT,POS/BYTE2,ALU/A.MINUS.B,CONST/@2,A/@1"
;1709	NODST <-- 00[]0000 - [] 	"LIT/LIT,POS/BYTE2,ALU/B.MINUS.A,CONST/@1,A/@2"
;1710	NODST <-- [] AND 00[]0000	"LIT/LIT,POS/BYTE2,ALU/A.AND.B,CONST/@2,A/@1"
;1711	NODST <-- [] OR 00[]0000	"LIT/LIT,POS/BYTE2,ALU/A.OR.B,CONST/@2,A/@1"
;1712	NODST <-- [] ANDNOT 00[]0000	"LIT/LIT,POS/BYTE2,ALU/A.AND.NOT.B,CONST/@2,A/@1"
;1713	NODST <-- [] XOR 00[]0000	"LIT/LIT,POS/BYTE2,ALU/A.XOR.B,CONST/@2,A/@1"
;1714	NODST <-- NOT 00[]0000		"LIT/LIT,POS/BYTE2,ALU/NOT.B,CONST/@1"
;1715	NODST <-- -00[]0000		"LIT/LIT,POS/BYTE2,ALU/NEG.B,CONST/@1"
;1716	NODST <-- 00[]0000		"LIT/LIT,POS/BYTE2,ALU/PASS.B,CONST/@1"
;1717
;1718	NODST <-- [] + []000000 	"LIT/LIT,POS/BYTE3,ALU/A.PLUS.B,CONST/@2,A/@1"
;1719	NODST <-- [] - []000000 	"LIT/LIT,POS/BYTE3,ALU/A.MINUS.B,CONST/@2,A/@1"
;1720	NODST <-- []000000 - [] 	"LIT/LIT,POS/BYTE3,ALU/B.MINUS.A,CONST/@1,A/@2"
;1721	NODST <-- [] AND []000000	"LIT/LIT,POS/BYTE3,ALU/A.AND.B,CONST/@2,A/@1"
;1722	NODST <-- [] OR []000000	"LIT/LIT,POS/BYTE3,ALU/A.OR.B,CONST/@2,A/@1"
;1723	NODST <-- [] ANDNOT []000000	"LIT/LIT,POS/BYTE3,ALU/A.AND.NOT.B,CONST/@2,A/@1"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   56
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1724	NODST <-- [] XOR []000000	"LIT/LIT,POS/BYTE3,ALU/A.XOR.B,CONST/@2,A/@1"
;1725	NODST <-- NOT []000000		"LIT/LIT,POS/BYTE3,ALU/NOT.B,CONST/@1"
;1726	NODST <-- -[]000000		"LIT/LIT,POS/BYTE3,ALU/NEG.B,CONST/@1"
;1727	NODST <-- []000000		"LIT/LIT,POS/BYTE3,ALU/PASS.B,CONST/@1"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   57
;     MACRO.MIC 	     ALU Macros 									      /REV=
;
;1728
;1729	;	ALU macros, continued.
;1730
;1731	;	Special ALU macros.
;1732
;1733	NOP				"[WBUS] <-- [NONE],LONG"
;1734	NOP NODEST			"[NONE] <-- [NONE],LONG"
;1735	SET PSL(V)			"[WBUS] <-- 000000[01],LONG,SET PSL CC.PPJP"
;1736	CLEAR PSL(V)			"[WBUS] <-- 000000[00],LONG,SET PSL CC.PPJP"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   58
;     MACRO.MIC 	     MEMREQ Macros									      /REV=
;
;1737	.TOC	"	MEMREQ Macros"
;1738
;1739	[] <-- MEM (VA) 		"MRQ/READ.V.RCHK,DST/@1"
;1740	[] <-- MEM.PR (VA)		"MRQ/READ.PR,DST/@1"
;1741	[] <-- MEM.LOCK (VA)		"MRQ/READ.V.LOCK,DST/@1"
;1742	[] <-- MEM.SCB (VA)		"MRQ/READ.P,DST/@1"
;1743	[] <-- MEM.PCB (VA)		"MRQ/READ.P,DST/@1"
;1744	[] <-- MEM.PHYS (VA)		"MRQ/READ.P,DST/@1"
;1745	[] <-- MEM.WCHK (VA)		"MRQ/READ.V.WCHK,DST/@1"
;1746	[] <-- MEM.NOCHK (VA)		"MRQ/READ.V.NOCHK,DST/@1"
;1747	[] <-- PROBE.R.MODE (VA)	"MRQ/PROBE.V.RCHK,DST/@1"
;1748	[] <-- PROBE.W.MODE (VA)	"MRQ/PROBE.V.WCHK,DST/@1"
;1749	[] <-- PROBE.R.MODE.NOFILL (VA) "MRQ/PROBE.V.RCHK.NOFILL,DST/@1"
;1750
;1751	MEM (VA)&			"MRQ/WRITE.V.WCHK"
;1752	MEM.PR (VA)&			"MRQ/WRITE.PR"
;1753	MEM.UNLOCK (VA)&		"MRQ/WRITE.V.UNLOCK"
;1754	MEM.NOCHK (VA)& 		"MRQ/WRITE.V.NOCHK"
;1755	MEM.PHYS (VA)&			"MRQ/WRITE.P"
;1756	MEM.PCB (VA)&			"MRQ/WRITE.P"
;1757	WCHK (VA)&			"MRQ/WCHK"
;1758
;1759	SYNCHRONIZE MBOX		"MRQ/SYNC.MBOX"
;1760	TB INVALIDATE SINGLE		"MRQ/TB.INVALIDATE.SINGLE"
;1761	TB INVALIDATE PROCESS		"MRQ/TB.INVALIDATE.PROCESS"
;1762	TB INVALIDATE ALL		"MRQ/TB.INVALIDATE.ALL"
;1763	TB TAG FILL			"MRQ/TB.TAG.FILL"
;1764	TB PTE FILL			"MRQ/TB.PTE.FILL"
;1765	LOAD PC 			"MRQ/LOAD.PC"
;1766
;1767	WAIT BDISP VALID		"MRQ/SYNC.BDISP"
;1768	RETIRE UNCOND BQ ENTRY		"MRQ/SYNC.BDISP.RETIRE"
;1769	RETIRE COND BQ ENTRY		"MRQ/SYNC.BDISP.TEST.PRED"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   59
;     MACRO.MIC 	     SHIFT Macros									      /REV=
;
;1770	.TOC	"	SHIFT Macros"
;1771
;1772	;	Shift macros with register operands that drive the Wbus.
;1773
;1774	[] <-- [] LROT []		"FORMAT/STANDARD,LIT/BREG,VAL/@3,DST/@1,B/@2,A/@2,SHF/LEFT.DOUBLE,W/SHF"
;1775	[] <-- [] LROT (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@2,A/@2,SHF/LEFT.DOUBLE,W/SHF"
;1776	[] <-- [] RROT []		"FORMAT/STANDARD,LIT/BREG,VAL/@3,DST/@1,B/@2,A/@2,SHF/RIGHT.DOUBLE,W/SHF"
;1777	[] <-- [] RROT (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@2,A/@2,SHF/RIGHT.DOUBLE,W/SHF"
;1778	[] <-- [] RROT (32-SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@2,A/@2,SHF/LEFT.DOUBLE,W/SHF"
;1779	[] <-- []!![] LSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@4,DST/@1,B/@3,A/@2,SHF/LEFT.DOUBLE,W/SHF"
;1780	[] <-- []!![] LSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@3,A/@2,SHF/LEFT.DOUBLE,W/SHF"
;1781	[] <-- []!![] RSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@4,DST/@1,B/@3,A/@2,SHF/RIGHT.DOUBLE,W/SHF"
;1782	[] <-- []!![] RSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@3,A/@2,SHF/RIGHT.DOUBLE,W/SHF"
;1783	[] <-- []!![] RSH (32-SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@3,A/@2,SHF/LEFT.DOUBLE,W/SHF"
;1784	[] <-- SEXT [] RSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@3,DST/@1,B/@2,A/SHIFT.SIGN,SHF/RIGHT.DOUBLE,W/SHF"
;1785	[] <-- SEXT [] RSH (SC) 	"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@2,A/SHIFT.SIGN,SHF/RIGHT.DOUBLE,W/SHF"
;1786	[] <-- SEXT [] RSH (32-SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@2,A/SHIFT.SIGN,SHF/LEFT.DOUBLE,W/SHF"
;1787
;1788	[] <-- PASSA [] 		"FORMAT/STANDARD,DST/@1,A/@2,SHF/PASS.A,W/SHF"
;1789	[] <-- PASSB [] 		"FORMAT/STANDARD,LIT/BREG,DST/@1,B/@2,SHF/PASS.B,W/SHF"
;1790	[] <-- 0			"FORMAT/STANDARD,DST/@1,SHF/PASS.Z,W/SHF"
;1791	[] <-- [] LSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@3,DST/@1,A/@2,SHF/LEFT.SINGLE,W/SHF"
;1792	[] <-- [] LSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,A/@2,SHF/LEFT.SINGLE,W/SHF"
;1793	[] <-- ZEXT [] RSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@3,DST/@1,B/@2,SHF/RIGHT.SINGLE,W/SHF"
;1794	[] <-- ZEXT [] RSH (SC) 	"FORMAT/STANDARD,LIT/BREG,VAL/0,DST/@1,B/@2,SHF/RIGHT.SINGLE,W/SHF"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   60
;     MACRO.MIC 	     SHIFT Macros									      /REV=
;
;1795
;1796	;	Shift macros, continued.
;1797
;1798	;	Shift macros with register operands that drive the shift latch.
;1799
;1800	Q <-- [] LROT []		"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,A/@1,SHF/LEFT.DOUBLE,Q/UPDATE.Q"
;1801	Q <-- [] LROT (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/@1,SHF/LEFT.DOUBLE,Q/UPDATE.Q"
;1802	Q <-- [] RROT []		"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,A/@1,SHF/RIGHT.DOUBLE,Q/UPDATE.Q"
;1803	Q <-- [] RROT (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/@1,SHF/RIGHT.DOUBLE,Q/UPDATE.Q"
;1804	Q <-- []!![] LSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@3,B/@2,A/@1,SHF/LEFT.DOUBLE,Q/UPDATE.Q"
;1805	Q <-- []!![] LSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@2,A/@1,SHF/LEFT.DOUBLE,Q/UPDATE.Q"
;1806	Q <-- []!![] RSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@3,B/@2,A/@1,SHF/RIGHT.DOUBLE,Q/UPDATE.Q"
;1807	Q <-- []!![] RSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@2,A/@1,SHF/RIGHT.DOUBLE,Q/UPDATE.Q"
;1808	Q <-- []!![] RSH (32-SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@2,A/@1,SHF/LEFT.DOUBLE,Q/UPDATE.Q"
;1809	Q <-- SEXT [] RSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,A/SHIFT.SIGN,SHF/RIGHT.DOUBLE,Q/UPDATE.Q"
;1810	Q <-- SEXT [] RSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/SHIFT.SIGN,SHF/RIGHT.DOUBLE,Q/UPDATE.Q"
;1811	Q <-- SEXT [] RSH (32-SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/SHIFT.SIGN,SHF/LEFT.DOUBLE,Q/UPDATE.Q"
;1812
;1813	Q <-- PASSA []			"FORMAT/STANDARD,A/@1,SHF/PASS.A,Q/UPDATE.Q"
;1814	Q <-- PASSB []			"FORMAT/STANDARD,LIT/BREG,B/@1,SHF/PASS.B,Q/UPDATE.Q"
;1815	Q <-- 0 			"FORMAT/STANDARD,SHF/PASS.Z,Q/UPDATE.Q"
;1816	Q <-- [] LSH [] 		"FORMAT/STANDARD,LIT/BREG,VAL/@2,A/@1,SHF/LEFT.SINGLE,Q/UPDATE.Q"
;1817	Q <-- [] LSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,A/@1,SHF/LEFT.SINGLE,Q/UPDATE.Q"
;1818	Q <-- ZEXT [] RSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,SHF/RIGHT.SINGLE,Q/UPDATE.Q"
;1819	Q <-- ZEXT [] RSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,SHF/RIGHT.SINGLE,Q/UPDATE.Q"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   61
;     MACRO.MIC 	     SHIFT Macros									      /REV=
;
;1820
;1821	;	Shift macros, continued.
;1822
;1823	;	Shift macros with constant operand that drive the Wbus.
;1824
;1825	[] <-- PASSB K10.[]		"FORMAT/STANDARD,LIT/LIT,MISC/CONST.10.BIT,DST/@1,CONST.10/@2,SHF/PASS.B,W/SHF"
;1826	[] <-- PASSB 000000[]		"FORMAT/STANDARD,LIT/LIT,POS/BYTE0,DST/@1,CONST/@2,SHF/PASS.B,W/SHF"
;1827	[] <-- PASSB 0000[]00		"FORMAT/STANDARD,LIT/LIT,POS/BYTE1,DST/@1,CONST/@2,SHF/PASS.B,W/SHF"
;1828	[] <-- PASSB 00[]0000		"FORMAT/STANDARD,LIT/LIT,POS/BYTE2,DST/@1,CONST/@2,SHF/PASS.B,W/SHF"
;1829	[] <-- PASSB []000000		"FORMAT/STANDARD,LIT/LIT,POS/BYTE3,DST/@1,CONST/@2,SHF/PASS.B,W/SHF"
;1830
;1831	;	Shift macros with constant operand that drive the shift latch.
;1832
;1833	Q <-- PASSB K10.[]		"FORMAT/STANDARD,LIT/LIT,MISC/CONST.10.BIT,CONST.10/@1,SHF/PASS.B,Q/UPDATE.Q"
;1834	Q <-- PASSB 000000[]		"FORMAT/STANDARD,LIT/LIT,POS/BYTE0,CONST/@1,SHF/PASS.B,Q/UPDATE.Q"
;1835	Q <-- PASSB 0000[]00		"FORMAT/STANDARD,LIT/LIT,POS/BYTE1,CONST/@1,SHF/PASS.B,Q/UPDATE.Q"
;1836	Q <-- PASSB 00[]0000		"FORMAT/STANDARD,LIT/LIT,POS/BYTE2,CONST/@1,SHF/PASS.B,Q/UPDATE.Q"
;1837	Q <-- PASSB []000000		"FORMAT/STANDARD,LIT/LIT,POS/BYTE3,CONST/@1,SHF/PASS.B,Q/UPDATE.Q"
;1838
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   62
;     MACRO.MIC 	     SHIFT Macros									      /REV=
;
;1839
;1840	;	Shift macros, continued.
;1841
;1842	;	Shift macros with register operands with no destination.
;1843
;1844	NODST <-- [] LROT []		"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,A/@1,SHF/LEFT.DOUBLE"
;1845	NODST <-- [] LROT (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/@1,SHF/LEFT.DOUBLE"
;1846	NODST <-- [] RROT []		"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,A/@1,SHF/RIGHT.DOUBLE"
;1847	NODST <-- [] RROT (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/@1,SHF/RIGHT.DOUBLE"
;1848	NODST <-- []!![] LSH [] 	"FORMAT/STANDARD,LIT/BREG,VAL/@3,B/@2,A/@1,SHF/LEFT.DOUBLE"
;1849	NODST <-- []!![] LSH (SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@2,A/@1,SHF/LEFT.DOUBLE"
;1850	NODST <-- []!![] RSH [] 	"FORMAT/STANDARD,LIT/BREG,VAL/@3,B/@2,A/@1,SHF/RIGHT.DOUBLE"
;1851	NODST <-- []!![] RSH (SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@2,A/@1,SHF/RIGHT.DOUBLE"
;1852	NODST <-- []!![] RSH (32-SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@2,A/@1,SHF/LEFT.DOUBLE"
;1853	NODST <-- SEXT [] RSH []	"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,A/SHIFT.SIGN,SHF/RIGHT.DOUBLE"
;1854	NODST <-- SEXT [] RSH (SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/SHIFT.SIGN,SHF/RIGHT.DOUBLE"
;1855	NODST <-- SEXT [] RSH (32-SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,A/SHIFT.SIGN,SHF/LEFT.DOUBLE"
;1856
;1857	NODST <-- PASSA []		"FORMAT/STANDARD,A/@1,SHF/PASS.A"
;1858	NODST <-- PASSB []		"FORMAT/STANDARD,LIT/BREG,B/@1,SHF/PASS.B"
;1859	NODST <-- 0			"FORMAT/STANDARD,SHF/PASS.Z"
;1860	NODST <-- [] LSH []		"FORMAT/STANDARD,LIT/BREG,VAL/@2,A/@1,SHF/LEFT.SINGLE"
;1861	NODST <-- [] LSH (SC)		"FORMAT/STANDARD,LIT/BREG,VAL/0,A/@1,SHF/LEFT.SINGLE"
;1862	NODST <-- ZEXT [] RSH []	"FORMAT/STANDARD,LIT/BREG,VAL/@2,B/@1,SHF/RIGHT.SINGLE"
;1863	NODST <-- ZEXT [] RSH (SC)	"FORMAT/STANDARD,LIT/BREG,VAL/0,B/@1,SHF/RIGHT.SINGLE"
;1864
;1865	;	Shift macros with constant operand with no destination.
;1866
;1867	NODST <-- PASSB K10.[]		"FORMAT/STANDARD,LIT/LIT,MISC/CONST.10.BIT,CONST.10/@1,SHF/PASS.B"
;1868	NODST <-- PASSB 000000[]	"FORMAT/STANDARD,LIT/LIT,POS/BYTE0,CONST/@1,SHF/PASS.B"
;1869	NODST <-- PASSB 0000[]00	"FORMAT/STANDARD,LIT/LIT,POS/BYTE1,CONST/@1,SHF/PASS.B"
;1870	NODST <-- PASSB 00[]0000	"FORMAT/STANDARD,LIT/LIT,POS/BYTE2,CONST/@1,SHF/PASS.B"
;1871	NODST <-- PASSB []000000	"FORMAT/STANDARD,LIT/LIT,POS/BYTE3,CONST/@1,SHF/PASS.B"
;1872
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   63
;     MACRO.MIC 	     SPECIAL Macros									      /REV=
;
;1873	.TOC	"	SPECIAL Macros"
;1874
;1875	FBOX OPERAND A[]		"FORMAT/SPECIAL,MISC1/FOP.VALID,DST/NONE,A/@1"
;1876	FBOX OPERAND A[] B[]		"FORMAT/SPECIAL,MISC1/FOP.VALID,DST/NONE,A/@1,LIT/BREG,B/@2"
;1877
;1878	RETIRE INSTRUCTION		"FORMAT/SPECIAL,MISC1/RETIRE.INSTRUCTION"
;1879	FLUSH VIC			"FORMAT/SPECIAL,MISC1/FLUSH.VIC"
;1880	FLUSH BRANCH PREDICTION TABLE	"FORMAT/SPECIAL,MISC1/FLUSH.BPC"
;1881	FLUSH PC QUEUE			"FORMAT/SPECIAL,MISC1/FLUSH.PCQ"
;1882
;1883	STATE.5-4 <-- 0 		"FORMAT/SPECIAL,MISC1/CLR.STATE.5-4"
;1884	STATE.3 <-- 1			"FORMAT/SPECIAL,MISC1/SET.STATE.3"
;1885	STATE.4 <-- 1			"FORMAT/SPECIAL,MISC1/SET.STATE.4"
;1886	STATE.5 <-- 1			"FORMAT/SPECIAL,MISC1/SET.STATE.5"
;1887
;1888	FBOX DEST CHECK 		"FORMAT/SPECIAL,LIT/BREG,MISC2/F.DEST.CHECK"
;1889	FLUSH PA QUEUE			"FORMAT/SPECIAL,LIT/BREG,MISC2/FLUSH.PAQ"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   64
;     MACRO.MIC 	     Q, L, V Field Macros								      /REV=
;
;1890	.TOC	"	Q, L, V Field Macros"
;1891
;1892	Q&				"Q/UPDATE.Q"
;1893
;1894	LEN(DL) 			"L/LEN(DL)"
;1895	LONG				"L/LONG"
;1896
;1897	VA&				"V/UPDATE.VA"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   65
;     MACRO.MIC 	     MISC Field Macros									      /REV=
;
;1898	.TOC	"	MISC Field Macros"
;1899
;1900	DL <-- BYTE			"MISC/DL.BYTE"
;1901	DL <-- WORD			"MISC/DL.WORD"
;1902	DL <-- LONG			"MISC/DL.LONG"
;1903	RESTART IBOX			"MISC/RESTART.IBOX"
;1904	RESTART MBOX			"MISC/RESTART.MBOX"
;1905	RESET CPU			"MISC/RESET.CPU"
;1906	STATE.3-0 <-- 0 		"MISC/CLR.STATE.3-0"
;1907	STATE.0 <-- 1			"MISC/SET.STATE.0"
;1908	STATE.1 <-- 1			"MISC/SET.STATE.1"
;1909	STATE.2 <-- 1			"MISC/SET.STATE.2"
;1910	SC <-- A []			"MISC/LOAD.SC.FROM.A,A/@1"
;1911	MPU <-- B.29..16 []		"MISC/LOAD.MPU.FROM.B,LIT/BREG,B/@1"
;1912	MULL				"MISC/MULL"
;1913	SET PSL CC.IIIP 		"MISC/LOAD.PSL.CC.IIIP"
;1914	SET PSL CC.IIII 		"MISC/LOAD.PSL.CC.IIII"
;1915	SET PSL CC.JIZJ 		"MISC/LOAD.PSL.CC.JIZJ"
;1916	SET PSL CC.IIIJ 		"MISC/LOAD.PSL.CC.IIIJ"
;1917	SET PSL CC.IIIP.QUAD		"MISC/LOAD.PSL.CC.IIIP.QUAD"
;1918	SET PSL CC.PPJP 		"MISC/LOAD.PSL.CC.PPJP"
;1919	CLEAR PMF COUNTERS		"MISC/CLR.PERF.COUNT"
;1920	INCREMENT PMF COUNTER		"MISC/INCR.PERF.COUNT"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   66
;     MACRO.MIC 	     Microsequencer Control Macros							      /REV=
;
;1921	.TOC	"	Microsequencer Control Macros"
;1922
;1923	CALL CASE [] AT []		"SEQ.FMT/BRANCH,SEQ.CALL/CALL,SEQ.COND.1/<SEQ.COND/@1>,J/@2"
;1924	CASE [] AT []			"SEQ.FMT/BRANCH,SEQ.CALL/NOP,SEQ.COND.1/<SEQ.COND/@1>,J/@2"
;1925
;1926	RETURN				"SEQ.FMT/JUMP,SEQ.CALL/NOP,SEQ.MUX/STACK,J/0"
;1927
;1928	CALL [] 			"SEQ.FMT/JUMP,SEQ.CALL/CALL,SEQ.MUX/J,J/@1"
;1929	GOTO [] 			"SEQ.FMT/JUMP,SEQ.CALL/NOP,SEQ.MUX/J,J/@1"
;1930
;1931	LAST CYCLE			"SEQ.FMT/JUMP,SEQ.CALL/NOP,SEQ.MUX/LAST.CYCLE,J/0"
;1932	LAST CYCLE CHECK OVERFLOW	"SEQ.FMT/JUMP,SEQ.CALL/NOP,SEQ.MUX/LAST.CYCLE.OVERFLOW,J/0"
;1933	LAST CYCLE NO RETIRE		"FORMAT/SPECIAL,LIT/BREG,DISABLE.RETIRE/YES,SEQ.FMT/JUMP,SEQ.CALL/NOP,SEQ.MUX/LAST.CYCLE,J/0"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   67
;     MACRO.MIC 	     A/B Select Macros									      /REV=
;
;1934	.TOC	"	A/B Select Macros"
;1935
;1936	;	The A/B Select macros provide a way to explicitly specify an A or B port select.
;1937
;1938	ACCESS A []			"A/@1"
;1939	ACCESS B []			"LIT/BREG,B/@1"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   68
;     MACRO.MIC 	     Error Macros									      /REV=
;
;1940	.TOC	"	Error Macros"
;1941
;1942	;	These macros provide standard entries to microcode error routines.
;1943
;1944	CONSOLE HALT [] 		"[SAVEPSL] <-- [PSL] OR 0000[@1]00,LONG,GOTO [IE.CONSOLE.HALT..]"
;1945	CONSOLE HALT NO CLEANUP []	"[SAVEPSL] <-- [PSL] OR 0000[@1]00,LONG,GOTO [IE.CONSOLE.HALT.NO.CLEANUP..]"
;1946	MACHINE CHECK []		"[SAVEPSL] <-- 00[@1]0000,LONG,GOTO [IE.MACHINE.CHECK..]"
;1947	RESERVED OPERAND FAULT		"GOTO [IE.RSVD.OPERAND..]"
;1948	RESERVED INSTRUCTION FAULT	"GOTO [RSVD.OPCODE..]"
;1949	RESERVED ADDRESSING MODE	"GOTO [IE.RSVD.ADDRESS..]"
;1950	INTERRUPT FAULT 		"GOTO [IE.INT.FAULT..]"
;1951	UNIMPLEMENTED MTPR REGISTER []	"[W2] <-- [@1] LSH [2.],LONG,GOTO [MTPR.IPR.NORMAL]"
;1952	UNIMPLEMENTED MFPR REGISTER []	"[W2] <-- [@1] LSH [2.],LONG,GOTO [MFPR.IPR.NORMAL]"
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   69
;     MACRO.MIC 	     Simulator Control Macros								      /REV=
;
;1953	.TOC	"	Simulator Control Macros"
;1954
;1955	;	These macros control simulator features that do not exist in the real hardware
;1956
;1957	;	Address selection macros.
;1958
;1959	sim addr []			"SIM.ADDR.SEL/ADDR,SIM.ADDR/@1"
;1960	sim addr [] - k 		"SIM.ADDR.SEL/ADDR.K,SIM.ADDR/@1"
;1961	sim addr [] + k 		"SIM.ADDR.SEL/ADDR.K,SIM.ADDR/@1"
;1962
;1963	;	Microbranch condition selection macros.
;1964
;1965	sim cond k s3.[]		"SIM.COND.SEL/CONST,SIM.COND.S3.S4/S3,SIM.COND.K/@1"
;1966	sim cond k s4.[]		"SIM.COND.SEL/CONST,SIM.COND.S3.S4/S4,SIM.COND.K/@1"
;1967	sim cond []			"SIM.COND.SEL/FNC,SIM.COND/@1"
;1968
;1969	;	Simulator control macros.
;1970
;1971	sim halt			"MISC/SIM.HALT"
;1972	sim ie.intexc			"MISC/SIM.IE.INTEXC"
;1973	sim exception			"SIM.CTRL/CMD,SIM.CMD/EXCEPTION"
;1974	sim rsvd opcode 		"SIM.CTRL/CMD,SIM.CMD/RSVD.OPCODE"
;1975	sim emulate			"SIM.CTRL/CMD,SIM.CMD/EMULATE"
;1976	sim vector fault		"SIM.CTRL/CMD,SIM.CMD/VECTOR.FAULT"
				;1977	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   70
;     ALIGN.MIC 	     ALIGN.MIC -- Hardware Entry Point Assignments					      /REV=
;
				;1978	.TOC	"ALIGN.MIC -- Hardware Entry Point Assignments"
				;1979	.TOC	"Revision 1.0"
				;1980
				;1981	;	Mike Uhler, Bob Supnik
				;1982
;1983	.nobin
;1984	;****************************************************************************
;1985	;*									    *
;1986	;*  COPYRIGHT (c) 1988, 1989, 1990, 1991, 1992 BY			    *
;1987	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;1988	;*  ALL RIGHTS RESERVED.						    *
;1989	;*									    *
;1990	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;1991	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;1992	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;1993	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;1994	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;1995	;*  TRANSFERRED.							    *
;1996	;*									    *
;1997	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;1998	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;1999	;*  CORPORATION.							    *
;2000	;*									    *
;2001	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;2002	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;2003	;*									    *
;2004	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   71
;     ALIGN.MIC 	     Revision History									      /REV=
;
;2005	.TOC	"	Revision History"
;2006
;2007	; Edit	  Date	 Who	     Description
;2008	; ---- --------- ---	---------------------
;2009	; (1)0 01-Aug-90 GMU	Initial production microcode.
;2010	;
;2011	; Begin version 1.0 here
;2012	;   16 31-JUL-90 GMU	Add constraints for NVAX+ vector entry points.
;2013	;   15 20-Jun-90 DGM	Fix FQ alignment constraints
;2014	;   14 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;2015	;   13 13-Mar-90 GMU	With the cancellation of SVS, remove the PROBEVMX..
;2016	;			entry point.
;2017	;   12 05-Mar-90 GMU	Duplicate individual field queue constraints to keep
;2018	;			ARCS from complaining about the use of the middle of
;2019	;			an ALIGNLIST as a branch target.
;2020	;   11 16-Jan-90 DGM	Change field queue alignments.
;2021	;   10 05-Jan-90 GMU	Remove vector issue microtrap constraint, collapse other
;2022	;			entry point addresses.
;2023	;    9 06-Dec-89 GMU	Continue comment update.
;2024	;    8 30-Nov-89 GMU	Combine ADWC, SBWC entry points, move EDIV.
;2025	;    7 28-Nov-89 GMU	Update microtrap addresses to reflect new hardware priority.
;2026	;    6 27-Sep-89 DGM	Modify alignment constraints on EDIV.  (remove .R & .M)
;2027	;    5 17-Aug-89 GMU	Update to reflect new field queue entry points.
;2028	;    4 24-Jul-89 GMU	Add new exception entry points.
;2029	;    3 07-Dec-88 DB	Redo floating point entry points, add FBOX.4.SL.ND..
;2030	;    2 06-Dec-88 DB	Redo floating point entry points
;2031	;    1 22-Nov-88 DB	Add new floating point entry points
;2032	; (0)0 16-Feb-88 RMS	Trial microcode.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   72
;     ALIGN.MIC 	     Revision History									      /REV=
;
;2033
;2034	;				ALLOCATION NOTE
;2035	;
;2036	;	Unlike previous instances of microcode allocators, the NVAX allocator
;2037	;	responds to four types of constraints:
;2038	;
;2039	;		0	Address bit is constrained to a 0.
;2040	;		1	Address bit is constrained to a 1.
;2041	;		*	Address bit is logically unconstrained,
;2042	;			but is forced to be constrained to a 1.
;2043	;		x	Address bit is unconstrained.
;2044	;
;2045	;	The addition of the 'x' constraint and the redefinition of the '*'
;2046	;	constraint was done to lessen the chance that the microcoder has
;2047	;	misanalyzed the constraint requirements by forcing the constraint
;2048	;	to a '1'.  Unfortunately, this causes congestion in addresses whose
;2049	;	lower address bits are a 1 to such an extent that the microcode
;2050	;	will not allocate entirely within the range 0..1599.  As such,
;2051	;	all ALIGNLISTs have been categorized into "safe" and "unsafe"
;2052	;	constraints.  "Safe" constraints are those that are judged to be
;2053	;	unlikely to be wrong (an opcode case is considered a "safe"
;2054	;	constraint).  "Unsafe" constraints are those where the logic is
;2055	;	complex enough that there is a non-zero chance that the constraint
;2056	;	could be wrong.  "Safe" constraints have been changed from '*'
;2057	;	constraints to 'x' constraints, while "unsafe" constraints remain
;2058	;	'*' constraints.
;2059
				;2060	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   73
;     ALIGN.MIC 	     Exception Dispatches								      /REV=
;
				;2061	.TOC	"	Exception Dispatches"
				;2062
				;2063	;	Exception dispatches are placed in page 0 of the
				;2064	;	Control Store, as follows:
				;2065	;
				;2066	;		 10  9	8  7  6  5  4  3  2  1	0
				;2067	;		+--+--+--+--+--+--+--+--+--+--+--+
				;2068	;		|0  0  0 |    dispatch	   |0  0 |
				;2069	;		+--+--+--+--+--+--+--+--+--+--+--+
				;2070	;
				;2071	;	where
				;2072	;
				;2073	;		dispatch =	dispatch address from the trap hardware
				;2074	;
				;2075	;	Note: The following entry points are spaced 4 locations apart to
				;2076	;	allow more than one CALL at each entry point.  Entry points starting
				;2077	;	with IE.CONSOLE.HALT.. are not constrained by hardware requirement,
				;2078	;	but are constrained such that exception handler addresses are
				;2079	;	constant for all microcode assemblies.
				;2080
				;2081	;= AT 0
				;2082	;= ALIGNLIST 00000xx	(
				;2083	;= IE.POWERUP..,	IE.ASYNC.HW.ERROR..,
				;2084	;= IE.INT.OVERFLOW..,	IE.BRANCH..,
				;2085	;= IE.RSVD.OPCODE.TRAP..,IE.SYNC.HW.ERROR..,
				;2086	;= IE.MEMMGT.., 	IE.RSVD.ADDRESS..,
				;2087	;= IE.FLT.FAULT..,	IE.INT..,
				;2088	;= IE.TRACE.TRAP..,	IE.FPD..,
				;2089	;= IE.STALL..,		IE.CONSOLE.HALT..,
				;2090	;= IE.MACHINE.CHECK..,	IE.RSVD.OPERAND..,
				;2091	;= IE.INT.FAULT..,	IE.SUBSCRIPT.ERROR..,
				;2092	;= IE.DIVIDE.ERROR..,		 )
				;2093
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   74
;     ALIGN.MIC 	     Instruction Dispatches								      /REV=
;
				;2094	.TOC	"	Instruction Dispatches"
				;2095
				;2096	;	Instruction dispatches are placed in pages 1, 2, and 3 of the
				;2097	;	Control Store, as follows:
				;2098	;
				;2099	;		 10  9	8  7  6  5  4  3  2  1	0
				;2100	;		+--+--+--+--+--+--+--+--+--+--+--+
				;2101	;		|  page  |	 dispatch     |0 |
				;2102	;		+--+--+--+--+--+--+--+--+--+--+--+
				;2103	;
				;2104	;	where
				;2105	;
				;2106	;		page	=	001: instructions with no first cycle constraints
				;2107	;			=	010: instructions with mild first cycle constraints
				;2108	;			=	011: MxPR
				;2109	;		dispatch =	dispatch address from the IPLA
				;2110	;
				;2111	;	Note: The following entry points are spaced 2 locations apart to
				;2112	;	allow a CALL at each entry point.  Changes to these entry points
				;2113	;	require a reassembly of the IROM.
				;2114	;
				;2115	;	Page 1 - instructions with no first cycle constraints.
				;2116
				;2117	;= AT 100
				;2118	;= ALIGNLIST 000000x	(
				;2119	;= RSVD.OPCODE..,TSTX..,	BITX.., 	CMPI..,
				;2120	;= MOVX..,	MOVQ.., 	CLRX.., 	CLRQ..,
				;2121	;= MOVZBX..,	MOVZWL..,	MCOMX..,	MNEGX..,
				;2122	;= ADDIN..,	SUBIN..,	ADWC.SBWC..,		,
				;2123	;= INCX..,	DECX.., 		,		,
				;2124	;= BISXN..,	BICXN..,	XORXN..,		,
				;2125	;= CVTBI..,	CVTWL..,	CVTLW..,	CVTXB..,
				;2126	;= ROTL..,	ASHL.., 	ASHQ.., 		,
				;2127	;= SOBGXX..,	AOBLXX..,		,		,
				;2128	;= ACBB..,	ACBW.., 	ACBL.., 		,
				;2129	;= BSBX..,	JSB..,		RSB..,		CASEX..,
				;2130	;= BRX..,	BXX..,		BLBX.., 	JMP..,
				;2131	;= MULBN..,	MULWN..,	MULLN..,	EMUL..,
				;2132	;= DIVBN..,	DIVWN..,	DIVLN..,	EDIV..,
				;2133	;= CALLX..,	RET..,			,		,
				;2134	;=	,		,		,		)
				;2135
				;2136	;= AT 180
				;2137	;= ALIGNLIST 000000x	(
				;2138	;= NOP..,	HALT.., 	BPT..,		XFC..,
				;2139	;= INDEX..,	MOVPSL..,	PUSHR..,	POPR..,
				;2140	;= INSQUE..,	REMQUE..,	INSQXI..,		,
				;2141	;= REI..,		,		,		,
				;2142	;= LOCC.SKPC.., SCANC.SPANC..,		,		,
				;2143	;= FBOX.1.SL.., FBOX.2.SL..,	FBOX.4.SL..,		,
				;2144	;= FBOX.1.SL.ND..,FBOX.2.SL.ND..,FBOX.4.SL.ND..,	,
				;2145	;= EMULATE.4.., EMULATE.5..,	EMULATE.6..,		,
				;2146	;= VLDX..,		,	VSTX.., 		,
				;2147	;= VGATHX..,		,	VSCATX..,		,
				;2148	;= MFVP..,		,	MTVP.., 		,
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   75
;     ALIGN.MIC 	     Instruction Dispatches								      /REV=
;
				;2149	;= VSYNC..,		,	IOTA.., 		,
				;2150	;= VVOPX..,		,	VVCMPX..,		,
				;2151	;= VSOPL..,		,	VSCMPL..,		,
				;2152	;= VSOPQ..,		,	VSCMPQ..,		,
				;2153	;=	,		,		,		)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   76
;     ALIGN.MIC 	     Instruction Dispatches								      /REV=
;
				;2154
				;2155	;	Page 2 - instructions with mild first cycle constraints.
				;2156
				;2157	;	The alignments for CVTPL.., BBX.., BBXS.., BBXC..,
				;2158	;	REMQXI.., ADAWI.., FIELD.., and INSV.. reflect the restrictions
				;2159	;	imposed by the field queue case constraints.  These alignments
				;2160	;	must not be changed relative to the coresponding .M and .R
				;2161	;	labels.
				;2162
				;2163	;= AT 200
				;2164	;= ALIGNLIST 000000x	(
				;2165	;= BIXPSW..,	MOVCX..,	CMPCX..,		,
				;2166	;= LDPCTX..,	SVPCTX..,	PROBEX..,		,
				;2167	;= CHMK..,	CHME.., 	CHMS.., 	CHMU..,
				;2168	;=	,		,		,		,
				;2169	;=	,		,		,		,
				;2170	;=	,		,		,		,
				;2171	;=	,		,		,		,
				;2172	;=	,		,		,		)
				;2173
				;2174	;	The following ALIGNLISTS must be separate from the above ALIGNLIST
				;2175	;	because the microcode analyzer ARCS does not like to see case targets
				;2176	;	in the middle of an ALIGNLIST nor as the beginning of a large
				;2177	;	ALIGNLIST.  Logically, this group of ALIGNLISTs belongs at the
				;2178	;	end of the large ALIGNLIST above.
				;2179
				;2180	;= AT 240
				;2181	;= ALIGNLIST 00x (ADAWI.M,	ADAWI.R,		,	ADAWI..,)
				;2182	;= AT 248
				;2183	;= ALIGNLIST 00x (BBX.M,	BBX.R,			,	BBX..)
				;2184	;= AT 250
				;2185	;= ALIGNLIST 00x (BBXS.M,	BBXS.R, 		,	BBXS..)
				;2186	;= AT 258
				;2187	;= ALIGNLIST 00x (BBXC.M,	BBXC.R, 		,	BBXC..)
				;2188	;= AT 260
				;2189	;= ALIGNLIST 00x (FIELD.M,	FIELD.R,		,	FIELD..)
				;2190	;= AT 268
				;2191	;= ALIGNLIST 00x (INSV.M,	INSV.R, 		,	INSV..)
				;2192	;= AT 270
				;2193	;= ALIGNLIST 00x (REMQXI.M,	REMQXI.R,		,	REMQXI..)
				;2194	;= AT 278
				;2195	;= ALIGNLIST 00x (EMULATE.3.CVTPL.M..,	CVTPL.R,	,	CVTPL..)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   77
;     ALIGN.MIC 	     Instruction Dispatches								      /REV=
;
				;2196
				;2197	;	Page 3 - MxPR.
				;2198
				;2199	;= AT 300
				;2200	;= ALIGNLIST 0x (MTPR..,	MFPR..)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   78
;   POWERUP.MIC 	     POWERUP.MIC -- Powerup Initialization						      /REV=
;
				;2201	.TOC	"POWERUP.MIC -- Powerup Initialization"
				;2202	.TOC	"Revision 1.5"
				;2203
				;2204	;	Mike Uhler, Bob Supnik, John Brown
				;2205
;2206	.nobin
;2207	;****************************************************************************
;2208	;*									    *
;2209	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;2210	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;2211	;*  ALL RIGHTS RESERVED.						    *
;2212	;*									    *
;2213	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;2214	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;2215	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;2216	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;2217	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;2218	;*  TRANSFERRED.							    *
;2219	;*									    *
;2220	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;2221	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;2222	;*  CORPORATION.							    *
;2223	;*									    *
;2224	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;2225	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;2226	;*									    *
;2227	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   79
;   POWERUP.MIC 	     Revision History									      /REV=
;
;2228	.TOC	"	Revision History"
;2229
;2230	; Edit	  Date	 Who	     Description
;2231	; ---- --------- ---	---------------------
;2232	;    5 09-Jan-92 JFB	Symptom: additional microword for edit 4 causes
;2233	;				 undesired reallocation for the mini-pass.
;2234	;			Cure:	 change order and tie down the single instruction
;2235	;				 that clears the PCSTS lock bit.
;2236	;    4 24-Jul-91 JFB	Symptom: In the burnin flow, the Pcache is enabled
;2237	;				 without clearing the lock bit in the PCSTS.
;2238	;				 This disables the Pcache regardless of the
;2239	;				 state of PCCTL.
;2240	;			Cure:	 Write a 1 to PCSTS to clear the lock bit
;2241	;				 before enabling the Pcache via PCCTL.
;2242	;    3 14-Jun-91 GMU	Symptom: When MAPEN is cleared in the console halt
;2243	;				 flow, the VIC can still have valid data
;2244	;				 corresponding to virtual addresses that
;2245	;				 matched the physical addresses in which
;2246	;				 the console is running (with the S1 space
;2247	;				 ECO, E0040000 is a valid S0 space virtual
;2248	;				 address).  This could cause the CPU to
;2249	;				 start executing bogus instructions rather
;2250	;				 than the console code.
;2251	;			Cure:	 Flush the VIC after turning off MAPEN in
;2252	;				 the console halt flow and before restarting
;2253	;				 prefetch.
;2254	;    2 20-May-91 GMU	Symptom: Certain console halts may be invoked from
;2255	;				 flows in which a RESET CPU and call to
;2256	;				 IE.CLEANUP.CPU have been performed.  If
;2257	;				 this call packs up the state for a string
;2258	;				 instruction, a second RESET CPU and call
;2259	;				 to IE.CLEANUP leaves SAVEPSL with FPD
;2260	;				 set and SAVEPC pointing at the instruction
;2261	;				 following the string instruction rather than
;2262	;				 at the string instruction.
;2263	;			Cure:	 Add an alternate console halt entry point,
;2264	;				 IE.CONSOLE.HALT.NO.CLEANUP.., to be reached
;2265	;				 using the CONSOLE HALT NO CLEANUP macro.
;2266	;				 Entry at this label causes the RESET CPU
;2267	;				 and call to IE.CLEANPU.CPU to be avoiding,
;2268	;				 leaving SAVEPC correct.
;2269	;    1 06-Aug-90 JFB	For safety, remove a special microinstruction from the
;2270	;			console.burn.in code that uses the Q register.
;2271	; (1)0 31-Jul-90 GMU	Initial production microcode.
;2272	;
;2273	; Begin version 1.0 here
;2274	;   20 31-Jul-90 JFB	Split out powerup flow for burn-in Pcache load path.
;2275	;   19 25-Jul-90 GMU	Change initial BPCR value from FECA to ECC8.
;2276	;   18 04-Jul-90 GMU	Clear the performance monitoring facility counters at powerup.
;2277	;   17 01-May-90 GMU	Uncomment references to CWB IPR.
;2278	;   16 30-Apr-90 GMU	Sync with Mbox after LOAD PC.
;2279	;   15 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;2280	;   14 12-Feb-90 GMU	Account for 9-bit shift required when referencing
;2281	;			IPR.MMAPEN.
;2282	;   13 19-Jan-90 GMU	FLUSH BRANCH PREDICTION CACHE -> FLUSH BRANCH PREDICTION TABLE.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   80
;   POWERUP.MIC 	     Revision History									      /REV=
;
;2283	;   12 09-Jan-90 GMU	Update INT.SYS initialization to reflect new interrupt
;2284	;			section design.
;2285	;   11 13-Dec-89 GMU	Add SYNCHRONIZE MBOX between Ibox BPCR write and LOAD PC
;2286	;			in halt flow to guarantee that the Ibox has processed
;2287	;			the IPR write before it sees the LOAD PC (which is another
;2288	;			IPR write from its point of view).
;2289	;   10 06-Dec-89 GMU	Continue comment update.
;2290	;    9 06-Dec-89 GMU	Add FLUSH BRANCH PREDICTION CACHE to console halt flow.
;2291	;    8 09-Nov-89 GMU	Revert to normal powerup start address at E0040000.
;2292	;    7 07-Nov-89 GMU	Complete RESET CPU interface.
;2293	;    6 30-Oct-89 GMU	Move REINITIALIZE.CPU routine to INTEXC.
;2294	;    5 26-Oct-89 DB	Move sim halt in IE.CONSOLE.HALT
;2295	;    4 09-Oct-89 GMU	Step on W1 rather than W0 in REINITIALIZE.CPU.
;2296	;    3 02-Aug-89 GMU	Add initialization of BPCR branch prediction history
;2297	;			algorithm.
;2298	;    2 19-Jul-89 GMU	Add one more cycle between RESET CPU and Mbox req.
;2299	;    1 10-Jul-89 GMU	Update to reflect current design.
;2300	; (0)0 18-Sep-87 RMS	Trial microcode.
;2301
				;2302	.bin
				;2303	;= BEGIN POWERUP
;2304	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   81
;   POWERUP.MIC 	     Powerup Initialization								      /REV=
;															    POWERUP
;2305	.TOC	"	Powerup Initialization"
;2306
;2307	;	This module contains the power up initialization code.
;2308
;2309	;	On chip reset (either power up or explicit reset), the hardware
;2310	;	and microcode conspire to initialize the CPU to a known state.
;2311	;	Hardware reset does the following:
;2312	;
;2313	;	      o The VIC, Pcache, and Bcache are disabled.
;2314	;	      o The RLOG is cleared.
;2315	;	      o The Fbox and vector unit are disabled.
;2316	;	      o The microstack is cleared.
;2317	;	      o The Mbox and Cbox are reset, and all previous operations are
;2318	;		flushed.
;2319	;	      o The Fbox is reset.
;2320	;	      o The Ibox is stopped, waiting for a LOAD PC.
;2321	;	      o All instruction and operand queues are flushed.
;2322	;	      o All MD valid bits are cleared, and all Wn valid bits are set.
;2323	;	      o A powerup microtrap is initiated which starts the Ebox at
;2324	;		the label IE.POWERUP..
;2325	;
;2326	;	Microcode at IE.POWERUP.. then does the following:
;2327	;
;2328	;	      o Hardware interrupt requests are cleared.
;2329	;	      o ICCS<6> is set to 0.
;2330	;	      o SISR<15:1> is set to 0.
;2331	;	      o ASTLVL is set to 4.
;2332	;	      o CPUID is set to 0.
;2333	;	      o The performance monitoring counters are cleared.
;2334	;	      o The Mbox is reset to 30-bit physical address mode.
;2335	;	      o The BPCR branch history algorithm is reset to the
;2336	;		default value.
;2337	;	      o A console halt is initiated with code ERR.PWRUP.
;2338	;	      o The performance monitoring facility counters are cleared.
;2339	;
;2340	;	The common console halt handler at IE.CONSOLE.HALT.. is used for
;2341	;	both power up halts and for all other halts initiated by the
;2342	;	microcode.  In addition, an alternate entry point IE.CONSOLE.HALT.NO.CLEANUP..
;2343	;	is provided for the exclusive use of those routines which
;2344	;	are known to have already done a RESET CPU/call to IE.CLEANUP.CPU
;2345	;	with the possibility of packing up state for a string instruction.
;2346	;
;2347	;	The console halt flow re-initializes the CPU and starts
;2348	;	execution in the boot ROM, by doing the following:
;2349
;2350	;	      o The Mbox and Cbox are reset, and all previous read operations
;2351	;		operations are flushed.
;2352	;	      o The Fbox is reset.
;2353	;	      o The Ibox is stopped, waiting for a LOAD PC.
;2354	;	      o All instruction and operand queues are flushed.
;2355	;	      o All MD valid bits are cleared, and all Wn valid bits are set.
;2356	;	      o The RLOG is unwound and backup PC is retrieved from the Ibox
;2357	;		and saved in the SAVPC processor register.
;2358	;	      o The current PSL, halt code, and value of MAPEN<0> are saved in
;2359	;		the SAVPSL processor register.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   82
;   POWERUP.MIC 	     Powerup Initialization								      /REV=
;															    POWERUP
;2360	;	      o MAPEN is cleared (memory management is disabled).
;2361	;	      o SP is saved in the current mode stack pointer register.  ISP
;2362	;		is then loaded into SP.
;2363	;	      o All state flags are cleared.
;2364	;	      o PSL is loaded with 041F0000.
;2365	;	      o PC is loaded with E0040000.
;2366
;2367	;	The powerup microcode provides a means for the burn-in and life-test programs
;2368	;	to load the Pcache with asynchronous, bit-serial instruction stream data. If
;2369	;	p%test_strobe_h, which is normally held high by an on-chip pull-up, is held
;2370	;	low during this flow, control is diverted from normal power-up routine to the
;2371	;	burn-in flow. The burn-in flow loads the Pcache by doing the following:
;2372	;
;2373	;	      o Set force Pcache hit, enable I and D
;2374	;	      o VA = 0
;2375	;	      o Assert p%machine_check to signify start of burn-in flow.
;2376	;	loop: o Wait for p%test_strobe_h assertion.
;2377	;	      o Append value of p%test_data_h onto Istream data.
;2378	;	      o If Istream data = 32 bits, then write into Pcache, VA = VA + 4.
;2379	;	      o If Istream data = 32K bits, then go to exit:
;2380	;	      o Wait for p%test_strobe_h de-assertion.
;2381	;	      o Go to loop:
;2382	;	exit: o De-assert p%machine_check to signify end of burn-in flow.
;2383	;	      o Load PC at 00004000, last cycle.
;2384
				;2385	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   83
;   POWERUP.MIC 	     Powerup Entry Point								      /REV=
;															    POWERUP
				;2386	.TOC	"	Powerup Entry Point"
				;2387
				;2388	;	Power up sequence.
				;2389
				;2390	IE.POWERUP..:
				;2391		;********** Hardware dispatch **********;
				;2392		VA <-- [0EC]000000, LONG,		; start building default BP algorithm
E 000  0080,3F61,2007,0001 J 001;2393		CLEAR PMF COUNTERS			; clear both PMF counters
				;2394
				;2395	;= AT IE.POWERUP..+1				; to allow ucode to be reloaded in beh model
				;2396		;---------------------------------------;
E 001  0500,3640,04B0,004B J 04B;2397		[W0] <-- [VA] OR 00[0C8]0000, LONG	; complete BP algorithm
				;2398
				;2399		;---------------------------------------;
				;2400		VA <-- K10.[IPR.PAMODE],		; load VA with PA mode IPR address
				;2401		MEM.PR (VA)&, [WBUS] <-- PASSA [K0],	; force Mbox to 30-bit mode
				;2402		LONG,					;
E 04B  00F4,7CE3,2311,0063 J 063;2403			sim addr [k]
				;2404
				;2405
				;2406		;---------------------------------------;
				;2407		VA <-- K10.[IPR.BPCR],			; load VA with BPCR IPR address
				;2408		MEM.PR (VA)&, [WBUS] <-- PASSA [W0],	; Load new prediction algorithm
				;2409		LONG,					;
E 063  00F4,7A83,2011,006F J 06F;2410			sim addr [k]
				;2411
				;2412	;	Note: INT.SYS must be cleared at least three cycles after the PMF
				;2413	;	counters are cleared to guarantee that the interrupt request is
				;2414	;	actually cleared.
				;2415
				;2416		;---------------------------------------;
E 06F  0080,3FC8,C000,0073 J 073;2417		[INT.SYS] <-- [ISR.CLEAR.ALL]000000, LONG ; clear interrupt latches
				;2418							; >> int.sys change, no decode in next
				;2419							; >> 3 cycles
				;2420
				;2421		;---------------------------------------;
E 073  0080,3C00,9400,00B1 J 0B1;2422		[ASTLVL] <-- [80]000000, LONG		; set ASTLVL = 4 (in bits <31:29>),
				;2423							;     CPUID = 0 (in bits <7:0>)
				;2424
				;2425		;---------------------------------------;
				;2426		SYNCHRONIZE MBOX,			; synchronize Ibox IPR write with
			    p.84;2427							; subsequent LOAD PC
E 0B1  0520,2818,A4C0,0034 J 034;2428		CONSOLE HALT [ERR.PWRUP]		; power up, invoke console
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   84
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;															    POWERUP
				;2429	.TOC	"	Console Halt Entry Point"
				;2430
				;2431	;	Console halt entry point.
				;2432
				;2433	;	Control arrives here as the result of the CONSOLE HALT macro.
				;2434	;	The CPU is in an indeterminate state and must be reset before
				;2435	;	proceeding.
				;2436	;
				;2437	;	Note: The IE.CONSOLE.HALT.NO.CLEANUP.. entry point is used by
				;2438	;	the CONSOLE HALT NO CLEANUP macro to avoid a call to IE.CLEANUP.NO.PACKUP.
				;2439	;
				;2440	;	At this point,
				;2441	;		SAVEPSL<31:16,7:0> =	PSL<31:16,7:0>
				;2442	;		SAVEPSL<15:14>	=	0
				;2443	;		SAVEPSL<13:8>	=	console halt code (from CONSOLE HALT macro)
				;2444
				;2445	IE.CONSOLE.HALT..:
				;2446		;---------------------------------------;
				;2447		Q <-- 0,				; no PSL bits to clear
				;2448		RESET CPU,				; abort current operations
				;2449		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;2450							; PSL<TP> unchanged, SAVEPC = BPC
			    p159;2451							; >> Fbox sync via DST <> NONE
E 034  0002,C000,2006,22D5 S 2D5;2452			sim exception
				;2453
				;2454	IE.CONSOLE.HALT.NO.CLEANUP..:			; from CONSOLE HALT NO CLEANUP macro only
				;2455		;---------------------------------------;
				;2456		VA <-- K10.[IPR.MMAPEN],		; read memory management enable
				;2457		[W1] <-- MEM.PR (VA), LONG,		; into E-box
				;2458		FLUSH BRANCH PREDICTION TABLE,		; flush branch prediction table
E 035  10D5,3CC1,0801,00B3 J 0B3;2459			sim addr [k]
				;2460
				;2461		;---------------------------------------;
				;2462		MEM.PR (VA)&, [WBUS] <-- [W1] XOR [W1], ; clear memory management enable
				;2463		LONG,					; mapen<0> returns in W1<9>,
E 0B3  0677,4610,2020,00D2 J 0D2;2464		Q <-- [W1] LSH [6.]			; position mapen<0> to bit <15>
				;2465
				;2466
				;2467		;---------------------------------------;
				;2468		[SAVEPSL] <-- [SAVEPSL] OR [Q], LONG,	; include MAPEN<0> in SAVEPSL<15>
E 0D2  1500,C050,A690,00E3 J 0E3;2469		FLUSH VIC				; clear stale mappings from VIC
				;2470							; >> FLUSH VIC: LOAD PC required
				;2471
				;2472		;---------------------------------------;
				;2473		Q <-- PASSB [04]000000, LONG,		; start building new PSL
				;2474		[W0] <-- [K1],				; load W0 with 1 for burn-in flow
E 0E3  0002,B820,072F,80EB J 0EB;2475			sim halt
				;2476
			    p.85;2477		;---------------------------------------;
E 0EB  0500,30F8,30A0,0410 J 410;2478		[PSL] <-- [Q] OR 00[1F]0000, LONG	; new PSL = 041F0000
				;2479							; >> PSL change, no decode for 3 cycles
				;2480
				;2481		;---------------------------------------;
				;2482		VA <-- K10.[IPR.CWB],			; push writes out of the chip
				;2483		MEM.PR (VA)&, [WBUS] <-- PASSA [K0], LONG, ; during halt process
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   85
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;															    POWERUP
			    p.86;2484		CASE [PSL.26-24] AT [CONSOLE.PSL.000],	; case on current PSL<26:24>
E 410  A0F4,6883,2311,4D61 B 461;2485			sim addr [k]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   86
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;															    POWERUP
				;2486
				;2487	;	Console halt, continued.
				;2488	;	PC, PSL, MAPEN saved, MAPEN off, new PSL set.
				;2489	;	Save current stack.
				;2490	;
				;2491	;	At this point,
				;2492	;		W0	=	1
				;2493
				;2494	;= ALIGNLIST 000x	(CONSOLE.PSL.000,	CONSOLE.PSL.001,
				;2495	;=			 CONSOLE.PSL.010,	CONSOLE.PSL.011,
				;2496	;=			 CONSOLE.PSL.100,	CONSOLE.PSL.101,
				;2497	;=			 CONSOLE.PSL.110,	CONSOLE.PSL.111)
				;2498
				;2499	CONSOLE.PSL.000:
				;2500		;---------------------------------------; psl<26:24> = 000:
				;2501		[KSP] <-- [SP], LONG,			; save SP in KSP
			    p.88;2502		STATE.5-4 <-- 0,			; clear all permanent state flags
E 461  1001,4000,81E0,0339 J 339;2503		GOTO [CONSOLE.LOAD.PC]			; go load ISP
				;2504
				;2505	CONSOLE.PSL.001:
				;2506		;---------------------------------------; psl<26:24> = 001:
				;2507		[ESP] <-- [SP], LONG,			; save SP in ESP
			    p.88;2508		STATE.5-4 <-- 0,			; clear all permanent state flags
E 463  1001,4000,85E0,0339 J 339;2509		GOTO [CONSOLE.LOAD.PC]			; go load ISP
				;2510
				;2511	CONSOLE.PSL.010:
				;2512		;---------------------------------------; psl<26:24> = 010:
				;2513		[SSP] <-- [SP], LONG,			; save SP in SSP
			    p.88;2514		STATE.5-4 <-- 0,			; clear all permanent state flags
E 465  1001,4000,89E0,0339 J 339;2515		GOTO [CONSOLE.LOAD.PC]			; go load ISP
				;2516
				;2517	CONSOLE.PSL.011:
				;2518		;---------------------------------------; psl<26:24> = 011:
				;2519		[USP] <-- [SP], LONG,			; save SP in USP
			    p.88;2520		STATE.5-4 <-- 0,			; clear all permanent state flags
E 467  1001,4000,8DE0,0339 J 339;2521		GOTO [CONSOLE.LOAD.PC]			; go load ISP
				;2522
				;2523	CONSOLE.PSL.100:
				;2524		;---------------------------------------; psl<26:24> = 100:
				;2525		[ISP] <-- [SP], LONG,			; save SP in ISP
			    p.88;2526		STATE.5-4 <-- 0,			; clear all permanent state flags
E 469  1001,4000,91E0,0339 J 339;2527		GOTO [CONSOLE.LOAD.PC]			; go load ISP
				;2528
				;2529	CONSOLE.PSL.101:
				;2530		;---------------------------------------; psl<26:24> = 101:
				;2531		[SAVEPSL] <-- [SAVEPSL] OR 0000[40]00,	; mark corrupted PSL, set SAVEPSL<14>
				;2532		LONG,					;
			    p.88;2533		STATE.5-4 <-- 0,			; clear all permanent state flags
E 46B  1501,6A00,A690,0339 J 339;2534		GOTO [CONSOLE.LOAD.PC]			; go load ISP
				;2535
				;2536	CONSOLE.PSL.110:
				;2537		;---------------------------------------; psl<26:24> = 110:
				;2538		[SAVEPSL] <-- [SAVEPSL] OR 0000[40]00,	; mark corrupted PSL, set SAVEPSL<14>
				;2539		LONG,					;
				;2540		STATE.5-4 <-- 0,			; clear all permanent state flags
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   87
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;			    p.88											    POWERUP
E 46D  1501,6A00,A690,0339 J 339;2541		GOTO [CONSOLE.LOAD.PC]			; go load ISP
				;2542
				;2543	CONSOLE.PSL.111:
				;2544		;---------------------------------------; psl<26:24> = 111:
				;2545		[SAVEPSL] <-- [SAVEPSL] OR 0000[40]00,	; mark corrupted PSL, set SAVEPSL<14>
				;2546		LONG,					;
			    p.88;2547		STATE.5-4 <-- 0,			; clear all permanent state flags
E 46F  1501,6A00,A690,0339 J 339;2548		GOTO [CONSOLE.LOAD.PC]			; go load ISP
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   88
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;															    POWERUP
				;2549
				;2550	;	Console halt, continued.
				;2551	;	PC, PSL, MAPEN saved, MAPEN off, new PSL set, current SP saved.
				;2552	;	Load new SP and PC, start machine.
				;2553	;
				;2554	;	At this point,
				;2555	;		W0	=	1
				;2556
				;2557	CONSOLE.LOAD.PC:
				;2558		;---------------------------------------;
				;2559		[SP] <-- [ISP], LONG,			; load ISP into SP
			    p.89;2560		Q <-- PASSB [0E0]000000,		; start building powerup address<31:24>
E 339  0002,BF00,7A40,50ED B 3ED;2561		CASE [TEST.PINS] AT [CONSOLE.BURN.IN]	; split here for burn-in flow
				;2562
				;2563	;= ALIGNLIST 110x	(CONSOLE.BURN.IN,	CONSOLE.LOAD.PC.CONT)
				;2564
				;2565	;	Here from above, or on completion of the burn-in flow, to start execution.
				;2566	;
				;2567	;	At this point,
				;2568	;		Q	=	base of boot address
				;2569
				;2570	CONSOLE.LOAD.PC.CONT:
				;2571		;---------------------------------------; alu.z = 1 or strobe = 1::
				;2572		[WBUS] <-- [Q] OR 00[04]0000, LONG,	; normal powerup address = E004000
				;2573		LOAD PC,				; burn-in powerup address = 0004000
				;2574							; load new PC, start prefetching
				;2575							; >> LOAD PC: sync required before exit
			    p144;2576		STATE.5-4 <-- 0,			; clear permanent flags again for burn-in exit
E 3EF  1525,7020,20A0,0271 J 271;2577		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; restart Ibox and decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   89
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;															    POWERUP
				;2578
				;2579	;	Burn-in power-up flow.
				;2580	;	PC, PSL, MAPEN saved, MAPEN off, new PSL set, current SP saved, new SP loaded.
				;2581	;
				;2582	;	At this point,
				;2583	;		W0	=	1 (bit counter)
				;2584
				;2585	CONSOLE.BURN.IN:
				;2586		;---------------------------------------; strobe = 0:
				;2587		[W1] <-- 000000[PCCTL.FORCE.HIT],	; data for Pcache control:
				;2588							; force hit+I enable+D enable
E 3ED  1082,2038,0800,05D2 J 5D2;2589		STATE.5 <-- 1				; set MCHK pin at start of burn-in flow.
				;2590
				;2591	;= AT 5D2
				;2592		;---------------------------------------; write Pcache status register to
				;2593		VA <-- K10.[IPR.PCSTS], LONG,		;   clear lock bit.
E 5D2  00F4,7E83,2321,0181 J 181;2594		MEM.PR (VA)&, [WBUS] <-- PASSA [K1]	;
				;2595
				;2596		;---------------------------------------; write Pcache control register.
				;2597		VA <-- K10.[IPR.PCCTL], LONG,		; left bank enabled, parity check disabled
E 181  00F4,7F03,2021,0343 J 343;2598		MEM.PR (VA)&, [WBUS] <-- PASSA [W1]
				;2599
				;2600		;---------------------------------------;
				;2601		VA&, [WBUS] <-- [K0],			; starting pcache load address = 0.
				;2602		Q <-- 0,				; Q holds the start of the boot address
E 343  0002,C001,2310,50E8 B 3E8;2603		CASE [TEST.PINS] AT [CONSOLE.DATA.0.STROBE.0] ; wait for first test_strobe assertion.
				;2604
				;2605	;= ALIGNLIST 100x	(CONSOLE.DATA.0.STROBE.0, CONSOLE.DATA.0.STROBE.1,
				;2606	;=			 CONSOLE.DATA.1.STROBE.0, CONSOLE.DATA.1.STROBE.1)
				;2607
				;2608	; Pin timing on p%test_strobe_h and p%test_data_h must guarrantee
				;2609	; that there are two cases at this point on each pass through the flow.
				;2610
				;2611	CONSOLE.DATA.0.STROBE.0:
				;2612		;---------------------------------------; data = 0, strobe = 0:
				;2613		[WBUS] <-- [W0] AND 000000[1F], LONG,	; [L1W] test bit count, alu.z=1 if 32
				;2614							;	bits accumulated
E 3E8  0400,20F8,2010,50E8 B 3E8;2615		CASE [TEST.PINS] AT [CONSOLE.DATA.0.STROBE.0] ; wait for strobe assertion
				;2616
				;2617	CONSOLE.DATA.1.STROBE.0:
				;2618		;---------------------------------------; data = 1, strobe = 0:
				;2619		[WBUS] <-- [W0] AND 000000[1F], LONG,	; [L1W] test bit count, alu.z=1 if 32
				;2620							;	bits accumulated
E 3EC  0400,20F8,2010,50E8 B 3E8;2621		CASE [TEST.PINS] AT [CONSOLE.DATA.0.STROBE.0] ; wait for strobe assertion
				;2622
				;2623	CONSOLE.DATA.0.STROBE.1:
				;2624		;---------------------------------------; data = 0, strobe = 1:
			    p.90;2625		[W1] <-- [K0]!![W1] RSH [1], LONG,	; [L1D] shift in a 1 bit
E 3EA  0001,8112,0B10,0341 J 341;2626		GOTO [CONSOLE.DATA.MERGE]		; merge with common code
				;2627
				;2628	CONSOLE.DATA.1.STROBE.1:
				;2629		;---------------------------------------; data = 1, strobe = 1:
			    p.90;2630		[W1] <-- [K1]!![W1] RSH [1], LONG,	; [L1D] shift in a 0 bit
E 3EE  0001,8112,0B20,0341 J 341;2631		GOTO [CONSOLE.DATA.MERGE]		; merge with common code
				;2632
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   90
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;															    POWERUP
				;2633	CONSOLE.DATA.MERGE:
				;2634		;---------------------------------------;
				;2635		[WBUS] <-- [W0] ANDNOT 0000[80]00, LONG, ; [L2] test bit count, alu.z=1 if
			    p.91;2636							; 32K bits accumulated
E 341  2480,2C00,2010,41FA B 3FA;2637		CASE [ALU.NZV] AT [CONSOLE.GET.NEXT.BIT] ; case on full longword from [L1W]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   91
;   POWERUP.MIC 	     Console Halt Entry Point								      /REV=
;															    POWERUP
				;2638
				;2639	;	Burn-in power-up flow.
				;2640	;	test_data has been strobed and added to current longword.
				;2641	;
				;2642	;	At this point:
				;2643	;		W0	=	running bit count
				;2644	;		VA	=	Pcache address
				;2645	;		Q	=	0 (boot address)
				;2646	;		W1	=	32 bits of accumulated data
				;2647	;		alu.z	=	1 if 32K bits accumulated (valid in cycle L4)
				;2648	;
				;2649	;= ALIGNLIST *0*x	(CONSOLE.GET.NEXT.BIT,	CONSOLE.WRITE.LW)
				;2650	;  ALU.NZVC set by LONGWORD AND with mask<31> = 0  --> N = V = 0
				;2651
				;2652	CONSOLE.GET.NEXT.BIT:
				;2653		;---------------------------------------; alu.z = 0:
E 3FA  0000,0000,2000,50FD B 3FD;2654		CASE [TEST.PINS] AT [CONSOLE.STROBE.0]	; [L3] wait for strobe deassertion
				;2655
				;2656	CONSOLE.WRITE.LW:
				;2657		;---------------------------------------; alu.z = 1:
E 3FE  0064,8012,2000,033B J 33B;2658		MEM (VA)&, [WBUS] <-- PASSB [W1], LONG	; [L3] write longword to Pcache
				;2659
				;2660		;---------------------------------------;
				;2661		VA <-- [VA] + 4,			; [L4] increment VA to next longword
E 33B  2C00,0001,20B0,41EB B 3EB;2662		CASE [ALU.NZV] AT [CONSOLE.WRITE.CONT] ; case on 32K bits accumulated from [L2]
				;2663
				;2664	;= ALIGNLIST 10*x	(CONSOLE.WRITE.CONT,	CONSOLE.LOAD.PC.CONT)
				;2665	;  ALU.NZVC set by AND --> V = 0
				;2666
				;2667	CONSOLE.WRITE.CONT:
				;2668		;---------------------------------------; alu.z = 0:
E 3EB  0000,0000,2000,50FD B 3FD;2669		CASE [TEST.PINS] AT [CONSOLE.STROBE.0]	; [L3] wait for strobe deassertion
				;2670
				;2671	;= ALIGNLIST 110x	(CONSOLE.STROBE.0,	CONSOLE.STROBE.1)
				;2672
				;2673	CONSOLE.STROBE.0:
				;2674		;---------------------------------------; strobe = 0:
			    p.89;2675		[W0] <-- [W0] + 1, LONG,		; increment running bit count
E 3FD  0800,0000,0410,50E8 B 3E8;2676		CASE [TEST.PINS] AT [CONSOLE.DATA.0.STROBE.0]	; strobe deasserted, get next bit
				;2677
				;2678	CONSOLE.STROBE.1:
				;2679		;---------------------------------------; strobe = 1 or alu.n = 1:
E 3FF  0000,0000,2000,50FD B 3FD;2680		CASE [TEST.PINS] AT [CONSOLE.STROBE.0] ; strobe asserted, wait
				;2681
				;2682	;= END POWERUP
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   92
;    INTEXC.MIC 	     INTEXC.MIC -- Interrupts and Exceptions						      /REV=
;
				;2683	.TOC	"INTEXC.MIC -- Interrupts and Exceptions"
				;2684	.TOC	"Revision 1.6"
				;2685
				;2686	;	Mike Uhler, Bob Supnik
				;2687
;2688	.nobin
;2689	;****************************************************************************
;2690	;*									    *
;2691	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;2692	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;2693	;*  ALL RIGHTS RESERVED.						    *
;2694	;*									    *
;2695	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;2696	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;2697	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;2698	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;2699	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;2700	;*  TRANSFERRED.							    *
;2701	;*									    *
;2702	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;2703	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;2704	;*  CORPORATION.							    *
;2705	;*									    *
;2706	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;2707	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;2708	;*									    *
;2709	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   93
;    INTEXC.MIC 	     Revision History									      /REV=
;
;2710	.TOC	"	Revision History"
;2711
;2712	; Edit	  Date	 Who	     Description
;2713	; ---- --------- ---	---------------------
;2714	;    6 01-Aug-91 GMU	Symptom: FPD opcode filter too long and too slow.
;2715	;			Cure:	 Rewrite the FPD filter algorithm to be
;2716	;				 more space and time efficient.
;2717	;    5 22-May-91 GMU	Symptom: When the instruction emulator for POLYx
;2718	;				 detects a fault in the instruction execution,
;2719	;				 it packs up state in the GPRs, sets PSL<FPD>,
;2720	;				 and dispatches to the appropriate handler.
;2721	;				 When the handler fixes the problem and REIs
;2722	;				 to restart the POLYx, a reserved instruction
;2723	;				 fault is supposed to be taken with PSL<FPD>
;2724	;				 set.  The NVAX implementation prioritizes
;2725	;				 PSL<FPD> above reserved instruction fault,
;2726	;				 so an emulated FPD fault is generated instead
;2727	;				 and the emulator faults out the unexpected
;2728	;				 opcode.  This same discussion applies to all
;2729	;				 other unimplemented opcodes, but an analysis
;2730	;				 of the emulator suggests that only the emulation
;2731	;				 of POLYx currently makes use of PSL<FPD>.
;2732	;			Cure:	 An opcode filter has been added to the FPD
;2733	;				 flow to check for all emulated instructions and
;2734	;				 dispatch them to the emulate FPD handler.  All
;2735	;				 remaining instructions are then dispatched to the
;2736	;				 reserved instruction fault handler.  The filter
;2737	;				 freely uses don't care opcode bits in such a way
;2738	;				 that some legal opcodes are dispatched to the
;2739	;				 emulate FPD handler.
;2740	;    4 20-May-91 GMU	Symptom: Certain console halts may be invoked from
;2741	;				 flows in which a RESET CPU and call to IE.CLEANUP.CPU
;2742	;				 have been performed (e.g., halt interrupt,
;2743	;				 interrupt stack not valid, illegal SCB vector).
;2744	;				 If this call packs up the state for a string
;2745	;				 instruction, a second RESET CPU and call to IE.CLEANUP.CPU
;2746	;				 leaves SAVEPSL with FPD set and SAVEPC pointing
;2747	;				 at the instruction following the string instruction
;2748	;				 rather than at the string instruction.
;2749	;			Cure:	 For those non-error related halts in which
;2750	;				 string state may have been packed up, change
;2751	;				 to use the CONSOLE HALT NO CLEANUP macro,
;2752	;				 which avoids the second RESET CPU and call to
;2753	;				 IE.CLEANUP.CPU.  Console halts that are due to
;2754	;				 errors in any form are not changed to guarantee
;2755	;				 that a RESET CPU is performed.
;2756	;    3 09-Apr-91 GMU	Symptom: The Mbox PA queue state isn't cleared after
;2757	;				 a FLUSH PA QUEUE until the Mbox is free
;2758	;				 to drive an S5 transaction from the EM latch.
;2759	;				 If the Mbox is servicing Cbox requests, the
;2760	;				 PA queue status bits don't change in time to
;2761	;				 prevent a store from advancing incorrectly
;2762	;				 from Ebox S4 into the EM latch.
;2763	;			Cure:	 Insert a second SYNCHRONIZE MBOX at IE.BRANCH..
;2764	;				 to force the Ebox to stall until the first
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   94
;    INTEXC.MIC 	     Revision History									      /REV=
;
;2765	;				 SYNCHRONIZE MBOX is serviced by the Mbox.
;2766	;				 This allows time for the PA queue state to change.
;2767	;    2 15-Oct-90 GMU	Symptom: If an S3 stall timeout was caused by a spec
;2768	;				 queue request that didn't finish for some
;2769	;				 reason, the Mbox would retry the request because
;2770	;				 it wasn't receiving E%FLUSH_MBOX_H before
;2771	;				 the special reset signal was deasserted.  As
;2772	;				 it turns out, the RESET CPU is REQUIRED before
;2773	;				 the special reset is deasserted.
;2774	;			Cure:	 Add a RESET CPU to the IE.ASYNC.HW.ERROR..
;2775	;				 entry point.  Note that this assumes that the
;2776	;				 special reset signal is at least 5 cycles
;2777	;				 in length.
;2778	;    1 25-Sep-90 GMU	Symptom: One of the effects of S3 stall timeout is
;2779	;				 the assertion of a special reset signal
;2780	;				 to the Mbox and Cbox.	This signal was previously
;2781	;				 asserted for 6 cycles, but a recent design
;2782	;				 change made it 18 cycles.  During the assertion
;2783	;				 of this signal, no Mbox or Cbox request may
;2784	;				 be made by the microcode, and the Mbox
;2785	;				 designers weren't clear about whether RESET CPU
;2786	;				 could be asserted during the assertion of
;2787	;				 the reset signal.
;2788	;			Cure:	 Add 3 microwords just above WAIT.TWO.CYCLES
;2789	;				 to implement a 23 cycle delay.  This routine
;2790	;				 is then called from IE.ASYNC.HW.ERROR.. before
;2791	;				 the machine check routine is entered.	With
;2792	;				 pipe latency from the start of the microtrap,
;2793	;				 this implements a 28-cycle delay before the
;2794	;				 RESET CPU and a 37-cycle delay before the first
;2795	;				 Mbox request.	This is overkill relative to
;2796	;				 the desired 18-cycle delay, but adds enough
;2797	;				 delay to allow additional small changes to the
;2798	;				 signal length with no additional microcode
;2799	;				 changes.
;2800	; (1)0 17-Jul-90 GMU	Initial production microcode.
;2801	;
;2802	; Begin version 1.0 here
;2803	;   31 16-Jul-90 GMU	Add delay at the start of the asynchronous hardware
;2804	;			error microtrap sequence that is required by the
;2805	;			Mbox/Cbox pseudo reset generated by S3 stall timeout.
;2806	;   30 01-Jul-90 GMU	Add support for performance monitoring facility.
;2807	;   29 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;2808	;   28 03-May-90 GMU	Reverse order of duplicate labels so that the one
;2809	;			included in an ALIGNLIST is last.
;2810	;   27 03-May-90 GMU	Fix bug in edit 26 that caused SP to be trashed at
;2811	;			the exit from an exception flow.
;2812	;   26 01-May-90 GMU	Read VAX restart bit before call to IE.EXCEPTION so
;2813	;			that it is not cleared by the stack writes.
;2814	;   25 01-May-90 GMU	Uncomment references to CWB IPR.
;2815	;   24 01-May-90 GMU	Save original value of SAVEPC in machine check stack
;2816	;			frame to allow software to find the correct PC for
;2817	;			a machine check due to a PTE read error in an interruptable
;2818	;			instruction.  This causes a change to the machine check
;2819	;			frame format.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   95
;    INTEXC.MIC 	     Revision History									      /REV=
;
;2820	;   23 30-Apr-90 GMU	Sync with Mbox after LOAD PC.
;2821	;   22 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;2822	;   21 26-Mar-90 GMU	Clear state<3> in queue packup routine before first
;2823	;			memory reference.
;2824	;   20 28-Feb-90 GMU	Convert Fbox exception handler to obtain condition
;2825	;			from the FBOX.CONDITION decode rather than from
;2826	;			FBOX.FAULT.CODE.
;2827	;   19 12-Feb-90 GMU	Remove FLUSH VIC from machine check flow.
;2828	;   18 19-Jan-90 GMU	Add code to clear CEFSTS RDLK bit in machine check.
;2829	;			This code is currently commented out until the model
;2830	;			catches up.
;2831	;   17 19-Jan-90 GMU	FLUSH BRANCH PREDICTION CACHE -> FLUSH BRANCH PREDICTION TABLE.
;2832	;   16 19-Jan-90 GMU	Add CPUID to machine check stack frame description.
;2833	;   15 09-Jan-90 GMU	Modify interrupt routine to reflect new hardware design
;2834	;			of interrupt section.
;2835	;   14 05-Jan-90 GMU	Remove IE.VECT.ISSUE.. routine.
;2836	;   13 07-Dec-89 GMU	Continue comment update, remove use of ZEXTWL ALU function.
;2837	;   12 06-Dec-89 GMU	Remove FLUSH BPC from cleanup routine.
;2838	;   11 17-Nov-89 GMU	Convert CLEAR WRITE BUFFER macro to use IPR write.
;2839	;   10 07-Nov-89 GMU	Convert all flows to use new RESET CPU interface.
;2840	;    9 25-Oct-89 GMU	Clean up string pack/unpack interface.
;2841	;    8 24-Oct-89 GMU	Don't clear state<5:4> until after all stack writes have
;2842	;			cleared memory management checks.  Also, clear both
;2843	;			bits after KSNV.
;2844	;    7 23-Oct-89 GMU	Clean up interface between CHMx and PROBEx faults and
;2845	;			IE.MEMMGT.
;2846	;    6 09-Oct-89 GMU	Change to reflect backup PC returned in SAVEPC from
;2847	;			call to REINITIALIZE.CPU.
;2848	;    5 01-Oct-89 GMU	Patch vector fault handler until the hardware drives
;2849	;			the correct value on the microtest bus.
;2850	;    4 29-Sep-89 GMU	Fix FPD entry point restart of instructions.
;2851	;    3 18-Aug-89 GMU	Rewrite ACV/TNV/M=0 routine.
;2852	;    2 16-Aug-89 GMU	Add termporary sim halt in exception handler.
;2853	;    1 19-Jul-89 GMU	Update to latest design.
;2854	; (0)0 16-Sep-87 RMS	Trial microcode.
;2855
				;2856	.bin
				;2857	;= BEGIN INTEXC
;2858	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   96
;    INTEXC.MIC 	     Revision History									      /REV=
;															     INTEXC
;2859
;2860	;	Interrupts and exceptions fall into three basic classes:  traps, faults, and aborts.
;2861	;	In each case the PC and the PSL are pushed onto the stack.  In certain cases, parameters
;2862	;	are also pushed.  Traps occur at the end of the instruction that caused the exception.
;2863	;	Faults occur during an instruction but leave the registers and memory such that elimination
;2864	;	of the fault condition and restarting the instruction will give correct results.  Aborts
;2865	;	occur during an instruction but leave the registers and memory such that the instruction
;2866	;	cannot necessarily be restarted.
;2867
;2868	;	Hardware dispatches:
;2869	;
;2870	;	Entry Point		From			Comments
;2871	;	-----------		----			--------
;2872	;	IE.POWERUP..		microtrap		powerup microtrap (in POWERUP.MIC)
;2873	;	IE.ASYNC.HW.ERROR..	microtrap		asynchronous hardware error
;2874	;	IE.RSVD.OPCODE.TRAP..	microtrap		reserved instruction fault (generated for floating point
;2875	;							instructions when the Fbox is disabled)
;2876	;	IE.SYNC.HW.ERROR..	mirotrap		synchronous hardware error
;2877	;	IE.MEMMGT..		microtrap		memory management exception
;2878	;	IE.INT.OVERFLOW..	microtrap		integer overflow trap
;2879	;	IE.BRANCH..		microtrap		branch mispredict trap
;2880	;	IE.RSVD.ADDRESS..	microtrap		reserved addressing mode
;2881	;	IE.FLT.FAULT..		microtrap		floating point fault
;2882	;	IE.INT..		exception dispatch	interrupt pending
;2883	;	IE.TRACE.TRAP.. 	exception dispatch	trace fault
;2884	;	IE.FPD..		execution dispatch	PSL<FPD> set at instruction dispatch
;2885	;	IE.STALL..		execution dispatch	instruction queue empty at instruction dispatch
;2886	;	RSVD.OPCODE..		execution or microcode	reserved instruction fault
;2887	;				dispatch
;2888	;
;2889	;	Microcode dispatches:
;2890	;
;2891	;	Entry Point		From			Comments
;2892	;	-----------		----			--------
;2893	;	IE.CONSOLE.HALT..	various 		console restart (in POWERUP.MIC)
;2894	;	IE.MACHINE.CHECK..	various 		machine check fault
;2895	;	IE.RSVD.OPERAND..	various 		reserved operand fault
;2896	;	IE.INT.FAULT..		CSTRING.MIC		interrupt in mid instruction (treated as a fault)
;2897	;	IE.SUBSCRIPT.ERROR..	MISC.MIC		subscript range trap
;2898	;	IE.DIVIDE.ERROR..	MULDIV.MIC		integer divide-by-zero trap
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   97
;    INTEXC.MIC 	     Revision History									      /REV=
;															     INTEXC
;2899
;2900	;	Design considerations in this module:
;2901	;
;2902	;	CPU CLEANUP REQUIREMENTS ON ENTRY
;2903	;
;2904	;	In many instances, this module is entered via microtrap or via
;2905	;	direct dispatch from the execution flows.  As a result, there
;2906	;	may be an unspecified number of outstanding reads to arbitrary
;2907	;	working registers.  Therefore, no working register may be either
;2908	;	read or written until other activity has been aborted.
;2909	;
;2910	;	With a few rare exceptions which are clearly documented in
;2911	;	the code, all entry points into this module must issue RESET CPU
;2912	;	and then perform the operations required to clean up the Ibox
;2913	;	and Mbox state.  In most instances, this is accomplished by
;2914	;	calling either IE.CLEANUP.CPU or IE.CLEANUP.CPU.NO.PACKUP from
;2915	;	the entry point.  These routines correctly clean up CPU state
;2916	;	and are written to conform to the requirements that are imposed
;2917	;	on this process.
;2918	;
;2919	;	Due to specific requirements in the routines, two routines
;2920	;	(IE.MEMMGT.. and IE.MACHINE.CHECK..) do not call IE.CLEANUP.CPU
;2921	;	in the microinstruction at the entry point of the routine.  In
;2922	;	these instances, the code following the entry point must be
;2923	;	aware that there are two fundamental restrictions on the
;2924	;	two microinstructions following the one in which the RESET CPU
;2925	;	is issued:
;2926	;
;2927	;		1. There must not be any read or write to a working
;2928	;		   register in either microinstruction.
;2929	;		2. There must not be any Mbox request via the MRQ or
;2930	;		   DST fields in either microinstruction.
;2931	;
;2932	;	These restrictions are imposed by the timing of RESET CPU.
;2933	;	Failure to observe these restriction results in UNDEFINED
;2934	;	behavior, including the possibility of hanging the CPU.
;2935	;	Both of these restrictions are met by calls to IE.CLEANUP.CPU
;2936	;	and IE.CLEANUP.CPU.NO.PACKUP from the microinstruction that
;2937	;	issues RESET CPU.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   98
;    INTEXC.MIC 	     Revision History									      /REV=
;															     INTEXC
;2938
;2939	;	STATE FLAG USAGE AND OPERATION
;2940	;
;2941	;	There are six state flags, state<5:0>, provided by Ebox hardware.
;2942	;	Three of them, state<2:0>, are provided for the arbitrary use
;2943	;	of instruction flows.  Some of these flags are also used within
;2944	;	the IE.EXCEPTION and IE.INTERRUPT routines, after they are
;2945	;	explicitly cleared.
;2946	;
;2947	;	One state flag, state<3>, is used to communicate information from
;2948	;	an instruction flow to an exception flow in this module.  state<3>
;2949	;	is set by an instruction flow when it wants to perform some special
;2950	;	cleanup action in the event that an exception or interrupt occurs during
;2951	;	instruction execution.	At present, this feature is used only by
;2952	;	the interlocked queue and the string instructions.  When
;2953	;	IE.CLEANUP.CPU is called, it checks the value of state<3> and
;2954	;	dispatches to the appropriate routine if the bit is set.  For
;2955	;	the interlocked queue instructions, the secondary interlock
;2956	;	in the queue header is released.  For the string instructions,
;2957	;	state is packed into the GPRs, and PSL<FPD> is set.
;2958	;
;2959	;	state<3:0> are automatically cleared by the hardware on
;2960	;	instruction and FPD dispatches.  These bits are explicitly not
;2961	;	cleared for other microtrap or non-instruction dispatches.
;2962	;	IE.CLEANUP.CPU.NO.PACKUP may be called in those instances where
;2963	;	it is known by context that state<3> has no meaning to force
;2964	;	state<3:0> to 0 before continuing with the cleanup process.
;2965	;
;2966	;	Two state flags, state<5:4>, are the so-called permanent state
;2967	;	flags, and are used exclusively by this module to encode the
;2968	;	current state of exception processing, as follows:
;2969	;
;2970	;		state<5:4>	Meaning
;2971	;		----------	-------
;2972	;		    00		Not in any of the following flows.
;2973	;		    01		Processing interrupt or exception
;2974	;		    10		Processing machine check
;2975	;		    11		Processing kernel stack not valid
;2976	;
;2977	;	The appropriate combination of these flags is set before any
;2978	;	stack writes are attempted.  If the memory management exception
;2979	;	or machine check routine is entered with state<5:4> having
;2980	;	a value other than 00, a console halt sequence is initiated.
;2981	;	In this manner, recursive failures are detected.
;2982	;
;2983	;	Flows other than machine check clear both state flags after
;2984	;	all stack writes are complete, but before dispatching the
;2985	;	event to the operating system.	The machine check flow
;2986	;	explicitly does not clear state<5> on exit.  Instead, the
;2987	;	operating system is required to acknowledge the machine check
;2988	;	via a write to the MCESR processor register, which clears
;2989	;	state<5:4> at that point.  In this manner, recursion is
;2990	;	detected all the way to the software machine check handler.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page   99
;    INTEXC.MIC 	     Revision History									      /REV=
;															     INTEXC
;2991
;2992	;	WORKING REGISTER USAGE
;2993	;
;2994	;	Working register usage within this module is governed by several
;2995	;	constraints.  The special packup routines for the interlocked
;2996	;	queue and the string instructions assume that certain state
;2997	;	has not changed relative to the instruction flow that caused
;2998	;	the original fault.  For this reason, W0 and W3 must not be
;2999	;	destroyed before the call to IE.CLEANUP.CPU, if state<3> is
;3000	;	set.
;3001	;
;3002	;
;3003	;	Specific usage of each working register in this module is
;3004	;	shown below:
;3005	;
;3006	;	W0:	Available after the call to IE.CLEANUP.CPU.  Used as
;3007	;		general temporary and trashed by IE.EXCEPTION/IE.INTERRUPT.
;3008	;
;3009	;	W1:	Trashed by IE.CLEANUP.CPU.  SCB offset as input to,
;3010	;		and SCB vector as output from IE.EXCEPTION/IE.INTERRUPT.
;3011	;
;3012	;	W2:	Exception PSL as input to and output from IE.EXCEPTION/IE.INTERRUPT
;3013	;
;3014	;	W3:	Available after the call to IE.CLEANUP.CPU.  Masked IPL
;3015	;		as input to IE.INTERRUPT.  Used as a general temporary and
;3016	;		trashed by IE.EXCEPTION/IE.INTERRUPT.
;3017	;
;3018	;	W4:	Available to flows.  Preserved by IE.EXCEPTION/IE.INTERRUPT.
;3019	;
;3020	;	W5:	Available to flows.  Preserved by IE.EXCEPTION/IE.INTERRUPT.
;3021	;
;3022	;	In addition to W4 and W5, both SAVEPSL and Q are preserved by
;3023	;	IE.EXCEPTION/IE.INTERRUPT, and may be used to save values across the
;3024	;	call to these routines.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  100
;    INTEXC.MIC 	     Revision History									      /REV=
;															     INTEXC
;3025
;3026	;	Implementation dependent decisions in INTEXC:
;3027	;
;3028	;	    1.	Vector<1:0> = 0 during machine check or ksnv is treated like
;3029	;		a normal exception, i.e., the exception is processed on the
;3030	;		kernel stack, and the IPL is not changed.
;3031	;
;3032	;	    2.	Vector<1:0> neq 0 during CHMx is IGNORED.
;3033	;
;3034	;	    3.	Vector<1:0> = 2 during any interrupt or other exception
;3035	;		causes a console restart (code = ERR.WCSVEC).
;3036	;
;3037	;	    4.	Vector<1:0> = 3 during any interrupt or other exception
;3038	;		causes a console restart (code = ERR.ILLVEC).
;3039	;
;3040	;	    5.	ACV/TNV during kernel stack not valid or
;3041	;		machine check causes a console restart.
;3042	;
;3043	;	    6.	Machine check during any exception causes
;3044	;		a console restart.
;3045	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  101
;    INTEXC.MIC 	     Revision History									      /REV=
;															     INTEXC
;3046
;3047	;	This is a list of machine checks in the microcode:
;3048	;
;3049	;	Mnemonic	   Dispatched From		Condition
;3050	;	--------	   ---------------	--------------------------------------
;3051	;	MCHK.UNKNOWN.MSTATUS	INTEXC		Unknown memory management status
;3052	;	MCHK.INT.ID.VALUE	INTEXC		Unknown interrupt ID
;3053	;	MCHK.CANT.GET.HERE	CALLRET 	Unknown microcode dispatch
;3054	;	MCHK.MOVC.STATUS	CSTRING 	Unknown MOVCx status
;3055	;	MCHK.ASYNC.ERROR	INTEXC		Asynchronous hardware error microtrap
;3056	;	MCHK.SYNC.ERROR 	INTEXC		Synchronous hardware error microctrap
;3057	;	MCHK.PMF.CONFIG 	OPSYS		Illegal PMF SCB vector
;3058	;
;3059	;	This is a list of console restarts in the microcode:
;3060	;
;3061	;	Mnemonic	   Dispatched From			Condition
;3062	;	--------	   ---------------	----------------------------------------------
;3063	;	ERR.HLTPIN		INTEXC		HALT pin asserted
;3064	;	ERR.PWRUP		POWERUP 	power up
;3065	;	ERR.INTSTK		INTEXC		interrupt stack not valid
;3066	;	ERR.DOUBLE		INTEXC		double fatal error
;3067	;	ERR.HLTINS		MISC		HALT instruction
;3068	;	ERR.ILLVEC		INTEXC		illegal vector
;3069	;	ERR.WCSVEC		INTEXC		vector to WCS
;3070	;	ERR.CHMFI		OPSYS		CHMx on interrupt stack
;3071	;	ERR.IE0 		INTEXC		ACV/TNV during machine check exception
;3072	;	ERR.IE1 		INTEXC		ACV/TNV during kernel stack not valid exception
;3073	;	ERR.IE2 		INTEXC		machine check during machine check exception
;3074	;	ERR.IE3 		INTEXC		machine check during kernel stack not valid exception
;3075	;	ERR.IE.PSL.26-24.101	INTEXC		PSL<26:24> = 101 during interrupt or exception
;3076	;	ERR.IE.PSL.26-24.110	INTEXC		PSL<26:24> = 110 during interrupt or exception
;3077	;	ERR.IE.PSL.26-24.111	INTEXC		PSL<26:24> = 111 during interrupt or exception
;3078	;	ERR.REI.PSL.26-24.101	OPSYS		PSL<26:24> = 101 during REI
;3079	;	ERR.REI.PSL.26-24.110	OPSYS		PSL<26:24> = 110 during REI
;3080	;	ERR.REI.PSL.26-24.111	OPSYS		PSL<26:24> = 111 during REI
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  102
;    INTEXC.MIC 	     Instruction Dispatch Stall 							      /REV=
;															     INTEXC
;3081	.TOC	"	Instruction Dispatch Stall"
;3082
;3083	;	This routine is dispatched by the microsequencer if the
;3084	;	instruction queue is empty at the last cycle of the
;3085	;	previous flow.
;3086	;
;3087	;	Entry conditions:
;3088	;		none
;3089	;
;3090	;	Exit conditions:
;3091	;		try to decode next instruction
;3092	;
				;3093	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  103
;    INTEXC.MIC 	     Instruction Dispatch Stall 							      /REV=
;															     INTEXC
				;3094
				;3095	;	Instruction dispatch stall.
				;3096
				;3097	;	Entered by microsequencer dispatch.  Machine state should
				;3098	;	not be disturbed as this is a temporary condition that will be
				;3099	;	resolved when the Ibox delivers either a new instruction or an
				;3100	;	exception dispatch.
				;3101	;
				;3102	;	Note: A NOP NODEST macro must be used here to prevent
				;3103	;	an RM stall if the next instruction to be retired is
				;3104	;	from the F-box.
				;3105
				;3106	IE.STALL..:
				;3107		;********** Hardware dispatch **********;
				;3108		NOP NODEST,				; No destination for instruction
E 030  1000,0100,0000,1000 L	;3109		LAST CYCLE NO RETIRE			; decode next instruction
				;3110
;3111	.nobin
;3112
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  104
;    INTEXC.MIC 	     Branch Mispredict Microtrap							      /REV=
;															     INTEXC
;3113	.TOC	"	Branch Mispredict Microtrap"
;3114
;3115	;	This routine is entered from a microtrap if the Ebox branch
;3116	;	direction does not match that predicted by the Ibox.
;3117	;
;3118	;	Entry conditions:
;3119	;		none
;3120	;
;3121	;	Exit conditions:
;3122	;		synchronize with previous EM latch store.
;3123	;		flush PA queue and restart Mbox
;3124	;		try to decode next instruction.
;3125	;
				;3126	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  105
;    INTEXC.MIC 	     Branch Mispredict Microtrap							      /REV=
;															     INTEXC
				;3127
				;3128	;	Branch mispredict.
				;3129	;
				;3130	;	Entered by microtrap.  The microtrap itself flushes most of the
				;3131	;	Ebox, Fbox, and Mbox state, and redirects the Ibox to the
				;3132	;	alternate instruction stream.  Because there may be a store
				;3133	;	pending in the EM latch that requires one or more PA queue entries,
				;3134	;	the PA queue is not flushed as a byproduct of the branch mispredict
				;3135	;	microtrap.  Instead, the microcode must synchronize with the completion
				;3136	;	of any possible store, and then explicitly flush the PA queue and
				;3137	;	restart the Mbox before starting the next instruction.
				;3138
				;3139	IE.BRANCH..:
				;3140		;********** Hardware dispatch **********;
				;3141		SYNCHRONIZE MBOX,			; sync with possible store,
				;3142		FLUSH PA QUEUE, 			; then flush the PA queue,
E 00C  1020,0400,2004,8183 J 183;3143		RESTART MBOX				; and restart the Mbox
				;3144
				;3145	;	Note: the following microinstruction contains a SYNCHRONIZE MBOX,
				;3146	;	which forces an EM latch stall at this point until the Mbox drives
				;3147	;	the previous microinstruction into S5.	This is required to allow
				;3148	;	the Mbox time to reset the PA queue status from non-empty to empty.
				;3149	;	Without this second SYNCHRONIZE MBOX, the Ebox may incorrectly
				;3150	;	drive a store into the EM latch even though the PA queue has no
				;3151	;	valid entries.
				;3152
				;3153		;---------------------------------------;
				;3154		SYNCHRONIZE MBOX,			; force stall until PA queue status changes
E 183  1020,0100,2000,1000 L	;3155		LAST CYCLE NO RETIRE			; decode next instruction
;3156	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  106
;    INTEXC.MIC 	     FPD -- PSL<fpd> Set								      /REV=
;															     INTEXC
;3157	.TOC	"	FPD -- PSL<fpd> Set"
;3158
;3159	;	This routine is dispatched by the microsequencer when the
;3160	;	instruction queue contains a vaild dispatch and PSL<FPD> is
;3161	;	set.  The Ibox has parsed only the instruction opcode.
;3162	;
;3163	;	Entry conditions:
;3164	;		RN.MODE.OPCODE	=	instruction opcode
;3165	;		Ibox state	=	stopped, waiting for LOAD PC
;3166	;
;3167	;	Exit conditions:
;3168	;		Dispatch to instruction specific restart routine.
;3169	;
;3170	;	Note: This routine is fairly complex because there are four classes
;3171	;	of instructions that must be separated:
;3172	;
;3173	;		1. The 8 string instructions which are implemented by the
;3174	;		   microcode, and for which the microcode directly manipulates
;3175	;		   PSL<FPD>: MOVC3 (28), MOVC5 (2C), CMPC3 (29), CMPC5 (2D),
;3176	;		   LOCC (3A), SKPC (3B), SCANC (2A), SPANC (2B).  These instructions
;3177	;		   are dispatched directly to the string uppack code in
;3178	;		   CSTRING.MIC.
;3179	;
;3180	;		2. The 21 emulated instructions which are processed by the
;3181	;		   VAX instruction emulator thru the emulated instruction
;3182	;		   interface: CVTPS (08), CVTSP (09), CRC (0B), ADDP4 (20),
;3183	;		   ADDP6 (21), SUBP4 (22), SUBP6 (23), CVTPT (24), MULP (25),
;3184	;		   CVTTP (26), DIVP (27), MOVTC (2E), MOVTUC (2F), MOVP (34),
;3185	;		   CMPP3 (35), CVTPL (36), CMPP4 (37), EDITPC (38), MATCHC (39),
;3186	;		   ASHP (F8), CVTLP (F9).  These instructions are dispatched
;3187	;		   to the emulate FPD code in EMULATE.MIC.
;3188	;
;3189	;		3. The 41 unimplemented instructions which may be processed
;3190	;		   by the VAX instruction emulator thru the reserved instruction
;3191	;		   fault interface:
;3192	;		   ACBF (4F), EMODF (54), POLYF (55), ACBD (6F), EMODD (74),
;3193	;		   POLYD (75), CVTDH (FD32), ACBG (FD4F), EMODG (FD54),
;3194	;		   POLYG (FD55), CVTGH (FD56), ADDH2 (FD60), ADDH3 (FD61), SUBH2 (FD62),
;3195	;		   SUBH3 (FD63), MULH2 (FD64), MULH3 (FD65), DIVH2 (FD66), DIVH3 (FD67),
;3196	;		   CVTHB (FD68), CVTHW (FD69), CVTHL (FD6A), CVTRHL (FD6B), CVTBH (FD6C),
;3197	;		   CVTWH (FD6D), CVTLH (FD6E), ACBH (FD6F), MOVH (FD70), CMPH (FD71),
;3198	;		   MNEGH (FD72), TSTH (FD73), EMODH (FD74), POLYH (FD75), CVTHG (FD76),
;3199	;		   CLRO (FD7C), MOVO (FD7D), MOVAO (FD7E), PUSHAO (FD7F), CVTFH (FD98),
;3200	;		   CVTHF (FDF6), CVTHD (FDF7).
;3201	;		   These instructions are dispatched to the reserved instruction
;3202	;		   fault handler.
;3203	;
;3204	;		4. All other instructions, for which setting PSL<FPD> results
;3205	;		   in UNPREDICTABLE operations as defined in the SRM.  These
;3206	;		   instructions may be dispatched to either the emulate FPD
;3207	;		   handler or to the reserved instruction fault handler.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  107
;    INTEXC.MIC 	     FPD -- PSL<fpd> Set								      /REV=
;															     INTEXC
;3208
;3209	;	Note that both single-byte and FD opcodes map together when opcode
;3210	;	tests are done in the code flow below because the opcode value returned
;3211	;	by the hardware for FD opcodes is the second opcode byte, not the value FD.
;3212	;	The opcodes are first separated into 4 categories based on bits <7:6>
;3213	;	of the opcode, as follows:
;3214	;
;3215	;	      Opcode Range			Action Taken
;3216	;	      ------------	------------------------------------------------
;3217	;		00 .. 3F	8 class 1 (string), 19 class 2 (emulated), 1
;3218	;				class 3 (unimplemented) instructions in this
;3219	;				category.  Classes are separated and dispatched
;3220	;				to the appropriate handler.
;3221	;
;3222	;		40 .. 7F	37 class 3 (unimplemented) instructions in
;3223	;				this category.	All instructions are dispatched
;3224	;				to reserved instruction fault handler.
;3225	;
;3226	;		80 .. BF	1 class 3 (unimplemented) instructions in this
;3227	;				category.  All instructions are dispatched to
;3228	;				reserved instruction fault handler.
;3229	;
;3230	;		C0 .. FF	2 class 2 (emulated), 2 class 3 (unimplemented)
;3231	;				instructions in this category.	Classes are
;3232	;				separated and dispatched to the appropriate
;3233	;				handler.
;3234
				;3235	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  108
;    INTEXC.MIC 	     FPD -- PSL<fpd> Set								      /REV=
;															     INTEXC
				;3236
				;3237	;	FPD processor.
				;3238
				;3239	;	Note: RESET CPU is not performed here so that the string
				;3240	;	unpack routine can restore the state of the CPU to that
				;3241	;	provided by the initial string instruction dispatch.  A
				;3242	;	RESET CPU is done in the emulated instruction restart routine
				;3243	;	and in the reserved instruction fault routine.
				;3244	;
				;3245	;	Because this is a microsequencer dispatch, all working
				;3246	;	registers are available without a RESET CPU.
				;3247	;
				;3248	;	Note: state<3:0> are cleared by the hardware on this entry point.
				;3249	;
				;3250
				;3251	IE.FPD..:
				;3252		;********** Hardware dispatch **********;
E 02C  0001,D07A,0800,0189 J 189;3253		[W1] <-- ZEXT [RN.MODE.OPCODE] RSH [16.] ; [1] position opcode to <7:0>
				;3254
				;3255		;---------------------------------------;
E 189  0400,27D0,0C20,0414 J 414;3256		[W2] <-- [W1] AND 000000[0FA], LONG	; [2] mask opcode to bits<7:3,1>,
				;3257							; test opcode on Abus
				;3258
				;3259		;---------------------------------------;
			    p109;3260		[WBUS] <-- [W2] XOR 000000[28], LONG,	; [3] test for MOVCx,CMPCx
E 414  A600,2140,2030,4583 B 483;3261		CASE [A.7-5] AT [IE.FPD.00..3F] 	; break out into opcode ranges
				;3262
				;3263	;= ALIGNLIST	001x	(IE.FPD.00..3F, 	IE.FPD.40..7F,
				;3264	;=			 IE.FPD.80..BF, 	IE.FPD.C0..FF)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  109
;    INTEXC.MIC 	     FPD -- PSL<fpd> Set								      /REV=
;															     INTEXC
				;3265
				;3266	;	FPD breakout, continued.
				;3267	;	Opcode is known to be in the range 00..3F or FD00..FD3F, inclusive.
				;3268	;	Within this range, the clsss breakdown is as follows:
				;3269	;
				;3270	;		Class 1:	MOVC3 (28), MOVC5 (2C), CMPC3 (29), CMPC5 (2D),
				;3271	;				LOCC (3A), SKPC (3B), SCANC (2A), SPANC (2B)
				;3272	;		Class 2:	CVTPS (08), CVTSP (09), CRC (0B), ADDP4 (20),
				;3273	;				ADDP6 (21), SUBP4 (22), SUBP6 (23), CVTPT (24), MULP (25),
				;3274	;				CVTTP (26), DIVP (27), MOVTC (2E), MOVTUC (2F), MOVP (34),
				;3275	;				CMPP3 (35), CVTPL (36), CMPP4 (37), EDITPC (38), MATCHC (39),
				;3276	;		Class 3:	CVTDH (FD32)
				;3277	;
				;3278	;	Class 1 instructions are first separated and dispatched, followed by
				;3279	;	the single class 3 instruction.  All others are then dispatched to the
				;3280	;	emulated instruction handler.
				;3281	;
				;3282	;	At this point,
				;3283	;		W1<7:0> =	unmasked opcode (bits <15:8> not zero)
				;3284	;		W2	=	opcode AND FA#16
				;3285	;		WBUS.Z	=	1 if opcode is MOVCx, CMPCx (from cycle 3)
				;3286
				;3287	IE.FPD.00..3F:
				;3288		;---------------------------------------; a<7:6> = 00:
E 483  0400,2770,0C20,0163 J 163;3289		[W2] <-- [W1] AND 000000[0EE], LONG	; [4] mask opcode to bits<7:5,3:1>
				;3290
				;3291		;---------------------------------------;
				;3292		[WBUS] <-- [W2] XOR 000000[2A], LONG,	; [5] test for SCANC/SPANC/LOCC/SKPC
E 163  2600,2150,2030,4161 B 161;3293		CASE [ALU.NZV] AT [FPD.TEST]		; case on MOVCx/CMPCx opcode
				;3294
				;3295	;= ALIGNLIST x0xx	(FPD.TEST,		MOVC.CMPC.FPD)
				;3296	;  ALU.NZVC set by XOR, bit<31> clear in both operands	--> N = V = C = 0
				;3297
				;3298	FPD.TEST:
				;3299		;---------------------------------------; alu.z = 0:
E 161  0001,D882,1800,0043 J 043;3300		[W5] <-- ZEXT [R0] RSH [24.], LONG	; [6] isolate delta PC for unpack
				;3301
				;3302		;---------------------------------------;
			    p110;3303		[W2] <-- [W1] AND 000000[0FF], LONG,	; [7] mask opcode to bits <7:0>
E 043  2400,27F8,0C20,41E1 B 0E1;3304		CASE [ALU.NZV] AT [FPD.EMULATE.TEST]	; case on SCANC/SPANC/LOCC/SKPC
				;3305
				;3306	;= ALIGNLIST x0xx	(FPD.EMULATE.TEST,	SCANC.LOCC.FPD)
				;3307	;  ALU.NZVC set by XOR, bit<31> clear in both operands	--> N = V = C = 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  110
;    INTEXC.MIC 	     FPD -- PSL<fpd> Set								      /REV=
;															     INTEXC
				;3308
				;3309	;	FPD breakout continued.
				;3310	;	Opcode is known to be in the range 00..3F or FD00..FD3F, inclusive,
				;3311	;	and not one of the string instructions.
				;3312	;	Separate out CVTDH and dispatch the rest to the emulated instruction
				;3313	;	handler.
				;3314	;
				;3315	;	At this point,
				;3316	;		W2	=	opcode AND FF#16
				;3317
				;3318	FPD.EMULATE.TEST:
				;3319		;---------------------------------------;
			    p276;3320		[WBUS] <-- [W2] XOR 000000[32], LONG,	; [8] test for CVTDH
E 0E1  0600,2190,2030,2497 S 497;3321		CALL [WAIT.ONE.CYCLE]			; [9] wait for condition codes
				;3322
				;3323		;---------------------------------------;
				;3324		[W2] <-- [PSL] ANDNOT 000000[0FF],	; [10] copy PSL, clear <7:0>
				;3325		LONG,					;
			    p631;3326		Q <-- PASSA [PSL],			; save current PSL
E 0E2  2482,67F8,0CC0,41F0 B 0F0;3327		CASE [ALU.NZV] AT [EMULATE.FPD] 	; case on CVTDH
				;3328
				;3329	;= ALIGNLIST x0xx	(EMULATE.FPD,		FPD.CVTDH)
				;3330	;  ALU.NZVC set by XOR, bit<31> clear in both operands	--> N = V = C = 0
				;3331
				;3332	FPD.CVTDH:
			    p126;3333		;---------------------------------------; alu.z = 1:
E 0F4  0000,0000,2000,0100 J 100;3334		RESERVED INSTRUCTION FAULT		; [12] reserved opcode, fault
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  111
;    INTEXC.MIC 	     FPD -- PSL<fpd> Set								      /REV=
;															     INTEXC
				;3335
				;3336	;	FPD breakout, continued.
				;3337	;	Opcode is known to be in the range C0..FF or FDC0..FDFF, inclusive.
				;3338	;	Within this range, the clsss breakdown is as follows:
				;3339	;
				;3340	;		Class 1:	None
				;3341	;		Class 2:	ASHP (F8), CVTLP (F9)
				;3342	;		Class 3:	CVTHF (FDF6), CVTHD (FDF7)
				;3343	;
				;3344	;	Class 2 instructions are first separated and dispatched.  All others
				;3345	;	are then dispatched to the reserved instruction fault handler.
				;3346	;
				;3347	;	At this point,
				;3348	;		W2	=	opcode AND FA#16
				;3349
				;3350	IE.FPD.C0..FF:
				;3351		;---------------------------------------; a<7:6> = 11:
			    p276;3352		[WBUS] <-- [W2] XOR 000000[0F8], LONG,	; [4] test for ASHP/CVTLP/FC/FD
E 48F  0600,27C0,2030,2497 S 497;3353		CALL [WAIT.ONE.CYCLE]			; [5] wait for condition codes
				;3354
				;3355		;---------------------------------------;
E 480  2000,0000,2000,4120 B 420;3356		CASE [ALU.NZV] AT [FPD.TEST.1]		; [6] case on ASHP/CVTLP/FC/FD
				;3357
				;3358	;= ALIGNLIST x0xx	(FPD.TEST.1,		ASHP.CVTLP.FPD)
				;3359	;  ALU.NZVC set by XOR, bit<31> clear in both operands	--> N = V = C = 0
				;3360
				;3361	FPD.TEST.1:
			    p126;3362		;---------------------------------------; alu.z = 0:
E 420  0000,0000,2000,0100 J 100;3363		RESERVED INSTRUCTION FAULT		; [7] opcodes reserved, fault
				;3364
				;3365	ASHP.CVTLP.FPD:
				;3366		;---------------------------------------; alu.z = 1:
				;3367		[W2] <-- [PSL] ANDNOT 000000[0FF],	; [7] copy PSL, clear <7:0>
				;3368		LONG,					;
			    p631;3369		Q <-- PASSA [PSL],			; save current PSL
E 424  0482,67F8,0CC0,00F0 J 0F0;3370		GOTO [EMULATE.FPD]			; join FPD flow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  112
;    INTEXC.MIC 	     FPD -- PSL<fpd> Set								      /REV=
;															     INTEXC
				;3371
				;3372	;	FPD breakout, continued.
				;3373	;	Opcode is known to be in the range 40..BF or FD40..FDBF, inclusive.
				;3374	;	Within this range, the clsss breakdown is as follows:
				;3375	;
				;3376	;		Class 1:	None
				;3377	;		Class 2:	None
				;3378	;		Class 3:	ACBF (4F), EMODF (54), POLYF (55), ACBD (6F), EMODD (74),
				;3379	;				POLYD (75), ACBG (FD4F), EMODG (FD54), POLYG (FD55),
				;3380	;				CVTGH (FD56), ADDH2 (FD60), ADDH3 (FD61), SUBH2 (FD62),
				;3381	;				SUBH3 (FD63), MULH2 (FD64), MULH3 (FD65), DIVH2 (FD66),
				;3382	;				DIVH3 (FD67), CVTHB (FD68), CVTHW (FD69), CVTHL (FD6A),
				;3383	;				CVTRHL (FD6B), CVTBH (FD6C), CVTWH (FD6D), CVTLH (FD6E),
				;3384	;				ACBH (FD6F), MOVH (FD70), CMPH (FD71), MNEGH (FD72),
				;3385	;				TSTH (FD73), EMODH (FD74), POLYH (FD75), CVTHG (FD76),
				;3386	;				CLRO (FD7C), MOVO (FD7D), MOVAO (FD7E), PUSHAO (FD7F),
				;3387	;				CVTFH (FD98)
				;3388	;
				;3389	;	All instructions are dispatched to the reserved instruction fault handler.
				;3390
				;3391	IE.FPD.40..7F:
			    p126;3392		;---------------------------------------; a<7:6> = 01:
E 487  0000,0000,2000,0100 J 100;3393		RESERVED INSTRUCTION FAULT		; [4] all opcodes reserved, fault
				;3394
				;3395	IE.FPD.80..BF:
			    p126;3396		;---------------------------------------; a<7:6> = 10:
E 48B  0000,0000,2000,0100 J 100;3397		RESERVED INSTRUCTION FAULT		; [4] all opcodes reserved, fault
				;3398
;3399	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  113
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
;3400	.TOC	"	Double Parameter Exceptions -- Memory Management Fault"
;3401
;3402	;	Memory management exceptions push two parameters on the stack:
;3403	;	the virtual address of the faulting access, and a fault type code.
;3404	;
;3405	;	An ACV exception results from an attempt to access a page with
;3406	;	insufficient privilege.
;3407	;
;3408	;	A TNV exception results from an attempt to access a page which
;3409	;	has PTE.V = 0.
;3410	;
;3411	;	A modify fault results from an attempt to write a page which
;3412	;	has PTE.M = 0.
;3413	;
;3414	;	Modify faults are intercepted and handled entirely by the microcode.
;3415	;	ACV and TNV exceptions are faults and cause the current instruction
;3416	;	to be packed up (interruptible instructions) or the instruction stream
;3417	;	to be backed up (all others).  This flow is entered from a memory
;3418	;	management microtrap, or by direct dispatch from PROBEx or CHMx.
;3419	;
;3420	;	Entry conditions (microtrap):
;3421	;		IPR.MMEADR =	fault address
;3422	;		IPR.MMESTS<2> = 0: read reference
;3423	;				1: write reference
;3424	;
;3425	;	Entry conditions (microcode dispatch):
;3426	;		VA = W4 =	fault address
;3427	;		SAVEPC	=	backed up PC
;3428	;		MMGT.MODE =	mode of faulting reference
;3429	;
;3430	;	Preserved resources used:
;3431	;		W4	=	fault address from IPR.MMEADR
;3432	;		W5	=	fault status from IPR.MMESTS
;3433	;
;3434	;	Exit conditions:
;3435	;		Current instruciton has been packed up, or instruction stream backed up.
;3436	;		For modify faults, PTE<M> has been set and the instruction stream restarted.
;3437	;		For ACV or TNV, exception taken through the appropriate vector in the
;3438	;		SCB.  For ACV/TNV, the stack frame is:
;3439	;
;3440	;		+---------------------------------------------------------+-+-+-+-+
;3441	;		|				0			  |A|M|P|L|  fault flags
;3442	;		+---------------------------------------------------------+-+-+-+-+
;3443	;		|				VA				  |  VA of reference which faulted
;3444	;		+-----------------------------------------------------------------+
;3445	;		|				PC				  |
;3446	;		+-----------------------------------------------------------------+
;3447	;		|				PSL				  |
;3448	;		+-----------------------------------------------------------------+
;3449	;
				;3450	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  114
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
				;3451
				;3452	;	Memory management exception.
				;3453
				;3454	;	Note: IE.CLEANUP.CPU is not called directly from the entry point
				;3455	;	because the MMESTS and MMEADR IPRs must be read before the special
				;3456	;	packup routines are called.  This avoids destroying the IPR state
				;3457	;	in the packup routines.
				;3458
				;3459	IE.MEMMGT..:
				;3460		;*********** Microtrap entry ***********;
				;3461		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;3462		RESET CPU,				; abort current operations
				;3463		CALL [WAIT.TWO.CYCLES], 		; wait for RESET CPU to take effect
			    p163;3464							; >> Fbox sync via DST <> NONE
E 018  0002,BA00,2006,22B7 S 2B7;3465			sim exception
				;3466
				;3467		;---------------------------------------;
				;3468		VA <-- K10.[IPR.MMESTS],		; read fault status code
				;3469		[W5] <-- MEM.PR (VA), LONG,		; into W5
E 019  00D4,3D41,1801,0144 J 144;3470			sim addr [k]
				;3471
				;3472		;---------------------------------------;
				;3473		VA <-- K10.[IPR.MMEADR],		; read fault address
			    p159;3474		[W4] <-- MEM.PR (VA), LONG,		; into W4
E 144  00D4,3D01,1401,22D7 S 2D7;3475		CALL [IE.CLEANUP.CPU]			; cleanup CPU state, state<3:0> unchanged
				;3476							; PSL<TP> = 0, SAVEPC = BPC
				;3477
				;3478	;	Note: Do not change the bit position or polarity of the
				;3479	;	MMESTS read/write bit without changing the state bit
				;3480	;	usage at CHMX.PROBEX.MM.FAULT.	They must be the same.
				;3481	;
				;3482	;	Note: The following TBIS can not cause an infinite loop
				;3483	;	in the Mbox because the preceding RESET CPU and read of
				;3484	;	backup PC guarantee that there are no TB miss sequences
				;3485	;	in progress when the command enters the EM latch.
				;3486
				;3487		;---------------------------------------;
				;3488		VA&, [WBUS] <-- [W4], LONG,		; invalidate the TB location
				;3489		TB INVALIDATE SINGLE,			; for the faulting address so that
				;3490							; the probe below misses
				;3491							; >> TB INVALIDATE, implicit sync performed
				;3492		ACCESS B [W5],				; test mmests<2> (read/write bit)
E 145  6010,0031,2050,4BD2 B 1D2;3493		CASE [STATE.5-3] AT [IE.MEMMGT.NEW]	; see if we've been here before
				;3494
				;3495	;= ALIGNLIST 001x	(IE.MEMMGT.NEW, 	IE.MEMMGT.SNV,
				;3496	;=			 IE.MEMMGT.MACH.CHK,	IE.MEMMGT.DOUBLE.ERROR)
				;3497
				;3498	;	STATE<5:4> = 00, new exception.
				;3499	;	Re-probe address to determine if the memory management state
				;3500	;	has changed.
				;3501
				;3502	IE.MEMMGT.NEW:
				;3503		;---------------------------------------; state<5:4> = 00:
			    p115;3504		[MMGT.MODE] <-- ZEXT [RN.MODE.OPCODE] RSH [22.], ; load curmod into mode reg
E 1D2  6001,D67A,D800,43D7 B 1D7;3505		CASE [B.2-0] AT [IE.MEMMGT.R]		; case on modify bit from status
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  115
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
				;3506
				;3507	;	Memory management fault, continued.
				;3508	;	Entered from above, or as an alternate entry from CHMX.PROBEX.MM.FAULT.
				;3509	;	A RESET CPU must have been done, and the fault address must have been
				;3510	;	invalidated from the TB.  STATE<2> may be set if entered from
				;3511	;	CHMX.PROBEX.MM.FAULT.
				;3512	;
				;3513	;	Due to macropipeline considerations, the state of a faulting page
				;3514	;	may have changed since the original fault was detected.  Therefore,
				;3515	;	the address must be re-probed, and the probe status must be used
				;3516	;	to determine if a fault really exists (the fault may have changed,
				;3517	;	or disappeared).  If the re-probe indicates that a fault still
				;3518	;	exists, the MMESTS value is re-read to build the stack frame.
				;3519	;
				;3520	;	Note: A RESET CPU clears the lock on MMESTS and MMEADR and the
				;3521	;	re-probe loads these registers without locking them again.  MMESTS
				;3522	;	is reread after the probe if the probe status indicates an
				;3523	;	exception condition.
				;3524	;
				;3525	;	At this point,
				;3526	;		VA = W4 =	faulting address
				;3527	;		SAVEPC	=	backed up PC
				;3528	;		MMGT.MODE =	mode of faulting reference
				;3529
				;3530	;= ALIGNLIST 011x	(IE.MEMMGT.R,	IE.MEMMGT.W)
				;3531
				;3532	IE.MEMMGT.R:
				;3533		;---------------------------------------; b<2> = 0 or state<2> = 0:
				;3534		[W2] <-- PROBE.R.MODE (VA),		; re-probe address for read access
E 1D7  005C,0000,0C00,0196 J 196;3535		GOTO [IE.MEMMGT.TEST.PROBE]		; join common flow
				;3536
				;3537	IE.MEMMGT.W:
				;3538		;---------------------------------------; b<2> = 1 or state<2> = 1::
				;3539		[W2] <-- PROBE.W.MODE (VA),		; re-probe address for write access
E 1DF  007C,0000,0C00,0196 J 196;3540		GOTO [IE.MEMMGT.TEST.PROBE]		; re-join common flow
				;3541
				;3542	IE.MEMMGT.TEST.PROBE:
				;3543		;---------------------------------------;
E 196  0000,0018,2000,0231 J 231;3544		ACCESS B [W2]				; test the probe status returned
				;3545
				;3546	;	Note: The following TBIS can not cause an infinite loop
				;3547	;	in the Mbox because the probe status is accessed before the
				;3548	;	command is issued, thereby guaranteeing that no TB miss
				;3549	;	sequence is in progress.
				;3550
				;3551		;---------------------------------------;
				;3552		[WBUS] <-- [W4], LONG,			; test sign bit of faulting address for
				;3553		TB INVALIDATE SINGLE,			; M=0 flow and remove entry from TB
			    p116;3554							; >> TB INVALIDATE, implicit sync performed
E 231  6010,0000,2050,43F1 B 2F1;3555		CASE [B.2-0] AT [IE.MEMMGT.PROBE.OK]	; case on probe status
				;3556
				;3557	;= ALIGNLIST 000x	(IE.MEMMGT.PROBE.OK,	IE.MEMMGT.PROBE.M0,
				;3558	;=			 IE.MEMMGT.PROBE.TNV,	IE.MEMMGT.PROBE.PPTE.TNV,
				;3559	;=			 IE.MEMMGT.PROBE.ACV,	IE.MEMMGT.PROBE.101,
				;3560	;=			 IE.MEMMGT.PROBE.110,	IE.MEMMGT.PROBE.111)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  116
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
				;3561
				;3562	;	Memory management fault, continued.
				;3563	;	No fault case.
				;3564	;
				;3565	;	This can happen due to the delay between the time that the
				;3566	;	fault is detected in the Mbox and the time that it is reported
				;3567	;	to the Ebox.  In this instance, the instruction stream is simply
				;3568	;	restarted.
				;3569	;
				;3570	;	At this point,
				;3571	;		SAVEPC	=	backup PC
				;3572
				;3573	IE.MEMMGT.PROBE.OK:
				;3574		;---------------------------------------; b<2:0>=000: no fault
				;3575		[WBUS] <-- [SAVEPC], LONG,		; get backup PC back
				;3576		LOAD PC,				; reload and start instruction
			    p144;3577							; >> LOAD PC: sync required before exit
E 2F1  0024,0000,2280,0271 J 271;3578		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; sync with LOAD PC, restart Ibox
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  117
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
				;3579
				;3580	;	Memory management fault, continued.
				;3581	;	M=0 fault case.
				;3582	;
				;3583	;	To avoid the overhead involved in dispatching modify faults to the
				;3584	;	operating system, microcode handles these events as internal micro-
				;3585	;	modify faults by reading the PTE, setting the M-bit, and writing
				;3586	;	it back to memory.
				;3587	;
				;3588	;	At this point,
				;3589	;		VA = W4 =	faulting address
				;3590	;		MMEPTE	=	virtual or physical PTE address
				;3591	;		SAVEPC	=	backed up PC
				;3592	;		W4<31> tested on Abus during the previous cycle.
				;3593
				;3594	IE.MEMMGT.PROBE.M0:
				;3595		;---------------------------------------; b<2:0>=001: M=0
				;3596		VA <-- K10.[IPR.MMEPTE], LONG,		; read PTE address from Mbox
				;3597		[W2] <-- MEM.PR (VA),			; into W2
E 2F3  E0D4,3D21,0C01,4747 B 247;3598		CASE [A31.BQA.BNZ1] AT [IE.MEMMGT.M0.PX] ; case on VA<31> to separate P0,P1/S0
				;3599
				;3600	;= ALIGNLIST 011x	(IE.MEMMGT.M0.PX,	IE.MEMMGT.M0.S0)
				;3601
				;3602	;	P0 or P1 address: PTE is in system virtual memory.  The read and write
				;3603	;	can only fault due to a TNV or a length violation.  The Mbox must
				;3604	;	have read the same location to generate the M=0 status for the
				;3605	;	PROBE, so the read can fail only if the PTE mapping the PPTE went
				;3606	;	from valid to invalid between the PROBE TB fill and now.  This is
				;3607	;	a software bug in violation of section 4.7, pages 4-28 and 4-29
				;3608	;	of the SRM.  Even if there is a software bug, state<4> is not set at this
				;3609	;	point, so a microtrap will come back in the top, which will dispatch a fault
				;3610	;	thru the SCB vector.  An REI should correctly restart the instruction.
				;3611
				;3612	IE.MEMMGT.M0.PX:
				;3613		;---------------------------------------; a<31>=0: P0, P1 address
				;3614		VA <-- [W2], LONG,			; read PTE from system virtual memory
E 247  0048,0001,0830,019C J 19C;3615		[W1] <-- MEM.NOCHK (VA) 		; with no access check
				;3616
				;3617		;---------------------------------------;
				;3618		MEM.NOCHK (VA)&,			; re-write PTE with M bit set
			    p116;3619		[WBUS] <-- [W1] OR [PTE.M]000000, LONG, ; and exit thru no-fault flow
E 19C  0568,3820,2020,02F1 J 2F1;3620		GOTO [IE.MEMMGT.PROBE.OK]		; restart instruction stream
				;3621
				;3622	;	S0 address: PTE is in physical memory
				;3623
				;3624	IE.MEMMGT.M0.S0:
				;3625		;---------------------------------------; a<31>=1: S0 address
				;3626		VA <-- [W2], LONG,			; read PTE from physical memory
E 24F  0050,0001,0830,01A4 J 1A4;3627		[W1] <-- MEM.PHYS (VA)			;
				;3628
				;3629		;---------------------------------------;
				;3630		MEM.PHYS (VA)&, 			; re-write PTE with M bit set
			    p116;3631		[WBUS] <-- [W1] OR [PTE.M]000000, LONG, ; and exit thru no-fault flow
E 1A4  0570,3820,2020,02F1 J 2F1;3632		GOTO [IE.MEMMGT.PROBE.OK]		; restart instruction stream
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  118
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
				;3633
				;3634	;	Memory management fault, continued.
				;3635	;	TNV and ACV fault cases.
				;3636	;
				;3637	;	At this point,
				;3638	;		VA = W4 =	faulting address
				;3639	;		MMESTS	=	fault status
				;3640	;		SAVEPC	=	backed up PC
				;3641
				;3642	IE.MEMMGT.PROBE.TNV:
				;3643		;---------------------------------------; b<2:0>=010: TNV
				;3644		[W2] <-- [SCBB] + 000000[SCB.TNV],	; get SCB offset for TNV fault
E 2F5  0880,2120,0E60,01BF J 1BF;3645		GOTO [IE.MEMMGT.ACV.TNV]		; join common flows
				;3646
				;3647	IE.MEMMGT.PROBE.PPTE.TNV:
				;3648		;---------------------------------------; b<2:0>=011: PPTE TNV
				;3649		[W2] <-- [SCBB] + 000000[SCB.TNV],	; get SCB offset for TNV fault
E 2F7  0880,2120,0E60,01BF J 1BF;3650		GOTO [IE.MEMMGT.ACV.TNV]		; join common flows
				;3651
				;3652	IE.MEMMGT.PROBE.ACV:
				;3653		;---------------------------------------; b<2:0>=100: ACV
				;3654		[W2] <-- [SCBB] + 000000[SCB.ACV],	; get SCB offset for ACV fault
E 2F9  0880,2100,0E60,01BF J 1BF;3655		GOTO [IE.MEMMGT.ACV.TNV]		; join common flows
				;3656
				;3657	IE.MEMMGT.ACV.TNV:
				;3658		;---------------------------------------;
				;3659		VA <-- K10.[IPR.MMESTS],		; read fault status code
				;3660		[W5] <-- MEM.PR (VA), LONG,		; into E-box
E 1BF  00D4,3D41,1801,01C9 J 1C9;3661			sim addr [k]
				;3662
				;3663		;---------------------------------------;
				;3664		VA <-- [W2],				; get SCB vector address
				;3665		[W1] <-- MEM.SCB (VA), LONG,		; and read vector
E 1C9  0050,0001,0830,01CE J 1CE;3666			sim addr [scb]
				;3667
				;3668		;---------------------------------------;
E 1CE  0400,2038,1860,0274 J 274;3669		[W5] <-- [W5] AND 000000[07], LONG	; mask parameter to 3 bits
				;3670
				;3671		;---------------------------------------;
				;3672		[W2] <-- [PSL], LONG,			; save current PSL
				;3673		STATE.4 <-- 1,				; flag start of exception
				;3674		STATE.3-0 <-- 0,			; clear other state flags
			    p153;3675							; >> no state<3> restriction after RESET CPU
E 274  1001,C000,0CC8,2311 S 311;3676		CALL [IE.EXCEPTION]			; call exception handling routine
				;3677
				;3678		;---------------------------------------;
				;3679		VA <-- [VA] - 4,			; decrement stack for a push
			    p124;3680		MEM (VA)&, [WBUS] <-- PASSB [W4], LONG, ; push address in page on stack
E 275  0CE4,802B,20B0,027D J 27D;3681		GOTO [IE.PUSH.W5.EXIT]			; go push W5 on stack and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  119
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
				;3682
				;3683	;	Memory management fault, continued.
				;3684	;	Illegal probe status cases.
				;3685
				;3686	IE.MEMMGT.PROBE.101:
			    p135;3687		;---------------------------------------; b<2:0>=101:
E 2FB  0080,3008,A400,0038 J 038;3688		MACHINE CHECK [MCHK.UNKNOWN.MSTATUS]	; initiate machine check
				;3689
				;3690	IE.MEMMGT.PROBE.110:
			    p135;3691		;---------------------------------------; b<2:0>=110:
E 2FD  0080,3008,A400,0038 J 038;3692		MACHINE CHECK [MCHK.UNKNOWN.MSTATUS]	; initiate machine check
				;3693
				;3694	IE.MEMMGT.PROBE.111:
			    p135;3695		;---------------------------------------; b<2:0>=111:
E 2FF  0080,3008,A400,0038 J 038;3696		MACHINE CHECK [MCHK.UNKNOWN.MSTATUS]	; initiate machine check
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  120
;    INTEXC.MIC 	     Double Parameter Exceptions -- Memory Management Fault				      /REV=
;															     INTEXC
				;3697
				;3698	;	Memory management fault continued.
				;3699	;	Nested memory management fault within exception flows (STATE<5:4> neq 00).
				;3700
				;3701	;	STATE<5:4> = 01, memory management fault while writing to kernel or interrupt stack.
				;3702	;		Initiate kernel stack not valid exception (kernel stack)
				;3703	;		or interrupt stack not valid console restart (interrupt stack).
				;3704
				;3705	;	The PSL<is> bit is updated in IE.INTERRUPT/IE.EXCEPTION before any virtual
				;3706	;	stack writes are attempted and is therefore valid at this point.
				;3707
				;3708	IE.MEMMGT.SNV:
				;3709		;---------------------------------------; state<5:4> = 01:
				;3710		STATE.5 <-- 1,				; set state<5>
				;3711		STATE.3-0 <-- 0,			; clear state<3:0>
			    p130;3712							; >> no state<3> restriction after RESET CPU
E 1D6  B002,0000,2008,4DB6 B 1B6;3713		CASE [PSL.26-24] AT [IE.KSNV]		; case on PSL<is>
				;3714
				;3715	;= ALIGNLIST 011x	(IE.KSNV,	IE.ISNV)
				;3716
				;3717	IE.ISNV:
			    p.84;3718		;---------------------------------------; psl<is> = 1:
E 1BE  0500,2820,A4C0,0035 J 035;3719		CONSOLE HALT NO CLEANUP [ERR.INTSTK]	; interrupt stack not valid, invoke console
				;3720							; >> string packup possible, no cleanup
				;3721							; >> may be done
				;3722
				;3723	;	STATE<5:4> = 10, memory management fault while inside the machine check flows.
				;3724	;		This is not recoverable, force a console restart.
				;3725
				;3726	IE.MEMMGT.MACH.CHK:
			    p.84;3727		;---------------------------------------; state<5:4> = 10:
E 1DA  0500,2880,A4C0,0034 J 034;3728		CONSOLE HALT [ERR.IE0]			; ACV/TNV in machine check, invoke console
				;3729
				;3730	;	STATE<5:4> = 11, memory management fault while inside the kernel stack not valid flows.
				;3731	;		This is not recoverable, force a console restart.
				;3732
				;3733	IE.MEMMGT.DOUBLE.ERROR:
			    p.84;3734		;---------------------------------------; state<5:4> = 11:
E 1DE  0500,2888,A4C0,0034 J 034;3735		CONSOLE HALT [ERR.IE1]			; ACV/TNV in ker stk invalid, invoke console
				;3736
;3737	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  121
;    INTEXC.MIC 	     Single Parameter Exceptions -- Arithmetic Traps and Faults 			      /REV=
;															     INTEXC
;3738	.TOC	"	Single Parameter Exceptions -- Arithmetic Traps and Faults"
;3739
;3740	;	These arithmetic exceptions push one parameter on the stack:
;3741	;	the trap/fault type code.
;3742	;
;3743	;	Arithmetic traps result from arithmetic errors in integer instructions,
;3744	;	and from a subscript range error in INDEX.
;3745	;
;3746	;	Arithmetic faults result from arithmetic errors in floating point
;3747	;	instructions.
;3748	;
;3749	;	Arithmetic traps only occur after instructions; arithmetic faults
;3750	;	occur in mid instruction.  Because of the macro-pipeline, both require
;3751	;	the instruction stream to be backed up;  however, traps preserve
;3752	;	PSL<tp>, while faults clear PSL<tp>.
;3753	;
;3754	;	The arithmetic traps are reached from normal execution flows or
;3755	;	via an integer overflow microtrap.
;3756	;
;3757	;	The arithmetic faults are reached from floating execution flows
;3758	;	via a floating condition microtrap.
;3759	;
;3760	;	Entry conditions (integer overflow trap, floating faults):
;3761	;		none
;3762	;
;3763	;	Entry conditions (subscript, divide by zero traps):
;3764	;		instruction explicitly retired
;3765	;
;3766	;	Preserved resources used:
;3767	;		W5	=	fault or trap code
;3768	;
;3769	;	Exit conditions:
;3770	;		Instruction stream has been backed up.
;3771	;		Exception taken through arithmetic exception vector in SCB.
;3772	;		Stack frame:
;3773	;
;3774	;		+-----------------------------------------------------------------+
;3775	;		|		ARITH.FAULT.xxx or ARITH.TRAP.xxx		  |  fault or trap code
;3776	;		+-----------------------------------------------------------------+
;3777	;		|				PC				  |
;3778	;		+-----------------------------------------------------------------+
;3779	;		|				PSL				  |
;3780	;		+-----------------------------------------------------------------+
;3781	;
				;3782	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  122
;    INTEXC.MIC 	     Single Parameter Exceptions -- Arithmetic Traps and Faults 			      /REV=
;															     INTEXC
				;3783
				;3784	;	Integer overflow trap.
				;3785	;	Entered by microtrap after last microinstruction of current instruction
				;3786	;	completes.  All resources available.
				;3787
				;3788	IE.INT.OVERFLOW..:
				;3789		;*********** Microtrap entry ***********;
				;3790		Q <-- 0,				; no PSL bits to clear
				;3791		RESET CPU,				; abort current operations
				;3792		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;3793							; PSL<TP> unchanged, SAVEPC = BPC
			    p159;3794							; >> Fbox sync via DST <> NONE
E 008  0002,C000,2006,22D5 S 2D5;3795			sim exception
				;3796
				;3797		;---------------------------------------;
			    p124;3798		[W5] <-- 000000[ARITH.TRAP.INTOVF], LONG, ; get proper trap code
E 009  0080,2008,1800,01D3 J 1D3;3799		GOTO [IE.ARITH.COMMON]			; join common code
				;3800
				;3801
				;3802	;	Subscript range trap.
				;3803	;	Entered from INDEX flows, all resources available, INDEX instruction retired.
				;3804
				;3805	IE.SUBSCRIPT.ERROR..:
				;3806		;---------------------------------------;
				;3807		Q <-- 0,				; no PSL bits to clear
				;3808		RESET CPU,				; abort current operations
				;3809		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;3810							; PSL<TP> unchanged, SAVEPC = BPC
			    p159;3811							; >> Fbox sync via DST <> NONE
E 044  0002,C000,2006,22D5 S 2D5;3812			sim exception
				;3813
				;3814		;---------------------------------------;
			    p124;3815		[W5] <-- 000000[ARITH.TRAP.SUBRNG], LONG,; get trap code
E 045  0080,2038,1800,01D3 J 1D3;3816		GOTO [IE.ARITH.COMMON]			; join common code
				;3817
				;3818
				;3819	;	Divide by zero trap.
				;3820	;	Entered from DIVIn, EDIV flows, all resources available, divide instruction retired.
				;3821
				;3822	IE.DIVIDE.ERROR..:
				;3823		;---------------------------------------;
				;3824		Q <-- 0,				; no PSL bits to clear
				;3825		RESET CPU,				; abort current operations
				;3826		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;3827							; PSL<TP> unchanged, SAVEPC = BPC
			    p159;3828							; >> Fbox sync via DST <> NONE
E 048  0002,C000,2006,22D5 S 2D5;3829			sim exception
				;3830
				;3831		;---------------------------------------;
			    p124;3832		[W5] <-- 000000[ARITH.TRAP.INTDIV], LONG,; get trap code
E 049  0080,2010,1800,01D3 J 1D3;3833		GOTO [IE.ARITH.COMMON]			; join common code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  123
;    INTEXC.MIC 	     Single Parameter Exceptions -- Arithmetic Traps and Faults 			      /REV=
;															     INTEXC
				;3834
				;3835	;	Floating overflow fault.
				;3836	;	Entered by microtrap from faulting Fbox instruction.
				;3837
				;3838	;	At this point:
				;3839	;		FBOX.CONDITION<2:1> =	encoded Fbox fault code
				;3840
				;3841	IE.FLT.FAULT..:
				;3842		;*********** Microtrap entry ***********;
				;3843		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;3844		RESET CPU,				; abort current operations
				;3845		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;3846							; PSL<TP> = 0, SAVEPC = BPC
			    p159;3847							; >> Fbox sync via DST <> NONE
E 020  0002,BA00,2006,22D5 S 2D5;3848			sim exception
				;3849
				;3850		;---------------------------------------;
E 021  2000,0000,2000,5102 B 002;3851		CASE [FBOX.CONDITION] AT [IE.FLT.RSVD.OPERAND] ; case on fault code
				;3852
				;3853	;= ALIGNLIST 001x	(IE.FLT.RSVD.OPERAND,	IE.FLT.DIVIDE.ZERO,
				;3854	;=			 IE.FLT.OVERFLOW,	IE.FLT.UNDERFLOW)
				;3855
				;3856	IE.FLT.RSVD.OPERAND:
				;3857		;---------------------------------------; b<1:0> = 00: reserved operand
				;3858		VA <-- [SCBB] + 000000[SCB.RESOP],	; offset into SCB for reserved operand
				;3859		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p129;3860		GOTO [IE.FAULT.COMMON], 		; join common code
E 002  08D0,20C1,0A60,0286 J 286;3861			sim addr [scb]
				;3862
				;3863	IE.FLT.DIVIDE.ZERO:
				;3864		;---------------------------------------; b<1:0> = 01: divide by zero
			    p124;3865		[W5] <-- 000000[ARITH.FAULT.FLTDIV], LONG, ; get proper fault code
E 006  0080,2048,1800,01D3 J 1D3;3866		GOTO [IE.ARITH.COMMON]			; join common code
				;3867
				;3868	IE.FLT.OVERFLOW:
				;3869		;---------------------------------------; b<1:0> = 10: floating overflow
			    p124;3870		[W5] <-- 000000[ARITH.FAULT.FLTOVF], LONG, ; get proper fault code
E 00A  0080,2040,1800,01D3 J 1D3;3871		GOTO [IE.ARITH.COMMON]			; join common code
				;3872
				;3873	IE.FLT.UNDERFLOW:
				;3874		;---------------------------------------; b<1:0> = 10: floating underflow
			    p124;3875		[W5] <-- 000000[ARITH.FAULT.FLTUND], LONG, ; get proper fault code
E 00E  0080,2050,1800,01D3 J 1D3;3876		GOTO [IE.ARITH.COMMON]			; join common code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  124
;    INTEXC.MIC 	     Single Parameter Exceptions -- Arithmetic Traps and Faults 			      /REV=
;															     INTEXC
				;3877
				;3878	;	Common exit points for arithmetic traps and floating point faults.
				;3879
				;3880	;	At this point,
				;3881	;		W5	=	fault or trap code
				;3882	;		SAVEPC	=	backed up PC
				;3883
				;3884	IE.ARITH.COMMON:
				;3885		;---------------------------------------;
				;3886		VA <-- [SCBB] + 000000[SCB.ARITH],	; get SCB offset for arithmetic exception
				;3887		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
E 1D3  08D0,21A1,0A60,027C J 27C;3888			sim addr [scb]
				;3889
				;3890		;---------------------------------------;
				;3891		[W2] <-- [PSL], LONG,			; save current PSL
				;3892		STATE.4 <-- 1,				; flag start of exception
				;3893		STATE.3-0 <-- 0,			; clear other state flags
			    p153;3894							; >> no state<3> restriction after RESET CPU
E 27C  1001,C000,0CC8,2311 S 311;3895		CALL [IE.EXCEPTION]			; call exception handling routine
				;3896
				;3897	IE.PUSH.W5.EXIT:
				;3898		;---------------------------------------;
				;3899		VA <-- [VA] - 4,			; decrement stack for a push
			    p151;3900		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG, ; push parameter on stack
E 27D  0CE4,8033,20B0,02AB J 2AB;3901		GOTO [IE.LOAD.PC]			; load pc and exit from flows
				;3902
;3903	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  125
;    INTEXC.MIC 	     Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV /REV=
;															     INTEXC
;3904	.TOC	"	Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV"
;3905
;3906	;	These instruction-related exceptions push no parameters on the stack:
;3907	;	the SCB vector provides sufficient information to process the exception.
;3908	;
;3909	;	A reserved instruction fault results from processing an undefined or
;3910	;	privileged instruction.
;3911	;
;3912	;	A reserved addressing mode fault results from processing an undefined or
;3913	;	reserved addressing mode.
;3914	;
;3915	;	A reserved operand fault results from processing an invalid operand in an
;3916	;	instruction.
;3917	;
;3918	;	A suspended vector faults results from issuing a vector instruction to
;3919	;	a suspended vector unit.
;3920	;
;3921	;	A trace trap occurs if TP is set at execution dispatch.
;3922	;
;3923	;	A kernel stack not valid abort results from an ACV or TNV microtrap inside
;3924	;	an exception.
;3925	;
;3926	;	Except for kernel stack not valid, which only occurs inside another exception,
;3927	;	these exceptions causes the the currently executing instruction to be packed up
;3928	;	(interruptible instructions) or the instruction stream to be backed up (all others).
;3929	;
;3930	;	This code is also used by XFC and BPT.
;3931	;
;3932	;	Entry conditions:
;3933	;		none
;3934	;
;3935	;	Preserved resources used:
;3936	;		none
;3937	;
;3938	;	Exit conditions:
;3939	;		Current instruction has been packed up, or instruction stream backed up.
;3940	;		Exception taken through specified vector in SCB.  Stack frame:
;3941	;
;3942	;		+-----------------------------------------------------------------+
;3943	;		|				PC				  |
;3944	;		+-----------------------------------------------------------------+
;3945	;		|				PSL				  |
;3946	;		+-----------------------------------------------------------------+
;3947	;
				;3948	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  126
;    INTEXC.MIC 	     Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV /REV=
;															     INTEXC
				;3949
				;3950	;	Reserved instruction fault.
				;3951	;	Entered by I-box initial dispatch with the I-box suspended or
				;3952	;	from execution flows via the RESERVED INSTRUCTION FAULT macro.
				;3953
				;3954	RSVD.OPCODE..:
				;3955		;********** Hardware dispatch **********;
				;3956		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;3957		RESET CPU,				; abort current operations
				;3958		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;3959							; PSL<TP> = 0, SAVEPC = BPC
			    p159;3960							; >> Fbox sync via DST <> NONE
E 100  0002,BA00,2006,22D5 S 2D5;3961			sim rsvd opcode
				;3962
				;3963		;---------------------------------------;
				;3964		VA <-- [SCBB] + 000000[SCB.RESPRIV],	; offset into SCB for reserved instruction
				;3965		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p129;3966		GOTO [IE.FAULT.COMMON], 		; join common code
E 101  08D0,2081,0A60,0286 J 286;3967			sim addr [scb]
				;3968
				;3969
				;3970	;	Reserved instruction fault.
				;3971	;	Entered by microtrap when a floating point instruction is
				;3972	;	dispatched and the Fbox is disabled.
				;3973
				;3974	IE.RSVD.OPCODE.TRAP..:
				;3975		;********** Hardware dispatch **********;
				;3976		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;3977		RESET CPU,				; abort current operations
				;3978		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;3979							; PSL<TP> = 0, SAVEPC = BPC
			    p159;3980							; >> Fbox sync via DST <> NONE
E 010  0002,BA00,2006,22D5 S 2D5;3981			sim rsvd opcode
				;3982
				;3983		;---------------------------------------;
				;3984		VA <-- [SCBB] + 000000[SCB.RESPRIV],	; offset into SCB for reserved instruction
				;3985		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p129;3986		GOTO [IE.FAULT.COMMON], 		; join common code
E 011  08D0,2081,0A60,0286 J 286;3987			sim addr [scb]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  127
;    INTEXC.MIC 	     Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV /REV=
;															     INTEXC
				;3988
				;3989	;	Reserved addressing mode fault.
				;3990	;	Entered by microtrap.
				;3991
				;3992	IE.RSVD.ADDRESS..:
				;3993		;********** Hardware dispatch **********;
				;3994		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;3995		RESET CPU,				; abort current operations
				;3996		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;3997							; PSL<TP> = 0, SAVEPC = BPC
			    p159;3998							; >> Fbox sync via DST <> NONE
E 01C  0002,BA00,2006,22D5 S 2D5;3999			sim exception
				;4000
				;4001		;---------------------------------------;
				;4002		VA <-- [SCBB] + 000000[SCB.RESADD], LONG, ; offset into SCB for reserved addressing mode
				;4003		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p129;4004		GOTO [IE.FAULT.COMMON], 		; join common code
E 01D  08D0,20E1,0A60,0286 J 286;4005			sim addr [scb]
				;4006
				;4007
				;4008	;	Reserved operand fault.
				;4009	;	Entered from execution flows via the RESERVED OPERAND FAULT
				;4010	;	macro.
				;4011
				;4012	IE.RSVD.OPERAND..:
				;4013		;---------------------------------------;
				;4014		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;4015		RESET CPU,				; abort current operations
				;4016		CALL [IE.CLEANUP.CPU],			; cleanup CPU state, state<3:0> unchanged
				;4017							; PSL<TP> = 0, SAVEPC = BPC
			    p159;4018							; >> Fbox sync via DST <> NONE
E 03C  0002,BA00,2006,22D7 S 2D7;4019			sim exception
				;4020
				;4021		;---------------------------------------;
				;4022		VA <-- [SCBB] + 000000[SCB.RESOP], LONG, ; offset into SCB for reserved operand
			    p129;4023		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
E 03D  08D0,20C1,0A60,0286 J 286;4024		GOTO [IE.FAULT.COMMON]			; join common code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  128
;    INTEXC.MIC 	     Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV /REV=
;															     INTEXC
				;4025
				;4026	;	Trace trap.
				;4027	;	Entered by microsequencer initial dispatch.
				;4028
				;4029	IE.TRACE.TRAP..:
				;4030		;********** Hardware dispatch **********;
				;4031		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;4032		RESET CPU,				; abort current operations
				;4033		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0
				;4034							; PSL<TP> = 0, SAVEPC = BPC
			    p159;4035							; >> Fbox sync via DST <> NONE
E 028  0002,BA00,2006,22D5 S 2D5;4036			sim exception
				;4037
				;4038		;---------------------------------------;
				;4039		VA <-- [SCBB] + 000000[SCB.TP], 	; offset into SCB for trace trap
				;4040		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p129;4041		GOTO [IE.FAULT.COMMON], 		; join common code
E 029  08D0,2141,0A60,0286 J 286;4042			sim addr [scb]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  129
;    INTEXC.MIC 	     Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV /REV=
;															     INTEXC
				;4043
				;4044	;	Common zero parameter fault/trap flows.
				;4045	;
				;4046	;	At this point,
				;4047	;		W1	=	SCB vector (read in progress)
				;4048	;		SAVEPC	=	backed up PC
				;4049
				;4050	IE.FAULT.COMMON:
				;4051		;---------------------------------------;
				;4052		[W2] <-- [PSL], LONG,			; save current PSL
				;4053		STATE.4 <-- 1,				; flag start of exception
				;4054		STATE.3-0 <-- 0,			; clear other state flags
			    p153;4055							; >> no state<3> restriction after RESET CPU
E 286  1001,C000,0CC8,2311 S 311;4056		CALL [IE.EXCEPTION]			; call exception handling routine
				;4057
				;4058		;---------------------------------------;
				;4059		[WBUS] <-- [W1] ANDNOT 000000[3], LONG, ; Wbus <-- vector with bits<1:0> = 00
				;4060		LOAD PC,				; load new PC, restart prefetching
			    p151;4061							; >> LOAD PC: sync required before exit
E 287  04A4,2018,2020,02CD J 2CD;4062		GOTO [IE.UPDATE.SP]			; update sp and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  130
;    INTEXC.MIC 	     Zero Parameter Exceptions -- Reserved Inst, Addr, Operand; Suspended Vector; Trace; KSNV /REV=
;															     INTEXC
				;4063
				;4064	;	Kernel stack not valid abort.
				;4065	;	Entered from ACV/TNV exceptions flows.
				;4066
				;4067	;	At this point,
				;4068	;		W2	=	original PSL
				;4069	;		SAVEPC	=	old PC
				;4070	;		STATE<5:0> =	110000
				;4071
				;4072	;	IE.MEMMGT guarantees reset of the CPU.
				;4073
				;4074	IE.KSNV:
				;4075		;---------------------------------------; psl<is> = 0:
				;4076		VA <-- [SCBB] + 000000[SCB.KSNV],	; offset into SCB for kernel stack not valid
				;4077		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
				;4078		STATE.3-0 <-- 0,			; clear other state flags
				;4079							; >> no state<3> restriction after RESET CPU
			    p153;4080		CALL [IE.EXCEPTION],			; call exception handling routine
E 1B6  08D0,2041,0A68,2311 S 311;4081			sim addr [scb]
				;4082
				;4083		;---------------------------------------;
				;4084		[WBUS] <-- [W1] ANDNOT 000000[3], LONG, ; Wbus <-- vector with bits<1:0> = 00
				;4085		LOAD PC,				; load new PC, restart prefetching
			    p151;4086							; >> LOAD PC: sync required before exit
E 1B7  04A4,2018,2020,02CD J 2CD;4087		GOTO [IE.UPDATE.SP]			; update sp and exit
				;4088
;4089	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  131
;    INTEXC.MIC 	     Hardware Error									      /REV=
;															     INTEXC
;4090	.TOC	"	Hardware Error"
;4091
;4092	;	These conditions represent hardware errors.
;4093	;
;4094	;	Asynchronous hardware errors are those that are detected and reported
;4095	;	asynchronously with respect to the instruction flow in the Ebox.  At
;4096	;	present, there are two such errors:
;4097	;
;4098	;		Ebox S3 stall timeout: The Ebox contains a very long counter
;4099	;		that counts as long as the Ebox is in an S3 stall (or an S4 stall,
;4100	;		which causes an S3 stall).  If the counter reaches its maximum
;4101	;		value, a microtrap is requested.  This can happen if some other
;4102	;		internal error causes the Ebox to get out of sync with one of
;4103	;		the queues, causing an infinite stall.
;4104	;
;4105	;		Mbox TB parity error: If the Mbox detects a parity error on the
;4106	;		TB, a microtrap is requested.
;4107	;
;4108	;	Synchronous hardware errors are those that are reported synchronously
;4109	;	with respect to the instruction flow in the Ebox.  An example of such
;4110	;	an error is a cache or memory error on an instruction operand.	This
;4111	;	event is reported via the error bits in the MD file, and a microtrap
;4112	;	is requested when the microword that references this location advances
;4113	;	to S4.
;4114	;
;4115	;	Entry conditions:
;4116	;		none
;4117	;
;4118	;	Exit conditions:
;4119	;		Machine check
;4120	;
;4121	;	Preserved resources used:
;4122	;		See machine check flow
				;4123	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  132
;    INTEXC.MIC 	     Hardware Error									      /REV=
;															     INTEXC
				;4124
				;4125	;	Asynchronous hardware error.
				;4126	;	Entered by microtrap.
				;4127	;
				;4128	;	S3 stall timeout, which is one of two events which forces this microtrap,
				;4129	;	asserts a special reset signal for 18 cycles to the Mbox and Cbox.  Because
				;4130	;	of this assertion the microcode must not make any Mbox request during this
				;4131	;	interval.  This restriction is enforced by simply waiting out the assertion
				;4132	;	before entering the machine check flow.  Note that the value 23 is used
				;4133	;	because it was the most conventient value provided by the nested routines
				;4134	;	which was above the required value of 18.
				;4135
				;4136	IE.ASYNC.HW.ERROR..:
				;4137		;*********** Microtrap entry ***********;
			    p163;4138		RESET CPU,				; clear out Ibox and Mbox
E 004  0000,0000,2006,22B4 S 2B4;4139		CALL [WAIT.23.CYCLES]			; add required delay
				;4140
			    p135;4141		;---------------------------------------;
E 005  0080,3028,A400,0038 J 038;4142		MACHINE CHECK [MCHK.ASYNC.ERROR]	; initiate machine check
				;4143
				;4144	;	Synchronous harware error.
				;4145	;	Entered by microtrap.
				;4146
				;4147	IE.SYNC.HW.ERROR..:
			    p135;4148		;*********** Microtrap entry ***********;
E 014  0080,3030,A400,0038 J 038;4149		MACHINE CHECK [MCHK.SYNC.ERROR] 	; initiate machine check
				;4150
;4151	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  133
;    INTEXC.MIC 	     Machine Check Exception								      /REV=
;															     INTEXC
;4152	.TOC	"	Machine Check Exception"
;4153
;4154	;	This exception represents a system error.  Depending on the type
;4155	;	of error, the setting of the VAX restart bit, and other conditions,
;4156	;	the current process may be restartable, it may have to be stopped,
;4157	;	or the operating system may have to be stopped.
;4158	;
;4159	;	A machine check results from an internally detected consistency error,
;4160	;	eg, microcode reaches an "impossible" state, or an externally detected
;4161	;	hardware error, e.g., memory parity.
;4162	;
;4163	;	A machine check is technically an ABORT.  The current instruction is unwound,
;4164	;	but there is no guarantee that the instruction can be properly restarted.
;4165	;	As much diagnostic information as possible is pushed on the stack, and the
;4166	;	rest is left to the operating system.
;4167	;
;4168	;	There is one condition in which case the PC pushed on the stack may not be
;4169	;	correct.  This occurs if a PTE read error is detected on an Ebox reference
;4170	;	in the middle of an interruptable instruction.	In this instance, PC may point
;4171	;	at the instruction FOLLOWING the interruptable instruction, and the SAVPC value
;4172	;	pushed on the stack may point at the instruction.  This condition is denoted
;4173	;	by the fact that PSL<FPD> is set, and the error registers indicate that a
;4174	;	PTE read error occurred.
;4175	;
;4176	;	Entry conditions:
;4177	;		SAVEPSL =	fault code
;4178	;		STATE<5> =	1 if inside ksnv or machine check flows
;4179	;		STATE<4> =	1 if inside exception flows
;4180	;
;4181	;	Preserved resources used:
;4182	;		W4	=	saved Q
;4183	;		W5	=	saved VA
;4184	;
;4185	;	Exit conditions:
;4186	;		Exception taken through machine check vector in SCB.
;4187	;		Stack frame:
;4188	;
;4189	;		+-----------------------------------------------------------------+
;4190	;		|			    00000n (HEX)			  |  byte count
;4191	;		+-----------------------------------------------------------------+
;4192	;		|ASTLVL|	 |   MC code	|		 |	CPUID	  |
;4193	;		+-----------------------------------------------------------------+
;4194	;		|			      INT.SYS				  |
;4195	;		+-----------------------------------------------------------------+
;4196	;		|			      SAVEPC				  |
;4197	;		+-----------------------------------------------------------------+
;4198	;		|				VA				  |
;4199	;		+-----------------------------------------------------------------+
;4200	;		|				 Q				  |
;4201	;		+-----------------------------------------------------------------+
;4202	;		|			   RN.MODE.OPCODE			  |
;4203	;		+-----------------------------------------------------------------+
;4204	;		|				PC				  |  backed-up PC
;4205	;		+-----------------------------------------------------------------+
;4206	;		|				PSL				  |  PSL at time of fault
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  134
;    INTEXC.MIC 	     Machine Check Exception								      /REV=
;															     INTEXC
;4207	;		+-----------------------------------------------------------------+
;4208
				;4209	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  135
;    INTEXC.MIC 	     Machine Check Exception								      /REV=
;															     INTEXC
				;4210
				;4211	;	Machine check exception.
				;4212	;	Build stack frame and dispatch through machine check vector.
				;4213	;
				;4214	;	NOTE: SAVEPC is preserved for one particular error case.  See the brief
				;4215	;	description above and the full description in the error handling chapter
				;4216	;	of the design spec.
				;4217
				;4218	IE.MACHINE.CHECK..:
				;4219		;---------------------------------------;
				;4220		RESET CPU,				; abort current operations
				;4221		[ASTLVL] <-- [ASTLVL] ANDNOT 00[0FF]0000, ; Make room for machine check code
				;4222		CALL [WAIT.TWO.CYCLES], 		; wait for RESET to take effect
			    p163;4223							; >> Fbox sync via DST <> NONE
E 038  0480,37F8,9656,22B7 S 2B7;4224			sim exception
				;4225
				;4226		;---------------------------------------;
				;4227		[W4] <-- B [Q], 			; save Q around call
E 039  0082,4050,1690,01F2 J 1F2;4228		Q <-- PASSA [SAVEPSL]			; move MC code to Q
				;4229
				;4230		;---------------------------------------;
E 1F2  0500,0050,9650,01FA J 1FA;4231		[ASTLVL] <-- [ASTLVL] OR [Q]		; Combine ASTLVL and MC code
				;4232
				;4233		;---------------------------------------;
				;4234		[W5] <-- [VA], LONG,			; save VA around call
E 1FA  1001,0000,18B0,0263 J 263;4235		FLUSH BRANCH PREDICTION TABLE		; flush branch prediction table
				;4236
				;4237		;---------------------------------------;
				;4238		[SAVEPSL] <-- [SAVEPC], 		; save SAVEPC around call
			    p159;4239		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
E 263  0002,BA00,A680,22D7 S 2D7;4240		CALL [IE.CLEANUP.CPU]			; cleanup CPU state, state<3:0> unchanged
				;4241							; PSL<TP> = 0, SAVEPC = BPC
				;4242
				;4243	;	Note: The following microinstruction depends on the
				;4244	;	fact that CEFSTS<RDLK> is bit 0, and that there are
				;4245	;	only read-only and write-1-to-clear bits in this
				;4246	;	register.
				;4247
				;4248		;---------------------------------------;
				;4249		VA <-- K10.[IPR.CEFSTS],		; load CEFSTS IPR address
			    p137;4250		MEM.PR (VA)&, [WBUS] <-- PASSA [K1], LONG, ; unconditionally clear RDLK bit
E 264  60F4,7583,2321,4BE2 B 2E2;4251		CASE [STATE.5-3] AT [IE.MACHCHK.NEW]	; see if we've been here before
				;4252
				;4253	;= ALIGNLIST 001x	(IE.MACHCHK.NEW,	IE.MACHCHK.DOUBLE.ERROR,
				;4254	;=			 IE.MACHCHK.MCHK,	IE.MACHCHK.KSNV)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  136
;    INTEXC.MIC 	     Machine Check Exception								      /REV=
;															     INTEXC
				;4255
				;4256	;	Machine check, continued.
				;4257	;	Nested machine check, invoke console.
				;4258	;
				;4259	;	STATE<5:4> = 01, machine check while inside normal exception flows.
				;4260	;		This is not recoverable, force a console restart.
				;4261
				;4262	IE.MACHCHK.DOUBLE.ERROR:
			    p.84;4263		;---------------------------------------; state<5:4> = 01:
E 2E6  0500,2828,A4C0,0034 J 034;4264		CONSOLE HALT [ERR.DOUBLE]		; nested machine check, invoke console
				;4265
				;4266	;	STATE<5:4> = 10, machine check while inside the machine check flows.
				;4267	;		This is not recoverable, force a console restart.
				;4268
				;4269	IE.MACHCHK.MCHK:
			    p.84;4270		;---------------------------------------; state<5:4> = 10:
E 2EA  0500,2890,A4C0,0034 J 034;4271		CONSOLE HALT [ERR.IE2]			; nested machine check, invoke console
				;4272
				;4273	;	STATE<5:4> = 11, machine check while inside the kernel stack not valid flows.
				;4274	;		This is not recoverable, force a console restart.
				;4275
				;4276	IE.MACHCHK.KSNV:
			    p.84;4277		;---------------------------------------; state<5:4> = 11:
E 2EE  0500,2898,A4C0,0034 J 034;4278		CONSOLE HALT [ERR.IE3]			; nested machine check, invoke console
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  137
;    INTEXC.MIC 	     Machine Check Exception								      /REV=
;															     INTEXC
				;4279
				;4280	;	STATE<5:4> = 00, new exception, process.
				;4281	;	Save state, cleanup, process exception.
				;4282
				;4283	;	At this point,
				;4284	;		W4	=	saved Q
				;4285	;		W5	=	saved VA
				;4286	;		SAVEPC	=	backed up PC
				;4287	;		SAVEPSL =	saved SAVEPC
				;4288	;		ASTLVL	=	ASTLVL, machine check code, CPUID
				;4289
				;4290	IE.MACHCHK.NEW:
				;4291		;---------------------------------------; state<5:4> = 00:
				;4292		VA <-- [SCBB] + 000000[SCB.MACHCHK],	; get SCB offset for machine check
				;4293		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
				;4294		STATE.5 <-- 1,				; flag start of machine check
E 2E2  18D2,2021,0A60,0282 J 282;4295			sim addr [scb]
				;4296
				;4297		;---------------------------------------;
				;4298		[W2] <-- [PSL], LONG,			; save current PSL
				;4299		Q <-- PASSB [RN.MODE.OPCODE],		; save VRB before stack write
				;4300		STATE.3-0 <-- 0,			; clear other state flags
			    p153;4301							; >> no state<3> restriction after RESET CPU
E 282  0002,8078,0CC8,2311 S 311;4302		CALL [IE.EXCEPTION]			; call exception handling routine
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  138
;    INTEXC.MIC 	     Machine Check Exception								      /REV=
;															     INTEXC
				;4303
				;4304	;	Machine check, continued.
				;4305	;	Write parameters to stack.
				;4306
				;4307	;	At this point,
				;4308	;		W1	=	SCB vector
				;4309	;		W4	=	saved Q
				;4310	;		W5	=	saved VA
				;4311	;		SAVEPC	=	backed up PC
				;4312	;		SAVEPSL =	machine check parameter
				;4313	;		VA	=	running stack pointer
				;4314	;		Q	=	RN.MODE.OPCODE
				;4315
				;4316		;---------------------------------------;
				;4317		VA <-- [VA] - 4,			; decrement stack pointer
				;4318		MEM (VA)&, [WBUS] <-- PASSB [Q],	; push rn.mode.opcode
			    p139;4319		LONG,					;
E 283  0CE4,8053,20B0,2267 S 267;4320		CALL [WRITE.W4.PREV]			; push saved Q
				;4321
				;4322		;---------------------------------------;
				;4323		VA <-- [VA] - 4,			; decrement stack pointer
E 284  0CE4,8033,20B0,02B0 J 2B0;4324		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG	; push saved VA on stack
				;4325
				;4326		;---------------------------------------;
			    p139;4327		[W4] <-- [SAVEPSL], LONG,		; get saved SAVEPC
E 2B0  0000,0000,1690,2267 S 267;4328		CALL [WRITE.W4.PREV]			; push on stack
				;4329
				;4330		;---------------------------------------;
			    p139;4331		[W4] <-- [INT.SYS], LONG,		; get interrupt system
E 2B1  0000,0000,1700,2267 S 267;4332		CALL [WRITE.W4.PREV]			; push on stack
				;4333
				;4334		;---------------------------------------;
			    p139;4335		[W4] <-- [ASTLVL], LONG,		; get ASTLVL, CPUID, MC code
E 2B2  0000,0000,1650,2267 S 267;4336		CALL [WRITE.W4.PREV]			; push on stack
				;4337
				;4338		;---------------------------------------;
				;4339		VA <-- [VA] - 4,			; decrement stack pointer
				;4340		MEM (VA)&, [WBUS] <-- PASSB 000000[24.], ; push byte count
E 2B3  0CE4,A0C3,20B0,024C J 24C;4341		LONG					;
				;4342
				;4343		;---------------------------------------;
				;4344		[WBUS] <-- [W1] ANDNOT 000000[3], LONG, ; Wbus <-- vector with bits<1:0> = 00
E 24C  04A4,2018,2020,0251 J 251;4345		LOAD PC 				; load new PC, restart prefetching
				;4346							; >> LOAD PC: sync required before exit
				;4347							; do not clear state flags
				;4348
				;4349		;---------------------------------------;
E 251  0000,0000,78B0,025C J 25C;4350		[SP] <-- [VA], LONG			; update SP for pushes
				;4351
				;4352		;---------------------------------------;
				;4353		VA <-- K10.[IPR.CWB],			; push writes out of the chip
			    p144;4354		MEM.PR (VA)&, [WBUS] <-- PASSA [K0], LONG,
E 25C  00F4,6883,2311,0271 J 271;4355		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; restart Ibox and decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  139
;    INTEXC.MIC 	     Machine Check Exception								      /REV=
;															     INTEXC
				;4356
				;4357	;	One line subroutine to decrement stack pointer, write W4 to stack.
				;4358	;
				;4359	;	Entry conditions:
				;4360	;		VA	=	current stack pointer
				;4361	;		W4	=	value to be pushed on stack
				;4362	;
				;4363	;	Exit conditions:
				;4364	;		VA	=	updated stack pointer after push
				;4365	;		W4 written on stack
				;4366
				;4367	WRITE.W4.PREV:
				;4368		;---------------------------------------;
				;4369		VA <-- [VA] - 4,			; decrement stack pointer
				;4370		MEM (VA)&, [WBUS] <-- PASSB [W4], LONG, ; push parameter on stack
E 267  0CE4,802B,20B0,0800 R	;4371		RETURN					; return to caller
				;4372
;4373	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  140
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
;4374	.TOC	"	Interrupts"
;4375
;4376	;	An interrupt differs from a zero parameter exception only in
;4377	;	the selection of the SCB vector (based on the interrupt level
;4378	;	or an external vector) and the value of the final IPL (set to
;4379	;	the level of the interrupt).
;4380	;
;4381	;	The interrupt flows are entered from execution dispatch or from an
;4382	;	interruptible instruction and cause the currently executing instruction
;4383	;	to be packed up (interruptible instruction) or the instruction stream
;4384	;	to be backed up (all others).  PSL<tp> is preserved on an interrupt
;4385	;	between instructions and clear on an interrupt fault.
;4386	;
;4387	;	Entry conditions:
;4388	;		INT.SYS<20:16> =	highest priority oustanding interrupt
;4389	;
;4390	;	Resources available (execution dispatch):
;4391	;		all chip resources
;4392	;
;4393	;	Resources available (fault):
;4394	;		W1, W4, W5
;4395	;
;4396	;	Exit conditions:
;4397	;		Current instruction has been packed up, or instruction stream backed up.
;4398	;		Exception taken through hardware interrupt vector in SCB.  Stack frame:
;4399	;
;4400	;		+-----------------------------------------------------------------+
;4401	;		|				PC				  |
;4402	;		+-----------------------------------------------------------------+
;4403	;		|				PSL				  |
;4404	;		+-----------------------------------------------------------------+
;4405	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  141
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
;4406
;4407	;	Interrupt requests are detected and prioritized by the interrupt section of the chip.  If an interrupt is
;4408	;	pending whose requested IPL is above the value of the PSL IPL (the current IPL is not considered for HALT),
;4409	;	the interrupt section asserts an interrupt request to the I-box.  At the next macro instruction boundary,
;4410	;	the microsequencer supplies the interrupt pending dispatch, whose handler starts at IE.INT.  In addition, the
;4411	;	interrupt section supplies the interrupt-pending signal as a dispatch condition on the microtest bus
;4412	;	(the SHF.NZ.INT decode) for use by the string microcode.  If an interrupt is requested during the execution
;4413	;	of the main loop of string instructions, the microcode dispatches directly to IE.INT.FAULT.
;4414	;
;4415	;	To find the highest priority interrupt request, microcode reads the Interrupt State Register (ISR) via the
;4416	;	INT.SYS decode.  When INT.SYS is read, the interrupt section supplies the encoded value of the highest
;4417	;	interrupt request in bits <20:16>.
;4418	;
;4419	;	There are three types of interrupts possible: Hardwired, Device, and Software.	Hardwired interrupt requests
;4420	;	are specific-purpose interrupts that are recevied by edge-sensitive logic, and remain asserted until cleared
;4421	;	by the microcode.  Such interrupts have implied SCB vectors.
;4422	;
;4423	;	Device interrupt requests are general-purpose interrupts that are receive by level-sensitive logic, and
;4424	;	remain asserted as long as the device asserts the request line.  They are cleared when the device receives
;4425	;	a a read of the IAK1x IPR corresponding to the interrupt request level.
;4426	;
;4427	;	Software interrupt requests implement the architecturally-defined software interrupt mechanism, and remain
;4428	;	asserted until microcode clears the corresponding SISR bit.
;4429	;
;4430	;	As viewed by the microcode thru the INT.SYS decodes, the Interrupt State Register looks as follows:
;4431	;
;4432	;	 31 30 29 28|27 26 25 24|23 22 21 20|19 18 17 16|15 14 13 12|11 10 09 08|07 06 05 04|03 02 01 00
;4433	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;4434	;	|  |  |  |  |  | 0  0|	| 0  0	0| INT.ID (RO)	|	       SISR<15:01> (RW) 	     |	|
;4435	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;4436	;	  |  |	|  |  |        |								       |
;4437	;	  |  |	|  |  |        +-- INT_TIM_L request flop (WC)				ICCS<6> (RW) --+
;4438	;	  |  |	|  |  +-- S_ERR_L request flop (WC)
;4439	;	  |  |	|  +-- PMF request flop (WC)
;4440	;	  |  |	+-- H_ERR_L request flop (WC)
;4441	;	  |  +-- PWRFL_L request flop (WC)
;4442	;	  +-- HALT_L request flop (WC)
;4443	;
;4444	;	The following table lists, in order of interrupt priority, the following information about each possible
;4445	;	interrupt request:
;4446	;
;4447	;		o The request source
;4448	;		o The IPL at which the interrupt is taken, in both hex and decimal
;4449	;		o The INT.ID encoding for the interrupt, in both hex and decimal
;4450	;		o The ISR bit number of the state element for the interrupt request
;4451	;		o The method for clearing the interrupt request
;4452	;		o The SCB vector used to service the interrupt
;4453	;
;4454	;	Note that in most cases, the encoded INT.ID value is equal to both the IPL and the ISR state element
;4455	;	bit number.  Exceptions to this rule are annotated with the "&" and "%" flags.	Also note that the
;4456	;	IRQ_L<2> interrupt request takes priority over the INT_TIM_L interrupt request, even though they are at
;4457	;	the same IPL, because IRQ_L<2> is used to implement inter-processor interrupts in multi-processor systems,
;4458	;	and such interrupts must take priority over interval timer interrupts.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  142
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
;4459
;4460	;	Interrupt	      INT.ID	   IPL	  ISR Bit	Method For
;4461	;	Request      Type     Hex Dec	 Hex Dec    Dec      Clearing Request		    SCB Vector Used
;4462	;	-------      ----     --- ---	 --- ---    ---     --------------------     -----------------------------
;4463	;	HALT_L	      HW       1F  31	  1F  31     31     Write ISR bit with 1     Console halt (code ERR.HLTPIN)
;4464	;	PWRFL_L       HW       1E  30	  1E  30     30     Write ISR bit with 1     SCB.PWRFL
;4465	;	H_ERR_L       HW       1D  29	  1D  29     29     Write ISR bit with 1     SCB.HERR
;4466	;	Perf. Monitor PM       1B  27	  1B  27     28%    Write ISR bit with 1     Handled by microcode
;4467	;	S_ERR_L       HW       1A  26	  1A  26     27%    Write ISR bit with 1     SCB.SERR
;4468	;	IRQ_L<3>      DV       17  23	  17  23     26%    Read IAK17 IPR	     Supplied by device
;4469	;	IRQ_L<2>      DV       16  22	  16  22     25%    Read IAK16 IPR	     Supplied by device
;4470	;	INT_TIM_L     HW       1C& 28&	  16  22     24%    Write ISR bit with 1     SCB.INTTIM
;4471	;	IRQ_L<1>      DV       15  21	  15  21     23%    Read IAK15 IPR	     Supplied by device
;4472	;	IRQ_L<0>      DV       14  20	  14  20     22%    Read IAK14 IPR	     Supplied by device
;4473	;	SISR<15>      SW       0F  15	  0F  15     15     Write ISR bit with 0     SCB.IPLSOFT+(4*0F)
;4474	;	SISR<14>      SW       0E  14	  0E  14     14     Write ISR bit with 0     SCB.IPLSOFT+(4*0E)
;4475	;	SISR<13>      SW       0D  13	  0D  13     13     Write ISR bit with 0     SCB.IPLSOFT+(4*0D)
;4476	;	SISR<12>      SW       0C  12	  0C  12     12     Write ISR bit with 0     SCB.IPLSOFT+(4*0C)
;4477	;	SISR<11>      SW       0B  11	  0B  11     11     Write ISR bit with 0     SCB.IPLSOFT+(4*0B)
;4478	;	SISR<10>      SW       0A  10	  0A  10     10     Write ISR bit with 0     SCB.IPLSOFT+(4*0A)
;4479	;	SISR<9>       SW       09  09	  09  09     09     Write ISR bit with 0     SCB.IPLSOFT+(4*09)
;4480	;	SISR<8>       SW       08  08	  08  08     08     Write ISR bit with 0     SCB.IPLSOFT+(4*08)
;4481	;	SISR<7>       SW       07  07	  07  07     07     Write ISR bit with 0     SCB.IPLSOFT+(4*07)
;4482	;	SISR<6>       SW       06  06	  06  06     06     Write ISR bit with 0     SCB.IPLSOFT+(4*06)
;4483	;	SISR<5>       SW       05  05	  05  05     05     Write ISR bit with 0     SCB.IPLSOFT+(4*05)
;4484	;	SISR<4>       SW       04  04	  04  04     04     Write ISR bit with 0     SCB.IPLSOFT+(4*04)
;4485	;	SISR<3>       SW       03  03	  03  03     03     Write ISR bit with 0     SCB.IPLSOFT+(4*03)
;4486	;	SISR<2>       SW       02  02	  02  02     02     Write ISR bit with 0     SCB.IPLSOFT+(4*02)
;4487	;	SISR<1>       SW       01  01	  01  01     01     Write ISR bit with 0     SCB.IPLSOFT+(4*01)
;4488	;	No Interrupt  --       00  00	  00  00     00     Dismiss interrupt
;4489	;	-----------------------------------------------------------------------------------------------
;4490	;	Type:						Flags:
;4491	;	    DV - Device interrupt			    & - INT.ID value differs from IPL
;4492	;	    HW - Hardwired interrupt			    % - ISR bit number differs from IPL
;4493	;	    SW - Software Interrupt
;4494	;	    PM - Performance monitoring interrupt
				;4495	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  143
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4496
				;4497	;	Interrupt at initial dispatch.
				;4498
				;4499	IE.INT..:
				;4500		;********** Hardware dispatch **********;
				;4501		Q <-- 0,				; no PSL bits to clear
				;4502		RESET CPU,				; abort current operations
				;4503		CALL [IE.CLEANUP.CPU.NO.PACKUP],	; cleanup CPU state, state<3:0> = 0,
			    p159;4504							; PSL<TP> unchanged, SAVEPC = BPC
E 024  0002,C000,2006,22D5 S 2D5;4505			sim exception
				;4506
				;4507		;---------------------------------------;
				;4508		[W3] <-- [INT.SYS] AND 00[1F]0000,	; get and mask interrupt id
			    p144;4509		LONG,					;
E 025  0400,30F8,1300,026C J 26C;4510		GOTO [IE.INT.CONT]			; join common code
				;4511
				;4512	;	Interrupt in mid instruction via the INTERRUPT FAULT macro.
				;4513
				;4514	IE.INT.FAULT..:
				;4515		;---------------------------------------;
				;4516		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;4517		RESET CPU,				; abort current operations
				;4518		CALL [IE.CLEANUP.CPU],			; cleanup CPU state, state<3:0> unchanged,
			    p159;4519							; PSL<TP> = 0, SAVEPC = BPC
E 040  0002,BA00,2006,22D7 S 2D7;4520			sim exception
				;4521
				;4522		;---------------------------------------;
				;4523		[W3] <-- [INT.SYS] AND 00[1F]0000,	; get and mask interrupt id
			    p144;4524		LONG,					;
E 041  0400,30F8,1300,026C J 26C;4525		GOTO [IE.INT.CONT]			; join common code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  144
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4526
				;4527	;	Interrupt, continued.
				;4528
				;4529	;	At this point,
				;4530	;		W3<20:16> =	interrupt id
				;4531	;		SAVEPC	=	old PC
				;4532
				;4533	IE.INT.CONT:
				;4534		;---------------------------------------;
				;4535		[W1] <-- ZEXT [W3] RSH [16.], LONG,	; position to <4:0> for case, SC load
E 26C  0001,D022,0802,8334 J 334;4536		DL <-- WORD				; set dl = word for vector read
				;4537
				;4538		;---------------------------------------;
				;4539		[W2] <-- [W1] LSH [2], LONG,		; position to <6:2> for soft vector
				;4540		SC <-- A [W1],				; load to SC to make mask
				;4541		ACCESS B [W1],				; test bits <4:3>
E 334  2001,4212,0C2A,4160 B 360;4542		CASE [ALU.NZV] AT [IE.INT.CONTINUE]	; case on interrupt id = 0
				;4543
				;4544	;= ALIGNLIST x0xx	(IE.INT.CONTINUE,	IE.NO.INTERRUPT)
				;4545	;  ALU.NZVC set by AND with mask<31> = 0 --> N = V = C = 0
				;4546
				;4547	;	Enter here at the completion of a PMF interrupt to re-enable
				;4548	;	the counters and restart the instruction stream.
				;4549
				;4550	IE.ENABLE.PMF.RESTART:
				;4551		;---------------------------------------;
			    p276;4552		[ECR] <-- [ECR] OR 00[ECR.PMF.ENABLE]0000, ; re-enable PMF counters
E 363  0500,3008,EBA0,2497 S 497;4553		CALL [WAIT.ONE.CYCLE]			; delay after ISR change
				;4554
				;4555	IE.NO.INTERRUPT:
				;4556		;---------------------------------------; alu.z = 1:
				;4557		[WBUS] <-- [SAVEPC], LONG,		; get old PC
				;4558		LOAD PC,				; load new PC, restart prefetching
				;4559							; >> LOAD PC: sync required before exit
				;4560		STATE.5-4 <-- 0,			; clear exception flags
E 364  1025,4000,2280,0271 J 271;4561		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; go resume instruction parsing
				;4562
				;4563	SYNC.RESTART.IBOX.NO.RETIRE:
				;4564		;---------------------------------------;
				;4565		SYNCHRONIZE MBOX,			; >> sync with LOAD PC
				;4566		RESTART IBOX,				; restart Ibox
E 271  1020,0100,2004,1000 L	;4567		LAST CYCLE NO RETIRE			; decode next instruction
				;4568
				;4569	;	Interrupt present, dispatch based on interrupt type.
				;4570
				;4571	IE.INT.CONTINUE:
				;4572		;---------------------------------------; alu.z = 0:
				;4573		Q <-- [K1] LSH (SC), LONG,		; create mask to clear interrupt request
			    p145;4574		ACCESS B [W1],				; test bits <2:0>
E 360  8003,4010,2320,4440 B 340;4575		CASE [B.5-3] AT [IE.SWRE.INT]		; case on interrupt id <4:3>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  145
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4576
				;4577	;	Software interrupt processing.
				;4578
				;4579	;	At this point,
				;4580	;		W2<6:2> =	interrupt id, masked
				;4581	;		W3<20:16> =	interrupt id (new IPL), masked
				;4582	;		SAVEPC	=	old PC
				;4583	;		Q	=	1b<interrupt id>
				;4584
				;4585	;= ALIGNLIST x00x	(IE.SWRE.INT,		IE.SWRE.INT.1,
				;4586	;=			 IE.DEVICE.INT, 	IE.HARDWIRE.INT)
				;4587	;  INT.SYS masked to 5 bits --> B<5> = 0 --> B<5:3> = 0??
				;4588
				;4589	IE.SWRE.INT:
				;4590		;---------------------------------------; b<4:3> = 00:
				;4591		[INT.SYS] <-- [INT.SYS] ANDNOT [Q],	; clear software interrupt request
				;4592		LONG,					; >> Int sys change, no decode for 4 cycles
E 340  0480,0050,C300,0280 J 280;4593		GOTO [IE.CLEAR.SWRE.INT]		; join common flows
				;4594
				;4595	IE.SWRE.INT.1:
				;4596		;---------------------------------------; b<4:3> = 01:
				;4597		[INT.SYS] <-- [INT.SYS] ANDNOT [Q],	; clear software interrupt request
				;4598		LONG,					; >> Int sys change, no decode for 4 cycles
E 342  0480,0050,C300,0280 J 280;4599		GOTO [IE.CLEAR.SWRE.INT]		; join common flows
				;4600
				;4601	IE.CLEAR.SWRE.INT:
				;4602		;---------------------------------------;
				;4603		[W2] <-- [W2] + 000000[SCB.IPLSOFT],	; add offset to SCB block base
E 280  0880,2400,0C30,0290 J 290;4604		LONG					;
				;4605
				;4606		;---------------------------------------;
				;4607		VA <-- [SCBB] + [W2],			; compute SCB offset
				;4608		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p151;4609		GOTO [IE.INT.COMMON],			; go to common code
E 290  08D0,0019,0A60,02AA J 2AA;4610			sim addr [scb]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  146
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4611
				;4612	;	Vectored interrupt processing.
				;4613
				;4614	;	At this point,
				;4615	;		W2<6:2> =	interrupt id, masked
				;4616	;		W3<20:16> =	interrupt id (new IPL), masked
				;4617	;		SAVEPC	=	old PC
				;4618	;		DL	=	WORD
				;4619
				;4620	IE.DEVICE.INT:
				;4621		;---------------------------------------; b<4:3> = 10:
				;4622		VA <-- [W2] + K10.[IPR.IAK.BASE],	; add IPL to pre-biased IAK base
E 344  08D4,2585,0831,0292 J 292;4623		[W1] <-- MEM.PR (VA), LEN(DL)		; read appropriate off-chip IPR
				;4624
				;4625		;---------------------------------------;
E 292  0080,0071,2000,0294 J 294;4626		VA <-- B [K.FFFF], LONG 		; get mask to clear upper word
				;4627
				;4628		;---------------------------------------;
				;4629		[W1] <-- [VA] AND [W1], LONG,		; zero upper word
E 294  0400,0010,08B0,0425 J 425;4630		ACCESS B [W1]				; test offset<1:0>
				;4631
				;4632		;---------------------------------------;
				;4633		VA <-- [SCBB] + [W1], LONG,		; compute SCB offset
E 425  6880,0011,2260,43B8 B 4B8;4634		CASE [B.2-0] AT [IE.INT.NORMAL] 	; case on offset<1:0>
				;4635
				;4636	;	Bits <1:0> of the returned vector specify how the microcode
				;4637	;	should process the interrupt, as follows:
				;4638	;
				;4639	;	00	Normal interrupt
				;4640	;	01	Qbus interrupt with IPL forced to 17
				;4641	;	1x	Micro-passive release
				;4642
				;4643	;= ALIGNLIST 100x	(IE.INT.NORMAL, 	IE.INT.QBUS,
				;4644	;=			 IE.PASSIVE.RELEASE.10, IE.PASSIVE.RELEASE.11)
				;4645
				;4646	IE.INT.QBUS:
				;4647		;---------------------------------------; b<1:0> = 01:
				;4648		[W3] <-- 00[17]0000, LONG,		; Qbus system, force IPL = 17
E 4BA  0080,30B8,1000,04B8 J 4B8;4649		GOTO [IE.INT.NORMAL]			; go to common code
				;4650
				;4651	IE.INT.NORMAL:
				;4652		;---------------------------------------; b<1:0> = 00:
				;4653		VA <-- [VA] ANDNOT 000000[03],		; force offset aligned
				;4654		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p151;4655		GOTO [IE.INT.COMMON],			; join common code
E 4B8  04D0,2019,08B0,02AA J 2AA;4656			sim addr [scb]
				;4657
				;4658	IE.PASSIVE.RELEASE.10:
				;4659		;---------------------------------------; b<1:0> = 10:
				;4660		[WBUS] <-- [SAVEPC], LONG,		; get old PC
				;4661		LOAD PC,				; load new PC, restart prefetching
				;4662							; >> LOAD PC: sync required before exit
			    p144;4663		STATE.5-4 <-- 0,			; clear exception flags
E 4BC  1025,4000,2280,0271 J 271;4664		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; go resume instruction parsing
				;4665
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  147
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4666	IE.PASSIVE.RELEASE.11:
				;4667		;---------------------------------------; b<1:0> = 11:
				;4668		[WBUS] <-- [SAVEPC], LONG,		; get old PC
				;4669		LOAD PC,				; load new PC, restart prefetching
				;4670							; >> LOAD PC: sync required before exit
			    p144;4671		STATE.5-4 <-- 0,			; clear exception flags
E 4BE  1025,4000,2280,0271 J 271;4672		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; go resume instruction parsing
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  148
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4673
				;4674	;	Hardwired interrupt processing, continued.
				;4675	;	Predefined interrupts.
				;4676
				;4677	;	At this point,
				;4678	;		W3<20:16> =	interrupt id (new IPL), masked
				;4679	;		SAVEPC	=	old PC
				;4680	;		Q	=	1b<interrupt id>
				;4681
				;4682	IE.HARDWIRE.INT:
				;4683		;---------------------------------------; b<4:3> = 11:
				;4684		[WBUS] <-- [K1], LONG,			; clear wbus.z for ipl 1b interrupt
E 346  6000,0000,2320,43A1 B 3A1;4685		CASE [B.2-0] AT [IE.INT.IPL18]		; case on all hardwired levels
				;4686
				;4687	;= ALIGNLIST 000x	(IE.INT.IPL18,	IE.INT.IPL19,	IE.INT.IPL1A,	IE.INT.IPL1B,
				;4688	;=			 IE.INT.IPL1C,	IE.INT.IPL1D,	IE.INT.IPL1E,	IE.INT.IPL1F)
				;4689
				;4690	IE.INT.IPL18:
			    p135;4691		;---------------------------------------; b<2:0> = 000:
E 3A1  0080,3010,A400,0038 J 038;4692		MACHINE CHECK [MCHK.INT.ID.VALUE]	; no such interrupt level, machine check
				;4693
				;4694	IE.INT.IPL19:
			    p135;4695		;---------------------------------------; b<2:0> = 001:
E 3A3  0080,3010,A400,0038 J 038;4696		MACHINE CHECK [MCHK.INT.ID.VALUE]	; no such interrupt level, machine check
				;4697
				;4698	IE.INT.IPL1A:
				;4699		;---------------------------------------; b<2:0> = 010:
				;4700		VA <-- [SCBB] + 000000[SCB.SERR],	; set up SCB offset for soft err interrupt
				;4701		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
E 3A5  08D0,22A1,0A60,0296 J 296;4702			sim addr [scb]
				;4703
				;4704		;---------------------------------------;
				;4705		[INT.SYS] <-- [INT.SYS] OR [ISR.SERR]000000, ; clear interrupt request
			    p151;4706		LONG,					; with different ISR bit
E 296  0500,3840,C300,02AA J 2AA;4707		GOTO [IE.INT.COMMON]			; join common interrupt code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  149
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4708
				;4709	;	Hardwired interrupt processing, continued.
				;4710	;
				;4711	;	At this point,
				;4712	;		W3<20:16> =	interrupt id (new IPL), masked
				;4713	;		SAVEPC	=	old PC
				;4714	;		Q	=	1b<interrupt id>
				;4715	;		WBUS.Z	=	0 (from previous cycle)
				;4716
				;4717	IE.INT.IPL1B:
				;4718		;---------------------------------------; b<2:0> = 011:
			    p496;4719		[ECR] <-- [ECR] ANDNOT 00[ECR.PMF.ENABLE]0000, ; disable PMF counters
E 3A7  0480,3008,EBA0,2177 S 177;4720		CALL [UPDATE.PMF.COUNTERS]		; update the memory counters
				;4721
				;4722		;---------------------------------------;
				;4723		[INT.SYS] <-- [INT.SYS] OR [ISR.PMF]000000, ; clear interrupt request
			    p144;4724		LONG,					; with different ISR bit
E 3A8  0500,3880,C300,0363 J 363;4725		GOTO [IE.ENABLE.PMF.RESTART]		; re-enable counters, restart
				;4726							;>> Int sys change, no decode for 4 cycles
				;4727
				;4728	IE.INT.IPL1C:
				;4729		;---------------------------------------; b<2:0> = 100
				;4730		VA <-- [SCBB] + 000000[SCB.INTTIM],	; set up SCB offset for timer interrupt
				;4731		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
E 3A9  08D0,2601,0A60,029B J 29B;4732			sim addr [scb]
				;4733
				;4734		;---------------------------------------;
E 29B  0080,30B0,1000,02C3 J 2C3;4735		[W3] <-- 00[16]0000, LONG		; interval timer is really IPL 16
				;4736
				;4737		;---------------------------------------;
				;4738		[INT.SYS] <-- [INT.SYS] OR [ISR.INT_TIM]000000, ; clear interrupt request
			    p151;4739		LONG,					; with different ISR bit
E 2C3  0500,3808,C300,02AA J 2AA;4740		GOTO [IE.INT.COMMON]			; join common interrupt code
				;4741
				;4742	IE.INT.IPL1D:
				;4743		;---------------------------------------; b<2:0> = 101:
				;4744		VA <-- [SCBB] + 000000[SCB.HERR],	; set up SCB offset for hard err interrupt
				;4745		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p150;4746		GOTO [IE.CLEAR.HWRE.INT],		; go join common interrupt code
E 3AB  08D0,2301,0A60,02C7 J 2C7;4747			sim addr [scb]
				;4748
				;4749	IE.INT.IPL1E:
				;4750		;---------------------------------------; b<2:0> = 110:
				;4751		VA <-- [SCBB] + 000000[SCB.PWRFL],	; set up SCB offset for power fail interrupt
				;4752		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p150;4753		GOTO [IE.CLEAR.HWRE.INT],		; go join common interrupt code
E 3AD  08D0,2061,0A60,02C7 J 2C7;4754			sim addr [scb]
				;4755
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  150
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4756
				;4757	;	Hardwired interrupt processing, continued.
				;4758	;
				;4759	;	At this point,
				;4760	;		W3<20:16> =	interrupt id (new IPL), masked
				;4761	;		SAVEPC	=	old PC
				;4762	;		Q	=	1b<interrupt id>
				;4763	;		WBUS.Z	=	0 (from previous cycle)
				;4764
				;4765	IE.INT.IPL1F:
				;4766		;---------------------------------------; b<2:0> = 111:
				;4767		[INT.SYS] <-- [INT.SYS] OR [ISR.HALT]000000, ; clear halt interrupt request
E 3AF  0500,3C00,C300,02C5 J 2C5;4768		LONG					; >> Int sys change, no decode for 4 cycles
				;4769
			    p.84;4770		;---------------------------------------;
E 2C5  0500,2810,A4C0,0035 J 035;4771		CONSOLE HALT NO CLEANUP [ERR.HLTPIN]	; HALT L asserted, invoke console
				;4772							; >> string packup possible, no cleanup
				;4773							; >> may be done
				;4774
				;4775	IE.CLEAR.HWRE.INT:
				;4776		;---------------------------------------;
				;4777		[INT.SYS] <-- [INT.SYS] OR [Q], LONG,	; clear hardwired interrupt request
			    p151;4778							; >> Int sys change, no decode for 4 cycles
E 2C7  0500,0050,C300,02AA J 2AA;4779		GOTO [IE.INT.COMMON]			; go join common interrupt code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  151
;    INTEXC.MIC 	     Interrupts 									      /REV=
;															     INTEXC
				;4780
				;4781	;	Merge point for interrupts.
				;4782
				;4783	;	At this point,
				;4784	;		W1	=	SCB vector
				;4785	;		W3	=	new IPL
				;4786
				;4787	IE.INT.COMMON:
				;4788		;---------------------------------------;
				;4789		[W2] <-- [PSL], LONG,			; save PSL
				;4790		STATE.4 <-- 1,				; flag exception
				;4791		STATE.3-0 <-- 0,			; clear other state flags
			    p153;4792							; >> no state<3> restriction after RESET CPU
E 2AA  1001,C000,0CC8,2368 S 368;4793		CALL [IE.INTERRUPT]			; call interrupt processor
				;4794
				;4795	IE.LOAD.PC:
				;4796		;---------------------------------------;
				;4797		[WBUS] <-- [W1] ANDNOT 000000[3], LONG, ; Wbus <-- vector with bits<1:0> = 00
				;4798		LOAD PC,				; load new PC, restart prefetching
				;4799							; >> LOAD PC: sync required before exit
E 2AB  04A4,2018,2020,02CD J 2CD;4800		GOTO [IE.UPDATE.SP]
				;4801
				;4802	;	Exit from exception flows.  A LOAD PC must have been done after the
				;4803	;	last stack write.  This is used as an implicit synchonization event with
				;4804	;	the Mbox such that the LOAD PC stalls until the final write clears
				;4805	;	the memory management checks.  state<5:4> must not be cleared in this
				;4806	;	cycle because a fault on the final stack write would be detected after
				;4807	;	the state bits are cleared.
				;4808
				;4809	IE.UPDATE.SP:
				;4810		;---------------------------------------;
				;4811		[SP] <-- PASSA [VA], LONG,		; update SP for pushes
E 2CD  0080,6883,78B1,02D1 J 2D1;4812		VA <-- K10.[IPR.CWB]			; load CWB address
				;4813
				;4814		;---------------------------------------;
				;4815		MEM.PR (VA)&, [WBUS] <-- [K0], LONG,	; push writes out of the chip
			    p144;4816		STATE.5-4 <-- 0,			; clear permanent state bits
E 2D1  1075,4000,2310,0271 J 271;4817		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; sync with LOAD PC, exit instruction
				;4818
;4819	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  152
;    INTEXC.MIC 	     Interrupt and Exception Handling Subroutines					      /REV=
;															     INTEXC
;4820	.TOC	"	Interrupt and Exception Handling Subroutines"
;4821
;4822	;	IE.INTERRUPT -- interrupt handling.
;4823	;
;4824	;	Entry conditions:
;4825	;		W1	=	SCB offset (read in progress)
;4826	;		W2	=	current PSL
;4827	;		W3<20:16> =	new IPL, masked
;4828	;		SAVEPC	=	old PC
;4829	;		STATE<3:0> =	0
;4830	;
;4831	;	Exit conditions:
;4832	;		W1	=	SCB vector
;4833	;		W2	=	original PSL
;4834	;		VA	=	new SP
;4835	;		W0,W3	=	trashed
;4836	;		SAVEPC	=	old PC
;4837	;		PSL, PC 	pushed on interrupt or kernel stack
;4838	;		W4, W5, Q, SAVEPSL all preserved.
;4839	;
;4840	;	IE.EXCEPTION -- exception handling.
;4841	;
;4842	;	Entry conditions:
;4843	;		W1	=	SCB offset (read in progress)
;4844	;		W2	=	current PSL
;4845	;		SAVEPC	=	old PC
;4846	;		STATE<3:0> =	0
;4847	;
;4848	;	Exit conditions:
;4849	;		W1	=	SCB vector
;4850	;		W2	=	original PSL
;4851	;		VA	=	new SP
;4852	;		W0,W3	=	trashed
;4853	;		SAVEPC	=	old PC
;4854	;		PSL, PC 	pushed on interrupt or kernel stack
;4855	;		W4, W5, Q, SAVEPSL all preserved.
;4856
				;4857	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  153
;    INTEXC.MIC 	     Interrupt and Exception Handling Subroutines					      /REV=
;															     INTEXC
				;4858
				;4859	;	Exception handler.
				;4860
				;4861	IE.EXCEPTION:
				;4862		;---------------------------------------;
				;4863		[W3] <-- [PSL] AND 00[1F]0000, LONG,	; start new PSL with current <ipl>
				;4864		STATE.0 <-- 1,				; flag exception vs interrupt
E 311  A400,30F8,10C8,CD68 B 368;4865		CASE [PSL.26-24] AT [IE.EXC.PRVMODE.00]; case on current mode to set prev mode
				;4866
				;4867	;= ALIGNLIST 100x	(IE.EXC.PRVMODE.00,	IE.EXC.PRVMODE.01,
				;4868	;=			 IE.EXC.PRVMODE.10,	IE.EXC.PRVMODE.11)
				;4869
				;4870	IE.EXC.PRVMODE.01:
				;4871		;---------------------------------------; psl<25:24> = 01:
				;4872		[W3] <-- [W3] OR 00[40]0000, LONG,	; new PSL<prv_mode> = curr PSL<cur_mode>
E 36A  0500,3200,1040,0368 J 368;4873		GOTO [IE.EXC.PRVMODE.00]		; go save current stack
				;4874
				;4875	IE.EXC.PRVMODE.10:
				;4876		;---------------------------------------; psl<25:24> = 10:
				;4877		[W3] <-- [W3] OR 00[80]0000, LONG,	; new PSL<prv_mode> = curr PSL<cur_mode>
E 36C  0500,3400,1040,0368 J 368;4878		GOTO [IE.EXC.PRVMODE.00]		; go save current stack
				;4879
				;4880	IE.EXC.PRVMODE.11:
				;4881		;---------------------------------------; psl<25:24> = 11:
				;4882		[W3] <-- [W3] OR 00[0C0]0000, LONG,	; new PSL<prv_mode> = curr PSL<cur_mode>
E 36E  0500,3600,1040,0368 J 368;4883		GOTO [IE.EXC.PRVMODE.00]		; go save current stack
				;4884
				;4885	;	Interrupt handler.
				;4886
				;4887	IE.INTERRUPT:
				;4888	IE.EXC.PRVMODE.00:
				;4889		;---------------------------------------; psl<25:24> = 00:
				;4890		[W0] <-- [SAVEPC], LONG,		; move old PC to W0 for later use
				;4891		ACCESS B [W1],				; get vector, check bits<1:0>
				;4892		CASE [PSL.26-24] AT [IE.INTEXC.SWAP.KS],; case on PSL current mode bits
			    p154;4893			sim cond k s3.[1],
E 368  A000,0010,068F,4D51 B 351;4894			sim ie.intexc
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  154
;    INTEXC.MIC 	     Interrupt and Exception Handling Subroutines					      /REV=
;															     INTEXC
				;4895
				;4896	;	Interrupt/exception processing, continued.
				;4897	;	Save current stack pointer.
				;4898
				;4899	;	At this point,
				;4900	;		W0,SAVEPC =	old PC
				;4901	;		W1	=	SCB vector
				;4902	;		W2	=	current PSL
				;4903	;		W3	=	new PSL
				;4904	;		STATE<0> =	1 if exception
				;4905	;		W4, W5, Q, SAVEPSL all preserved.
				;4906
				;4907	;= ALIGNLIST 000x	(IE.INTEXC.SWAP.KS,	IE.INTEXC.SWAP.ES,
				;4908	;=			 IE.INTEXC.SWAP.SS,	IE.INTEXC.SWAP.US,
				;4909	;=			 IE.INTEXC.SWAP.IS,	IE.INTEXC.SWAP.101,
				;4910	;=			 IE.INTEXC.SWAP.110,	IE.INTEXC.SWAP.111)
				;4911
				;4912	IE.INTEXC.SWAP.KS:
				;4913		;---------------------------------------; psl<26:24> = 000:
			    p155;4914		[KSP] <-- [SP], LONG,			; save SP in KSP register
E 351  6000,0000,81E0,4369 B 369;4915		CASE [B.2-0] AT [IE.INTEXC.KS]		; case on vector<1:0>
				;4916
				;4917	IE.INTEXC.SWAP.ES:
				;4918		;---------------------------------------; psl<26:24> = 001:
			    p155;4919		[ESP] <-- [SP], LONG,			; save SP in ESP register
E 353  6000,0000,85E0,4369 B 369;4920		CASE [B.2-0] AT [IE.INTEXC.KS]		; case on vector<1:0>
				;4921
				;4922	IE.INTEXC.SWAP.SS:
				;4923		;---------------------------------------; psl<26:24> = 010:
			    p155;4924		[SSP] <-- [SP], LONG,			; save SP in SSP register
E 355  6000,0000,89E0,4369 B 369;4925		CASE [B.2-0] AT [IE.INTEXC.KS]		; case on vector<1:0>
				;4926
				;4927	IE.INTEXC.SWAP.US:
				;4928		;---------------------------------------; psl<26:24> = 011:
			    p155;4929		[USP] <-- [SP], LONG,			; save SP in USP register
E 357  6000,0000,8DE0,4369 B 369;4930		CASE [B.2-0] AT [IE.INTEXC.KS]		; case on vector<1:0>
				;4931
				;4932	IE.INTEXC.SWAP.IS:
				;4933		;---------------------------------------; psl<26:24> = 100:
			    p155;4934		[W3] <-- [W3] OR [04]000000, LONG,	; set <is> in new PSL
E 359  6500,3820,1040,4369 B 369;4935		CASE [B.2-0] AT [IE.INTEXC.KS]		; case on vector<1:0>
				;4936
				;4937	IE.INTEXC.SWAP.101:
			    p.84;4938		;---------------------------------------; psl<26:24> = 101:
E 35B  0500,28C8,A4C0,0034 J 034;4939		CONSOLE HALT [ERR.IE.PSL.26-24.101]	; on interrupt stack in exec mode, die
				;4940
				;4941	IE.INTEXC.SWAP.110:
			    p.84;4942		;---------------------------------------; psl<26:24> = 110:
E 35D  0500,28D0,A4C0,0034 J 034;4943		CONSOLE HALT [ERR.IE.PSL.26-24.110]	; on interrupt stack in super mode, die
				;4944
				;4945	IE.INTEXC.SWAP.111:
			    p.84;4946		;---------------------------------------; psl<26:24> = 111:
E 35F  0500,28D8,A4C0,0034 J 034;4947		CONSOLE HALT [ERR.IE.PSL.26-24.111]	; on interrupt stack in user mode, die
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  155
;    INTEXC.MIC 	     Interrupt and Exception Handling Subroutines					      /REV=
;															     INTEXC
				;4948
				;4949	;	Interrupt/exception processing, continued.
				;4950	;	Process based on vector<1:0>.
				;4951
				;4952	;	At this point,
				;4953	;		W0,SAVEPC =	old PC
				;4954	;		W1	=	SCB vector
				;4955	;		W2	=	current PSL
				;4956	;		W3	=	new PSL
				;4957	;		STATE<0> =	1 if exception
				;4958	;		W4, W5, Q, SAVEPSL all preserved.
				;4959
				;4960	;= ALIGNLIST 100x	(IE.INTEXC.KS,	IE.INTEXC.IS,
				;4961	;=			 IE.INTEXC.WCS, IE.INTEXC.RES)
				;4962
				;4963	;	Vector<1:0> = 00, process on kernel stack.
				;4964
				;4965	IE.INTEXC.KS:
				;4966		;---------------------------------------; b<1:0> = 00:
				;4967		[PSL] <-- [W3], LONG,			; load new PSL
			    p157;4968							; >> Int sys change, no decode for 4 cycles
E 369  A000,0000,3040,4D56 B 356;4969		CASE [PSL.26-24] AT [IE.INTEXC.KS.LOAD] ; case on old PSL<is> to load new stk
				;4970
				;4971	;	Vector<1:0> = 01, process on interrupt stack.
				;4972	;	If exception, set PSL<ipl> = 1F.
				;4973
				;4974	IE.INTEXC.IS:
				;4975		;---------------------------------------; b<1:0> = 01:
				;4976		[W3] <-- [W3] OR [04]000000, LONG,	; set new PSL<is> = 1
E 36B  4500,3820,1040,4A7C B 37C;4977		CASE [STATE.2-0] AT [IE.INTEXC.IS.INT]	; case on interrupt vs exception
				;4978
				;4979	;= ALIGNLIST **0x	(IE.INTEXC.IS.INT,	IE.INTEXC.IS.EXC)
				;4980	;  STATE<2:1> = 00 --> STATE<2:0> = 00?
				;4981
				;4982	IE.INTEXC.IS.INT:
				;4983		;---------------------------------------; state<0> = 0:
				;4984		[PSL] <-- [W3], LONG,			; load new PSL
			    p157;4985							; >> Int sys change, no decode for 4 cycles
E 37C  A000,0000,3040,4D77 B 377;4986		CASE [PSL.26-24] AT [IE.INTEXC.IS.LOAD] ; case on old PSL<is> to load new stk
				;4987
				;4988	IE.INTEXC.IS.EXC:
				;4989		;---------------------------------------; state<0> = 1:
				;4990		[PSL] <-- [W3] OR 00[1F]0000, LONG,	; load new PSL, force ipl to 1F
			    p157;4991							; >> Int sys change, no decode for 4 cycles
E 37E  A500,30F8,3040,4D77 B 377;4992		CASE [PSL.26-24] AT [IE.INTEXC.IS.LOAD] ; case on old PSL<is> to load new stk
				;4993
				;4994	;	Vector<1:0> = 10, process in WCS, gonzo for VLSI chips.
				;4995
				;4996	IE.INTEXC.WCS:
			    p.84;4997		;---------------------------------------; b<1:0> = 10:
E 36D  0500,2840,A4C0,0035 J 035;4998		CONSOLE HALT NO CLEANUP [ERR.WCSVEC]	; invalid vector, invoke console
				;4999							; >> string packup possible, no cleanup
				;5000							; >> may be done
				;5001
				;5002	;	Vector<1:0> = 11, process nowhere, gonzo for everybody.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  156
;    INTEXC.MIC 	     Interrupt and Exception Handling Subroutines					      /REV=
;															     INTEXC
				;5003
				;5004	IE.INTEXC.RES:
			    p.84;5005		;---------------------------------------; b<1:0> = 11:
E 36F  0500,2838,A4C0,0035 J 035;5006		CONSOLE HALT NO CLEANUP [ERR.ILLVEC]	; invalid vector, invoke console
				;5007							; >> string packup possible, no cleanup
				;5008							; >> may be done
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  157
;    INTEXC.MIC 	     Interrupt and Exception Handling Subroutines					      /REV=
;															     INTEXC
				;5009
				;5010	;	Interrupt/exception processing, continued.
				;5011	;	Load new stack ptr, if needed, write PSL, PC to stack frame.
				;5012
				;5013	;	At this point,
				;5014	;		W0,SAVEPC =	old PC
				;5015	;		W1	=	SCB vector
				;5016	;		W2	=	current PSL
				;5017	;		W4, W5, Q, SAVEPSL all preserved.
				;5018
				;5019	;= ALIGNLIST 011x	(IE.INTEXC.KS.LOAD,	IE.INTEXC.KS.NOLOAD)
				;5020
				;5021	IE.INTEXC.KS.LOAD:
				;5022		;---------------------------------------; psl<is> = 0:
E 356  0000,0000,7A00,035E J 35E;5023		[SP] <-- [KSP], LONG			; load new stack pointer
				;5024
				;5025	IE.INTEXC.KS.NOLOAD:
				;5026		;---------------------------------------; psl<is> = 1:
				;5027		VA <-- [SP] - 4,			; decrement the stack for a push
				;5028		MEM (VA)&, [WBUS] <-- PASSB [W2], LONG, ; write old PSL to stack
				;5029		GOTO [IE.INTEXC.WRITE.OLDPC],		; go write PC
E 35E  0CE4,801B,21E0,02D3 J 2D3;5030			sim addr [sp]
				;5031
				;5032	;= ALIGNLIST 011x	(IE.INTEXC.IS.LOAD,	IE.INTEXC.IS.NOLOAD)
				;5033
				;5034	IE.INTEXC.IS.LOAD:
				;5035		;---------------------------------------; psl<is> = 0:
E 377  0000,0000,7A40,037F J 37F;5036		[SP] <-- [ISP], LONG			; load new stack pointer
				;5037
				;5038	IE.INTEXC.IS.NOLOAD:
				;5039		;---------------------------------------; psl<is> = 1:
				;5040		VA <-- [SP] - 4,			; decrement the stack for a push
				;5041		MEM (VA)&, [WBUS] <-- PASSB [W2], LONG, ; write old PSL to stack
				;5042		GOTO [IE.INTEXC.WRITE.OLDPC],		; go write PC
E 37F  0CE4,801B,21E0,02D3 J 2D3;5043			sim addr [sp]
				;5044
				;5045	IE.INTEXC.WRITE.OLDPC:
				;5046		;---------------------------------------;
				;5047		VA <-- [VA] - 4,			; decrement the stack for a push
				;5048		MEM (VA)&, [WBUS] <-- PASSB [W0], LONG, ; push old PC
E 2D3  0CE4,800B,20B0,0800 R	;5049		RETURN					; return to caller
				;5050
;5051	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  158
;    INTEXC.MIC 	     CPU Cleanup Subroutine								      /REV=
;															     INTEXC
;5052	.TOC	"	CPU Cleanup Subroutine"
;5053
;5054	;	IE.CLEANUP.CPU -- clean up CPU, with possible packup
;5055	;	IE.CLEANUP.CPU.NO.PACKUP -- clean up CPU with no packup
;5056	;
;5057	;	Entry conditions:
;5058	;		RESET CPU done in previous or earlier cycle.
;5059	;		Ibox stopped.
;5060	;		Fbox synchronization done in previous or earlier microword (via DST field anything other than NODST)
;5061	;		Q	=	mask of bits to clear in the PSL
;5062	;		STATE<3> =	1 for string packup or interlocked queue instruction
;5063	;		W0	=	address of queue header (if state<3> = 1 from interlocked queue instruction)
;5064	;		W0	=	character or mask (if state<3> = 1 from string instruction)
;5065	;		W3	=	packup state (if state<3> = 1 from string instruction)
;5066	;
;5067	;	Exit conditions:
;5068	;		Q, W1 trashed
;5069	;		W4, W5 preserved
;5070	;		state<3> cleared
;5071	;		state<2:0> cleared only on call to IE.CLEANUP.CPU.NO.PACKUP (see CHMX.PROBEX.MM.FAULT)
;5072	;		pending EM latch stores have completed.
;5073	;		PA queue flushed.
;5074	;		Mbox restarted.
;5075	;		RLOG unwind complete.
;5076	;		PC queue is flushed.
;5077	;		Ibox stopped, waiting for LOAD PC, RESTART IBOX.
;5078	;		PSL	=	old PSL after being masked with Q
;5079	;		SAVEPC	=	backed up PC
;5080	;
;5081	;	Note:	W4, W5 must be preserved by this routine and by all
;5082	;		instruction specific cleanup routines.
;5083
				;5084	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  159
;    INTEXC.MIC 	     CPU Cleanup Subroutine								      /REV=
;															     INTEXC
				;5085
				;5086	;	CPU cleanup routine.
				;5087
				;5088	IE.CLEANUP.CPU.NO.PACKUP:
				;5089		;---------------------------------------;
E 2D5  0000,0000,2008,02D7 J 2D7;5090		STATE.3-0 <-- 0 			; disable packup of instruction
				;5091							; >> potential RESET CPU last cycle:
				;5092							; >> no Wn write or MRQ this cycle
				;5093							; >> no PSL read this cycle
				;5094							; >> no state<3> restriction after RESET CPU
				;5095
				;5096	IE.CLEANUP.CPU:
				;5097		;---------------------------------------;
				;5098		VA <-- K10.[IPR.BPC.UNWIND], LONG,	; load BPC/unwind IPR address
				;5099							; >> potential RESET CPU last cycle:
				;5100							; >> no Wn write or MRQ this cycle
				;5101							; >> no PSL read this cycle
E 2D7  0080,3AE1,2001,0519 J 519;5102			sim addr [k]
				;5103
				;5104		;---------------------------------------;
				;5105		[PSL] <-- [PSL] ANDNOT [Q], LONG,	; clear PSL bits based on mask
E 519  6480,0050,30C0,4B7D B 57D;5106		CASE [STATE.5-3] AT [IE.CLEANUP.CPU.NORMAL] ; need to packup state?
				;5107
				;5108	;= ALIGNLIST	110x	(IE.CLEANUP.CPU.NORMAL, IE.CLEANUP.CPU.PACKUP)
				;5109
				;5110	;	Normal cleanup, or end of queue instruction packup.  There may
				;5111	;	still be a store in the EM latch, and the PA queue may not be
				;5112	;	flushed until the store has completed.	The Ibox IPR read of BPC
				;5113	;	stalls in S4 until a store has cleared the EM latch.  At that
				;5114	;	point, the PA queue may be flushed and the Mbox restartd.
				;5115
				;5116	IE.CLEANUP.CPU.NORMAL:
				;5117		;---------------------------------------;
				;5118		[W1] <-- MEM.PR (VA), LONG,		; unwind RLOG, read BPC, sync
				;5119							; with possible EM latch store;
				;5120		FLUSH PA QUEUE, 			; flush the PA queue,
E 57D  1054,0400,0804,82E0 J 2E0;5121		RESTART MBOX				; and restart the Mbox
				;5122
				;5123	;	The PC queue flush is delayed until the Ibox returns the IPR
				;5124	;	read data to the working register.
				;5125
				;5126		;---------------------------------------;
				;5127		[SAVEPC] <-- [W1], LONG,		; wait for Ibox, return BPC in SAVEPC
				;5128		FLUSH PC QUEUE, 			; and then flush the PC queue
E 2E0  1003,0000,A020,0800 R	;5129		RETURN					; return to caller
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  160
;    INTEXC.MIC 	     CPU Cleanup Subroutine								      /REV=
;															     INTEXC
				;5130
				;5131	;	CPU cleanup, continued.
				;5132	;	Special packup needed, go to packup routine based on opcode.
				;5133	;
				;5134	;	At this point,
				;5135	;		W0	=	address of header (queue), character (string)
				;5136	;		W3	=	used in MOVCx packup.
				;5137	;		RN.MODE.OPCODE = current opcode.
				;5138	;
				;5139	;	Opcode<6> can be used to distinguish the string instructions from the
				;5140	;		queue instructions.
				;5141	;
				;5142	;		MOVC3	=	28	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5143	;		CMPC3	=	29	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5144	;		SCANC	=	2A	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5145	;		SPANC	=	2B	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5146	;		MOVC5	=	2C	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5147	;		CMPC5	=	2D	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5148	;		LOCC	=	3A	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5149	;		SKPC	=	3B	-->	IE.CLEANUP.CPU.STRING and STRING.PACK
				;5150	;		INSQHI	=	5C	-->	IE.CLEANUP.CPU.QUEUE
				;5151	;		INSQTI	=	5D	-->	IE.CLEANUP.CPU.QUEUE
				;5152	;		REMQHI	=	5E	-->	IE.CLEANUP.CPU.QUEUE
				;5153	;		REMQTI	=	5F	-->	IE.CLEANUP.CPU.QUEUE
				;5154
				;5155	IE.CLEANUP.CPU.PACKUP:
				;5156		;---------------------------------------;
E 57F  0003,D078,2000,02E4 J 2E4;5157		Q <-- ZEXT [RN.MODE.OPCODE] RSH [16.]	; extract opcode for test
				;5158
				;5159		;---------------------------------------;
				;5160		VA <-- K10.[IPR.BPC], LONG,		; load BPC IPR address for string
				;5161		ACCESS A [Q],				; test opcode<6>
E 2E4  0080,3AC1,20A1,0520 J 520;5162			sim addr [k]
				;5163
				;5164		;---------------------------------------;
			    p162;5165		Q <-- [W0] LSH [24.], LONG,		; position match character for string
E 520  A003,5800,2010,458A B 58A;5166		CASE [A.7-5] AT [IE.CLEANUP.CPU.STRING] ; case on string vs. queue
				;5167
				;5168	;= ALIGNLIST	101x	(IE.CLEANUP.CPU.STRING, IE.CLEANUP.CPU.QUEUE)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  161
;    INTEXC.MIC 	     CPU Cleanup Subroutine								      /REV=
;															     INTEXC
				;5169
				;5170	;	CPU cleanup, continued.
				;5171	;	Process exception in interlocked queue instruction.
				;5172	;
				;5173	;	At this point,
				;5174	;		W0	=	address of queue header
				;5175
				;5176	IE.CLEANUP.CPU.QUEUE:
				;5177		;---------------------------------------; opcode<6> = 1 --> queue:
				;5178		VA <-- [W0],				; VA <-- H
				;5179		[W3] <-- MEM.LOCK (VA), LONG,		; read header, acquire hardware interlock
				;5180		STATE.3-0 <-- 0,			; clear state<3> before mem ref
				;5181							; >> no state<3> restriction after RESET CPU
E 58E  004C,0001,1018,0350 J 350;5182			sim addr [queue.1]
				;5183
				;5184		;---------------------------------------;
				;5185		MEM.UNLOCK (VA)&, [WBUS] <-- [W3] ANDNOT 000000[01], ; release secondary interlock
E 350  04EC,2008,2040,0352 J 352;5186		LONG					; update header
				;5187
				;5188		;---------------------------------------;
				;5189		VA <-- K10.[IPR.BPC.UNWIND], LONG,	; load BPC/unwind IPR address
			    p159;5190		GOTO [IE.CLEANUP.CPU.NORMAL],		; join normal cleanup flow
E 352  0080,3AE1,2001,057D J 57D;5191			sim addr [k]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  162
;    INTEXC.MIC 	     CPU Cleanup Subroutine								      /REV=
;															     INTEXC
				;5192
				;5193	;	CPU cleanup, continued.
				;5194	;	Process exception in string instruction.
				;5195	;
				;5196	;	At this point,
				;5197	;		VA	=	IPR.BPC
				;5198	;		Q<31:24> =	character or mask.
				;5199	;		W3	=	used in MOVCx packup.
				;5200	;
				;5201
				;5202	;	There may still be a store in the EM latch, and the PA queue
				;5203	;	may not be flushed until the store has completed.  The Ibox IPR
				;5204	;	read of BPC stalls in S4 until a store has cleared the EM latch.
				;5205	;	At that point, the PA queue may be flushed.
				;5206
				;5207	IE.CLEANUP.CPU.STRING:
				;5208		;---------------------------------------; opcode<6> = 0 --> string:
				;5209		[W1] <-- MEM.PR (VA), LONG,		; read BPC, sync
				;5210							; with possible EM latch store;
E 58A  1054,0400,0800,0354 J 354;5211		FLUSH PA QUEUE				; flush the PA queue,
				;5212
				;5213	;	Once the Ibox has returned BPC, the instruction is retired so that
				;5214	;	the PC of the instruction after the string instruction is visible.
				;5215	;	A second read of BPC returns this value, and we now have both the
				;5216	;	PC of the string instruction, and the PC of the following instruction.
				;5217
				;5218		;---------------------------------------;
				;5219		[SAVEPC] <-- [W1], LONG,		; wait for Ibox, return BPC in SAVEPC
E 354  1000,4000,A020,035A J 35A;5220		RETIRE INSTRUCTION			; retire rlog and PC queue resources
				;5221
				;5222		;---------------------------------------;
				;5223		VA <-- K10.[IPR.BPC.UNWIND], LONG,	; load BPC/unwind IPR address
E 35A  00D4,3AE1,0C01,0367 J 367;5224		[W2] <-- MEM.PR (VA), LONG		; unwind RLOG, read PC
				;5225
				;5226	;	The PC queue flush is delayed until the Ibox returns the IPR
				;5227	;	read data to the working register.  The second RESET CPU is required
				;5228	;	because the RETIRE INSTRUCTION left the instruction queue in an
				;5229	;	inconsistent state.
				;5230
				;5231		;---------------------------------------;
				;5232		ACCESS B [W2],				; wait for PC read to complete
				;5233		FLUSH PC QUEUE, 			; and flush the PC queue
			    p553;5234		RESET CPU,				; reset the corrupt instruction queue
E 367  1003,0018,2006,05A4 J 5A4;5235		GOTO [STRING.PACK]			; join common string flow, then return
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  163
;    INTEXC.MIC 	     CPU Cleanup Subroutine								      /REV=
;															     INTEXC
				;5236
				;5237	;	Subroutines to delay a specified number of cycles
				;5238	;	before returning to the caller.
				;5239
				;5240	WAIT.23.CYCLES:
				;5241		;---------------------------------------;
E 2B4  0000,0000,2000,22B5 S 2B5;5242		CALL [WAIT.11.CYCLES]			; wait 11, fall thru
				;5243
				;5244	WAIT.11.CYCLES:
				;5245		;---------------------------------------;
E 2B5  0000,0000,2000,22B6 S 2B6;5246		CALL [WAIT.5.CYCLES]			; wait 5, fall thru
				;5247
				;5248	WAIT.5.CYCLES:
				;5249		;---------------------------------------;
E 2B6  0000,0000,2000,22B7 S 2B7;5250		CALL [WAIT.TWO.CYCLES]			; wait 2, fall thru
				;5251
				;5252	WAIT.TWO.CYCLES:
			    p276;5253		;---------------------------------------;
E 2B7  0000,0000,2000,0497 J 497;5254		GOTO [WAIT.ONE.CYCLE]
				;5255
				;5256	;= END INTEXC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  164
; INTLOGADR.MIC 	     INTLOGADR.MIC -- Integer, Logical, and Address Class Instructions			      /REV=
;
				;5257	.TOC	"INTLOGADR.MIC -- Integer, Logical, and Address Class Instructions"
				;5258	.TOC	"Revision 1.0"
				;5259
				;5260	;	Bob Supnik
				;5261
;5262	.nobin
;5263	;****************************************************************************
;5264	;*									    *
;5265	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;5266	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;5267	;*  ALL RIGHTS RESERVED.						    *
;5268	;*									    *
;5269	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;5270	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;5271	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;5272	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;5273	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;5274	;*  TRANSFERRED.							    *
;5275	;*									    *
;5276	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;5277	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;5278	;*  CORPORATION.							    *
;5279	;*									    *
;5280	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;5281	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;5282	;*									    *
;5283	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  165
; INTLOGADR.MIC 	     Revision History									      /REV=
;
;5284	.TOC	"	Revision History"
;5285
;5286	; Edit	  Date	 Who	     Description
;5287	; ---- --------- ---	---------------------
;5288	; (1)0 18-Jul-90 GMU	Initial production microcode.
;5289	;
;5290	; Begin version 1.0 here
;5291	;   11 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;5292	;   10 01-May-90 GMU	Uncomment references to CWB IPR.
;5293	;    9 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;5294	;    8 29-Mar-90 DGM	Optimize ASHL flow for left 0-31
;5295	;    7 21-Mar-90 DGM	Update comments
;5296	;    6 16-Jan-90 DGM	Change field queue alignment
;5297	;    5	3-Jan-90 DGM	Remove all ALU SEXT and ZEXT functions
;5298	;    4 30-Nov-89 GMU	Convert ADWC/SBWC flows to avoid ALU functions that
;5299	;			use PSL<C> carry-in.
;5300	;    3 19-Oct-89 GMU	Add CWB to ADAWI with register destination.
;5301	;    2 24-AUG-89 GMU	Fix PSL condition code sets for second LW of MOVQ.
;5302	;    1 17-Aug-89 GMU	convert split dispatch for ADAWI to use field queue.
;5303	; (0)0 15-Jul-87 RMS	Trial microcode.
;5304
				;5305	.bin
				;5306	;= BEGIN INTLOG
;5307	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  166
; INTLOGADR.MIC 	     Revision History									      /REV=
;															     INTLOG
;5308
;5309	;	This module implements the integer and logical class, and address class, instructions,
;5310	;	except for multiply and divide.  The instructions in these classes are:
;5311	;
;5312	;
;5313	;	Integer and Logical Instructions
;5314	;
;5315	;	Opcode	 Instruction							N Z V C 	Exceptions
;5316	;	------	 -----------							------- 	----------
;5317	;
;5318	;	58	 ADAWI add.rw, sum.mw						* * * * 	iov
;5319	;
;5320	;	80	 ADDB2 add.rb, sum.mb						* * * * 	iov
;5321	;	C0	 ADDL2 add.rl, sum.ml						* * * * 	iov
;5322	;	A0	 ADDW2 add.rw, sum.mw						* * * * 	iov
;5323	;
;5324	;	81	 ADDB3 add1.rb, add2.rb, sum.wb 				* * * * 	iov
;5325	;	C1	 ADDL3 add1.rl, add2.rl, sum.wl 				* * * * 	iov
;5326	;	A1	 ADDW3 add1.rw, add2.rw, sum.ww 				* * * * 	iov
;5327	;
;5328	;	D8	 ADWC add.rl, sum.ml						* * * * 	iov
;5329	;
;5330	;	78	 ASHL cnt.rb, src.rl, dst.wl					* * * 0 	iov
;5331	;	79	 ASHQ cnt.rb, src.rq, dst.wq					* * * 0 	iov
;5332	;
;5333	;	8A	 BICB2 mask.rb, dst.mb						* * 0 -
;5334	;	CA	 BICL2 mask.rl, dst.ml						* * 0 -
;5335	;	AA	 BICW2 mask.rw, dst.mw						* * 0 -
;5336	;
;5337	;	8B	 BICB3 mask.rb, src.rb, dst.wb					* * 0 -
;5338	;	CB	 BICL3 mask.rl, src.rl, dst.wl					* * 0 -
;5339	;	AB	 BICW3 mask.rw, src.rw, dst.ww					* * 0 -
;5340	;
;5341	;	88	 BISB2 mask.rb, dst.mb						* * 0 -
;5342	;	C8	 BISL2 mask.rl, dst.ml						* * 0 -
;5343	;	A8	 BISW2 mask.rw, dst.mw						* * 0 -
;5344	;
;5345	;	89	 BISB3 mask.rb, src.rb, dst.wb					* * 0 -
;5346	;	C9	 BISL3 mask.rl, src.rl, dst.wl					* * 0 -
;5347	;	A9	 BISW3 mask.rw, src.rw, dst.ww					* * 0 -
;5348	;
;5349	;	93	 BITB mask.rb, src.rb						* * 0 -
;5350	;	D3	 BITL mask.rl, src.rl						* * 0 -
;5351	;	B3	 BITW mask.rw, src.rw						* * 0 -
;5352	;
;5353	;	94	 CLRB dst.wb							0 1 0 -
;5354	;	D4	 CLRL{=F} dst.wl						0 1 0 -
;5355	;	7C	 CLRQ{=D=G} dst.wq						0 1 0 -
;5356	;	B4	 CLRW dst.ww							0 1 0 -
;5357	;
;5358	;	91	 CMPB src1.rb, src2.rb						* * 0 *
;5359	;	D1	 CMPL src1.rl, src2.rl						* * 0 *
;5360	;	B1	 CMPW src1.rw, src2.rw						* * 0 *
;5361	;
;5362	;	98	 CVTBL src.rb, dst.wl						* * 0 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  167
; INTLOGADR.MIC 	     Revision History									      /REV=
;															     INTLOG
;5363	;	99	 CVTBW src.rb, dst.wl						* * 0 0
;5364	;	F6	 CVTLB src.rl, dst.wb						* * * 0 	iov
;5365	;	F7	 CVTLW src.rl, dst.ww						* * * 0 	iov
;5366	;	33	 CVTWB src.rw, dst.wb						* * * 0 	iov
;5367	;	32	 CVTWL src.rw, dst.wl						* * 0 0
;5368	;
;5369	;	97	 DECB dif.mb							* * * * 	iov
;5370	;	D7	 DECL dif.ml							* * * * 	iov
;5371	;	B7	 DECW dif.mw							* * * * 	iov
;5372	;
;5373	;	96	 INCB sum.mb							* * * * 	iov
;5374	;	D6	 INCL sum.ml							* * * * 	iov
;5375	;	B6	 INCW sum.mw							* * * * 	iov
;5376	;
;5377	;	92	 MCOMB src.rb, dst.wb						* * 0 -
;5378	;	D2	 MCOML src.rl, dst.wl						* * 0 -
;5379	;	B2	 MCOMW src.rw, dst.ww						* * 0 -
;5380	;
;5381	;	8E	 MNEGB src.rb, dst.wb						* * * * 	iov
;5382	;	CE	 MNEGL src.rl, dst.wl						* * * * 	iov
;5383	;	AE	 MNEGW src.rw, dst.ww						* * * * 	iov
;5384	;
;5385	;	90	 MOVB src.rb, dst.wb						* * 0 -
;5386	;	D0	 MOVL src.rl, dst.wl						* * 0 -
;5387	;	7D	 MOVQ src.rq, dst.wq						* * 0 -
;5388	;	B0	 MOVW src.rw, dst.ww						* * 0 -
;5389	;
;5390	;	9A	 MOVZBW src.rb, dst.wb						0 * 0 -
;5391	;	9B	 MOVZBL src.rb, dst.wl						0 * 0 -
;5392	;	3C	 MOVZWL src.rw, dst.ww						0 * 0 -
;5393	;
;5394	;	DD	 PUSHL src.rl, {-(SP).wl}					* * 0 -
;5395	;
;5396	;	9C	 ROTL cnt.rb, src.rl, dst.wl					* * 0 -
;5397	;
;5398	;	D9	 SBWC sub.rl, dif.ml						* * * * 	iov
;5399	;
;5400	;	82	 SUBB2 sub.rb, dif.mb						* * * * 	iov
;5401	;	C2	 SUBL2 sub.rl, dif.ml						* * * * 	iov
;5402	;	A2	 SUBW2 sub.rw, dif.mw						* * * * 	iov
;5403	;
;5404	;	83	 SUBB3 sub.rb, min.rb, dif.wb					* * * * 	iov
;5405	;	C3	 SUBL3 sub.rl, min.rl, dif.wl					* * * * 	iov
;5406	;	A3	 SUBW3 sub.rw, min.rw, dif.ww					* * * * 	iov
;5407	;
;5408	;	95	 TSTB src.rb							* * 0 0
;5409	;	D5	 TSTL src.rl							* * 0 0
;5410	;	B5	 TSTW src.rw							* * 0 0
;5411	;
;5412	;	8C	 XORB2 mask.rb, dst.mb						* * 0 -
;5413	;	CC	 XORL2 mask.rl, dst.ml						* * 0 -
;5414	;	AC	 XORW2 mask.rw, dst.mw						* * 0 -
;5415	;
;5416	;	8D	 XORB3 mask.rb, src.rb, dst.wb					* * 0 -
;5417	;	CD	 XORL3 mask.rl, src.rl, dst.wl					* * 0 -
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  168
; INTLOGADR.MIC 	     Revision History									      /REV=
;															     INTLOG
;5418	;	AD	 XORW3 mask.rw, src.rw, dst.ww					* * 0 -
;5419	;
;5420	;
;5421	;	Address Instructions
;5422	;
;5423	;	Opcode	 Instruction							N Z V C 	Exceptions
;5424	;	------	 -----------							------- 	----------
;5425	;
;5426	;	9E	 MOVAB src.ab, dst.wl						* * 0 -
;5427	;	DE	 MOVAL{=F} src.al, dst.wl					* * 0 -
;5428	;	7E	 MOVAQ{=D=G} src.aq, dst.wl					* * 0 -
;5429	;	3E	 MOVAW src.aw, dst.wl						* * 0 -
;5430	;
;5431	;	9F	 PUSHAB src.ab, {-(SP).wl}					* * 0 -
;5432	;	DF	 PUSHAL{=F} src.al, {-(SP).wl}					* * 0 -
;5433	;	7F	 PUSHAQ{=D=G} src.aq, {-(SP).wl}				* * 0 -
;5434	;	3F	 PUSHAW src.aw, {-(SP).wl}					* * 0 -
;5435	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  169
; INTLOGADR.MIC 	     TSTx										      /REV=
;															     INTLOG
;5436	.TOC	"	TSTx"
;5437
;5438	;	These instructions test the source operand against zero.
;5439	;
;5440	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;5441	;	--------      ------	---------				----	-----		--------
;5442	;	TSTB		95	src.rb - 0				1	r/b		TSTX..
;5443	;	TSTW		B5	src.rw - 0				1	r/w		TSTX..
;5444	;	TSTL		D5	src.rl - 0				1	r/l		TSTX..
;5445	;
;5446	;	Entry conditions:
;5447	;		source queue	=	src.rx operand
;5448	;		dest queue	=	none
;5449	;		branch queue	=	none
;5450	;		field queue	=	none
;5451	;		DL		=	data length of first operand
;5452	;		Ibox state	=	running
;5453	;		Mbox state	=	running
;5454	;
;5455	;	Exit conditions:
;5456	;		The PSL condition codes are set.
;5457	;
;5458	;	Condition codes:
;5459	;		N <-- dst lss 0
;5460	;		Z <-- dst eql 0
;5461	;		V <-- 0 		[Integer overflow trap disabled.]
;5462	;		C <-- 0
;5463	;
				;5464	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  170
; INTLOGADR.MIC 	     TSTx										      /REV=
;															     INTLOG
				;5465
				;5466	;	TSTx operation:
				;5467	;
				;5468	;		src.rx - 0
				;5469
				;5470	TSTX..:
				;5471		;********** Hardware dispatch **********;
				;5472		[WBUS] <-- [S1], LEN(DL),		; src operand to Wbus for test
				;5473		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 102  0000,0004,208D,1000 L	;5474		LAST CYCLE				; decode next instruction
				;5475
;5476	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  171
; INTLOGADR.MIC 	     INCx, DECx 									      /REV=
;															     INTLOG
;5477	.TOC	"	INCx, DECx"
;5478
;5479	;	These instructions increment or decrement the destination operand.
;5480	;
;5481	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;5482	;	--------      ------	---------				----	-----		--------
;5483	;	INCB		96	dst.mb <-- dst.mb + 1			1	m/b		INCX..
;5484	;	INCW		B6	dst.mw <-- dst.mw + 1			1	m/w		INCX..
;5485	;	INCL		D6	dst.ml <-- dst.ml + 1			1	m/l		INCX..
;5486	;
;5487	;	DECB		97	dst.mb <-- dst.mb - 1			1	m/b		DECX..
;5488	;	DECW		B7	dst.mw <-- dst.mw - 1			1	m/w		DECX..
;5489	;	DECL		D7	dst.ml <-- dst.ml - 1			1	m/l		DECX..
;5490	;
;5491	;	Entry conditions:
;5492	;		source queue	=	dst.mx operand
;5493	;		dest queue	=	dst.mx result
;5494	;		branch queue	=	none
;5495	;		field queue	=	none
;5496	;		DL		=	data length of first operand
;5497	;		Ibox state	=	running
;5498	;		Mbox state	=	running
;5499	;
;5500	;	Exit conditions:
;5501	;		The PSL condition codes are set.
;5502	;		The result has been stored in the destination memory location or register.
;5503	;
;5504	;	Condition codes:
;5505	;		(INCx)			(DECx)
;5506	;		N <-- dst lss 0 	N <-- dst lss 0
;5507	;		Z <-- dst eql 0 	Z <-- dst eql 0
;5508	;		V <-- overflow		V <-- overflow		[Integer overflow trap enabled.]
;5509	;		C <-- carry out 	C <-- borrow out
;5510	;
				;5511	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  172
; INTLOGADR.MIC 	     INCx, DECx 									      /REV=
;															     INTLOG
				;5512
				;5513	;	INCx operation:
				;5514	;
				;5515	;		dst.mx <-- dst.mx + 1
				;5516
				;5517	INCX..:
				;5518		;********** Hardware dispatch **********;
				;5519		[DST] <-- [S1] + 1, LEN(DL),		; increment operand, store
				;5520		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 120  0800,0004,248D,1800 L	;5521		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5522
				;5523
				;5524	;	DECx operation:
				;5525	;
				;5526	;		dst.mx <-- dst.mx - 1
				;5527
				;5528	DECX..:
				;5529		;********** Hardware dispatch **********;
				;5530		[DST] <-- [S1] - 1, LEN(DL),		; decrement operand, store
				;5531		SET PSL CC.IIIJ,			; set psl cc's, psl map is iiij
E 122  0B00,0004,248D,9800 L	;5532		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5533
;5534	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  173
; INTLOGADR.MIC 	     CLRx										      /REV=
;															     INTLOG
;5535	.TOC	"	CLRx"
;5536
;5537	;	These instructions clear the destination operand.
;5538	;
;5539	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;5540	;	--------      ------	---------				----	-----		--------
;5541	;	CLRB		94	dst.wb <-- 0				1	w/b		CLRX..
;5542	;	CLRW		B4	dst.ww <-- 0				1	w/w		CLRX..
;5543	;	CLRL		D4	dst.wl <-- 0				1	w/l		CLRX..
;5544	;	CLRQ		7C	dst.wq <-- 0				1	w/q		CLRQ..
;5545	;
;5546	;	Entry conditions:
;5547	;		source queue	=	none
;5548	;		dest queue	=	dst.wx result
;5549	;		branch queue	=	none
;5550	;		field queue	=	none
;5551	;		DL		=	data length of first operand
;5552	;		Ibox state	=	running
;5553	;		Mbox state	=	running
;5554	;
;5555	;	Exit conditions:
;5556	;		The PSL condition codes are set.
;5557	;		The result has been stored in the destination memory location or register.
;5558	;
;5559	;	Condition codes:
;5560	;		N <-- 0
;5561	;		Z <-- 1
;5562	;		V <-- 0 		[Integer overflow trap enabled.]
;5563	;		C <-- C
;5564	;
				;5565	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  174
; INTLOGADR.MIC 	     CLRx										      /REV=
;															     INTLOG
				;5566
				;5567	;	CLRx operation:
				;5568	;
				;5569	;		dst.wx <-- 0
				;5570
				;5571	CLRX..:
				;5572		;********** Hardware dispatch **********;
				;5573		Q&, [DST] <-- PASSB 000000[00], 	; write zero to destination, set shift latch
				;5574		LEN(DL),				;
				;5575		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 10C  0002,A006,240C,1000 L	;5576		LAST CYCLE				; decode next instruction
				;5577
				;5578	CLRQ..:
				;5579		;********** Hardware dispatch **********;
				;5580		Q&, [DST] <-- PASSB 000000[00], 	; write zero to destination, set shift latch
				;5581		LEN(DL),				;
E 10E  0002,A006,240C,0376 J 376;5582		SET PSL CC.IIIP 			; set psl cc's, default map is iiip
				;5583
				;5584	WRITE.QW:
				;5585		;---------------------------------------;
				;5586		[DST] <-- [Q], LONG,			; write high result to destination
E 376  0000,0000,24A0,1000 L	;5587		LAST CYCLE				; decode next instruction
				;5588
;5589	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  175
; INTLOGADR.MIC 	     CMPx, BITx 									      /REV=
;															     INTLOG
;5590	.TOC	"	CMPx, BITx"
;5591
;5592	;	These instructions operate on two read only sources.
;5593	;
;5594	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;5595	;	--------      ------	---------				----	-----		--------
;5596	;	CMPB		91	src1.rb - src2.rb			2	rr/bb		CMPI..
;5597	;	CMPW		B1	src1.rw - src2.rw			2	rr/ww		CMPI..
;5598	;	CMPL		D1	src1.rl - src2.rl			2	rr/ll		CMPI..
;5599	;
;5600	;	BITB		93	src1.rb and src2.rb			2	rr/bb		BITX..
;5601	;	BITW		B3	src1.rw and src2.rw			2	rr/ww		BITX..
;5602	;	BITL		D3	src1.rl and src2.rl			2	rr/ll		BITX..
;5603	;
;5604	;	Entry conditions:
;5605	;		source queue	=	src1.rx operand
;5606	;					src2.rx operand
;5607	;		dest queue	=	none
;5608	;		branch queue	=	none
;5609	;		field queue	=	none
;5610	;		DL		=	data length of second operand
;5611	;		Ibox state	=	running
;5612	;		Mbox state	=	running
;5613	;
;5614	;	Exit conditions:
;5615	;		The PSL condition codes are set.
;5616	;
;5617	;	Condition codes:
;5618	;		(CMPx)			(BITx)
;5619	;		N <-- src1 lss src2	N <-- dst lss 0
;5620	;		Z <-- src1 eql src2	Z <-- dst eql 0
;5621	;		V <-- 0 		V <-- 0 		[Integer overflow trap disabled.]
;5622	;		C <-- src1 lssu src2	C <-- C
;5623	;
				;5624	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  176
; INTLOGADR.MIC 	     CMPx, BITx 									      /REV=
;															     INTLOG
				;5625
				;5626	;	CMPx operation:
				;5627	;
				;5628	;		src1.rx - src2.rx
				;5629
				;5630	CMPI..:
				;5631		;********** Hardware dispatch **********;
				;5632		[WBUS] <-- [S1] - [S2], LEN(DL),	; compare operands, result to Wbus
				;5633		SET PSL CC.JIZJ,			; set psl cc's, psl map is jizj
E 106  0A80,004C,208C,9000 L	;5634		LAST CYCLE				; decode next instruction
				;5635
				;5636
				;5637	;	BITx operation:
				;5638	;
				;5639	;		src1.rx and src2.rx
				;5640
				;5641	BITX..:
				;5642		;********** Hardware dispatch **********;
				;5643		[WBUS] <-- [S1] AND [S2], LEN(DL),	; and operands, result to Wbus
				;5644		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 104  0400,004C,208C,1000 L	;5645		LAST CYCLE				; decode next instruction
				;5646
;5647	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  177
; INTLOGADR.MIC 	     ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC					      /REV=
;															     INTLOG
;5648	.TOC	"	ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC"
;5649
;5650	;	These two operand versions of these instructions operate on a source operand and a destination operand,
;5651	;	and store the result in the destination operand.
;5652	;
;5653	;	The three operand versions of these instructions operate on two source operands, and store the result
;5654	;	in the destination operand.
;5655	;
;5656	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;5657	;	--------      ------	---------				----	-----		--------
;5658	;	ADDB2		80	dst.mb <-- src.rb + dst.mb		2	rm/bb		ADDIN..
;5659	;	ADDW2		A0	dst.mw <-- src.rw + dst.mw		2	rm/ww		ADDIN..
;5660	;	ADDL2		C0	dst.ml <-- src.rl + dst.ml		2	rm/ll		ADDIN..
;5661	;	ADDB3		81	dst.wb <-- src1.rb + src2.rb		3	rrw/bbb 	ADDIN..
;5662	;	ADDW3		A1	dst.ww <-- src1.rw + src2.rw		3	rrw/www 	ADDIN..
;5663	;	ADDL3		C1	dst.wl <-- src1.rl + src2.rl		3	rrw/lll 	ADDIN..
;5664	;
;5665	;	SUBB2		82	dst.mb <-- dst.mb - src.rb		2	rm/bb		SUBIN..
;5666	;	SUBW2		A2	dst.mw <-- dst.mw - src.rw		2	rm/ww		SUBIN..
;5667	;	SUBL2		C2	dst.ml <-- dst.ml - src.rl		2	rm/ll		SUBIN..
;5668	;	SUBB3		83	dst.wb <-- src2.rb - src1.rb		3	rrw/bbb 	SUBIN..
;5669	;	SUBW3		A3	dst.ww <-- src2.rw - src1.rw		3	rrw/www 	SUBIN..
;5670	;	SUBL3		C3	dst.wl <-- src2.rl - src1.rl		3	rrw/lll 	SUBIN..
;5671	;
;5672	;	BISB2		88	dst.mb <-- src.rb or dst.mb		2	rm/bb		BISXN..
;5673	;	BISW2		A8	dst.mw <-- src.rw or dst.mw		2	rm/ww		BISXN..
;5674	;	BISL2		C8	dst.ml <-- src.rl or dst.ml		2	rm/ll		BISXN..
;5675	;	BISB3		89	dst.wb <-- src1.rb or src2.rb		3	rrw/bbb 	BISXN..
;5676	;	BISW3		A9	dst.ww <-- src1.rw or src2.rw		3	rrw/www 	BISXN..
;5677	;	BISL3		C9	dst.wl <-- src1.rl or src2.rl		3	rrw/lll 	BISXN..
;5678	;
;5679	;	BICB2		8A	dst.mb <-- ~src.rb and dst.mb		2	rm/bb		BICXN..
;5680	;	BICW2		AA	dst.mw <-- ~src.rw and dst.mw		2	rm/ww		BICXN..
;5681	;	BICL2		CA	dst.ml <-- ~src.rl and dst.ml		2	rm/ll		BICXN..
;5682	;	BICB3		8B	dst.wb <-- ~src1.rb and src2.rb 	3	rrw/bbb 	BICXN..
;5683	;	BICW3		AB	dst.ww <-- ~src1.rw and src2.rw 	3	rrw/www 	BICXN..
;5684	;	BICL3		CB	dst.wl <-- ~src1.rl and src2.rl 	3	rrw/lll 	BICXN..
;5685	;
;5686	;	XORB2		8C	dst.mb <-- src.rb xor dst.mb		2	rm/bb		XORXN..
;5687	;	XORL2		AC	dst.mw <-- src.rw xor dst.mw		2	rm/ww		XORXN..
;5688	;	XORW2		CC	dst.ml <-- src.rl xor dst.ml		2	rm/ll		XORXN..
;5689	;	XORB3		8D	dst.wb <-- src1.rb xor src2.rb		3	rrw/bbb 	XORXN..
;5690	;	XORL3		AD	dst.ww <-- src1.rw xor src2.rw		3	rrw/www 	XORXN..
;5691	;	XORW3		CD	dst.wl <-- src1.rl xor src2.rl		3	rrw/lll 	XORXN..
;5692	;
;5693	;	ADWC		D8	dst.ml <-- src.rl + dst.ml + C		2	rm/ll		ADWC.SBWC..
;5694	;
;5695	;	SBWC		D9	dst.ml <-- dst.ml - src.rl - C		2	rm/ll		ADWC.SBWC..
;5696	;
;5697	;	Entry conditions:	      (2 operands)  (3 operands)
;5698	;		source queue	=	src.rx	 or   src1.rx	operand
;5699	;					dst.mx	 or   src2.rx	operand
;5700	;		dest queue	=	dst.mx	 or   dst.wx	result
;5701	;		branch queue	=	none
;5702	;		field queue	=	none
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  178
; INTLOGADR.MIC 	     ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC					      /REV=
;															     INTLOG
;5703	;		DL		=	data length of destination operand
;5704	;		Ibox state	=	running
;5705	;		Mbox state	=	running
;5706	;
;5707	;	Exit conditions:
;5708	;		The PSL condition codes are set.
;5709	;		The result has been stored in the destination memory location or register.
;5710	;
;5711	;	Condition codes:
;5712	;		(ADDin, ADWC)		(SUBin, SBWC)
;5713	;		N <-- dst lss 0 	N <-- dst lss 0
;5714	;		Z <-- dst eql 0 	Z <-- dst eql 0
;5715	;		V <-- overflow		V <-- overflow		[Integer overflow trap enabled.]
;5716	;		C <-- carry out 	C <-- borrow out
;5717	;
;5718	;		(BISxn, BICxn, XORxn)
;5719	;		N <-- dst lss 0
;5720	;		Z <-- dst eql 0
;5721	;		V <-- 0 					[Integer overflow disabled.]
;5722	;		C <-- C
;5723	;
				;5724	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  179
; INTLOGADR.MIC 	     ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC					      /REV=
;															     INTLOG
				;5725
				;5726	;	ADDin operation:
				;5727	;
				;5728	;		dst.mx <-- dst.mx + src.rx		(ADDi2)
				;5729	;		dst.wx <-- src2.rx + src1.rx		(ADDi3)
				;5730
				;5731	ADDIN..:
				;5732		;********** Hardware dispatch **********;
				;5733		[DST] <-- [S1] + [S2], LEN(DL), 	; compute result, write to destination
				;5734		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 118  0880,004C,248D,1800 L	;5735		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5736
				;5737
				;5738	;	SUBin operation:
				;5739	;
				;5740	;		dst.mx <-- dst.mx - src.rx		(SUBi2)
				;5741	;		dst.wx <-- src2.rx - src1.rx		(SUBi3)
				;5742
				;5743	SUBIN..:
				;5744		;********** Hardware dispatch **********;
				;5745		[DST] <-- (-[S1] + [S2]), LEN(DL),	; compute result, write to destination
				;5746		SET PSL CC.IIIJ,			; set psl cc's, psl map is iiij
E 11A  0A00,004C,248D,9800 L	;5747		LAST CYCLE CHECK OVERFLOW		; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  180
; INTLOGADR.MIC 	     ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC					      /REV=
;															     INTLOG
				;5748
				;5749	;	BISxn operation:
				;5750	;
				;5751	;		dst.mx <-- dst.mx or src.rx		(BISx2)
				;5752	;		dst.wx <-- src2.rx or src1.rx		(BISx3)
				;5753
				;5754	BISXN..:
				;5755		;********** Hardware dispatch **********;
				;5756		[DST] <-- [S1] OR [S2], LEN(DL),	; compute result, write to destination
				;5757		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 128  0500,004C,248C,1000 L	;5758		LAST CYCLE				; decode next instruction
				;5759
				;5760
				;5761	;	BICxn operation:
				;5762	;
				;5763	;		dst.mx <-- dst.mx andnot src.rx 	(BICx2)
				;5764	;		dst.wx <-- src2.rx andnot src1.rx	(BICx3)
				;5765
				;5766	BICXN..:
				;5767		;********** Hardware dispatch **********;
				;5768		[DST] <-- [S2] ANDNOT [S1], LEN(DL),	; compute result, write to destination
				;5769		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 12A  0480,0044,249C,1000 L	;5770		LAST CYCLE				; decode next instruction
				;5771
				;5772
				;5773	;	XORxn operation:
				;5774	;
				;5775	;		dst.mx <-- dst.mx xor src.rx		(XORx2)
				;5776	;		dst.wx <-- src2.rx xor src1.rx		(XORx3)
				;5777
				;5778	XORXN..:
				;5779		;********** Hardware dispatch **********;
				;5780		[DST] <-- [S1] XOR [S2], LEN(DL),	; compute result, write to destination
				;5781		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 12C  0600,004C,248C,1000 L	;5782		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  181
; INTLOGADR.MIC 	     ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC					      /REV=
;															     INTLOG
				;5783
				;5784	;	ADWC operation:
				;5785	;
				;5786	;		dst.ml <-- dst.ml + src.rl + psl.c
				;5787	;
				;5788	;	SBWC operation:
				;5789	;
				;5790	;		dst.ml <-- dst.ml - src.rl - psl.c
				;5791
				;5792	ADWC.SBWC..:
				;5793		;********** Hardware dispatch **********;
				;5794		[W0] <-- [S1], LONG,			; get first operand
E 11C  0002,8048,0480,0378 J 378;5795		Q <-- PASSB [S2]			; get second operand
				;5796							; wait a cycle for psl.c
				;5797
				;5798		;---------------------------------------;
E 378  0400,2008,20C0,0046 J 046;5799		[WBUS] <-- [PSL] AND 000000[01], LONG	; test PSL<C>
				;5800							; >> PSL<C> reference in 2nd cycle OK
				;5801
			    p182;5802		;---------------------------------------;
E 046  8000,0000,2000,4C51 B 051;5803		CASE [OPCODE.2-0] AT [ADWC]		; break into separate opcode flows
				;5804
				;5805	;= ALIGNLIST	xx0x	(ADWC,			SBWC)
				;5806	;  Opcodes = D8, D9 --> opcode<2:0> = 00?
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  182
; INTLOGADR.MIC 	     ADDin, SUBin, BISxn, BICxn, XORxn, ADWC, SBWC					      /REV=
;															     INTLOG
				;5807
				;5808	;	ADWC, SBWC, continued.
				;5809	;	Complete computation.
				;5810	;
				;5811	;	At this point,
				;5812	;		W0	=	first operand
				;5813	;		Q	=	second operand
				;5814	;		ALU.Z	=	0 if PSL<C>=1, 1 if PSL<C>=0
				;5815
				;5816	;	ADWC
				;5817
				;5818	ADWC:
				;5819		;---------------------------------------; opcode<0> = 0:
E 051  2000,0000,2000,4161 B 061;5820		CASE [ALU.NZV] AT [ADWC.C1]		; case on psl<c> value
				;5821
				;5822	;= ALIGNLIST	x0xx	(ADWC.C1,		ADWC.C0)
				;5823	;  ALU.NZV set from AND with 1 --> N = V = 0
				;5824
				;5825	ADWC.C0:
				;5826		;---------------------------------------; alu.z = 1:
				;5827		[DST] <-- [W0] + [Q], LONG,		; compute result, write to destination
				;5828		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 065  0880,0050,241D,1800 L	;5829		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5830
				;5831	ADWC.C1:
				;5832		;---------------------------------------; alu.z = 0:
				;5833		[DST] <-- [W0] + [Q] + 1, LONG, 	; compute result, write to destination
				;5834		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 061  0900,0050,241D,1800 L	;5835		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5836
				;5837	;	SBWC
				;5838
				;5839	SBWC:
				;5840		;---------------------------------------; opcode<0> = 1:
E 053  2000,0000,2000,4171 B 071;5841		CASE [ALU.NZV] AT [SBWC.C1]		; case on psl<c> value
				;5842
				;5843	;= ALIGNLIST	x0xx	(SBWC.C1,		SBWC.C0)
				;5844	;  ALU.NZV set from AND with 1 --> N = V = 0
				;5845
				;5846	SBWC.C0:
				;5847		;---------------------------------------; alu.z = 1:
				;5848		[DST] <-- [Q] - [W0], LONG,		; compute result, write to memory
				;5849		SET PSL CC.IIIJ,			; set psl cc's, psl map is iiij
E 075  0A80,0008,24AD,9800 L	;5850		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5851
				;5852	SBWC.C1:
				;5853		;---------------------------------------; alu.z = 0:
				;5854		[DST] <-- [Q] - [W0] - 1, LONG, 	; compute result, write to memory
				;5855		SET PSL CC.IIIJ,			; set psl cc's, psl map is iiij
E 071  0780,0008,24AD,9800 L	;5856		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5857
;5858	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  183
; INTLOGADR.MIC 	     MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx, MNEGx					      /REV=
;															     INTLOG
;5859	.TOC	"	MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx, MNEGx"
;5860
;5861	;	These instructions move or operate on a source operand and store the result in a destination operand.
;5862	;
;5863	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;5864	;	--------      ------	---------				----	-----		--------
;5865	;	MOVB		90	dst.wb <-- src.rb			2	rw/bb		MOVX..
;5866	;	MOVW		B0	dst.ww <-- src.rw			2	rw/ww		MOVX..
;5867	;	MOVL		D0	dst.wl <-- src.rl			2	rw/ll		MOVX..
;5868	;	MOVQ		7D	dst.wq <-- src.rq			2	rw/qq		MOVQ..
;5869	;
;5870	;	MOVAB		9E	dst.wl <-- src.ab			2	aw/bl		MOVX..
;5871	;	MOVAW		3E	dst.wl <-- src.aw			2	aw/wl		MOVX..
;5872	;	MOVAL		DE	dst.wl <-- src.al			2	aw/ll		MOVX..
;5873	;	MOVAQ		7E	dst.wl <-- src.aq			2	aw/ql		MOVX..
;5874	;
;5875	;	MOVZBL		9A	dst.wl <-- zext(src.rb) 		2	rw/bl		MOVZBX..
;5876	;	MOVZBW		9B	dst.ww <-- zext(src.rb) 		2	rw/bw		MOVZBX..
;5877	;	MOVZWL		3C	dst.wl <-- zext(src.rw) 		2	rw/wl		MOVZWL..
;5878	;
;5879	;	PUSHL		DD	-(sp) <-- src.rl			1	r/l		MOVX..
;5880	;
;5881	;	PUSHAB		9F	-(sp) <-- src.ab			1	a/b		MOVX..
;5882	;	PUSHAW		3F	-(sp) <-- src.aw			1	a/w		MOVX..
;5883	;	PUSHAL		DF	-(sp) <-- src.al			1	a/l		MOVX..
;5884	;	PUSHAQ		7F	-(sp) <-- src.aq			1	a/q		MOVX..
;5885	;
;5886	;	MCOMB		92	dst.wb <-- ~src.rb			2	rw/bb		MCOMX..
;5887	;	MCOMW		B2	dst.ww <-- ~src.rw			2	rw/ww		MCOMX..
;5888	;	MCOML		D2	dst.wl <-- ~src.rl			2	rw/ll		MCOMX..
;5889	;
;5890	;	MNEGB		8E	dst.wb <-- -src.rb			2	rw/bb		MNEGX..
;5891	;	MNEGL		AE	dst.ww <-- -src.rw			2	rw/ww		MNEGX..
;5892	;	MNEGW		CE	dst.wl <-- -src.rl			2	rw/ll		MNEGX..
;5893	;
;5894	;	Entry conditions:
;5895	;		source queue	=	src.rx	or  src.ax operand
;5896	;		dest queue	=	dst.wx	or  (implicit -(sp) specifier)	result
;5897	;		branch queue	=	none
;5898	;		field queue	=	none
;5899	;		DL		=	data length of second operand
;5900	;		Ibox state	=	running
;5901	;		Mbox state	=	running
;5902	;
;5903	;	Exit conditions:
;5904	;		The PSL condition codes are set.
;5905	;		The result has been stored in the destination register or memory location.
;5906	;
;5907	;	Condition codes:
;5908	;		(MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx):
;5909	;		N <-- dst lss 0
;5910	;		Z <-- dst eql 0
;5911	;		V <-- 0 			[Integer overflow trap disabled.]
;5912	;		C <-- C
;5913	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  184
; INTLOGADR.MIC 	     MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx, MNEGx					      /REV=
;															     INTLOG
;5914	;		(MNEGx):
;5915	;		N <-- dst lss 0
;5916	;		Z <-- dst eql 0
;5917	;		V <-- overflow			[Integer overflow trap enabled.]
;5918	;		C <-- borrow out
;5919	;
;5920	;	Notes:
;5921	;		1.  Performance:  Creating an implicit specifier for PUSHL, PUSHAx allows
;5922	;		    the I-box to continue instead of suspending.
;5923	;
				;5924	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  185
; INTLOGADR.MIC 	     MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx, MNEGx					      /REV=
;															     INTLOG
				;5925
				;5926	;	MOVx, MOVAx, PUSHL, PUSHAx operation:
				;5927	;
				;5928	;		dst.wx <-- src.rx [src.ax]
				;5929
				;5930	MOVX..:
				;5931		;********** Hardware dispatch **********;
				;5932		[DST] <-- [S1], LEN(DL),		; write source to destination
				;5933		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 108  0000,0004,248C,1000 L	;5934		LAST CYCLE				; decode next instruction
				;5935
				;5936	MOVQ..:
				;5937		;********** Hardware dispatch **********;
				;5938		[DST] <-- [S1], LEN(DL),		; save first longword
				;5939		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 10A  0002,804C,248C,0399 J 399;5940		Q <-- PASSB [S2]			; save second longword
				;5941
				;5942	WRITE.QW.SETCC:
				;5943		;---------------------------------------;
				;5944		[DST] <-- PASSA [Q], LONG,		; store second longword via shifter
				;5945		SET PSL CC.IIIP.QUAD,			; finish psl cc's from 2nd LW
E 399  0000,4002,24AE,1000 L	;5946		LAST CYCLE
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  186
; INTLOGADR.MIC 	     MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx, MNEGx					      /REV=
;															     INTLOG
				;5947
				;5948	;	MOVZxy operation:
				;5949	;
				;5950	;		dst.wy <-- zext(src.rx)
				;5951
				;5952	MOVZBX..:
				;5953		;********** Hardware dispatch **********;
				;5954		[DST] <-- [S1] AND 000000[0FF], 	; mask source down to a byte
				;5955		LEN(DL),				; write destination word or longword
				;5956		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 110  0400,27FC,248C,1000 L	;5957		LAST CYCLE				; decode next instruction
				;5958
				;5959	MOVZWL..:
				;5960		;********** Hardware dispatch **********;
				;5961		[DST] <-- [S1] AND [K.FFFF], LONG,	; mask source down to a word
				;5962		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 112  0400,0070,248C,1000 L	;5963		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  187
; INTLOGADR.MIC 	     MOVx, MOVAx, MOVZxy, PUSHL, PUSHAx, MCOMx, MNEGx					      /REV=
;															     INTLOG
				;5964
				;5965	;	MCOMx operation:
				;5966	;
				;5967	;		dst.wx <-- ~src.rx
				;5968
				;5969	MCOMX..:
				;5970		;********** Hardware dispatch **********;
				;5971		[DST] <-- NOT [S1], LEN(DL),		; complement source operand, store
				;5972		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 114  0D80,0044,240C,1000 L	;5973		LAST CYCLE				; decode next instruction
				;5974
				;5975
				;5976	;	MNEGx operation:
				;5977	;
				;5978	;		dst.wx <-- -src.rx
				;5979
				;5980	MNEGX..:
				;5981		;********** Hardware dispatch **********;
				;5982		[DST] <-- -[S1], LEN(DL),		; negate source operand, store
				;5983		SET PSL CC.IIIJ,			; set psl cc's, psl map is iiij
E 116  0D00,0044,240D,9800 L	;5984		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;5985
;5986	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  188
; INTLOGADR.MIC 	     ADAWI										      /REV=
;															     INTLOG
;5987	.TOC	"	ADAWI"
;5988
;5989	;	This instruction does an interlocked add to an aligned word in memory.
;5990	;
;5991	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;5992	;	--------      ------	---------				----	-----			--------
;5993	;	ADAWI		58	dst.mw <-- src.rw + dst.mw		2	rv{m1}/ww		ADAWI..
;5994	;
;5995	;	Entry conditions:
;5996	;		source queue	=	src.rw operand
;5997	;					dst.mw operand (register) or dst.mw address (memory)
;5998	;		dest queue	=	dst.mw result (register) or none (memory)
;5999	;		branch queue	=	none
;6000	;		field queue	=	one valid entry for second specifier
;6001	;		DL		=	WORD
;6002	;		Ibox state	=	running
;6003	;		Mbox state	=	stopped
;6004	;
;6005	;	Exit conditions:
;6006	;		The PSL condition codes are set.
;6007	;		The result has been stored in the destination memory location or register.
;6008	;
;6009	;	Condition codes:
;6010	;		N <-- dst lss 0
;6011	;		Z <-- dst eql 0
;6012	;		V <-- overflow		[Integer overflow trap enabled.]
;6013	;		C <-- carry out
;6014	;
;6015	;	Notes:
;6016	;		1.  Performance:  The register flows could be one cycle shorter, except for the MISC
;6017	;		    field conflict of RESTART MBOX and LOAD PSL CC.MAP.IIII.
;6018	;		2.  Memory management:	For memory, the initial read is with write check, thus the write
;6019	;		    forces memory management errors to be made visible before instruction completion.
;6020	;
				;6021	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  189
; INTLOGADR.MIC 	     ADAWI										      /REV=
;															     INTLOG
				;6022
				;6023	;	ADAWI operation:
				;6024	;
				;6025	;		dst.mw <-- src.rw + dst.mw, interlocked
				;6026
				;6027	;
				;6028	;	Note: Constraints for ADAWI.., ADAWI.R, and ADAWI.M are
				;6029	;	done in ALIGN.MIC.
				;6030
				;6031	ADAWI..:
				;6032		;********** Hardware dispatch **********; fq.vr = 11 (invalid)
E 246  4000,0000,2000,5240 B 240;6033		CASE [FQ.VR] AT [ADAWI.M]		; wait for field queue to
				;6034							; indicate register or memory
				;6035
				;6036	ADAWI.R:
				;6037		;---------------------------------------; fq.vr = 01 (valid, register)
				;6038		[DST] <-- [S1] + [S2], LEN(DL), 	; perform add, no interlock for rmode
E 242  0880,004C,248D,039B J 39B;6039		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;6040
				;6041		;---------------------------------------;
				;6042		VA <-- K10.[IPR.CWB],			; push out buffered writes
				;6043		MEM.PR (VA)&, [WBUS] <-- PASSA [K0], LONG, ; (NUDGE function)
E 39B  00F4,6883,2311,03A4 J 3A4;6044		GOTO [ADAWI.COMPLETE]			; go restart suspended I-box
				;6045
				;6046	ADAWI.M:
				;6047		;---------------------------------------; fq.vr = 00 (valid, memory)
				;6048		VA <-- B [S2], LONG,			; save dst address, test bit<0>
				;6049		[W0] <-- PASSA [S1],			; save source operand
				;6050			sim cond k s3.[0],
E 240  0080,404B,0480,0521 J 521;6051			sim addr [ea.2]
				;6052
				;6053		;---------------------------------------;
				;6054		NOP,					; nothing to do...
E 521  6000,0000,2000,438D B 58D;6055		CASE [B.2-0] AT [ADAWI.WORD.ALIGNED]	; if not word aligned, reserved operand
				;6056
				;6057	;= ALIGNLIST 110x	(ADAWI.WORD.ALIGNED,	ADAWI.NOT.WORD.ALIGNED)
				;6058
				;6059	ADAWI.NOT.WORD.ALIGNED:
			    p127;6060		;---------------------------------------; b<0> = 1:
E 58F  0000,0000,2000,003C J 03C;6061		RESERVED OPERAND FAULT			; reserved operand fault
				;6062
				;6063	ADAWI.WORD.ALIGNED:
				;6064		;---------------------------------------; b<0> = 0:
E 58D  004C,0004,0800,03A0 J 3A0;6065		[W1] <-- MEM.LOCK (VA), LEN(DL) 	; read destination operand, locked
				;6066
				;6067		;---------------------------------------;
				;6068		MEM.UNLOCK (VA)&, [WBUS] <-- [W0] + [W1], ; compute result
				;6069		LEN(DL),				; write to memory
E 3A0  08EC,0014,201D,03A4 J 3A4;6070		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;6071
				;6072	ADAWI.COMPLETE:
				;6073		;---------------------------------------;
				;6074		RESTART MBOX,				; resume operand processing
E 3A4  0000,0000,2004,9800 L	;6075		LAST CYCLE CHECK OVERFLOW		; decode next instruction
;6076	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  190
; INTLOGADR.MIC 	     CVTBW, CVTBL, CVTWL								      /REV=
;															     INTLOG
;6077	.TOC	"	CVTBW, CVTBL, CVTWL"
;6078
;6079	;	These instructions sign extend and move a data item from the first
;6080	;	(source) operand to the second (destination) operand.
;6081	;
;6082	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;6083	;	--------      ------	---------				----	-----		--------
;6084	;	CVTBW		99	dst.ww <-- src.rb			2	rw/bw		CVTBI..
;6085	;	CVTBL		98	dst.wl <-- src.rb			2	rw/bl		CVTBI..
;6086	;	CVTWL		32	dst.wl <-- src.rw			2	rw/wl		CVTWL..
;6087	;
;6088	;	Entry conditions:
;6089	;		source queue	=	src.rx operand
;6090	;		dest queue	=	dst.wx result
;6091	;		branch queue	=	none
;6092	;		field queue	=	none
;6093	;		DL		=	data length of second operand
;6094	;		Ibox state	=	running
;6095	;		Mbox state	=	running
;6096	;
;6097	;	Exit conditions:
;6098	;		The PSL condition codes are set.
;6099	;		The result has been stored in the destination memory location or register.
;6100	;
;6101	;	Condition codes:
;6102	;		N <-- dst lss 0
;6103	;		Z <-- dst eql 0
;6104	;		V <-- 0 		[Integer overflow trap disabled.]
;6105	;		C <-- 0
;6106	;
;6107	;	Notes:
;6108	;		1.  Performance:  Adding the SEXT alu functions makes these instructions a cycle shorter.
;6109	;
				;6110	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  191
; INTLOGADR.MIC 	     CVTBW, CVTBL, CVTWL								      /REV=
;															     INTLOG
				;6111
				;6112	;	CVTBW, CVTBL, CVTWL operation:
				;6113	;
				;6114	;		dst.wy <-- sext(src.wx)
				;6115
				;6116	CVTBI..:
				;6117		;********** Hardware dispatch **********;
E 130  0003,5800,2080,03AA J 3AA;6118		Q <-- [S1] LSH [24.], LONG		; set shifter sign to sign of byte
				;6119
				;6120		;---------------------------------------;
				;6121		[DST] <-- SEXT [Q] RSH [24.], LEN(DL),	; sign extend byte to lw, store wd/lw
				;6122		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 3AA  0001,9856,279D,1000 L	;6123		LAST CYCLE				; decode next instruction
				;6124
				;6125	CVTWL..:
				;6126		;********** Hardware dispatch **********;
E 132  0003,5000,2080,03AC J 3AC;6127		Q <-- [S1] LSH [16.], LONG		; set shifter sign to sign of word
				;6128
				;6129		;---------------------------------------;
				;6130		[DST] <-- SEXT [Q] RSH [16.], LONG,	; sign extend word to longword, store
				;6131		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 3AC  0001,9052,279D,1000 L	;6132		LAST CYCLE				; decode next instruction
				;6133
;6134	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  192
; INTLOGADR.MIC 	     CVTWB, CVTLB, CVTLW								      /REV=
;															     INTLOG
;6135	.TOC	"	CVTWB, CVTLB, CVTLW"
;6136
;6137	;	These instructions truncate and move a data item from the first
;6138	;	(source) operand to the second (destination) operand.
;6139	;
;6140	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;6141	;	--------      ------	---------				----	-----		--------
;6142	;	CVTWB		33	dst.wb <-- src.rw			2	rw/wb		CVTXB..
;6143	;	CVTLB		F6	dst.wb <-- src.rl			2	rw/lb		CVTXB..
;6144	;	CVTLW		F7	dst.ww <-- src.rl			2	rw/lw		CVTLW..
;6145	;
;6146	;	Entry conditions:
;6147	;		source queue	=	src.rx operand
;6148	;		dest queue	=	dst.wx result
;6149	;		branch queue	=	none
;6150	;		field queue	=	none
;6151	;		DL		=	data length of second operand
;6152	;		Ibox state	=	running
;6153	;		Mbox state	=	running
;6154	;
;6155	;	Exit conditions:
;6156	;		The PSL condition codes are set.
;6157	;		The result has been stored in the destination memory location or register.
;6158	;
;6159	;	Condition codes:
;6160	;		N <-- dst lss 0
;6161	;		Z <-- dst eql 0
;6162	;		V <-- overflow		[Integer overflow trap enabled.]
;6163	;		C <-- 0
;6164	;
;6165	;	Notes:
;6166	;		1.  Performance:  Adding the SEXT alu functions makes these instructions a cycle shorter.
;6167	;
				;6168	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  193
; INTLOGADR.MIC 	     CVTWB, CVTLB, CVTLW								      /REV=
;															     INTLOG
				;6169
				;6170	;	CVTWB, CVTLB, CVTLW operation:
				;6171	;
				;6172	;		dst.wy <-- trunc(src.rx)
				;6173
				;6174	CVTXB..:
				;6175		;********** Hardware dispatch **********;
				;6176		VA&, [DST] <-- [S1], LEN(DL),		; result byte to dst
				;6177		Q <-- [S1] LSH [24.],			; set shifter sign to sign of byte
				;6178		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
				;6179							; va = lllb or xxwb,  q = b000
E 136  8003,5805,248D,4C0D B 10D;6180		CASE [OPCODE.2-0] AT [CVTLB]		; breakout into separate flows
				;6181
				;6182	;= ALIGNLIST	110x	(CVTLB, 		CVTWB)
				;6183
				;6184	CVTLB:
				;6185		;---------------------------------------; opcode<0> = 0:
				;6186		Q <-- SEXT [Q] RSH [24.], LONG, 	; sign extend byte to lw
				;6187		DL <-- LONG,				; set dl for lw comparison
E 10D  0003,9850,2393,03E5 J 3E5;6188		GOTO [CVTXI.COMMON]			; join common convert code
				;6189							; va = lllb, q = sssb
				;6190
				;6191	CVTWB:
				;6192		;---------------------------------------; opcode<0> = 1:
				;6193		Q <-- SEXT [Q] RSH [24.], LONG, 	; sign extend byte to lw
				;6194		DL <-- WORD,				; set dl for word comparison
E 10F  0003,9850,2392,83E5 J 3E5;6195		GOTO [CVTXI.COMMON]			; join common convet code
				;6196							; va = xxwb,  q = sssb
				;6197
				;6198	CVTLW..:
				;6199		;********** Hardware dispatch **********;
				;6200		VA&, [DST] <-- [S1], LEN(DL),		; result word to dst
				;6201		Q <-- [S1] LSH [16.],			; set shifter sign to sign of word
E 134  0003,5005,248D,03E4 J 3E4;6202		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;6203							; va = llww,  q = ww00
				;6204
				;6205		;---------------------------------------;
				;6206		Q <-- SEXT [Q] RSH [16.], LONG, 	; sign extend word to lw
				;6207		DL <-- LONG,				; set dl for lw comparison
E 3E4  0003,9050,2393,03E5 J 3E5;6208		GOTO [CVTXI.COMMON]			; join common convert code
				;6209							; va = llww,  q = ssww
				;6210
				;6211	CVTXI.COMMON:
				;6212		;---------------------------------------;
				;6213		[WBUS] <-- [VA] XOR [Q], LEN(DL),	; compare src with sext(trunc(src))
				;6214		SET PSL CC.PPJP,			; set psl v if compare <> 0
E 3E5  0600,0054,20BE,9800 L	;6215		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;6216
;6217	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  194
; INTLOGADR.MIC 	     ROTL										      /REV=
;															     INTLOG
;6218	.TOC	"	ROTL"
;6219
;6220	;	This instruction rotates a longword source operand left or right and stores
;6221	;	the result in the destination operand.
;6222	;
;6223	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;6224	;	--------      ------	---------				----	-----		--------
;6225	;	ROTL		9C	dst.wl <-- src.rl rot cnt.rb		3	rrw/bll 	ROTL..
;6226	;
;6227	;	Entry conditions:
;6228	;		source queue	=	cnt.rb operand
;6229	;					src.rl operand
;6230	;		dest queue	=	dst.wl result
;6231	;		branch queue	=	none
;6232	;		field queue	=	none
;6233	;		DL		=	LONG
;6234	;		Ibox state	=	running
;6235	;		Mbox state	=	running
;6236	;
;6237	;	Exit conditions:
;6238	;		The PSL condition codes are set.
;6239	;		The result has been stored in the destination memory location or register.
;6240	;
;6241	;	Condition codes:
;6242	;		N <-- dst lss 0
;6243	;		Z <-- dst eql 0
;6244	;		V <-- 0 		[Integer overflow trap disabled.]
;6245	;		C <-- C
;6246	;
				;6247	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  195
; INTLOGADR.MIC 	     ROTL										      /REV=
;															     INTLOG
				;6248
				;6249	;	ROTL operation:
				;6250	;
				;6251	;		dst.wl <-- src.rl rot cnt.rb
				;6252
				;6253	ROTL..:
				;6254		;********** Hardware dispatch **********;
				;6255		[W0] <-- B [S2], LONG,			; save operand
E 138  0080,0048,048A,03E6 J 3E6;6256		SC <-- A [S1]				; move rotate count to SC
				;6257
				;6258		;---------------------------------------;
				;6259		[DST] <-- [W0] LROT (SC), LONG, 	; rotate and write result to register
				;6260		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 3E6  0001,000A,241C,1000 L	;6261		LAST CYCLE				; decode next instruction
				;6262
;6263	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  196
; INTLOGADR.MIC 	     ASHL										      /REV=
;															     INTLOG
;6264	.TOC	"	ASHL"
;6265
;6266	;	This instruction shifts a source operand left or right and stores
;6267	;	the result in the destination operand.
;6268	;
;6269	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;6270	;	--------      ------	---------				----	-----		--------
;6271	;	ASHL		78	dst.wl <-- src.rl shift cnt.rb		3	rrw/bll 	ASHL..
;6272	;
;6273	;	Entry conditions:
;6274	;		source queue	=	cnt.rb operand
;6275	;					src.rl operand
;6276	;		dest queue	=	dst.wl result
;6277	;		branch queue	=	none
;6278	;		field queue	=	none
;6279	;		DL		=	LONG
;6280	;		Ibox state	=	running
;6281	;		Mbox state	=	running
;6282	;
;6283	;	Exit conditions:
;6284	;		The PSL condition codes are set.
;6285	;		The result has been stored in the destination memory location or register.
;6286	;
;6287	;	Condition codes:
;6288	;		N <-- dst lss 0
;6289	;		Z <-- dst eql 0
;6290	;		V <-- overflow		[Integer overflow trap enabled.]
;6291	;		C <-- 0
;6292	;
				;6293	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  197
; INTLOGADR.MIC 	     ASHL										      /REV=
;															     INTLOG
				;6294
				;6295	;	ASHL operation:
				;6296	;
				;6297	;		dst.wl <-- src.rl shift cnt.rb
				;6298
				;6299	ASHL..:
				;6300		;********** Hardware dispatch **********;
				;6301		[W0] <-- PASSB [S2], LONG,		; test sign of, save source operand
				;6302		SC <-- A [S1],				; load shift count
E 13A  0000,804A,048A,0411 J 411;6303			sim cond [s3.sv]
				;6304
				;6305		;---------------------------------------;
				;6306		Q <-- SEXT [W0] RSH (32-SC), LONG,	; get only sign bits of source
E 411  A003,0008,2390,4570 B 470;6307		CASE [A.7-5] AT [ASHL.LEFT.0.31]	; case on shift count<7:5>
				;6308
				;6309	;= ALIGNLIST 000x	(ASHL.LEFT.0.31,	ASHL.LEFT.32.63,
				;6310	;=			 ASHL.LEFT.64.95,	ASHL.LEFT.96.127,
				;6311	;=			 ASHL.RIGHT.128.97,	ASHL.RIGHT.96.65,
				;6312	;=			 ASHL.RIGHT.64.33,	ASHL.RIGHT.32.1)
				;6313
				;6314	ASHL.LEFT.0.31:
				;6315		;---------------------------------------; 0 <= count <= 31:
				;6316		[DST] <-- [W0] LSH (SC), LONG,		; shift source operand left by count
E 470  0001,4002,241D,03E7 J 3E7;6317		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;6318
				;6319		;---------------------------------------;
				;6320		[WBUS] <-- [SHIFT.SIGN] XOR [Q], LONG,	; compare sign of result with
				;6321							;  sign bits of source
				;6322		SET PSL CC.PPJP,			; set overflow if they are not equal
E 3E7  0600,0050,239E,9800 L	;6323		LAST CYCLE CHECK OVERFLOW		; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  198
; INTLOGADR.MIC 	     ASHL										      /REV=
;															     INTLOG
				;6324
				;6325	;	ASHL, continued.
				;6326	;	Left shift out of range, result is zero.
				;6327
				;6328	;	At this point,
				;6329	;		W0	=	source operand
				;6330	;		SC	=	shift count
				;6331
				;6332	ASHL.LEFT.32.63:
				;6333		;---------------------------------------; 32 <= count <= 63:
				;6334		Q&, [DST] <-- PASSB 000000[00], LONG,	; result is zero, set shift latch
				;6335		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 472  0002,A002,240D,03E9 J 3E9;6336		GOTO [ASHL.LEFT.ZERO]			; go test for overflow
				;6337
				;6338	ASHL.LEFT.64.95:
				;6339		;---------------------------------------; 64 <= count <= 95:
				;6340		Q&, [DST] <-- PASSB 000000[00], LONG,	; result is zero, set shift latch
				;6341		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 474  0002,A002,240D,03E9 J 3E9;6342		GOTO [ASHL.LEFT.ZERO]			; go test for overflow
				;6343
				;6344	ASHL.LEFT.96.127:
				;6345		;---------------------------------------; 96 <= count <= 127:
				;6346		Q&, [DST] <-- PASSB 000000[00], LONG,	; result is zero, set shift latch
				;6347		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 476  0002,A002,240D,03E9 J 3E9;6348		GOTO [ASHL.LEFT.ZERO]			; go test for overflow
				;6349
				;6350	ASHL.LEFT.ZERO:
				;6351		;---------------------------------------;
				;6352		[WBUS] <-- [Q] XOR [W0], LONG,		; compare unshifted original with result
				;6353		SET PSL CC.PPJP,			; set overflow if they are not equal
E 3E9  0600,0008,20AE,9800 L	;6354		LAST CYCLE CHECK OVERFLOW		; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  199
; INTLOGADR.MIC 	     ASHL										      /REV=
;															     INTLOG
				;6355
				;6356	;	ASHL, continued.
				;6357	;	Right shift cases.
				;6358
				;6359	;	At this point,
				;6360	;		W0	=	source operand
				;6361	;		SC	=	shift count
				;6362	;		shifter sign =	set from source
				;6363
				;6364	ASHL.RIGHT.128.97:
				;6365		;---------------------------------------; -128 <= count <= -97:
				;6366		[DST] <-- SEXT [W0] RSH [31.], LONG,	; result is sign of source
				;6367		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 478  0001,9F0A,279D,1000 L	;6368		LAST CYCLE				; decode next instruction (no overflow)
				;6369
				;6370	ASHL.RIGHT.96.65:
				;6371		;---------------------------------------; -96 <= count <= -65:
				;6372		[DST] <-- SEXT [W0] RSH [31.], LONG,	; result is sign of source
				;6373		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 47A  0001,9F0A,279D,1000 L	;6374		LAST CYCLE				; decode next instruction (no overflow)
				;6375
				;6376	ASHL.RIGHT.64.33:
				;6377		;---------------------------------------; -64 <= count <= -33:
				;6378		[DST] <-- SEXT [W0] RSH [31.], LONG,	; result is sign of source
				;6379		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 47C  0001,9F0A,279D,1000 L	;6380		LAST CYCLE				; decode next instruction (no overflow)
				;6381
				;6382	ASHL.RIGHT.32.1:
				;6383		;---------------------------------------; -32 <= count <= -1:
				;6384		[DST] <-- SEXT [W0] RSH (32-SC),	; shift right, inverting shift count
				;6385		LONG,					;
				;6386		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 47E  0001,000A,279D,1000 L	;6387		LAST CYCLE				; decode next instruction (no overflow)
				;6388
;6389	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  200
; INTLOGADR.MIC 	     ASHQ										      /REV=
;															     INTLOG
;6390	.TOC	"	ASHQ"
;6391
;6392	;	This instruction shifts a quadword source operand left or right and stores
;6393	;	the result in the destination operand.
;6394	;
;6395	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;6396	;	--------      ------	---------				----	-----		--------
;6397	;	ASHQ		79	dst.wl <-- src.rq shift cnt.rb		3	rrw/bql 	ASHQ..
;6398	;
;6399	;	Entry conditions:
;6400	;		source queue	=	cnt.rb operand
;6401	;					src.rq operand
;6402	;		dest queue	=	dst.wl result
;6403	;		branch queue	=	none
;6404	;		field queue	=	none
;6405	;		DL		=	LONG
;6406	;		Ibox state	=	running
;6407	;		Mbox state	=	running
;6408	;
;6409	;	Exit conditions:
;6410	;		The PSL condition codes are set.
;6411	;		The result has been stored in the destination memory location or register.
;6412	;
;6413	;	Condition codes:
;6414	;		N <-- dst lss 0
;6415	;		Z <-- dst eql 0
;6416	;		V <-- overflow		[Integer overflow trap enabled.]
;6417	;		C <-- 0
;6418	;
				;6419	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  201
; INTLOGADR.MIC 	     ASHQ										      /REV=
;															     INTLOG
				;6420
				;6421	;	ASHQ operation:
				;6422	;
				;6423	;		dst.wq <-- src.rq shift cnt.rb
				;6424
				;6425	ASHQ..:
				;6426		;********** Hardware dispatch **********;
				;6427		[W0] <-- PASSB [S2], LONG,		; save low src operand
				;6428		SC <-- A [S1],				; load shift count
E 13C  0000,804A,048A,0402 J 402;6429			sim cond [s3.sv]
				;6430
				;6431		;---------------------------------------;
				;6432		VA <-- NOT 000000[00],			; set VA = -1
				;6433		Q&, [W1] <-- PASSA [S1], LONG,		; test sign of, save hi src operand
				;6434		CASE [A.7-5] AT [ASHQ.LEFT.0.31],	; case on shift count<7:5>
E 402  AD82,6003,0880,4530 B 430;6435			sim cond k s3.[0]
				;6436
				;6437	;= ALIGNLIST 000x	(ASHQ.LEFT.0.31,	ASHQ.LEFT.32.63,
				;6438	;=			 ASHQ.LEFT.64.95,	ASHQ.LEFT.96.127,
				;6439	;=			 ASHQ.RIGHT.128.97,	ASHQ.RIGHT.96.65,
				;6440	;=			 ASHQ.RIGHT.64.33,	ASHQ.RIGHT.32.1)
				;6441
				;6442	ASHQ.LEFT.0.31:
				;6443		;---------------------------------------; 0 <= count <= 31:
				;6444		[DST] <-- [W0] LSH (SC), LONG,		; shift low source operand left by count
E 430  0001,4002,241D,0361 J 361;6445		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;6446
				;6447		;---------------------------------------;
				;6448		Q&, [DST] <-- [W1]!![W0] LSH (SC),	; shift source operand left by count
				;6449		LONG,					;
				;6450		SET PSL CC.IIIP.QUAD,			; finish psl cc's from 2nd LW
E 361  0003,000A,242E,23F0 S 3F0;6451		CALL [ASHX.RESHIFT]			; shift back, sign extending
				;6452
				;6453		;---------------------------------------;
				;6454		[WBUS] <-- [Q] XOR [W1], LONG,		; compare unshifted original with
				;6455							;  sign-extended result
				;6456		SET PSL CC.PPJP,			; set overflow if they are not equal
E 362  0600,0010,20AE,9800 L	;6457		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;6458
				;6459
				;6460	;	One line subroutine for arithmetic shifts.
				;6461
				;6462	ASHX.RESHIFT:
				;6463		;---------------------------------------;
				;6464		Q <-- SEXT [Q] RSH (SC), LONG,		; shift back, sign extending
				;6465		RETURN, 				; return to caller
E 3F0  0003,8050,2390,0800 R	;6466			sim cond k s3.[0]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  202
; INTLOGADR.MIC 	     ASHQ										      /REV=
;															     INTLOG
				;6467
				;6468	;	ASHQ, continued.
				;6469	;	Left shift in range [32:63].
				;6470
				;6471	;	At this point,
				;6472	;		W1'W0	=	source operand
				;6473	;		SC	=	shift count
				;6474
				;6475	ASHQ.LEFT.32.63:
				;6476		;---------------------------------------; 32 <= count <= 63:
				;6477		VA <-- NOT [W1],			; complement high src for neg test
E 432  0D80,4013,2710,0511 J 511;6478		[DST] <-- PASSA [K0], LONG		; low result is zero
				;6479
				;6480		;---------------------------------------;
				;6481		Q&, [DST] <-- [W0] LSH (SC), LONG,	; high result is low src shifted left
			    p201;6482		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 511  0003,4002,241D,23F0 S 3F0;6483		CALL [ASHX.RESHIFT]			; shift back, sign extending
				;6484
				;6485		;---------------------------------------;
				;6486		[W0] <-- [Q] XOR [W0], LONG,		; low src must equal reshifted result
E 512  E600,0008,04A0,4746 B 546;6487		CASE [A31.BQA.BNZ1] AT [ASHQ.LEFT.32.63.POS]	; case on sign of result
				;6488
				;6489	;= ALIGNLIST 011x	(ASHQ.LEFT.32.63.POS,	ASHQ.LEFT.32.63.NEG)
				;6490
				;6491	ASHQ.LEFT.32.63.POS:
				;6492		;---------------------------------------; a<31> = 0:
				;6493		[WBUS] <-- [W1] OR [W0], LONG,		; and high src must be zero
				;6494		SET PSL CC.PPJP,			; set psl.v if non-zero result
E 546  0500,0008,202E,9800 L	;6495		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;6496
				;6497	ASHQ.LEFT.32.63.NEG:
				;6498		;---------------------------------------; a<31> = 1:
				;6499		[WBUS] <-- [VA] OR [W0], LONG,		; and high src must be -1
				;6500		SET PSL CC.PPJP,			; set psl.v if non-zero result
E 54E  0500,0008,20BE,9800 L	;6501		LAST CYCLE CHECK OVERFLOW		; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  203
; INTLOGADR.MIC 	     ASHQ										      /REV=
;															     INTLOG
				;6502
				;6503	;	ASHQ, continued.
				;6504	;	Left shift in range [64:127].
				;6505	;	Result is zero, check for overflow.
				;6506
				;6507	;	At this point,
				;6508	;		W1'W0	=	source operand
				;6509	;		SC	=	shift count
				;6510
				;6511	ASHQ.LEFT.64.95:
				;6512		;---------------------------------------; 64 <= count <= 95:
				;6513		[DST] <-- PASSB 000000[00], LONG,	; low result is zero
				;6514		SET PSL CC.IIII,			; set psl cc's, psl map is iii
E 434  0000,A002,240D,03F1 J 3F1;6515		GOTO [ASHQ.LEFT.64.127] 		; go write high result
				;6516
				;6517	ASHQ.LEFT.96.127:
				;6518		;---------------------------------------; 96 <= count <= 127:
				;6519		[DST] <-- PASSB 000000[00], LONG,	; low result is zero
				;6520		SET PSL CC.IIII,			; set psl cc's, psl map is iii
E 436  0000,A002,240D,03F1 J 3F1;6521		GOTO [ASHQ.LEFT.64.127] 		; go write high result
				;6522
				;6523	ASHQ.LEFT.64.127:
				;6524		;---------------------------------------;
			    p202;6525		Q&, [DST] <-- PASSB 000000[00], LONG,	; high result is zero
E 3F1  0002,A002,2400,0546 J 546;6526		GOTO [ASHQ.LEFT.32.63.POS]		; go test for overflow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  204
; INTLOGADR.MIC 	     ASHQ										      /REV=
;															     INTLOG
				;6527
				;6528	;	ASHQ, continued.
				;6529	;	Right shift in range [-33:-128].
				;6530
				;6531	;	At this point,
				;6532	;		W1'W0	=	source operand
				;6533	;		SC	=	shift count
				;6534	;		VA	=	-1
				;6535	;		shifter sign =	set from source operand
				;6536
				;6537	ASHQ.RIGHT.128.97:
				;6538		;---------------------------------------; -128 <= count <= -97:
				;6539		[DST] <-- SEXT [W1] RSH [31.], LONG,	; result is sign
				;6540		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 438  0001,9F12,279D,03F2 J 3F2;6541		GOTO [ASHQ.RIGHT.EXIT]			; go write high result
				;6542
				;6543	ASHQ.RIGHT.96.65:
				;6544		;---------------------------------------; -96 <= count <= -65:
				;6545		[DST] <-- SEXT [W1] RSH [31.], LONG,	; result is sign
				;6546		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 43A  0001,9F12,279D,03F2 J 3F2;6547		GOTO [ASHQ.RIGHT.EXIT]			; go write high result
				;6548
				;6549	ASHQ.RIGHT.64.33:
				;6550		;---------------------------------------; -64 <= count <= -33:
				;6551		[DST] <-- SEXT [W1] RSH (32-SC),	; shift high src right, inverting shift count
				;6552		LONG,					;
E 43C  0001,0012,279D,03F2 J 3F2;6553		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;6554
				;6555	ASHQ.RIGHT.EXIT:
				;6556		;---------------------------------------;
				;6557		[DST] <-- SEXT [W1] RSH [31.], LONG,	; high result is sign of source
E 3F2  0001,9F12,2790,1000 L	;6558		LAST CYCLE				; decode next instruction (no overflow)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  205
; INTLOGADR.MIC 	     ASHQ										      /REV=
;															     INTLOG
				;6559
				;6560	;	ASHQ, continued.
				;6561	;	Right shift in range [-32:-1].
				;6562
				;6563	;	At this point,
				;6564	;		W1'W0	=	source operand
				;6565	;		SC	=	shift count
				;6566	;		VA	=	-1
				;6567	;		shifter sign =	set from source operand
				;6568
				;6569	ASHQ.RIGHT.32.1:
				;6570		;---------------------------------------; -32 <= count <= -1:
				;6571		[DST] <-- [W1]!![W0] RSH (32-SC),	; shift low src right, inverting shift count
				;6572		LONG,					;
				;6573		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 43E  E001,000A,242D,4737 B 437;6574		CASE [A31.BQA.BNZ1] AT [ASHQ.RIGHT.32.1.POS]	; case on sign of source operand
				;6575
				;6576	;= ALIGNLIST 011x	(ASHQ.RIGHT.32.1.POS,	ASHQ.RIGHT.32.1.NEG)
				;6577
				;6578	ASHQ.RIGHT.32.1.POS:
				;6579		;---------------------------------------; a<31> = 0:
				;6580		[DST] <-- [K0]!![W1] RSH (32-SC),	; shift high src right, inverting shift count
				;6581		LONG,					;
				;6582		SET PSL CC.IIIP.QUAD,			; finish psl cc's from 2nd LW
E 437  0001,0012,271E,1000 L	;6583		LAST CYCLE				; decode next instruction (no overflow)
				;6584
				;6585	ASHQ.RIGHT.32.1.NEG:
				;6586		;---------------------------------------; a<31> = 1:
				;6587		[DST] <-- [VA]!![W1] RSH (32-SC),	; shift high src right, inverting shift count
				;6588		LONG,					;
				;6589		SET PSL CC.IIIP.QUAD,			; finish psl cc's from 2nd LW
E 43F  0001,0012,24BE,1000 L	;6590		LAST CYCLE				; decode next instruction (no overflow)
				;6591
				;6592	;= END INTLOG
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  206
;    VFIELD.MIC 	     VFIELD.MIC -- Variable-Length Bit Field Instructions				      /REV=
;
				;6593	.TOC	"VFIELD.MIC -- Variable-Length Bit Field Instructions"
				;6594	.TOC	"Revision 1.1"
				;6595
				;6596	;	Dan Miner, Bob Supnik
				;6597
;6598	.nobin
;6599	;****************************************************************************
;6600	;*									    *
;6601	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;6602	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;6603	;*  ALL RIGHTS RESERVED.						    *
;6604	;*									    *
;6605	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;6606	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;6607	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;6608	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;6609	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;6610	;*  TRANSFERRED.							    *
;6611	;*									    *
;6612	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;6613	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;6614	;*  CORPORATION.							    *
;6615	;*									    *
;6616	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;6617	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;6618	;*									    *
;6619	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  207
;    VFIELD.MIC 	     Revision History									      /REV=
;
;6620	.TOC	"	Revision History"
;6621
;6622	; Edit	  Date	 Who	     Description
;6623	; ---- --------- ---	---------------------
;6624	;    1 28-Jan-91 GMU	Symptom: Ibox CSU deadlock can occur if the field
;6625	;				 queue is referenced before all source queue
;6626	;				 entries corresponding to earlier specifiers
;6627	;				 are referenced.
;6628	;			Cure:	 Modify the FIELD.. and INSV.. entry points to
;6629	;				 remove the source queue entries corresponding
;6630	;				 to the specifiers before the field specifier
;6631	;				 before casing on the field queue.  To avoid
;6632	;				 changing the IROM also, the original field queue
;6633	;				 entry point constraints remain in ALIGN.MIC,
;6634	;				 but are no longer used.
;6635	; (1)0 18-Jul-90 GMU	Initial production microcode.
;6636	;
;6637	; Begin version 1.0 here
;6638	;   14 17-Jul-90 GMU	Update with Bob's review comments.
;6639	;   13 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;6640	;   12 21-May-90 DGM	Fix bug in FIELD.M path - check for 2nd read incorrect
;6641	;   11 03-May-90 GMU	Reverse order of duplicate labels so that the one
;6642	;			included in an ALIGNLIST is last.
;6643	;   10 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;6644	;    9 21-Mar-90 DGM	Update comments
;6645	;    8 09-Feb-90 DGM	Remove VIELD.P type SEQ.COND from INSV
;6646	;    7 04-Feb-90 GMU	Document simultaneous reference restrictions.
;6647	;    6 30-Jan-90 DGM	Remove VIELD.P type SEQ.COND from FIELD instructions
;6648	;    5 16-Jan-90 DGM	Change field queue alignment
;6649	;    4 18-Sep-89 GMU	Correct PSL CCs for FFx which finds no bits.
;6650	;    3 24-Aug-89 GMU	Fix bad shift count for INSV.
;6651	;    2 17-Aug-89 GMU	Convert split dispatch to use field queue.
;6652	;    1	4-May-88 SDP	Fix FIELD.M bug for 0 SIZE case.  Added S1 access on exit path.
;6653	; (0)0 10-Sep-87 RMS	Trial microcode.
;6654
				;6655	.bin
				;6656	;= BEGIN VFIELD
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  208
;    VFIELD.MIC 	     Revision History									      /REV=
;															     VFIELD
				;6657
;6658	.nobin
;6659	;	This module implements the variable-length bit field class instructions.
;6660	;	The instructions in this class are:
;6661	;
;6662	;	Opcode	 Instruction							N Z V C 	Exceptions
;6663	;	------	 -----------							------- 	----------
;6664	;
;6665	;	EC	 CMPV pos.rl, size.rb, base.vb, {field.rv}, src.rl		* * 0 * 	rsv
;6666	;	ED	 CMPZV pos.rl, size.rb, base.vb, {field.rv}, src.rl		* * 0 * 	rsv
;6667	;
;6668	;	EE	 EXTV pos.rl, size.rb, base.vb, {field.rv}, dst.wl		* * 0 - 	rsv
;6669	;	EF	 EXTZV pos.rl, size.rb, base.vb, {field.rv}, dst.wl		* * 0 - 	rsv
;6670	;
;6671	;	EB	 FFC startpos.rl, size.rb, base.vb, {field.rv}, findpos.wl	0 * 0 0 	rsv
;6672	;	EA	 FFS startpos.rl, size.rb, base.vb, {field.rv}, findpos.wl	0 * 0 0 	rsv
;6673	;
;6674	;	F0	 INSV src.rl, pos.rl, size.rb, base.vb, {field.wv}		- - - - 	rsv
;6675	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  209
;    VFIELD.MIC 	     Revision History									      /REV=
;															     VFIELD
;6676
;6677	;					CAUTION
;6678	;					-------
;6679	;
;6680	;	Ebox microcode for any instruction whose IROM entry contains a .ax or
;6681	;	.vx specifier followed immediately by a .rx, .mx, or .vx specifier may not
;6682	;	reference the source queue entries for this pair of specifiers in the
;6683	;	same microinstruction.	This restriction is necessary to avoid getting
;6684	;	the incorrect operand data for the second specifier of the pair if the
;6685	;	first specifier of the pair is auto-increment, auto-decrement, or auto-increment
;6686	;	deferred, and the second specifier of the pair is register mode using the
;6687	;	same register specified for the first specifier of the pair.  Because the Ibox
;6688	;	must write both the address operand to the MD, and the auto-inc/dec value
;6689	;	to the GPR, the Ebox may read the old value of the GPR if both specifiers
;6690	;	are referenced in the same microword.  In addition, a simultaneous reference
;6691	;	to these specifiers may cause an infinite Ibox RXS stall if the source
;6692	;	queue retire for the second GPR specifier arrives at the Ibox before
;6693	;	the scoreboard is incremented.
;6694	;
;6695	;	This restriction does not apply if, by context, it is known that the
;6696	;	second specifier of the pair is not register mode.
;6697	;
;6698	;	Several of the instructions processed by this module are affected by this
;6699	;	restriction.  The following table lists the restriction for each instruction using
;6700	;	the notation [spec n; spec n+1] to denote a restriction in referencing the
;6701	;	source queue entries for these two specifiers in the same microinstruction.
;6702	;
;6703	;	Entry Point   Opcode   Mnemonic 		   Restriction
;6704	;	-----------   ------   -------- 	----------------------------------
;6705	;	FIELD.. 	EA	 FFS		none
;6706	;			EB	 FFC		none
;6707	;			EC	 CMPV		[spec 3; spec 4]
;6708	;			ED	 CMPZV		[spec 3; spec 4]
;6709	;			EE	 EXTV		none
;6710	;			EF	 EXTZV		none
;6711	;
;6712	;	INSV..		F0	 INSV		none
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  210
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
;6713	.TOC	"	FFS, FFC, CMPV, CMPZV, EXTV, EXTZV"
;6714
;6715	;	These instructions find the first set/clear bit in, compare an operand to, or
;6716	;	extract, a variable-length bit field.
;6717	;
;6718	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;6719	;	--------      ------	---------				----	-----			--------
;6720	;	FFS		EA	dst.wl <-- first one in 		4	rrv{r2}w/lbbl		FIELD..
;6721	;					field(pos.rl, size.rb, base.vb)
;6722	;	FFC		EB	dst.wl <-- first zero in		4	rrv{r2}w/lbbl		FIELD..
;6723	;					field(pos.rl, size.rb, base.vb)
;6724	;
;6725	;	CMPV		EC	sext{field(pos.rl, size.rb, base.vb)} - 4	rrv{r2}r/lbbl		FIELD..
;6726	;					src2.rl
;6727	;	CMPZV		ED	zext{field(pos.rl, size.rb, base.vb)} - 4	rrv{r2}r/lbbl		FIELD..
;6728	;					src2.rl
;6729	;
;6730	;	EXTV		EE	dst.wl <--				4	rrv{r2}w/lbbl		FIELD..
;6731	;					sext{field(pos.rl, size.rb, base.vb)}
;6732	;	EXTZV		EF	dst.wl <--				4	rrv{r2}w/lbbl		FIELD..
;6733	;					zext{field(pos.rl, size.rb, base.vb)}
;6734	;
;6735	;	Entry conditions:		(CMPV, CMPZV)				(FFS, FFC, EXTV, EXTZV)
;6736	;		source queue	=	pos.rl operand				pos.rl operand
;6737	;					size.rb operand 			size.rb operand
;6738	;					base.rq operand, if register or 	base.rq operand, if register or
;6739	;					base.ab operand, if memory		base.ab operand, if memory
;6740	;					src2.rl
;6741	;		dest queue	=	none					dst.wl
;6742	;		branch queue	=	none
;6743	;		field queue	=	one valid entry for third operand
;6744	;		DL		=	BYTE
;6745	;		Ibox state	=	running
;6746	;		Mbox state	=	stopped
;6747	;
;6748	;	Exit conditions (EXTV, EXTZV, FFS, FFC):
;6749	;		The PSL condition codes are set.
;6750	;		The result has been stored in the destination memory location or register.
;6751	;	Exit conditions (CMPV, CMPZV):
;6752	;		The PSL condition codes are set.
;6753	;
;6754	;	Condition codes:
;6755	;		(FFS, FFC)		(CMPV, CMPZV)		(EXTV, EXTZV)
;6756	;		N <-- 0 		N <-- field LSS src2	N <-- dst LSS 0
;6757	;		Z <-- {bit not found}	Z <-- field EQL src2	Z <-- dst EQL 0
;6758	;		V <-- 0 		V <-- 0 		V <-- 0 	[Integer overflow trap disabled.]
;6759	;		C <-- 0 		C <-- field LSSU src2	C <-- C
;6760	;
;6761	;	Notes:
;6762	;		1.  Memory management:	The source list is emptied (except for CMPxV src2) before
;6763	;		    the field is accessed.
;6764	;		2.  The IROM sets DL to BYTE for the FIELD dispatches.
;6765	;
				;6766	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  211
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;6767
				;6768	;	FFS, FFC operation:
				;6769	;
				;6770	;		dst.wl <-- pos of first one (zero) bit in field(pos.rl, size.rb, base.vb)
				;6771
				;6772	;	CMPV, CMPZV operation:
				;6773	;
				;6774	;		sext (zext){field(pos.rl, size.rb, base.vb)} - src2.rl
				;6775
				;6776	;	EXTV, EXTZV operation:
				;6777	;
				;6778	;		dst.wl <-- sext (zext){field(pos.rl, size.rb, base.vb)}
				;6779	;
				;6780	;	Note: In pass 1 microcode, the microcode case on the field queue entry
				;6781	;	is done at the entry point of this instruction, and the field queue
				;6782	;	alignment constraints are done in ALIGN.MIC.  In pass 2 microcode, the
				;6783	;	field queue case is moved into the body of the instruction itself.
				;6784	;	To avoid having to change the IROM, the original field queue constraint
				;6785	;	was not removed from ALIGN.MIC.
				;6786	;
				;6787	;	CAUTION: Do not change the order of reference to the
				;6788	;	source queue in the entry point below without
				;6789	;	reading the explanation at the beginning of this module.
				;6790	;
				;6791	;	The following simultaneous reference restriction exists for
				;6792	;	this entry point: [spec 3; spec 4].
				;6793
				;6794	FIELD..:
				;6795		;********** Hardware dispatch **********; obsolete fq.vr constraint in ALIGN.MIC
				;6796		[W2] <-- B [S2], LEN(DL),		; [1] save zext(size)
E 266  0082,404C,0C80,059E J 59E;6797		Q <-- PASSA [S1]			; save position
				;6798
				;6799	;= ALIGNLIST 100x	(FIELD.MEM,		FIELD.RMODE,
				;6800	;=					,	FIELD.INVALID)
				;6801
				;6802	FIELD.INVALID:
				;6803		;---------------------------------------; fq.vr = 11 (invalid)
			    p214;6804		[WBUS] <-- [W2], LEN(DL),		; [2] re-test size for zero
E 59E  4000,0004,2030,5298 B 598;6805		CASE [FQ.VR] AT [FIELD.MEM]		; wait for field queue to
				;6806							; indicate register or memory
				;6807
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  212
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;6808
				;6809	;	Field in registers.
				;6810
				;6811	;	NOTE: DL is set to BYTE for this flow
				;6812
				;6813	FIELD.RMODE:
				;6814		;---------------------------------------; fq.vr = 01 (valid, register)
				;6815		[WBUS] <-- [W2] - 000000[33.], LONG,	; [3] test size > 32
E 59A  0A80,2108,2034,8022 J 022;6816		RESTART MBOX				; resume operand processing
				;6817
				;6818		;---------------------------------------;
				;6819		VA <-- [Q] ANDNOT 000000[1F], LONG,	; [4] test pos > 31
				;6820		[W0] <-- PASSA [Q],			; save pos
				;6821		SC <-- A [Q],				; load position into SC
E 022  2480,60FB,04AA,415B B 05B;6822		CASE [ALU.NZV] AT [FIELD.R.SIZE.NOT.ZERO] ; case on size = 0 from [2]
				;6823
				;6824	;= ALIGNLIST 10xx	(FIELD.R.SIZE.NOT.ZERO, FIELD.R.SIZE.ZERO)
				;6825	;  ALU.NZVC set by move --> V = C = 0
				;6826
				;6827	FIELD.R.SIZE.NOT.ZERO:
				;6828		;---------------------------------------; alu.z = 0 (size not zero)
				;6829		[W4] <-- [S2]!![S1] RSH (SC), LONG,	; [5] right justify source field,
			    p213;6830							;     sc = position
E 05B  2001,8042,1490,4136 B 036;6831		CASE [ALU.NZV] AT [FIELD.R.SIZE.TOO.BIG] ; case on size > 32 from [3]
				;6832							; >> no [spec 3; spec 4] reference
				;6833	;= ALIGNLIST 011x	(FIELD.R.SIZE.TOO.BIG,	FIELD.R.SIZE.OK)
				;6834
				;6835	FIELD.R.SIZE.OK:
				;6836		;---------------------------------------; alu.n = 1 (size <= 32)
				;6837		SC <-- A [W2],				; [6] load size as shift count
			    p213;6838		[SC] <-- 000000[32.] - [W2], LONG,	; load 32-size as DEFERRED shif count
E 03E  2A00,2100,D43A,4169 B 069;6839		CASE [ALU.NZV] AT [FIELD.R.POS.TOO.BIG] ; case on pos > 31 from [4]
				;6840
				;6841	;= ALIGNLIST 10xx	(FIELD.R.POS.TOO.BIG,	FIELD.R.POS.OK)
				;6842	;  ALU.NZVC set by ANDNOT --> V = 0
				;6843
				;6844	FIELD.R.POS.OK:
				;6845		;---------------------------------------; alu.z = 1 (pos <= 31)
				;6846		[W4] <-- [W4] RROT (SC), LONG,		; [7] left justify field,
			    p216;6847							;     sc = size
E 06D  8001,802A,1450,4CD0 B 0D0;6848		CASE [OPCODE.2-0] AT [FIELD.DATA.CASE]	; case on opcode
				;6849
				;6850
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  213
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;6851
				;6852	;	Field in registers, continued.
				;6853	;	These are the special cases for field in register.
				;6854
				;6855	FIELD.R.SIZE.ZERO:
				;6856		;---------------------------------------; alu.z = 1 (size = 0)
				;6857		ACCESS A [S1], ACCESS B [S2],		; [5] chuck source operand
			    p221;6858		[W4] <-- 0, LONG,			; extracted field is zero
E 05F  8000,C04A,1480,4C33 B 033;6859		CASE [OPCODE.2-0] AT [FIELD.ZERO.CASE]	; case on opcode
				;6860
				;6861	FIELD.R.SIZE.TOO.BIG:
			    p127;6862		;---------------------------------------; alu.n = 0 (size > 32)
E 036  0000,0000,2000,003C J 03C;6863		RESERVED OPERAND FAULT			; reserved operand fault
				;6864
				;6865	FIELD.R.POS.TOO.BIG:
				;6866		;---------------------------------------; alu.z = 0 (pos > 31)
			    p127;6867							; pos > 31, size > 0, size <= 32:
E 069  0000,0000,2000,003C J 03C;6868		RESERVED OPERAND FAULT			; reserved operand fault
				;6869
				;6870
				;6871	;	These are the special cases for field in memory.
				;6872
				;6873	FIELD.M.SIZE.TOO.BIG:
			    p127;6874		;---------------------------------------; alu.c = 0 (size > 32)
E 04D  0000,0000,2000,003C J 03C;6875		RESERVED OPERAND FAULT			; reserved operand fault
				;6876
				;6877	FIELD.M.SIZE.ZERO:
				;6878		;---------------------------------------; alu.z = 1 (size = 0)
				;6879		[W4] <-- 000000[00], LONG,		; [5] extracted field is zero
				;6880		ACCESS A [S1],				; chuck base operand
			    p221;6881		RESTART MBOX,				; resume operand processing
E 07D  8080,2000,1484,CC33 B 033;6882		CASE [OPCODE.2-0] AT [FIELD.ZERO.CASE]	; field is zero, case on opcode
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  214
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;6883
				;6884	;	Field in memory.
				;6885
				;6886	;	NOTE: DL is set to BYTE for this flow
				;6887
				;6888	FIELD.MEM:
				;6889		;---------------------------------------; fq.vr = 00 (valid, memory)
E 598  0A00,2100,1830,0031 J 031;6890		[W5] <-- 000000[32.] - [W2], LONG	; [3] test size > 32
				;6891
				;6892		;---------------------------------------;
				;6893		[W0] <-- B [Q], LONG,			; [4] save position
				;6894		Q <-- SEXT [Q] RSH [3], 		; calc byte position
E 031  2083,8350,0790,4179 B 079;6895		CASE [ALU.NZV] AT [FIELD.M.SIZE.NOT.ZERO] ; case on size = 0 from [2]
				;6896
				;6897	;= ALIGNLIST 10xx	(FIELD.M.SIZE.NOT.ZERO, FIELD.M.SIZE.ZERO)
				;6898	;  ALU.NZVC set by move --> V = C = 0
				;6899
				;6900	FIELD.M.SIZE.NOT.ZERO:
				;6901		;---------------------------------------; alu.z = 0 (size not zero)
				;6902		[W3] <-- [S1] + [Q], LONG,		; [5] calc, save base + sext byte position
				;6903		Q <-- [S1] LSH [3],			; calc base * 8
			    p213;6904							; >> no [spec 3; spec 4] reference
E 079  4883,4350,1080,424D B 04D;6905		CASE [ALU.NZC] AT [FIELD.M.SIZE.TOO.BIG] ; case on size > 32 from [3]
				;6906
				;6907	;= ALIGNLIST 110x	(FIELD.M.SIZE.TOO.BIG,	FIELD.M.SIZE.OK)
				;6908
				;6909	FIELD.M.SIZE.OK:
				;6910		;---------------------------------------; alu.c = 1 (size <= 32)
				;6911		VA <-- [W3] ANDNOT 000000[03],		; [6] calc longword aligned base address
			    p215;6912		[W4] <-- MEM (VA), LONG,		; read field surround
E 04F  04C0,2019,1440,0262 J 262;6913			sim addr [field]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  215
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;6914
				;6915	;	Field in memory, continued.
				;6916	;	Continue field extraction.
				;6917
				;6918	;	At this point,
				;6919	;		W0	=	position
				;6920	;		W2	=	zext size
				;6921	;		W3	=	base + sext byte position
				;6922	;		W4	=	low longword of field surround
				;6923	;		W5	=	32 - size
				;6924	;		Q	=	base * 8
				;6925	;		VA	=	field address, longword aligned
				;6926
				;6927	FIELD.R:					; Dummy label
				;6928		;---------------------------------------; obsolete fq.vr constraint in ALIGN.MIC
E 262  0880,0008,08A0,0260 J 260;6929		[W1] <-- [Q] + [W0], LONG		; [7] base * 8 + pos
				;6930
				;6931	FIELD.M:					; Dummy label
				;6932		;---------------------------------------; obsolete fq.vr constraint in ALIGN.MIC
E 260  0400,20F8,0820,0026 J 026;6933		[W1] <-- [W1] AND 000000[1F], LONG	; [8] base * 8 + pos mod 32 = aligned pos
				;6934
				;6935		;---------------------------------------;
			    p276;6936		[W1] <-- [W5] - [W1], LONG,		; [9] 32-size-pos = 32-(pos+size)
E 026  0A80,0010,0860,2497 S 497;6937		CALL [WAIT.ONE.CYCLE]			; [10] wait for alu cc's
				;6938
				;6939		;---------------------------------------;
				;6940		SC <-- A [W1],				; [11] load 32-(pos+size) as shift count
			    p216;6941		[SC] <-- B [W5], LONG,			; load 32-size as DEFERRED shift count
E 027  4080,0030,D42A,424C B 04C;6942		CASE [ALU.NZC] AT [FIELD.M.2]		; case on pos + size <= 32 from [9]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  216
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;6943
				;6944	;	Field in memory, continued.
				;6945	;	First longword read, read second if required, left align field.
				;6946
				;6947	;	At this point,
				;6948	;		W0	=	position
				;6949	;		W1	=	32-(pos+size)
				;6950	;		W2	=	zext size
				;6951	;		W4	=	low longword of field
				;6952	;		W5	=	32-size
				;6953	;		VA	=	field address, longword aligned
				;6954	;		SC	=	32-(pos+size) in first cycle, 32-size in second cycle
				;6955
				;6956	;= ALIGNLIST 110x	(FIELD.M.2,		FIELD.M.1)
				;6957
				;6958	;	Field in single aligned longword
				;6959
				;6960	FIELD.M.1:
				;6961		;---------------------------------------; alu.c = 1 (pos + size <= 32)
				;6962		[W4] <-- [W4] LSH (SC), LONG,		; [12] left justify field for single word case
				;6963							;      sc = 32-(pos+size)
				;6964		RESTART MBOX,				; resume operand processing
E 04E  8001,4002,1454,CCD0 B 0D0;6965		CASE [OPCODE.2-0] AT [FIELD.DATA.CASE]	; case on opcode
				;6966
				;6967	;	Field in two adjacent aligned longwords
				;6968
				;6969	FIELD.M.2:
				;6970		;---------------------------------------; alu.c = 0 (pos + size > 32)
				;6971		VA <-- [VA] + 4,			; [12] point to next longword
				;6972		[W5] <-- MEM (VA), LONG,		; read next longword
E 04C  0C42,8031,18B0,03F3 J 3F3;6973		Q <-- PASSB [W5]			; save 32-size
				;6974
				;6975		;---------------------------------------;
				;6976		SC <-- A [W1], LONG,			; [13] load 32-(pos+size) as shift count
E 3F3  0080,0050,D42A,00D0 J 0D0;6977		[SC] <-- B [Q]				; load 32-size as DEFERRED shift count
				;6978
				;6979	FIELD.DATA.CASE:				; dummy label
				;6980		;---------------------------------------;
				;6981		[W4] <-- [W5]!![W4] LSH (SC), LONG,	; [14] left align field
				;6982							;      sc = 32-(pos+size)
				;6983		RESTART MBOX,				; resume operand processing
E 0D0  8001,002A,1464,CCD0 B 0D0;6984		CASE [OPCODE.2-0] AT [FIELD.DATA.CASE]	; case on opcode
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  217
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;6985
				;6986	;	Zero length field.
				;6987	;	Finish instruction and exit.
				;6988
				;6989	;	At this point,
				;6990	;		W0	=	position
				;6991	;		W4	=	extracted field (zero)
				;6992	;		S1	=	fourth source operand (CMPXV)
				;6993
				;6994	;= ALIGNLIST 001x	(FIELD.ZERO.CASE,	FFX.0,
				;6995	;=			 CMPXV.0,		EXTXV.0)
				;6996
				;6997	FFX.0:
				;6998		;---------------------------------------; FFx:
E 037  0000,0000,2410,03F4 J 3F4;6999		[DST] <-- [W0], LONG			; write position to destination
				;7000
				;7001	FFX.0.EXIT:
				;7002		;---------------------------------------;
				;7003		[WBUS] <-- [K0], LONG,			; set alu z bit
				;7004		SET PSL CC.IIII,			; and PSL CCs
E 3F4  0000,0000,231D,1000 L	;7005		LAST CYCLE				; decode next instruction
				;7006
				;7007	CMPXV.COMPARE:
				;7008	CMPXV.0:
				;7009		;---------------------------------------; CMPxV:
				;7010		[WBUS] <-- [W4] - [S1], LONG,		; compare field to source operand
				;7011		SET PSL CC.JIZJ,			; set psl cc's, psl map is jizj
E 03B  0A80,0040,205C,9000 L	;7012		LAST CYCLE				; decode next instruction
				;7013
				;7014	EXTXV.0:
				;7015		;---------------------------------------; EXTxV:
				;7016		[DST] <-- 000000[00], LONG,		; field is zero
				;7017		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 03F  0080,2000,240C,1000 L	;7018		LAST CYCLE				; decode next instruction.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  218
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;7019
				;7020	;	Non-zero length field.
				;7021	;	CMPV, CMPZV completion.
				;7022
				;7023	;	At this point,
				;7024	;		W0	=	position
				;7025	;		W2	=	zext size
				;7026	;		W4	=	left justified field
				;7027	;		SC	=	32 - size
				;7028	;		shifter sign =	set from left justified field
				;7029
				;7030	;	To complete CMPV, CMPZV:
				;7031	;		sign/zero extend field,
				;7032	;		compare, set condition codes, and decode.
				;7033
				;7034	;= ALIGNLIST 000x	(FIELD.DATA.CASE,	,
				;7035	;=			 FFS,			 FFC,
				;7036	;=			 CMPV,			 CMPZV,
				;7037	;=			 EXTV,			 EXTZV)
				;7038
				;7039	CMPV:
				;7040		;---------------------------------------; opcode<2:0> = 100:
			    p217;7041		[W4] <-- SEXT [W4] RSH (SC), LONG,	; right justify and sign extend field
E 0D8  0001,802A,1790,003B J 03B;7042		GOTO [CMPXV.COMPARE]			; go finish compare
				;7043
				;7044	CMPZV:
				;7045		;---------------------------------------; opcode<2:0> = 101:
			    p217;7046		[W4] <-- ZEXT [W4] RSH (SC), LONG,	; right justify and zero extend field
E 0DA  0001,C02A,1400,003B J 03B;7047		GOTO [CMPXV.COMPARE]			; go finish compare
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  219
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;7048
				;7049	;	EXTV, EXTZV completion.
				;7050
				;7051	;	At this point,
				;7052	;		W0	=	position
				;7053	;		W2	=	zext size
				;7054	;		W4	=	left justified field
				;7055	;		SC	=	32 - size
				;7056	;		shifter sign =	set from left justified field
				;7057	;
				;7058	;	To complete EXTV, EXTZV:
				;7059	;		sign/zero extend field,
				;7060	;		write field to dst.wl and decode.
				;7061
				;7062	EXTV:
				;7063		;---------------------------------------; opcode<2:0> = 110:
				;7064		[DST] <-- SEXT [W4] RSH (SC), LONG,	; right justify and sign extend field
				;7065		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 0DC  0001,802A,279C,1000 L	;7066		LAST CYCLE				; decode next instruction
				;7067
				;7068	EXTZV:
				;7069		;---------------------------------------; opcode<2:0> = 111:
				;7070		[DST] <-- ZEXT [W4] RSH (SC), LONG,	; right justify and zero extend field
				;7071		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 0DE  0001,C02A,240C,1000 L	;7072		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  220
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;7073
				;7074	;	FFS, FFC completion.
				;7075
				;7076	;	At this point,
				;7077	;		W0	=	position
				;7078	;		W2	=	zext size
				;7079	;		W4	=	left justified field
				;7080	;		SC	=	32 - size
				;7081	;		shifter sign =	set from left justified field
				;7082	;
				;7083	;	To complete FFS, FFC:
				;7084	;		if FFC, invert field so can use FFS algorithm,
				;7085	;		zero extend field,
				;7086	;		if field is zero, calculate answer and write result,
				;7087	;		otherwise, find first one bit in field, write result.
				;7088
				;7089	FFC:
				;7090		;---------------------------------------; opcode<2:0> = 010:
E 0D6  0D80,0028,1400,00D4 J 0D4;7091		[W4] <-- NOT [W4], LONG 		; complement 1's and 0's
				;7092
				;7093	FFS:
				;7094		;---------------------------------------; opcode<2:0> = 011:
E 0D4  0001,C02A,0800,03F5 J 3F5;7095		[W1] <-- ZEXT [W4] RSH (SC), LONG	; right justify and zero extend field
				;7096
				;7097	;	The upcoming bit search can only fail if (FFS) field = 00..00 (FFC) field = 11..11.
				;7098	;	In FFC, the field is complemented BEFORE right shifting.  Garbage to the right of
				;7099	;	the field is shifted off, and zeros are shifting in, causing the zero test to work.
				;7100
				;7101		;---------------------------------------;
E 3F5  0003,5000,2020,0522 J 522;7102		Q <-- [W1] LSH [16.], LONG		; shift field <13:0> to <29:16> for MPU
				;7103
				;7104		;---------------------------------------;
				;7105		[W3] <-- [W1] LSH [2.], LONG,		; shift field <27:14> to <29:16> for MPU
			    p221;7106		MPU <-- B.29..16 [Q],			; load MPU with field <13:0>
E 522  E001,4252,102A,CF9B B 59B;7107		CASE [SHF.NZ.INT] AT [FF.NOT.ZERO]	; if field not zero, go find first set bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  221
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;7108
				;7109	;	FFx, continued.
				;7110	;	Prepare to search field.
				;7111
				;7112	;	At this point,
				;7113	;		W0	=	position
				;7114	;		W1	=	field
				;7115	;		W2	=	size (zero extended)
				;7116	;		W3	=	field left shifted 2
				;7117	;		MPU	=	field<13:0>, not yet testable
				;7118
				;7119	;= ALIGNLIST 101x	(FF.NOT.ZERO,	FF.ZERO)
				;7120
				;7121	FF.ZERO:
				;7122		;---------------------------------------; shf.z = 1:
			    p217;7123		[DST] <-- [W0] + [W2], LONG,		; position is initial position + size
E 59F  0880,0018,2410,03F4 J 3F4;7124		GOTO [FFX.0.EXIT]			; go set psl.z, decode next instruction
				;7125
				;7126	FF.NOT.ZERO:
				;7127		;---------------------------------------; alu.z = 0:
				;7128		[W4] <-- [K1]!![W1] RSH [12.], LONG,	; shift field <31:28> to <19:16> for MPU
				;7129							; add guard 1 for paranoia
E 59B  0001,8C12,172D,0033 J 033;7130		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;7131
				;7132	FIELD.ZERO.CASE:				; dummy label
				;7133		;---------------------------------------;
			    p222;7134		MPU <-- B.29..16 [W3],			; load MPU with field <27:14>
E 033  0000,0020,200A,C8C0 B 0C0;7135		CASE [MPU.0-6] AT [FF.0_6.0]		; case on previous mask<6:0>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  222
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;7136
				;7137	;	FFx, continued.
				;7138	;	Search field 14 bits at a time to find set bit.
				;7139
				;7140	;	At this point,
				;7141	;		W0	=	position
				;7142	;		W4	=	1'field<31:28> in <20:16>
				;7143	;		MPU	=	field <27:14>, not yet testable for 2 cycles
				;7144
				;7145	;= ALIGNLIST 000x	(FF.0_6.0,	FF.0_6.1,	FF.0_6.2,	FF.0_6.3,
				;7146	;=			 FF.0_6.4,	FF.0_6.5,	FF.0_6.6,	FF.0_6.NEXT)
				;7147
				;7148	FF.0_6.0:
				;7149		;---------------------------------------; mask<0> = 1:
				;7150		[DST] <-- [W0] + 000000[00], LONG,	; store result = position + 0
E 0C0  0880,2000,2410,1000 L	;7151		LAST CYCLE				; decode next instruction
				;7152
				;7153	FF.0_6.1:
				;7154		;---------------------------------------; mask<1> = 1:
				;7155		[DST] <-- [W0] + 000000[01], LONG,	; store result = position + 1
E 0C2  0880,2008,2410,1000 L	;7156		LAST CYCLE				; decode next instruction
				;7157
				;7158	FF.0_6.2:
				;7159		;---------------------------------------; mask<2> = 1:
				;7160		[DST] <-- [W0] + 000000[02], LONG,	; store result = position + 2
E 0C4  0880,2010,2410,1000 L	;7161		LAST CYCLE				; decode next instruction
				;7162
				;7163	FF.0_6.3:
				;7164		;---------------------------------------; mask<3> = 1:
				;7165		[DST] <-- [W0] + 000000[03], LONG,	; store result = position + 3
E 0C6  0880,2018,2410,1000 L	;7166		LAST CYCLE				; decode next instruction
				;7167
				;7168	FF.0_6.4:
				;7169		;---------------------------------------; mask<4> = 1:
				;7170		[DST] <-- [W0] + 000000[04], LONG,	; store result = position + 4
E 0C8  0880,2020,2410,1000 L	;7171		LAST CYCLE				; decode next instruction
				;7172
				;7173	FF.0_6.5:
				;7174		;---------------------------------------; mask<5> = 1:
				;7175		[DST] <-- [W0] + 000000[05], LONG,	; store result = position + 5
E 0CA  0880,2028,2410,1000 L	;7176		LAST CYCLE				; decode next instruction
				;7177
				;7178	FF.0_6.6:
				;7179		;---------------------------------------; mask<6> = 1:
				;7180		[DST] <-- [W0] + 000000[06], LONG,	; store result = position + 6
E 0CC  0880,2030,2410,1000 L	;7181		LAST CYCLE				; decode next instruction
				;7182
				;7183	FF.0_6.NEXT:
				;7184		;---------------------------------------; mask<6:0> = 0:
			    p223;7185		[W0] <-- [W0] + 000000[14.], LONG,	; assume search continues
E 0CE  2880,2070,0410,49C1 B 0C1;7186		CASE [MPU.7-13] AT [FF.7_13.7]		; case on prev mask<13:7>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  223
;    VFIELD.MIC 	     FFS, FFC, CMPV, CMPZV, EXTV, EXTZV 						      /REV=
;															     VFIELD
				;7187
				;7188	;	FFx, continued.
				;7189	;	Case on second three bit group in current six.
				;7190
				;7191	;	At this point,
				;7192	;		W0	=	position + 14
				;7193	;		W4	=	1'field<31:28> in <20:16>
				;7194	;		MPU	=	field <27:16>, not yet testable
				;7195
				;7196	;= ALIGNLIST 000x	(FF.7_13.7,	FF.7_13.8,	FF.7_13.9,	FF.7_13.10,
				;7197	;=			 FF.7_13.11,	FF.7_13.12,	FF.7_13.13,	FF.7_13.NEXT)
				;7198
				;7199	FF.7_13.7:
				;7200		;---------------------------------------; mask<7> = 1:
				;7201		[DST] <-- [W0] - 000000[07], LONG,	; store result = position + 14 - 7
E 0C1  0A80,2038,2410,1000 L	;7202		LAST CYCLE				; decode next instruction
				;7203
				;7204	FF.7_13.8:
				;7205		;---------------------------------------; mask<8> = 1:
				;7206		[DST] <-- [W0] - 000000[06], LONG,	; store result = position + 14 - 6
E 0C3  0A80,2030,2410,1000 L	;7207		LAST CYCLE				; decode next instruction
				;7208
				;7209	FF.7_13.9:
				;7210		;---------------------------------------; mask<9> = 1:
				;7211		[DST] <-- [W0] - 000000[05], LONG,	; store result = position + 14 - 5
E 0C5  0A80,2028,2410,1000 L	;7212		LAST CYCLE				; decode next instruction
				;7213
				;7214	FF.7_13.10:
				;7215		;---------------------------------------; mask<10> = 1:
				;7216		[DST] <-- [W0] - 000000[04], LONG,	; store result = position + 14 - 4
E 0C7  0A80,2020,2410,1000 L	;7217		LAST CYCLE				; decode next instruction
				;7218
				;7219	FF.7_13.11:
				;7220		;---------------------------------------; mask<11> = 1:
				;7221		[DST] <-- [W0] - 000000[03], LONG,	; store result = position + 14 - 3
E 0C9  0A80,2018,2410,1000 L	;7222		LAST CYCLE				; decode next instruction
				;7223
				;7224	FF.7_13.12:
				;7225		;---------------------------------------; mask<12> = 1:
				;7226		[DST] <-- [W0] - 000000[02], LONG,	; store result = position + 14 - 2
E 0CB  0A80,2010,2410,1000 L	;7227		LAST CYCLE				; decode next instruction
				;7228
				;7229	FF.7_13.13:
				;7230		;---------------------------------------; mask<13> = 1:
				;7231		[DST] <-- [W0] - 000000[01], LONG,	; store result = position + 14 - 1
E 0CD  0A80,2008,2410,1000 L	;7232		LAST CYCLE				; decode next instruction
				;7233
				;7234	FF.7_13.NEXT:
				;7235		;---------------------------------------; mask<13:7> = 0:
				;7236		MPU <-- B.29..16 [W4],			; load MPU with 1'field<31:28>
			    p222;7237							; MPU prev had field<27:14>
E 0CF  0000,0028,200A,C8C0 B 0C0;7238		CASE [MPU.0-6] AT [FF.0_6.0]		; case on prev mask<6:0>
				;7239
;7240	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  224
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
;7241	.TOC	"	INSV"
;7242
;7243	;	This instruction inserts a source operand into a variable-length bit field.
;7244	;
;7245	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;7246	;	--------      ------	---------				----	-----			--------
;7247	;	INSV		F0	field(pos.rl, size.rb, base.vb) 	4o	rrrv{m2}/llbb		INSV..
;7248	;					<-- src.rl
;7249	;
;7250	;	Entry conditions:
;7251	;		source queue	=	src.rl operand
;7252	;					pos.rl operand
;7253	;					size.rb operand
;7254	;					base.rq operand, if register or
;7255	;					base.ab operand, if memory
;7256	;		dest queue	=	dst.wq, if register
;7257	;					none, if memory
;7258	;		branch queue	=	none
;7259	;		field queue	=	one valid entry for fourth operand
;7260	;		DL		=	BYTE
;7261	;		Ibox state	=	running
;7262	;		Mbox state	=	stopped
;7263	;
;7264	;	Exit conditions:
;7265	;		The source has been inserted into the specified bit field.
;7266	;
;7267	;	Condition codes:
;7268	;		N <-- N
;7269	;		Z <-- Z
;7270	;		V <-- V 		[Integer overflow trap disabled.]
;7271	;		C <-- C
;7272	;
;7273	;	Notes:
;7274	;		1.  Memory management:	If size = 0, source list is drained and dest list is discarded.
;7275	;		2.  Memory management:	Source list is emptied before field is accessed or destination is written.
;7276	;		3.  Memory management:	For field in memory, the field reads are done with write check.  Thus, the
;7277	;		    reads force memory management errors to be made visible before instruction completion.
;7278	;
				;7279	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  225
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7280
				;7281	;	INSV operation:
				;7282	;
				;7283	;		field(pos.rl, size.rb, base.vb) <-- src.rl
				;7284	;
				;7285	;	Note: In pass 1 microcode, the microcode case on the field queue entry
				;7286	;	is done at the entry point of this instruction, and the field queue
				;7287	;	alignment constraints are done in ALIGN.MIC.  In pass 2 microcode, the
				;7288	;	field queue case is moved into the body of the instruction itself.
				;7289	;	To avoid having to change the IROM, the original field queue constraint
				;7290	;	was not removed from ALIGN.MIC.
				;7291
				;7292	INSV..:
				;7293		;********** Hardware dispatch **********; obsolete fq.vr constraint in ALIGN.MIC
				;7294		[W0] <-- B [S1], LONG,			; [1] save source
				;7295		Q <-- PASSA [S2],			; save position, set sign for shift
				;7296		SC <-- A [S2],				; set shift count to position for rmode
E 26E  0082,4040,049A,03F6 J 3F6;7297			sim cond [s3.v.ps]
				;7298
				;7299		;---------------------------------------;
E 3F6  0400,27F8,1080,05AE J 5AE;7300		[W3] <-- [S1] AND 000000[0FF], LONG	; [2] zext size
				;7301
				;7302	;= ALIGNLIST 100x	(INSV.MEM,		INSV.RMODE,
				;7303	;=					,	INSV.INVALID)
				;7304
				;7305	INSV.INVALID:
				;7306		;---------------------------------------; fq.vr = 11 (invalid)
			    p230;7307		[W2] <-- [W3], LONG,			; [3] copy size for mem case, test = zero
E 5AE  4000,0000,0C40,52A8 B 5A8;7308		CASE [FQ.VR] AT [INSV.MEM]		; wait for field queue to
				;7309							; indicate register or memory
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  226
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7310
				;7311	;	Field in registers.
				;7312	;	At this point,
				;7313	;		W0	=	source
				;7314	;		Q	=	position
				;7315	;		SC	=	shift count set from position
				;7316	;		W3	=	zext (size)
				;7317
				;7318	INSV.RMODE:
				;7319		;---------------------------------------; fq.vr = 01 (valid, register)
				;7320		[W2] <-- 000000[32.] - [W3], LONG,	; [4] calc 32-size, test size > 32
E 5AA  0A00,2100,0C44,8423 J 423;7321		RESTART MBOX				; resume operand processing
				;7322
				;7323		;---------------------------------------;
				;7324		[W4] <-- [W2] - [Q],			; [5] calc 32-size-pos = 32-(pos+size)
				;7325							; position will be validated later
E 423  2A80,0050,1430,4131 B 431;7326		CASE [ALU.NZV] AT [INSV.R.SIZE.NOT.ZERO] ; case on size = 0 from [3]
				;7327
				;7328	;= ALIGNLIST x0xx	(INSV.R.SIZE.NOT.ZERO,	INSV.R.SIZE.ZERO)
				;7329	;  ALU.NZVC set by LONGWORD AND with mask<31> = 0  --> N = V = C = 0
				;7330
				;7331	INSV.R.SIZE.NOT.ZERO:
				;7332		;---------------------------------------; alu.z = 0 (size not zero)
			    p227;7333		[W1] <-- [S1] RROT (SC), LONG,		; [6] left justify low surround
E 431  4001,8042,0880,42AC B 4AC;7334		CASE [ALU.NZC] AT [INSV.R.SIZE.TOO.BIG] ; case on size > 32 from [4]
				;7335
				;7336	;= ALIGNLIST 110x	(INSV.R.SIZE.TOO.BIG,	INSV.R.SIZE.OK)
				;7337
				;7338	INSV.R.SIZE.OK:
				;7339		;---------------------------------------; alu.c = 1 (size < 32)
				;7340		[W5] <-- [S1],				; [7] get high field surround
			    p229;7341		NODST <-- ZEXT [Q] RSH [5.], LONG,	; test position > 31
E 4AE  4001,C550,1880,42AD B 4AD;7342		CASE [ALU.NZC] AT [INSV.R.2]		; case on pos+size : 32 from [5]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  227
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7343
				;7344	;	INSV register mode, continued.
				;7345	;	These are the special cases for INSV in register.
				;7346
				;7347	INSV.R.SIZE.ZERO:
				;7348		;---------------------------------------; alu.z = 1 (size = 0)
				;7349		[DST] <-- [S1], LONG,			; [6] copy source operand 1 to itself
			    p174;7350		Q <-- PASSB [S2],			; get source operand 2
E 435  0002,8048,2480,0376 J 376;7351		GOTO [WRITE.QW] 			; go write source operand 2 to itself
				;7352
				;7353	INSV.R.SIZE.TOO.BIG:
			    p127;7354		;---------------------------------------; alu.c = 0 (size > 32)
E 4AC  0000,0000,2000,003C J 03C;7355		RESERVED OPERAND FAULT			; reserved operand fault
				;7356
				;7357	INSV.R.1.POS.TOO.BIG:
			    p127;7358		;---------------------------------------; shf.z = 0 (pos > 31)
E 193  0000,0000,2000,003C J 03C;7359		RESERVED OPERAND FAULT			; reserved operand fault
				;7360
				;7361	INSV.R.2.POS.TOO.BIG:
			    p127;7362		;---------------------------------------; shf.z = 0 (pos > 31)
E 1E2  0000,0000,2000,003C J 03C;7363		RESERVED OPERAND FAULT			; reserved operand fault
				;7364
				;7365
				;7366	;	These are the special cases for INSV in memory.
				;7367
				;7368	INSV.M.SIZE.ZERO:
				;7369		;---------------------------------------; alu.z = 1 (size = 0)
				;7370		ACCESS A [S1],				; discard base operand
				;7371		RESTART MBOX,				; resume operand processing
E 43D  0000,0000,2084,9000 L	;7372		LAST CYCLE				; decode next instruction
				;7373
				;7374	INSV.M.SIZE.TOO.BIG:
			    p127;7375		;---------------------------------------; alu.c = 0 (size > 32)
E 4BD  0000,0000,2000,003C J 03C;7376		RESERVED OPERAND FAULT			; reserved operand fault
				;7377
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  228
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7378
				;7379	;	INSV register mode, continued.
				;7380	;	Field extract for one longword field.  (size + position <= 32)
				;7381	;
				;7382	;	Field surround is:  aaaaaa aazzbb
				;7383	;	Source is: xxxxnn
				;7384	;	where:	aaaaaa aa is the left part of the field surround
				;7385	;		zz	  is the part of the field to be replaced
				;7386	;		bb	  is the right part of the field surround
				;7387	;		nn	  is the field to be inserted
				;7388	;		xxxx	  is unused bits
				;7389	;
				;7390	;	At this point,
				;7391	;		W0	=	source (xxxxnn)
				;7392	;		W1	=	low field surround rotated by position (bbaazz <-- aazzbb)
				;7393	;		W2	=	32 - size
				;7394	;		W3	=	zext size
				;7395	;		W4	=	32 - (position + size)
				;7396	;		W5	=	high longword of field surround (aaaaaa)
				;7397	;		Q = SC	=	position
				;7398
				;7399	;= ALIGNLIST 110x	(INSV.R.2,		INSV.R.1)
				;7400
				;7401	INSV.R.1:
				;7402		;---------------------------------------; alu.n = 1 (size + position <= 32)
				;7403		SC <-- A [W2], LONG,			; [8] load 32-size as shift count
E 4AF  0080,0028,D43A,0167 J 167;7404		[SC] <-- B [W4] 			; load 32-(pos+size) as DEFERRED shift count
				;7405
				;7406		;---------------------------------------;		 --W0--  --W1--
				;7407		[W1] <-- [W0]!![W1] RSH (32-SC), LONG,	; [9] nnbbaa <-- xxxxnn!!bbaazz
			    p227;7408							;     sc = 32-size --> eff sc = size
E 167  E001,0012,0810,4F93 B 193;7409		CASE [SHF.NZ.INT] AT [INSV.R.1.POS.TOO.BIG] ; case on pos > 31 from [7]
				;7410
				;7411	;= ALIGNLIST	x01x	(INSV.R.1.POS.TOO.BIG,	INSV.R.1.POS.OK)
				;7412	;  SHF.NZ set by ZEXT right shift --> N = 0
				;7413
				;7414	INSV.R.1.POS.OK:
				;7415		;---------------------------------------; shf.z = 1	  --W5--
E 197  0001,8012,2420,03F7 J 3F7;7416		[DST] <-- [W1] RROT (SC), LONG		; [10] aannbb <-- nnbbaa
				;7417							;      sc = 32-(pos+size)
				;7418
				;7419		;---------------------------------------;
				;7420		[DST] <-- [W5], LONG,			; [11] write second register to itself
E 3F7  0000,0000,2460,1000 L	;7421		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  229
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7422
				;7423	;	INSV register mode, continued.
				;7424	;	Field extract for two longword field.  (size + position > 32)
				;7425	;
				;7426	;	Field surround is:  aaaayy zzbbbb
				;7427	;	Source is: xxnnmm
				;7428	;	where:	aaaa  is the left part of the field surround
				;7429	;		yy zz is the part of the field to be replaced
				;7430	;		bbbb  is the right part of the field surround
				;7431	;		nn mm is the field to be inserted
				;7432	;		xx    is unused bits
				;7433	;
				;7434	;	At this point,
				;7435	;		W0	=	source
				;7436	;		W1	=	low field surround rotated by position (bbbbzz <-- zzbbbb)
				;7437	;		W2	=	32 - size
				;7438	;		W3	=	zext size
				;7439	;		W4	=	32 - (position + size)
				;7440	;		W5	=	high longword of field surround (aaaaaa)
				;7441	;		Q = SC	=	position
				;7442
				;7443	INSV.R.2:
				;7444		;---------------------------------------; alu.n = 0 (size + position > 32)
				;7445							;		 --W0--  --W1--
E 4AD  0001,0012,0810,0171 J 171;7446		[W1] <-- [W0]!![W1] RSH (32-SC), LONG	; [8] mmbbbb <-- xxnnmm!!bbbbzz
				;7447							;     sc = pos --> eff sc = 32-pos
				;7448
				;7449		;---------------------------------------;		 --W0--
				;7450		[W0] <-- [W4]!![W0] RSH (32-SC), LONG,	; [9] xxxxnn <-- xxnnmm
				;7451							;     sc = pos --> eff sc = 32-pos
			    p227;7452		SC <-- A [W4],				; load 32-(pos+size) as shift count
E 171  E001,000A,045A,4FE2 B 1E2;7453		CASE [SHF.NZ.INT] AT [INSV.R.2.POS.TOO.BIG] ; case on pos > 31 from [7]
				;7454
				;7455	;= ALIGNLIST	x01x	(INSV.R.2.POS.TOO.BIG,	INSV.R.2.POS.OK)
				;7456	;  SHF.NZ set by ZEXT right shift --> N = 0
				;7457
				;7458	INSV.R.2.POS.OK:
				;7459		;---------------------------------------; shf.z = 1:
E 1E6  0000,0000,2420,026A J 26A;7460		[DST] <-- [W1], LONG			; [10] store low result
				;7461
				;7462	INSV.R: 					; Dummy label
				;7463		;---------------------------------------;		 --W0--  ---Q--
E 26A  0001,0032,0C10,03F9 J 3F9;7464		[W2] <-- [W0]!![W5] LSH (SC), LONG	; [11] nnaaaa <-- xxxxnn!!aaaayy
				;7465							;      sc = 32-(pos+size)
				;7466
				;7467		;---------------------------------------;		 --W2--
				;7468		[DST] <-- [W2] RROT (SC), LONG, 	; [12] aaaann <-- nnaaaa
				;7469							;      sc = 32-(pos+size)
E 3F9  0001,801A,2430,1000 L	;7470		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  230
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7471
				;7472	;	INSV, field in memory.
				;7473	;	At this point,
				;7474	;		W0	=	source
				;7475	;		Q	=	position
				;7476	;		SC	=	shift count set from position
				;7477	;		W2	=	zext (size)
				;7478	;		shifter sign set from position
				;7479
				;7480	INSV.MEM:
				;7481		;---------------------------------------; fq.vr = 00 (valid, memory)
E 5A8  0A00,2100,1830,0426 J 426;7482		[W5] <-- 000000[32.] - [W2], LONG	; [4] test size > 32
				;7483
				;7484		;---------------------------------------;
				;7485		[W4] <-- B [Q], LONG,			; [5] save position
				;7486		Q <-- SEXT [Q] RSH [3], 		; calc sext pos rsh 3
E 426  2083,8350,1790,4139 B 439;7487		CASE [ALU.NZV] AT [INSV.M.SIZE.NOT.ZERO] ; case on size = 0 from [3]
				;7488
				;7489	;= ALIGNLIST x0xx	(INSV.M.SIZE.NOT.ZERO,	INSV.M.SIZE.ZERO)
				;7490	;  ALU.NZVC set by LONGWORD AND with bit<31> = 0 --> N = V = 0
				;7491
				;7492	INSV.M.SIZE.NOT.ZERO:
				;7493		;---------------------------------------; alu.z = 0 (size not zero)
				;7494		[W3] <-- [S1] + [Q], LONG,		; [6] calc, save base + sext byte position
			    p227;7495		Q <-- [S1] LSH [3],			; calc base * 8
E 439  4883,4350,1080,42BD B 4BD;7496		CASE [ALU.NZC] AT [INSV.M.SIZE.TOO.BIG] ; case on size > 32 from [4]
				;7497
				;7498	;= ALIGNLIST 110x	(INSV.M.SIZE.TOO.BIG,	INSV.M.SIZE.OK)
				;7499
				;7500	INSV.M.SIZE.OK:
				;7501		;---------------------------------------; alu.c = 1 (size <= 32)
			    p231;7502		VA <-- [W3] ANDNOT 000000[03],		; [7] calc longword aligned base address
E 4BF  04C4,2019,0840,03FB J 3FB;7503		[W1] <-- MEM.WCHK (VA), LONG		; read field surround
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  231
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7504
				;7505	;	INSV memory mode, continued.
				;7506	;	Continue field extraction.
				;7507
				;7508	;	At this point,
				;7509	;		W0	=	source
				;7510	;		W1	=	field surround
				;7511	;		W2	=	zext size
				;7512	;		W3	=	base + sext byte position
				;7513	;		W4	=	position
				;7514	;		W5	=	32 - size
				;7515	;		Q	=	base * 8
				;7516	;		VA	=	longword aligned base address
				;7517
				;7518		;---------------------------------------;
E 3FB  0880,0028,10A0,0268 J 268;7519		[W3] <-- [Q] + [W4], LONG		; [8] base * 8 + pos = bit offset
				;7520
				;7521	INSV.M: 					; Dummy label
				;7522		;---------------------------------------;
E 268  0400,20F8,1040,0444 J 444;7523		[W3] <-- [W3] AND 000000[1F], LONG	; [9] base * 8 + pos mod 32 = aligned pos
				;7524
				;7525		;---------------------------------------;
				;7526		[W4] <-- (-[W3] + [W5]), LONG,		; [10] (32-size)-aligned pos = 32-(pos+size)
E 444  0A00,0030,144A,0445 J 445;7527		SC <-- A [W3]				; load aligned position to SC
				;7528
				;7529		;---------------------------------------;		 --W1--
E 445  0001,8012,0820,0523 J 523;7530		[W1] <-- [W1] RROT (SC), LONG		; [11] bbaazz <-- aazzbb
				;7531							;      sc = aligned pos
				;7532
				;7533		;---------------------------------------;
				;7534		SC <-- A [W5],				; [12] set 32-size as shift count
			    p233;7535		[SC] <-- B [W4], LONG,			; set 32-(pos+size) as DEFERRED shift count
E 523  4080,0028,D46A,42AD B 5AD;7536		CASE [ALU.NZC] AT [INSV.M.2]		; case on pos + size <= 32 from [10]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  232
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7537
				;7538	;	INSV memory mode, continued.
				;7539	;	Field in one longword, insert data into field.
				;7540	;
				;7541	;	Field surround is:  aazzbb
				;7542	;	Source is: xxxxnn
				;7543	;	where:	aa   is the left part of the field surround
				;7544	;		zz   is the part of the field to be replaced
				;7545	;		bb   is the right part of the field surround
				;7546	;		nn   is the field to be inserted
				;7547	;		xxxx is unused bits
				;7548	;
				;7549	;	At this point,
				;7550	;		W0	=	source (xxxxnn)
				;7551	;		W1	=	low field surround rotated by position (bbaazz <-- aazzbb)
				;7552	;		W2	=	zext size
				;7553	;		W3	=	longword aligned position
				;7554	;		W4	=	32 - (position + size)
				;7555	;		W5	=	32 - size
				;7556	;		VA	=	longword aligned field address
				;7557	;		SC	=	32-size  (then 32-(pos+size) in next cycle)
				;7558
				;7559	;= ALIGNLIST	110x	(INSV.M.2,		INSV.M.1)
				;7560
				;7561	INSV.M.1:
				;7562		;---------------------------------------; alu.c = 1	  --W0--  --W1--
E 5AF  0001,0012,0410,0446 J 446;7563		[W0] <-- [W0]!![W1] RSH (32-SC), LONG	; [13] nnbbaa <-- xxxxnn!!bbaazz
				;7564							;      sc = 32-size --> eff sc = size
				;7565
				;7566		;---------------------------------------;		 --W0--
				;7567		MEM (VA)&, [WBUS] <-- [W0] RROT (SC),	; [14] aannbb <-- nnbbaa
				;7568							;      sc = 32-(pos+size)
				;7569		LONG,					; write result to memory
				;7570		RESTART MBOX,				; resume operand processing
E 446  0065,800A,2014,9000 L	;7571		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  233
;    VFIELD.MIC 	     INSV										      /REV=
;															     VFIELD
				;7572
				;7573	;	INSV memory mode, continued.
				;7574	;	Field in two longwords, insert data into field.
				;7575	;
				;7576	;	Field surround is:  aaaayy zzbbbb
				;7577	;	Source is: xxnnmm
				;7578	;	where:	aaaa  is the left part of the field surround
				;7579	;		yy zz is the part of the field to be replaced
				;7580	;		bbbb  is the right part of the field surround
				;7581	;		nn mm is the field to be inserted
				;7582	;		xx    is unused bits
				;7583	;
				;7584	;	At this point,
				;7585	;		W0	=	source (xxnnmm)
				;7586	;		W1	=	low field surround rotated by position (bbaazz <-- aazzbb)
				;7587	;		W2	=	zext size
				;7588	;		W3	=	longword aligned position
				;7589	;		W4	=	32 - (position + size)
				;7590	;		W5	=	32 - size
				;7591	;		VA	=	longword aligned field address
				;7592	;		SC	=	32-size  (then 32-(pos+size) in next cycle)
				;7593
				;7594	INSV.M.2:
				;7595		;---------------------------------------; pos+size > 32:
				;7596		VA <-- [VA] + 4,			; [13] point to next longword
E 5AD  0C44,0001,0CB0,0447 J 447;7597		[W2] <-- MEM.WCHK (VA), LONG		; read next longword
				;7598
				;7599		;---------------------------------------;
E 447  0000,0000,204A,0449 J 449;7600		SC <-- A [W3]				; [14] reload SC with position
				;7601
				;7602		;---------------------------------------;		  --W0--  --W1--
E 449  0001,0012,0810,044B J 44B;7603		[W1] <-- [W0]!![W1] RSH (32-SC), LONG	; [15] mmbbbb <-- xxnnmm!!bbbbzz
				;7604							;      sc = pos --> eff sc = 32-pos
				;7605
				;7606		;---------------------------------------;		  --W0--
				;7607		[W5] <-- [W4]!![W0] RSH (32-SC), LONG,	; [16] xxxxnn <-- xxnnmm
				;7608							;      sc = pos --> eff sc = 32-pos
E 44B  0001,000A,185A,044D J 44D;7609		SC <-- A [W4]				; load 32-(pos+size) as shift count
				;7610
				;7611		;---------------------------------------;		  --W5--  --W2--
E 44D  0001,001A,0460,0450 J 450;7612		[W0] <-- [W5]!![W2] LSH (SC), LONG	; [17] nnaaaa <-- xxxxnn!!aaaayy
				;7613							;      sc = 32-(pos+size)
				;7614
				;7615		;---------------------------------------;		  --W0--
				;7616		MEM (VA)&, [WBUS] <-- [W0] RROT (SC),	; [18] aaaann <-- nnaaaa
				;7617							;      sc = 32-(pos+size)
E 450  0065,800A,2010,0452 J 452;7618		LONG					;
				;7619
				;7620		;---------------------------------------;
				;7621		VA <-- [VA] - 4,			; [19] go back to previous word
				;7622		MEM (VA)&, [WBUS] <-- PASSB [W1], LONG, ; write first result
				;7623		RESTART MBOX,				; resume operand processing
E 452  0CE4,8013,20B4,9000 L	;7624		LAST CYCLE				; decode next instruction
				;7625
				;7626	;= END VFIELD
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  234
;      CTRL.MIC 	     CTRL.MIC -- Control Instructions							      /REV=
;
				;7627	.TOC	"CTRL.MIC -- Control Instructions"
				;7628	.TOC	"Revision 1.0"
				;7629
				;7630	;	Bob Supnik, Mike Uhler
				;7631
;7632	.nobin
;7633	;****************************************************************************
;7634	;*									    *
;7635	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;7636	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;7637	;*  ALL RIGHTS RESERVED.						    *
;7638	;*									    *
;7639	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;7640	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;7641	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;7642	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;7643	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;7644	;*  TRANSFERRED.							    *
;7645	;*									    *
;7646	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;7647	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;7648	;*  CORPORATION.							    *
;7649	;*									    *
;7650	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;7651	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;7652	;*									    *
;7653	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  235
;      CTRL.MIC 	     Revision History									      /REV=
;
;7654	.TOC	"	Revision History"
;7655
;7656	; Edit	  Date	 Who	     Description
;7657	; ---- --------- ---	---------------------
;7658	; (1)0 20-Jul-90 GMU	Initial production microcode.
;7659	;
;7660	; Begin version 1.0 here
;7661	;    9 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;7662	;    8 28-May-90 GMU	Do not sync with branch queue in BBxC and BBxS until
;7663	;			all source queue entries have been referenced.	This
;7664	;			prevents deadlock if one of the specifiers is in
;7665	;			I/O space.
;7666	;    7 30-Apr-90 GMU	Sync with Mbox after LOAD PC.
;7667	;    6 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;7668	;    5 21-Mar-90 DGM	Update comments
;7669	;    4	8-Jan-90 DGM	Remove all ALU SEXT and ZEXT functions	(In CASEx flow)
;7670	;			Also change field queue alignment.
;7671	;    3 17-Aug-89 GMU	Convert split dispatches to field queue.
;7672	;    2 12-Jan-89 GMU	Update to reflect current design.
;7673	;    1 23-Aug-88 GMU	Add PM hook for CASEx.
;7674	; (0)0 16-Jul-87 RMS	Trial microcode.
;7675
				;7676	.bin
				;7677	;= BEGIN CTRL
;7678	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  236
;      CTRL.MIC 	     Revision History									      /REV=
;															       CTRL
;7679
;7680	;	This module implements the control class instructions.
;7681	;	The instructions in this class are:
;7682	;
;7683	;	Opcode	 Instruction							N Z V C 	Exceptions
;7684	;	------	 -----------							------- 	----------
;7685	;
;7686	;	9D	 ACBB limit.rb, add.rb, index.mb, displ.bw			* * * - 	iov
;7687	;	F1	 ACBL limit.rl, add.rl, index.ml, displ.bw			* * * - 	iov
;7688	;	3D	 ACBW limit.rw, add.rw, index.mw, displ.bw			* * * - 	iov
;7689	;
;7690	;	F3	 AOBLEQ limit.rl, index.ml, displ.bb				* * * - 	iov
;7691	;	F2	 AOBLSS limit.rl, index.ml, displ.bb				* * * - 	iov
;7692	;
;7693	;	1E	 BCC{=BGEQU} displ.bb						- - - -
;7694	;	1F	 BCS{=BLSSU} displ.bb						- - - -
;7695	;	13	 BEQL{=BEQLU} displ.bb						- - - -
;7696	;	18	 BGEQ displ.bb							- - - -
;7697	;	14	 BGTR displ.bb							- - - -
;7698	;	1A	 BGTRU displ.bb 						- - - -
;7699	;	15	 BLEQ displ.bb							- - - -
;7700	;	1B	 BLEQU displ.bb 						- - - -
;7701	;	19	 BLSS displ.bb							- - - -
;7702	;	12	 BNEQ{=BNEQU} displ.bb						- - - -
;7703	;	1C	 BVC displ.bb							- - - -
;7704	;	1D	 BVS displ.bb							- - - -
;7705	;
;7706	;	E1	 BBC pos.rl, base.vb, displ.bb, {field.rv}			- - - - 	rsv
;7707	;	E0	 BBS pos.rl, base.vb, displ.bb, {field.rv}			- - - - 	rsv
;7708	;
;7709	;	E5	 BBCC pos.rl, base.vb, displ.bb, {field.mv}			- - - - 	rsv
;7710	;	E3	 BBCS pos.rl, base.vb, displ.bb, {field.mv}			- - - - 	rsv
;7711	;	E4	 BBSC pos.rl, base.vb, displ.bb, {field.mv}			- - - - 	rsv
;7712	;	E2	 BBSS pos.rl, base.vb, displ.bb, {field.mv}			- - - - 	rsv
;7713	;
;7714	;	E7	 BBCCI pos.rl, base.vb, displ.bb, {field.mv}			- - - - 	rsv
;7715	;	E6	 BBSSI pos.rl, base.vb, displ.bb, {field.mv}			- - - - 	rsv
;7716	;
;7717	;	E9	 BLBC src.rl, displ.bb						- - - -
;7718	;	E8	 BLBS src.rl, displ.bb						- - - -
;7719	;
;7720	;	11	 BRB displ.bb							- - - -
;7721	;	31	 BRW displ.bw							- - - -
;7722	;
;7723	;	10	 BSBB displ.bb, {-(SP).wl}					- - - -
;7724	;	30	 BSBW displ.bw, {-(SP).wl}					- - - -
;7725	;
;7726	;	8F	 CASEB selector.rb, base.rb, limit.rb, displ.bw-list		* * 0 *
;7727	;	CF	 CASEL selector.rl, base.rl, limit.rl, displ.bw-list		* * 0 *
;7728	;	AF	 CASEW selector.rw, base.rw, limit.rw, displ.bw-list		* * 0 *
;7729	;
;7730	;	17	 JMP dst.ab							- - - -
;7731	;
;7732	;	16	 JSB dst.ab, {-(SP).wl} 					- - - -
;7733	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  237
;      CTRL.MIC 	     Revision History									      /REV=
;															       CTRL
;7734	;	05	 RSB {(SP)+.rl} 						- - - -
;7735	;
;7736	;	F4	 SOBGEQ index.ml, displ.bb					* * * - 	iov
;7737	;	F5	 SOBGTR index.ml, displ.bb					* * * - 	iov
;7738	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  238
;      CTRL.MIC 	     BRx, Bxx, JMP									      /REV=
;															       CTRL
;7739	.TOC	"	BRx, Bxx, JMP"
;7740
;7741	;	The branch instructions perform unconditional or conditional branches.
;7742	;	The JMP instruction performs an unconditional JMP.
;7743	;
;7744	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch	BCOND
;7745	;	--------      ------	---------				----	-----		--------	-----
;7746	;	BRB		11	PC <-- PC + sext(displ.bb)		0	--		BRX..		--
;7747	;	BRW		31	PC <-- PC + sext(displ.bw)		0	--		BRX..		--
;7748	;
;7749	;	BNEQ, BNEQU	12	if Z eql 0, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.~Z
;7750	;	BEQL, BEQLU	13	if Z eql 1, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.Z
;7751	;	BGTR		14	if {N or Z} eql 0,			0	--		BXX..		PSL.~(N+Z)
;7752	;					PC <-- PC + sext(displ.bb)
;7753	;	BLEQ		15	if {N or Z} eql 1,			0	--		BXX..		PSL.(N+Z)
;7754	;					PC <-- PC + sext(displ.bb)
;7755	;	BGEQ		18	if N eql 0, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.~N
;7756	;	BLSS		19	if N eql 1, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.N
;7757	;	BGTRU		1A	if {C or Z} eql 0,			0	--		BXX..		PSL.~(C+Z)
;7758	;					PC <-- PC + sext(displ.bb)
;7759	;	BLEQU		1B	if {C or Z} eql 1,			0	--		BXX..		PSL.(C+Z)
;7760	;					PC <-- PC + sext(displ.bb)
;7761	;	BVC		1C	if V eql 0, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.~V
;7762	;	BVS		1D	if V eql 1, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.V
;7763	;	BGEQU, BCC	1E	if C eql 0, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.~C
;7764	;	BLSSU, BCS	1F	if C eql 1, PC <-- PC + sext(displ.bb)	0	--		BXX..		PSL.C
;7765	;
;7766	;	JMP		17	PC <-- src.ab				1	a/b		BRX..		--
;7767	;
;7768	;	Entry conditions (Bxx):
;7769	;		source queue	=	none
;7770	;		dest queue	=	none
;7771	;		branch queue	=	conditional branch entry, including prediction
;7772	;		field queue	=	none
;7773	;		DL		=	BYTE
;7774	;		Ibox state	=	running, has updated the PC with predicted address
;7775	;		Mbox state	=	running
;7776	;		The PSL has the branch condition, if any.
;7777	;
;7778	;	Entry conditions (BRx):
;7779	;		source queue	=	none
;7780	;		dest queue	=	none
;7781	;		branch queue	=	unconditional branch entry
;7782	;		field queue	=	none
;7783	;		DL		=	BYTE
;7784	;		Ibox state	=	running, has updated the PC with new address
;7785	;		Mbox state	=	running
;7786	;
;7787	;	Entry conditions (JMP):
;7788	;		source queue	=	src.ab operand
;7789	;		dest queue	=	none
;7790	;		branch queue	=	none
;7791	;		field queue	=	none
;7792	;		DL		=	BYTE
;7793	;		Ibox state	=	running, has updated the PC with new address
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  239
;      CTRL.MIC 	     BRx, Bxx, JMP									      /REV=
;															       CTRL
;7794	;		Mbox state	=	running
;7795	;
;7796	;	Exit conditions:
;7797	;		The prediction state is evaluated and sent to the Ibox and a microtrap is generated
;7798	;		if the prediction is wrong (Bxx).
;7799	;		The branch queue entry is retired (Bxx and BRx).
;7800	;
;7801	;	Condition codes:
;7802	;		N <-- N
;7803	;		Z <-- Z
;7804	;		V <-- V 		[Integer overflow trap disabled.]
;7805	;		C <-- C
;7806	;
				;7807	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  240
;      CTRL.MIC 	     BRx, Bxx, JMP									      /REV=
;															       CTRL
				;7808
				;7809	;	Branch operation:
				;7810	;
				;7811	;		if branch condition satisfied then PC <-- PC + sext(displ.bx)
				;7812
				;7813	;	Jump operation:
				;7814	;
				;7815	;			PC <-- src.ab
				;7816
				;7817	BXX..:
				;7818		;********** Hardware dispatch **********;
				;7819		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;7820							; prediction and trap if wrong,
				;7821							; retire BQE
E 15A  000C,0000,2000,1000 L	;7822		LAST CYCLE				; decode next instruction
				;7823
				;7824	BRX..:
				;7825		;********** Hardware dispatch **********;
				;7826		RETIRE UNCOND BQ ENTRY, 		; wait until displacement is valid,
E 158  0008,0000,2000,1000 L	;7827		LAST CYCLE				; decode next instruction
				;7828							; retire BQE
				;7829
				;7830	JMP..:
				;7831		;********** Hardware dispatch **********;
				;7832		ACCESS A [S1],				; throw away source queue
E 15E  0000,0000,2080,1000 L	;7833		LAST CYCLE				; decode next instruction
				;7834
;7835	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  241
;      CTRL.MIC 	     BSBB, BSBW, JSB									      /REV=
;															       CTRL
;7836	.TOC	"	BSBB, BSBW, JSB"
;7837
;7838	;	These instructions call local subroutines.
;7839	;
;7840	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;7841	;	--------      ------	---------				----	-----		--------
;7842	;	BSBB		10	-(SP) <-- PC, PC <-- PC + sext(displ.bb) 0	--		BSBX..
;7843	;	BSBW		30	-(SP) <-- PC, PC <-- PC + sext(displ.bw) 0	--		BSBX..
;7844	;
;7845	;	JSB		16	-(SP) <-- PC, PC <-- src.ab		1	a/b		JSB..
;7846	;
;7847	;	Entry conditions (BSBx):
;7848	;		source queue	=	(implicit specifier) current PC
;7849	;		dest queue	=	address from implicit -(sp) specifier
;7850	;		branch queue	=	unconditional branch entry
;7851	;		field queue	=	none
;7852	;		DL		=	BYTE
;7853	;		Ibox state	=	running, has updated the PC with new address
;7854	;		Mbox state	=	running
;7855	;
;7856	;	Entry conditions (JSB):
;7857	;		source queue	=	dst.ab new PC operand
;7858	;					(implicit specifier) current PC
;7859	;		dest queue	=	address from implicit -(sp) specifier
;7860	;		branch queue	=	none
;7861	;		field queue	=	none
;7862	;		DL		=	BYTE
;7863	;		Ibox state	=	running, has updated the PC with new address
;7864	;		Mbox state	=	running
;7865	;
;7866	;	Exit conditions:
;7867	;		The PC has been pushed on the stack.
;7868	;		The branch queue entry is retired (BSBx).
;7869	;
;7870	;	Condition codes:
;7871	;		N <-- N
;7872	;		Z <-- Z
;7873	;		V <-- V 		[Integer overflow trap disabled.]
;7874	;		C <-- C
;7875	;
;7876	;	Notes:
;7877	;		1.  Performance:  The implied specifier allows the Ibox to continue without suspending.
;7878	;
				;7879	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  242
;      CTRL.MIC 	     BSBB, BSBW, JSB									      /REV=
;															       CTRL
				;7880
				;7881	;	BSBB, BSBW operation:
				;7882	;
				;7883	;		-(SP) <-- PC, PC <-- PC + sext(displ.bx)
				;7884
				;7885	BSBX..:
				;7886		;********** Hardware dispatch **********;
				;7887		[DST] <-- B [S1], LONG, 		; push PC on stack
				;7888		RETIRE UNCOND BQ ENTRY, 		; wait until displacement is valid,
				;7889							; retire BQE
E 150  0088,0040,2400,1000 L	;7890		LAST CYCLE				; decode next instruction
				;7891
				;7892
				;7893	;	JSB operation:
				;7894	;
				;7895	;		-(SP) <-- PC, PC <-- src.ab
				;7896
				;7897	JSB..:
				;7898		;********** Hardware dispatch **********;
				;7899		[DST] <-- B [S2], LONG, 		; push PC on stack
				;7900		ACCESS A [S1],				; access destination address
E 152  0080,0048,2480,1000 L	;7901		LAST CYCLE				; decode next instruction
				;7902
;7903	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  243
;      CTRL.MIC 	     RSB										      /REV=
;															       CTRL
;7904	.TOC	"	RSB"
;7905
;7906	;	This instruction returns control from a subroutine called by BSBB, BSBW, or JSB.
;7907	;
;7908	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;7909	;	--------      ------	---------				----	-----		--------
;7910	;	RSB		05	PC <-- (SP)+				0	--		RSB..
;7911	;
;7912	;	Entry conditions:
;7913	;		source queue	=	(implicit specifier) new PC
;7914	;		dest queue	=	none
;7915	;		branch queue	=	none
;7916	;		field queue	=	none
;7917	;		DL		=	BYTE
;7918	;		Ibox state	=	running, has read the new PC and updated the SP and PC.
;7919	;		Mbox state	=	running
;7920	;
;7921	;	Exit conditions:
;7922	;		None.
;7923	;
;7924	;	Condition codes:
;7925	;		N <-- N
;7926	;		Z <-- Z
;7927	;		V <-- V 		[Integer overflow trap disabled by default iiip map.]
;7928	;		C <-- C
;7929	;
;7930	;	Notes:
;7931	;		1.  Performance:  The implied specifier allows the Ibox to continue without suspending.
;7932	;
				;7933	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  244
;      CTRL.MIC 	     RSB										      /REV=
;															       CTRL
				;7934
				;7935	;	RSB operation:
				;7936	;
				;7937	;		PC <-- (SP)+
				;7938
				;7939	RSB..:
				;7940		;********** Hardware dispatch **********;
				;7941		ACCESS A [S1],				; throw away source queue
E 154  0000,0000,2080,1000 L	;7942		LAST CYCLE				; decode next instruction
				;7943
;7944	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  245
;      CTRL.MIC 	     CASEx										      /REV=
;															       CTRL
;7945	.TOC	"	CASEx"
;7946
;7947	;	These instructions implement multiway case branching on an input selector.
;7948	;
;7949	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;7950	;	--------      ------	---------				----	-----		--------
;7951	;	CASEB		8F	(see below)				3	rrr/bbb 	CASEX..
;7952	;	CASEW		AF	(see below)				3	rrr/www 	CASEX..
;7953	;	CASEL		CF	(see below)				3	rrr/lll 	CASEX..
;7954	;
;7955	;	The case operation is as follows:
;7956	;		tmp <-- selector.rx - base.rx
;7957	;		PC <-- PC + if (tmp LEQU limit.rx) then {sext(displ.bw[tmp])} else {2 + 2*zext(limit.rx))
;7958	;
;7959	;	Entry conditions from specifier flows:
;7960	;		source queue	=	selector.rx operand
;7961	;					base.rx operand
;7962	;					limit.rx operand
;7963	;					(implicit specifier) current PC
;7964	;		dest queue	=	none
;7965	;		branch queue	=	none
;7966	;		field queue	=	none
;7967	;		DL		=	data type of limit.rx operand
;7968	;		Ibox state	=	stopped
;7969	;		Mbox state	=	running
;7970	;
;7971	;	Exit conditions:
;7972	;		The PSL condition codes are set.
;7973	;		The PC has been updated and the Ibox is restarted.
;7974	;
;7975	;	Condition codes:
;7976	;		N <-- selector - base LSS limit
;7977	;		Z <-- selector - base EQL limit
;7978	;		V <-- 0 				[Integer overflow trap disabled.]
;7979	;		C <-- selector - base LSSU limit
;7980	;
;7981	;	Notes:
;7982	;		1.  Performance:  Omitting the SEXT alu function adds one cycle to this instruction.
;7983	;		2.  Memory management:	The source queue is emptied (except for the implicit current
;7984	;		    PC specifier, which cannot fault) before the start of Ebox I/O.
;7985	;
				;7986	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  246
;      CTRL.MIC 	     CASEx										      /REV=
;															       CTRL
				;7987
				;7988	;	CASEx operation:
				;7989	;
				;7990	;		tmp <-- selector.rx - base.rx
				;7991	;		PC <-- PC + if (tmp LEQU limit.rx) then {sext(displ.bw[tmp])}
				;7992	;						   else {2 + 2*zext(limit.rx))}
				;7993
				;7994	CASEX..:
				;7995		;********** Hardware dispatch **********;
E 156  0A80,004C,0480,0454 J 454;7996		[W0] <-- [S1] - [S2], LEN(DL)		; [1] compute zext(selector - base)
				;7997
				;7998		;---------------------------------------;
				;7999		[WBUS] <-- [W0] - [S1], LEN(DL),	; [2] compare with limit (to Wbus for cc's)
				;8000		Q <-- PASSB [S1],			; save limit
				;8001		SET PSL CC.JIZJ,			; set psl cc's, map is jizj
E 454  0A82,8044,201C,8456 J 456;8002			sim cond [s4.casex]
				;8003
				;8004		;---------------------------------------;
				;8005		[W1] <-- B [Q], LEN(DL),		; [3] zext and save limit
E 456  0083,4154,0810,0513 J 513;8006		Q <-- [W0] LSH [1.]			; compute displacement from PC
				;8007
				;8008		;---------------------------------------;
				;8009		[W1] <-- [W1] + [W1] + 1, LONG, 	; [4] compute zext(limit) * 2 + 1
			    p247;8010		DL <-- WORD,				; set dl = word for read
E 513  4900,0010,0822,C249 B 549;8011		CASE [ALU.NZC] AT [CASEX.IN.RANGE.1]	; case on in-range from [2]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  247
;      CTRL.MIC 	     CASEx										      /REV=
;															       CTRL
				;8012
				;8013	;	CASEx, continued.
				;8014	;	Case range checked.  Compute new PC
				;8015
				;8016	;	At this point,
				;8017	;		W1	=	zext(limit) * 2 + 1
				;8018	;		Q	=	zext(selector - base) * 2
				;8019
				;8020	;= ALIGNLIST 100x	(CASEX.IN.RANGE.1,	CASEX.OUT.RANGE,
				;8021	;=					 ,	CASEX.IN.RANGE.2)
				;8022
				;8023	CASEX.OUT.RANGE:
				;8024		;---------------------------------------; alu.zc = 01:
				;8025		[WBUS] <-- [W1] + [S1] + 1, LONG,	; [5] PC + zext(limit*2) + 2
				;8026		LOAD PC,				; load new PC, restart prefetching
				;8027							; >> LOAD PC: queues must be empty
			    p481;8028							; >> LOAD PC: sync required before exit
E 54B  0924,0040,2020,0572 J 572;8029		GOTO [SYNC.RESTART.IBOX]		; go resume instruction parsing
				;8030
				;8031	CASEX.IN.RANGE.1:
				;8032		;---------------------------------------; alu.zc = 00:
				;8033		VA <-- [Q] + [S1],			; [5] PC + zext(selector-base)*2
				;8034		Q <-- PASSB [S1],			; save current PC
				;8035		[W1] <-- MEM (VA), LEN(DL),		; read displacement
				;8036		GOTO [CASEX.IN.RANGE.COMMON],		; join common flow
E 549  08C2,8045,08A0,0458 J 458;8037			sim addr [case]
				;8038
				;8039	CASEX.IN.RANGE.2:
				;8040		;---------------------------------------; alu.zc = 11:
				;8041		VA <-- [Q] + [S1],			; [5] PC + zext(selector-base)*2
				;8042		Q <-- PASSB [S1],			; save current PC
				;8043		[W1] <-- MEM (VA), LEN(DL),		; read displacement
E 54F  08C2,8045,08A0,0458 J 458;8044			sim addr [case]
				;8045
				;8046	CASEX.IN.RANGE.COMMON:
				;8047		;---------------------------------------;
E 458  0001,5002,0820,045A J 45A;8048		[W1] <-- [W1] LSH [16.], LONG		; [6] set shifter sign to sign of displacement
				;8049
				;8050		;---------------------------------------;
E 45A  0001,9012,0B90,0460 J 460;8051		[W1] <-- SEXT [W1] RSH [16.], LONG	; [7] sign extend displacement to longword
				;8052
				;8053		;---------------------------------------;
				;8054		[WBUS] <-- [Q] + [W1], LONG,		; [8] PC + sext(displ)
				;8055		LOAD PC,				; load new PC, restart prefetching
				;8056							; >> LOAD PC: queues must be empty
			    p481;8057							; >> LOAD PC: sync required before exit
E 460  08A4,0010,20A0,0572 J 572;8058		GOTO [SYNC.RESTART.IBOX]		; go resume instruction parsing
				;8059
;8060	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  248
;      CTRL.MIC 	     SOBGTR, SOBGEQ									      /REV=
;															       CTRL
;8061	.TOC	"	SOBGTR, SOBGEQ"
;8062
;8063	;	These instructions decrement an index and test it against zero.
;8064	;
;8065	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch	BCOND
;8066	;	--------      ------	---------				----	-----		--------	-----
;8067	;	SOBGEQ		F4	index.ml <-- index.ml - 1		1	m/l		SOBGXX..	ALU.~N
;8068	;					if (index geq 0) then PC <-- PC + sext(displ.bb)
;8069	;	SOBGTR		F5	index.ml <-- index.ml - 1		1	m/l		SOBGXX..	ALU.~(N+Z)
;8070	;					if (index gtr 0) then PC <-- PC + sext(displ.bb)
;8071	;
;8072	;	Entry conditions:
;8073	;		source queue	=	index.ml operand
;8074	;		dest queue	=	index.ml result pointer
;8075	;		branch queue	=	conditional branch entry, including prediction
;8076	;		field queue	=	none
;8077	;		DL		=	LONG
;8078	;		Ibox state	=	running, has updated the PC with predicted address
;8079	;		Mbox state	=	running
;8080	;
;8081	;	Exit conditions:
;8082	;		The prediction state is evaluated and sent to the Ibox and a microtrap is generated
;8083	;		if the prediction is wrong.
;8084	;		The branch queue entry is retired.
;8085	;		The PSL condition codes are set.
;8086	;		The modified index has been stored in the destination memory location or register.
;8087	;
;8088	;	Condition codes:
;8089	;		N <-- index LSS 0
;8090	;		Z <-- index EQL 0
;8091	;		V <-- overflow		[Integer overflow trap enabled.]
;8092	;		C <-- C
;8093	;
				;8094	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  249
;      CTRL.MIC 	     SOBGTR, SOBGEQ									      /REV=
;															       CTRL
				;8095
				;8096	;	SOBGEQ, SOBGTR operation:
				;8097	;
				;8098	;		index.ml <-- index.ml - 1
				;8099	;		if (index geq, gtr 0) then PC <-- PC + sext(displ.bb)
				;8100
				;8101	SOBGXX..:
				;8102		;********** Hardware dispatch **********;
				;8103		[DST] <-- [S1] - 1, LONG,		; decrement index
				;8104		SET PSL CC.IIIP,			; set psl cc's, map is iiip
				;8105		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8106							; prediction and trap if wrong,
				;8107							; retire BQE
E 140  0B0C,0000,248C,1800 L	;8108		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;8109
;8110	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  250
;      CTRL.MIC 	     AOBLSS, AOBLEQ									      /REV=
;															       CTRL
;8111	.TOC	"	AOBLSS, AOBLEQ"
;8112
;8113	;	These instructions increment an index and test it against a limit.
;8114	;
;8115	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch	BCOND
;8116	;	--------      ------	---------				----	-----		--------	-----
;8117	;	AOBLSS		F2	index.ml <-- index.ml + 1		2	rm/ll		AOBLXX..	ALU.LSS
;8118	;					if (index lss limit) then PC <-- PC + sext(displ.bb)
;8119	;	AOBLEQ		F3	index.ml <-- index.ml + 1		2	rm/ll		AOBLXX..	ALU.LEQ
;8120	;					if (index leq limit) then PC <-- PC + sext(displ.bb)
;8121	;
;8122	;	Entry conditions:
;8123	;		source queue	=	limit.rl operand
;8124	;				=	index.ml operand
;8125	;		dest queue	=	index.ml result pointer
;8126	;		branch queue	=	conditional branch entry, including prediction
;8127	;		field queue	=	none
;8128	;		DL		=	LONG
;8129	;		Ibox state	=	running, has updated the PC with predicted address
;8130	;		Mbox state	=	running
;8131	;
;8132	;	Exit conditions:
;8133	;		The prediction state is evaluated and sent to the Ibox and a microtrap is generated
;8134	;		if the prediction is wrong.
;8135	;		The branch queue entry is retired.
;8136	;		The PSL condition codes are set.
;8137	;		The modified index has been stored in the destination memory location or register.
;8138	;
;8139	;	Condition codes:
;8140	;		N <-- index LSS 0
;8141	;		Z <-- index EQL 0
;8142	;		V <-- overflow		[Integer overflow trap enabled.]
;8143	;		C <-- C
;8144	;
				;8145	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  251
;      CTRL.MIC 	     AOBLSS, AOBLEQ									      /REV=
;															       CTRL
				;8146
				;8147	;	AOBLSS, AOBLEQ operation:
				;8148	;
				;8149	;		index.ml <-- index.ml + 1
				;8150	;		if (index lss, leq limit) then PC <-- PC + sext(displ.bb)
				;8151
				;8152	AOBLXX..:
				;8153		;********** Hardware dispatch **********;
				;8154		[W1] <-- [S2] + 1, LONG,		; compute result
				;8155		Q <-- PASSB [S1],			; save limit
E 142  0802,8040,089C,0462 J 462;8156		SET PSL CC.IIIP 			; set psl cc's, map is iiip
				;8157
				;8158		;---------------------------------------;
				;8159		NODST <-- [W1] - [Q], LONG,		; compare result with limit
				;8160		[DST] <-- PASSA [W1],			; store result
				;8161		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8162							; prediction and trap if wrong,
				;8163							; retire BQE
E 462  0A8C,4052,2420,1800 L	;8164		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;8165
;8166	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  252
;      CTRL.MIC 	     ACBx										      /REV=
;															       CTRL
;8167	.TOC	"	ACBx"
;8168
;8169	;	These instructions add a value to an index and test the result against a limit.
;8170	;
;8171	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch	BCOND
;8172	;	--------      ------	---------				----	-----		--------	-----
;8173	;	ACBB		9D	index.mb <-- index.mb + add.rb		3	rrm/bbb 	ACBB..		ALU.LEQ
;8174	;					if (add geq 0 and index leq limit) then PC <-- PC + sext(displ.bw)
;8175	;					if (add lss 0 and index geq limit) then PC <-- PC + sext(displ.bw)
;8176	;	ACBW		3D	index.mw <-- index.mw + add.rw		3	rrm/www 	ACBW..		ALU.LEQ
;8177	;					if (add geq 0 and index leq limit) then PC <-- PC + sext(displ.bw)
;8178	;					if (add lss 0 and index geq limit) then PC <-- PC + sext(displ.bw)
;8179	;	ACBL		F1	index.ml <-- index.ml + add.rl		3	rrm/lll 	ACBL..		ALU.LEQ
;8180	;					if (add geq 0 and index leq limit) then PC <-- PC + sext(displ.bw)
;8181	;					if (add lss 0 and index geq limit) then PC <-- PC + sext(displ.bw)
;8182	;
;8183	;	Entry conditions:
;8184	;		source queue	=	limit.rx operand
;8185	;				=	add.rx operand
;8186	;				=	index.mx operand
;8187	;		dest queue	=	index.mx result pointer
;8188	;		branch queue	=	conditional branch entry, including prediction
;8189	;		field queue	=	none
;8190	;		DL		=	data type of index.mx operand
;8191	;		Ibox state	=	running, has updated the PC with predicted address
;8192	;		Mbox state	=	running
;8193	;
;8194	;	Exit conditions:
;8195	;		The prediction state is evaluated and sent to the Ibox and a microtrap is generated
;8196	;		if the prediction is wrong.
;8197	;		The branch queue entry is retired.
;8198	;		The PSL condition codes are set.
;8199	;		The modified index has been stored in the destination memory location or register.
;8200	;
;8201	;	Condition codes:
;8202	;		N <-- index LSS 0
;8203	;		Z <-- index EQL 0
;8204	;		V <-- overflow		[Integer overflow trap enabled.]
;8205	;		C <-- C
;8206	;
				;8207	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  253
;      CTRL.MIC 	     ACBx										      /REV=
;															       CTRL
				;8208
				;8209	;	ACBx operation:
				;8210	;
				;8211	;		index.mx <-- index.mx + add.rx
				;8212	;			if (add geq 0 and index leq limit) then PC <-- PC + sext(displ.bb)
				;8213	;			if (add lss 0 and index geq limit) then PC <-- PC + sext(displ.bb)
				;8214
				;8215	ACBB..:
				;8216		;********** Hardware dispatch **********;
				;8217		[W0] <-- [S2], LEN(DL), 		; [1] test sign of add operand, save
				;8218		Q <-- PASSB [S1],			; save limit
E 148  0002,8044,0490,042D J 42D;8219			sim cond [s3.acbx]
				;8220
				;8221		;---------------------------------------;
				;8222		[W1] <-- [W0] + [S1], LEN(DL),		; [2] index <-- add + index
			    p254;8223		SET PSL CC.IIIP,			; set psl cc's, map is iiip
E 42D  A880,0044,081C,45C6 B 4C6;8224		CASE [A.7-5] AT [ACBI.GEQ]		; case on add<msb>
				;8225
				;8226	ACBW..:
				;8227		;********** Hardware dispatch **********;
				;8228		[W0] <-- [S2], LEN(DL), 		; [1] test sign of add operand, save
				;8229		Q <-- PASSB [S1],			; save limit
E 14A  0002,8044,0490,0433 J 433;8230			sim cond [s3.acbx]
				;8231
				;8232		;---------------------------------------;
				;8233		[W1] <-- [W0] + [S1], LEN(DL),		; [2] index <-- add + index
			    p254;8234		SET PSL CC.IIIP,			; set psl cc's, map is iiip
E 433  C880,0044,081C,46C6 B 4C6;8235		CASE [A.15-12] AT [ACBI.GEQ]		; case on add<msb>
				;8236
				;8237	ACBL..:
				;8238		;********** Hardware dispatch **********;
				;8239		[W0] <-- [S2], LEN(DL), 		; [1] test sign of add operand, save
				;8240		Q <-- PASSB [S1],			; save limit
E 14C  0002,8044,0490,043B J 43B;8241			sim cond [s3.acbx]
				;8242
				;8243		;---------------------------------------;
				;8244		[W1] <-- [W0] + [S1], LEN(DL),		; [2] index <-- add + index
			    p254;8245		SET PSL CC.IIIP,			; set psl cc's, map is iiip
E 43B  E880,0044,081C,47C6 B 4C6;8246		CASE [A31.BQA.BNZ1] AT [ACBI.GEQ]	; case on add<msb>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  254
;      CTRL.MIC 	     ACBx										      /REV=
;															       CTRL
				;8247
				;8248	;	ACBi, continued.
				;8249	;
				;8250	;	At this point,
				;8251	;		W1	=	New index value
				;8252	;		Q	=	limit value
				;8253
				;8254	;= ALIGNLIST 011x	(ACBI.GEQ,	ACBI.LSS)
				;8255
				;8256	ACBI.GEQ:
				;8257		;---------------------------------------; add<msb> = 0:
				;8258		NODST <-- [W1] - [Q], LEN(DL),		; [3] compute index - limit
				;8259		[DST] <-- PASSA [W1],			; store result
				;8260		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8261							; prediction and trap if wrong,
				;8262							; retire BQE
E 4C6  0A8C,4056,2420,1800 L	;8263		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;8264
				;8265	ACBI.LSS:
				;8266		;---------------------------------------; add<msb> = 1:
				;8267		NODST <-- [Q] - [W1], LEN(DL),		; [3] compute limit - index
				;8268		[DST] <-- PASSB [W1],			; store result
				;8269		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8270							; prediction and trap if wrong,
				;8271							; retire BQE
E 4CE  0A8C,8016,24A0,1800 L	;8272		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;8273
;8274	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  255
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
;8275	.TOC	"	BBx, BBxS, BBxC, BBxxI"
;8276
;8277	;	These instructions test, or test and alter, a one-bit field.
;8278	;
;8279	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch	BCOND
;8280	;	--------      ------	---------				----	-----		--------	-----
;8281	;	BBS		E0	if bit(pos.rl, base.vb) eql 1		2	rv{r1}/lb	BBX..		SHF<0>
;8282	;					then PC <-- PC + sext(displ.bb)
;8283	;	BBC		E1	if bit(pos.rl, base.vb) eql 0		2	rv{r1}/lb	BBX..		~SHF<0>
;8284	;					then PC <-- PC + sext(displ.bb)
;8285	;
;8286	;	BBSS		E2	if bit(pos.rl, base.vb) eql 1		2	rv{m1}/lb	BBXS..		SHF<0>
;8287	;					then PC <-- PC + sext(displ.bb)
;8288	;					bit(pos.rl, base.vb) <-- 1
;8289	;	BBCS		E3	if bit(pos.rl, base.vb) eql 0		2	rv{m1}/lb	BBXS..		~SHF<0>
;8290	;					then PC <-- PC + sext(displ.bb)
;8291	;					bit(pos.rl, base.vb) <-- 1
;8292	;
;8293	;	BBSC		E4	if bit(pos.rl, base.vb) eql 1		2	rv{m1}/lb	BBXC..		SHF<0>
;8294	;					then PC <-- PC + sext(displ.bb)
;8295	;					bit(pos.rl, base.vb) <-- 0
;8296	;	BBCC		E5	if bit(pos.rl, base.vb) eql 0		2	rv{m1}/lb	BBXC..		~SHF<0>
;8297	;					then PC <-- PC + sext(displ.bb)
;8298	;					bit(pos.rl, base.vb) <-- 0
;8299	;
;8300	;	BBSSI		E6	if bit(pos.rl, base.vb) eql 1		2	rv{m1}/lb	BBXS..		SHF<0>
;8301	;					then PC <-- PC + sext(displ.bb)
;8302	;					bit(pos.rl, base.vb) <-- 1 INTERLOCKED
;8303	;	BBCCI		E7	if bit(pos.rl, base.vb) eql 0		2	rv{m1}/lb	BBXC..		~SHF<0>
;8304	;					then PC <-- PC + sext(displ.bb)
;8305	;					bit(pos.rl, base.vb) <-- 0 INTERLOCKED
;8306	;
;8307	;	Entry conditions:
;8308	;		source queue	=	pos.rl operand
;8309	;				=	register value (if register), or address of base operand (if memory)
;8310	;		dest queue	=	register result pointer (BBxy or BBxxI, register only)
;8311	;		branch queue	=	conditional branch entry, including prediction
;8312	;		field queue	=	none
;8313	;		DL		=	BYTE
;8314	;		Ibox state	=	running, has updated the PC with predicted address
;8315	;		Mbox state	=	stopped
;8316	;
;8317	;	Exit conditions:
;8318	;		The prediction state is evaluated and sent to the Ibox and a microtrap is generated
;8319	;		if the prediction is wrong.
;8320	;		The branch queue entry is retired.
;8321	;		If not BBx, the selected bit has been updated.
;8322	;		Mbox operand processing is resumed.
;8323	;
;8324	;	Condition codes:
;8325	;		N <-- N
;8326	;		Z <-- Z
;8327	;		V <-- V 		[Integer overflow trap disabled.]
;8328	;		C <-- C
;8329	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  256
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
;8330	;	Notes:
;8331	;		1.  Performance:   In memory flows, SC <-- A<2:0> and built in sext right shift would save a cycle.
;8332	;		3.  Memory management:	The memory reads with modify intent are done with write checking.  Thus,
;8333	;		    the writes force memory management errors to be made visible before instruction completion.
;8334	;
				;8335	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  257
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
				;8336
				;8337	;	BBx operation:
				;8338	;
				;8339	;		if bit(pos.rl, base.vb) eql x then PC <-- PC + sext(displ.bb)
				;8340
				;8341	;	BBxy operation:
				;8342	;
				;8343	;		if bit(pos.rl, base.vb) eql x then PC <-- PC + sext(displ.bb)
				;8344	;		bit(pos.rl, base.vb) <-- y
				;8345
				;8346	;	BBxxI operation:
				;8347	;
				;8348	;		if bit(pos.rl, base.vb) eql x then PC <-- PC + sext(displ.bb)
				;8349	;		bit(pos.rl, base.vb) <-- x INTERLOCKED
				;8350	;
				;8351	;	Note: Constraints for BBX.., BBX.R, and BBX.M are
				;8352	;	done in ALIGN.MIC.
				;8353
				;8354	BBX..:
			    p260;8355		;********** Hardware dispatch **********; fq.vr = 11 (invalid)
E 24E  4000,0000,2000,5248 B 248;8356		CASE [FQ.VR] AT [BBX.M] 		; [1] wait for field queue to
				;8357							; indicate register or memory
				;8358
				;8359	BBX.R:
				;8360		;---------------------------------------; fq.vr = 01 (valid, register)
				;8361		VA <-- [S1] ANDNOT 000000[1F], LONG,	; [2] test position <= 31
				;8362		SC <-- A [S1],				; load shift count with position
E 24A  0480,20F9,208A,2464 S 464;8363		CALL [BBX.GET.SRC.RESTART.MBOX] 	; [3] get source operand in w0, restart mbox
				;8364
				;8365		;---------------------------------------;
				;8366		NOP,					; [4] nothing to do
E 24B  2000,0000,2000,411B B 21B;8367		CASE [ALU.NZV] AT [BBX.R.RSRV]		; case on position <= 31
				;8368
				;8369	;= ALIGNLIST 10xx	(BBX.R.RSRV,		BBX.R.TEST)
				;8370	; ALU.NZV set from ANDNOT --> V = C = 0
				;8371
				;8372	BBX.R.RSRV:
			    p127;8373		;---------------------------------------; alu.z = 0 --> pos > 31:
E 21B  0000,0000,2000,003C J 03C;8374		RESERVED OPERAND FAULT			; reserved operand fault
				;8375
				;8376	BBX.R.TEST:
				;8377		;---------------------------------------; alu.z = 1 --> pos <= 31:
				;8378		Q <-- ZEXT [W0] RSH (SC), LONG, 	; [5] shift selected bit to <0>
				;8379		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8380							; prediction and trap if wrong,
				;8381							; retire BQE
E 21F  000F,C008,2000,1000 L	;8382		LAST CYCLE				; decode next instruction
				;8383
				;8384	; One line subroutine to save source operand in W0 and restart Mbox
				;8385
				;8386	BBX.GET.SRC.RESTART.MBOX:
				;8387		;---------------------------------------;
				;8388		[W0] <-- [S1], LONG,			; get source operand
				;8389		RESTART MBOX,				; resume operand processing
E 464  0000,0000,0484,8800 R	;8390		RETURN					; return to caller
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  258
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
				;8391
				;8392	;	BBxS or BBSSI, field in register.
				;8393	;
				;8394	;	Note: Constraints for BBXS.., BBXS.R, and BBXS.M are
				;8395	;	done in ALIGN.MIC.
				;8396
				;8397	BBXS..:
			    p261;8398		;********** Hardware dispatch **********; fq.vr = 11 (invalid)
E 256  4000,0000,2000,5250 B 250;8399		CASE [FQ.VR] AT [BBXS.M]		; [1] wait for field queue to
				;8400							; indicate register or memory
				;8401
				;8402	BBXS.R:
				;8403		;---------------------------------------; fq.vr = 01 (valid, register)
				;8404		VA <-- [S1] ANDNOT 000000[1F], LONG,	; [2] test position <= 31
			    p257;8405		SC <-- A [S1],				; load shift count with position
E 252  0480,20F9,208A,2464 S 464;8406		CALL [BBX.GET.SRC.RESTART.MBOX] 	; [3] get source operand in w0, restart mbox
				;8407
				;8408		;---------------------------------------;
				;8409		[W1] <-- [K1] LSH (SC), LONG,		; [4] form mask from position
E 253  2001,4002,0B20,4149 B 249;8410		CASE [ALU.NZV] AT [BBXS.R.RSRV] 	; case on position <= 31
				;8411
				;8412	;= ALIGNLIST 10xx	(BBXS.R.RSRV,		BBXS.R.TEST)
				;8413	; ALU.NZV set from ANDNOT --> V = C = 0
				;8414
				;8415	BBXS.R.RSRV:
			    p127;8416		;---------------------------------------; alu.z = 0 --> pos > 31:
E 249  0000,0000,2000,003C J 03C;8417		RESERVED OPERAND FAULT			; reserved operand fault
				;8418
				;8419	BBXS.R.TEST:
				;8420		;---------------------------------------; alu.z = 1 --> pos <= 31:
				;8421		[DST] <-- [W1] OR [W0], LONG,		; [5] set selected bit
				;8422		Q <-- ZEXT [W0] RSH (SC),		; shift selected bit to <0>
				;8423		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8424							; prediction and trap if wrong,
				;8425							; retire BQE
E 24D  050F,C008,2420,1000 L	;8426		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  259
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
				;8427
				;8428	;	BBxC or BBCCI, field in register.
				;8429	;
				;8430	;	Note: Constraints for BBXC.., BBXC.R, and BBXC.M are
				;8431	;	done in ALIGN.MIC.
				;8432
				;8433	BBXC..:
			    p262;8434		;********** Hardware dispatch **********; fq.vr = 11 (invalid)
E 25E  4000,0000,2000,5258 B 258;8435		CASE [FQ.VR] AT [BBXC.M]		; [1] wait for field queue to
				;8436							; indicate register or memory
				;8437
				;8438	BBXC.R:
				;8439		;---------------------------------------; fq.vr = 01 (valid, register)
				;8440		VA <-- [S1] ANDNOT 000000[1F], LONG,	; [2] test position <= 31
			    p257;8441		SC <-- A [S1],				; load shift count with position
E 25A  0480,20F9,208A,2464 S 464;8442		CALL [BBX.GET.SRC.RESTART.MBOX] 	; [3] get source operand in w0, restart mbox
				;8443
				;8444		;---------------------------------------;
				;8445		[W1] <-- [K1] LSH (SC), LONG,		; [4] form mask from position
E 25B  2001,4002,0B20,4159 B 259;8446		CASE [ALU.NZV] AT [BBXC.R.RSRV] 	; case on position <= 31
				;8447
				;8448	;= ALIGNLIST 10xx	(BBXC.R.RSRV,		BBXC.R.TEST)
				;8449	; ALU.NZV set from ANDNOT --> V = C = 0
				;8450
				;8451	BBXC.R.RSRV:
			    p127;8452		;---------------------------------------; alu.z = 0 --> pos > 31:
E 259  0000,0000,2000,003C J 03C;8453		RESERVED OPERAND FAULT			; reserved operand fault
				;8454
				;8455	BBXC.R.TEST:
				;8456		;---------------------------------------; alu.z = 1 --> pos <= 31:
				;8457		[DST] <-- NOT [W1] AND [W0], LONG,	; [5] clear selected bit
				;8458		Q <-- ZEXT [W0] RSH (SC),		; shift selected bit to <0>
				;8459		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8460							; prediction and trap if wrong,
				;8461							; retire BQE
E 25D  068F,C008,2420,1000 L	;8462		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  260
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
				;8463
				;8464	;	BBx, field in memory.
				;8465
				;8466	BBX.M:
				;8467		;---------------------------------------; fq.vr = 00 (valid, memory)
				;8468		[SC] <-- [S1] AND 000000[07], LONG,	; [2] position in byte to SC
E 248  0402,6038,D480,0468 J 468;8469		Q <-- PASSA [S1]			; position to shift latch
				;8470
				;8471		;---------------------------------------;
E 468  0001,8352,0B90,046A J 46A;8472		[W1] <-- SEXT [Q] RSH [3], LONG 	; [3] convert position to signed byte offset
				;8473
				;8474		;---------------------------------------;
				;8475		VA <-- [S1] + [W1],			; [4] calculate addr of selected byte
				;8476		[W0] <-- MEM (VA), LEN(DL),		; read selected byte
				;8477		RESTART MBOX,				; resume operand processing
			    p257;8478		GOTO [BBX.R.TEST],			; go test selected byte
E 46A  08C0,0015,0484,821F J 21F;8479			sim addr [field]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  261
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
				;8480
				;8481	;	BBxS, field in memory.
				;8482	;
				;8483	;	Note: All source queue entries must be referenced before the branch
				;8484	;	queue entry to prevent deadlock if one of the specifiers is in
				;8485	;	I/O space.
				;8486
				;8487	BBXS.M:
				;8488		;---------------------------------------; fq.vr = 00 (valid, memory)
				;8489		[SC] <-- [S1] AND 000000[07], LONG,	; [2] position in byte to SC
E 250  0402,6038,D480,0440 J 440;8490		Q <-- PASSA [S1]			; position to shift latch
				;8491
				;8492		;---------------------------------------;
				;8493		[W1] <-- SEXT [Q] RSH [3], LONG,	; [3] convert position to signed byte offset
E 440  8001,8352,0B90,4CC7 B 4C7;8494		CASE [OPCODE.2-0] AT [BBXS.M.READ]	; case on normal vs interlocked
				;8495
				;8496	;= ALIGNLIST 011x	(BBXS.M.READ,		BBSSI.M.READ)
				;8497
				;8498	BBXS.M.READ:
				;8499		;---------------------------------------; BBxS:
				;8500		VA <-- [S1] + [W1],			; [4] calculate addr of selected byte
				;8501		[W0] <-- MEM.WCHK (VA), LEN(DL),	; read selected byte, check write
			    p263;8502		CALL [BBX.MAKE.MASK.WAIT.BDISP],	; [5] form mask in W1, wait for displacement
E 4C7  08C4,0015,0480,2471 S 471;8503			sim addr [field]
				;8504
				;8505	;	Note: Write must not be done until displacement is known to
				;8506	;	be accessable
				;8507
				;8508		;---------------------------------------;
				;8509		MEM (VA)&, [WBUS] <-- [W1] OR [W0],	; [6] set bit, write result
				;8510		LEN(DL),				;
			    p257;8511		RESTART MBOX,				; resume operand processing
E 4C8  0564,000C,2024,821F J 21F;8512		GOTO [BBX.R.TEST]			; go test selected bit
				;8513
				;8514	;	Note: Read lock must not be done until displacement is known to
				;8515	;	be accessable
				;8516
				;8517	BBSSI.M.READ:
				;8518		;---------------------------------------; BBSSI:
				;8519		VA <-- [S1] + [W1],			; [4] calculate addr of selected byte
				;8520		WAIT BDISP VALID,			; wait until displacement is valid
				;8521		CALL [BBX.RDLK.MAKE.MASK],		; [5-6] Read interlocked data to W0, form
			    p263;8522							; mask in W1
E 4CF  0884,0011,2080,246C S 46C;8523			sim addr [field]
				;8524
				;8525		;---------------------------------------;
				;8526		MEM.UNLOCK (VA)&, [WBUS] <-- [W1] OR [W0], ; [7] set bit, write result, unlock
				;8527		LEN(DL),				;
			    p257;8528		RESTART MBOX,				; resume operand processing
E 4C0  056C,000C,2024,821F J 21F;8529		GOTO [BBX.R.TEST]			; go test selected bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  262
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
				;8530
				;8531	;	BBxC, continued.
				;8532	;
				;8533	;	Note: All source queue entries must be referenced before the branch
				;8534	;	queue entry to prevent deadlock if one of the specifiers is in
				;8535	;	I/O space.
				;8536
				;8537	BBXC.M:
				;8538		;---------------------------------------; fq.vr = 00 (valid, memory)
				;8539		[SC] <-- [S1] AND 000000[07], LONG,	; [2] position in byte to SC
E 258  0402,6038,D480,0441 J 441;8540		Q <-- PASSA [S1]			; position to shift latch
				;8541
				;8542		;---------------------------------------;
				;8543		[W1] <-- SEXT [Q] RSH [3], LONG,	; [3] convert position to signed byte offset
E 441  8001,8352,0B90,4CDA B 4DA;8544		CASE [OPCODE.2-0] AT [BBXC.M.READ]	; case on normal vs interlocked
				;8545
				;8546	;= ALIGNLIST 101x	(BBXC.M.READ,	BBCCI.M.READ)
				;8547
				;8548	BBXC.M.READ:
				;8549		;---------------------------------------; BBxC:
				;8550		VA <-- [S1] + [W1],			; [4] calculate addr of selected byte
				;8551		[W0] <-- MEM.WCHK (VA), LEN(DL),	; read selected byte, check write
			    p263;8552		CALL [BBX.MAKE.MASK.WAIT.BDISP],	; [5] form mask in W1, wait for displacement
E 4DA  08C4,0015,0480,2471 S 471;8553			sim addr [field]
				;8554
				;8555	;	Note: Write must not be done until displacement is known to
				;8556	;	be accessable
				;8557
				;8558		;---------------------------------------;
				;8559		MEM (VA)&, [WBUS] <-- NOT [W1] AND [W0], ; [6] clear bit, write result
				;8560		LEN(DL),				;
			    p257;8561		RESTART MBOX,				; resume operand processing
E 4DB  06E4,000C,2024,821F J 21F;8562		GOTO [BBX.R.TEST]			; go test selected bit
				;8563
				;8564	;	Note: Read lock must not be done until displacement is known to
				;8565	;	be accessable
				;8566
				;8567	BBCCI.M.READ:
				;8568		;---------------------------------------; BBCCI:
				;8569		VA <-- [S1] + [W1],			; [4] calculate addr of selected byte
				;8570		WAIT BDISP VALID,			; wait until displacement is valid
				;8571		CALL [BBX.RDLK.MAKE.MASK],		; [5-6] Read interlocked data to W0, form
			    p263;8572							; mask in W1
E 4DE  0884,0011,2080,246C S 46C;8573			sim addr [field]
				;8574
				;8575		;---------------------------------------;
				;8576		MEM.UNLOCK (VA)&, [WBUS] <-- NOT [W1] AND [W0], ; [7] clear bit, write result, unlock
				;8577		LEN(DL),				;
			    p257;8578		RESTART MBOX,				; resume operand processing
E 4DF  06EC,000C,2024,821F J 21F;8579		GOTO [BBX.R.TEST]			; go test selected bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  263
;      CTRL.MIC 	     BBx, BBxS, BBxC, BBxxI								      /REV=
;															       CTRL
				;8580
				;8581	;	Subroutine to interlock read the selected byte and form
				;8582	;	a mask of the selected bit.
				;8583	;
				;8584	;	Entry conditions:
				;8585	;		VA	=	Address of byte
				;8586	;		DL	=	Byte
				;8587	;		SC	=	Position of bit within longword
				;8588	;
				;8589	;	Exit conditions:
				;8590	;		W0	=	Interlocked byte from memory
				;8591	;		W1	=	Mask
				;8592	;
				;8593	;	Note:  A second WAIT BDISP VALID is done for BBSSI and BBCCI, but
				;8594	;	this command has no side effects if the first succeeded.
				;8595
				;8596	BBX.RDLK.MAKE.MASK:
				;8597		;---------------------------------------;
				;8598		[W0] <-- MEM.LOCK (VA), LEN(DL),	; read selected byte
E 46C  004C,0004,0400,0471 J 471;8599		GOTO [BBX.MAKE.MASK.WAIT.BDISP] 	; form mask, return to caller
				;8600
				;8601
				;8602	;	Subroutine to form a mask of the selected bit.
				;8603	;
				;8604	;	Entry conditions:
				;8605	;		SC	=	Position of bit within longword
				;8606	;
				;8607	;	Exit conditions:
				;8608	;		W1	=	Mask
				;8609
				;8610	BBX.MAKE.MASK.WAIT.BDISP:
				;8611		;---------------------------------------;
				;8612		[W1] <-- [K1] LSH (SC), LONG,		; form mask from position
				;8613		WAIT BDISP VALID,			; wait until displacement is valid
E 471  0005,4002,0B20,0800 R	;8614		RETURN					; return to caller
				;8615
;8616	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  264
;      CTRL.MIC 	     BLBx										      /REV=
;															       CTRL
;8617	.TOC	"	BLBx"
;8618
;8619	;	These instructions test the low order bit of the source operand.
;8620	;
;8621	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch	BCOND
;8622	;	--------      ------	---------				----	-----		--------	-----
;8623	;	BLBS		E8	if src.rl<0> eql 1			1	r/l		BLBX..		SHF<0>
;8624	;					then PC <-- PC + sext(displ.bb)
;8625	;	BLBC		E9	if src.rl<0> eql 0			1	r/l		BLBX..		~SHF<0>
;8626	;					then PC <-- PC + sext(displ.bb)
;8627	;
;8628	;	Entry conditions:
;8629	;		source queue	=	src.rl operand
;8630	;		dest queue	=	none
;8631	;		branch queue	=	conditional branch entry, including prediction
;8632	;		field queue	=	none
;8633	;		DL		=	LONG
;8634	;		Ibox state	=	running, has updated the PC with predicted address
;8635	;		Mbox state	=	running
;8636	;
;8637	;	Exit conditions:
;8638	;		The prediction state is evaluated and sent to the Ibox and a microtrap is generated
;8639	;		if the prediction is wrong.
;8640	;		The branch queue entry is retired.
;8641	;
;8642	;	Condition codes:
;8643	;		N <-- N
;8644	;		Z <-- Z
;8645	;		V <-- V 		[Integer overflow trap disabled.]
;8646	;		C <-- C
;8647	;
				;8648	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  265
;      CTRL.MIC 	     BLBx										      /REV=
;															       CTRL
				;8649
				;8650	;	BLBx operation:
				;8651	;
				;8652	;		if (src.rl<0> eql x) then PC <-- PC + sext(displ.bb)
				;8653
				;8654	BLBX..:
				;8655		;********** Hardware dispatch **********;
				;8656		Q <-- PASSA [S1], LONG, 		; test low bit in shifter
				;8657		RETIRE COND BQ ENTRY,			; wait for valid bdisp, test
				;8658							; prediction and trap if wrong,
				;8659							; retire BQE
E 15C  000E,4000,2080,1000 L	;8660		LAST CYCLE				; decode next instruction
				;8661
				;8662	;= END CTRL
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  266
;    MULDIV.MIC 	     MULDIV.MIC -- Multiply and Divide Instructions					      /REV=
;
				;8663	.TOC	"MULDIV.MIC -- Multiply and Divide Instructions"
				;8664	.TOC	"Revision 1.2"
				;8665
				;8666	;	Dan Miner, Bob Supnik
				;8667
;8668	.nobin
;8669	;****************************************************************************
;8670	;*									    *
;8671	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;8672	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;8673	;*  ALL RIGHTS RESERVED.						    *
;8674	;*									    *
;8675	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;8676	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;8677	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;8678	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;8679	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;8680	;*  TRANSFERRED.							    *
;8681	;*									    *
;8682	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;8683	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;8684	;*  CORPORATION.							    *
;8685	;*									    *
;8686	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;8687	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;8688	;*									    *
;8689	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  267
;    MULDIV.MIC 	     Revision History									      /REV=
;
;8690	.TOC	"	Revision History"
;8691
;8692	; Edit	  Date	 Who	     Description
;8693	; ---- --------- ---	---------------------
;8694	;    2 08-Mar-91 GMU	Symptom: Warm MULLx instructions set PSL<V> incorrectly
;8695	;				 when the signs of the operands are different.
;8696	;				 This was caused by a microbranch on the sign
;8697	;				 bit of the multiplier when the multiplicand
;8698	;				 was actually being tested.
;8699	;			Cure:	 At MULL.WARM, pass the multiplier on the A
;8700	;				 bus and the multiplicand on the B bus to
;8701	;				 correctly setup the test on multiplier sign.
;8702	;    1 13-Nov-90 GMU	Symptom: Ibox enters infinite RXS stall on an EDIV
;8703	;				 whose final two specifiers are auto-xcrement
;8704	;				 and GPR, with identical register values.  The
;8705	;				 stall is due to a simultaneous reference of
;8706	;				 these two specifiers by the microcode, which
;8707	;				 causes the Ibox to see a source queue retire
;8708	;				 for the GPR before the scoreboard is incremented,
;8709	;				 which causes the scoreboard to decrement below
;8710	;				 zero.
;8711	;			Cure:	 Separate the queue references for the final
;8712	;				 two specifiers such that they are in different
;8713	;				 microinstructions.
;8714	; (1)0 20-Jul-90 GMU	Initial production microcode.
;8715	;
;8716	; Begin version 1.0 here
;8717	;   15 19-Jul-90 GMU	Update with Bob's review comments.
;8718	;   14 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;8719	;   13 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;8720	;   12 21-Mar-90 DGM	Update comments
;8721	;   11 03-Feb-90 GMU	Document simultaneous reference restriction for EDIV.
;8722	;   10 18-Jan-90 DGM	Fix uCode restriction violation (cannot read Q after SMUL/UDIV)
;8723	;			  and rename FBOX.DISABLE to FBOX.CONDITION
;8724	;    9 16-Jan-90 DGM	Change field queue alignment
;8725	;    8 11-Jan-90 DGM	Fix bug in EDIV
;8726	;    7 28-Nov-89 DGM	Optimize MULx and DIVx flows.  Also fixed bug in EDIV
;8727	;    6 26-Sep-89 DGM	Fix MULBn overflow and EDIV divide by zero
;8728	;    5 21-Sep-89 GMU	Create INT.MUL.LONG entry point to be shared with INDEX.
;8729	;    4 28-Aug-89 DGM	Fix multiple bugs in EDIV & one in multiply code
;8730	;    3 17-Aug-89 GMU	convert split dispatch to use field queue for EDIV.
;8731	;    2 22-Jun-89 DGM	Add warm MUL & DIV microcode
;8732	;    1	2-Dec-88 DB	Add FBOX DEST CHECK -- for new Fbox interface
;8733	; (0)0	3-Dec-87 RMS	Trial microcode.
;8734
				;8735	.bin
				;8736	;= BEGIN MULDIV
;8737	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  268
;    MULDIV.MIC 	     Revision History									      /REV=
;															     MULDIV
;8738
;8739	;	This module implements integer multiply and divide.
;8740	;	The instructions implemented here are:
;8741	;
;8742	;	Opcode	 Instruction							N Z V C 	Exceptions
;8743	;	------	 -----------							------- 	----------
;8744	;
;8745	;	86	 DIVB2 divr.rb, quo.mb						* * * 0 	iov, idvz
;8746	;	C6	 DIVL2 divr.rl, quo.ml						* * * 0 	iov, idvz
;8747	;	A6	 DIVW2 divr.rw, quo.mw						* * * 0 	iov, idvz
;8748	;
;8749	;	87	 DIVB3 divr.rb, divd.rb, quo.wb 				* * * 0 	iov, idvz
;8750	;	C7	 DIVL3 divr.rl, divd.rl, quo.wl 				* * * 0 	iov, idvz
;8751	;	A7	 DIVW3 divr.rw, divd.rw, quo.ww 				* * * 0 	iov, idvz
;8752	;
;8753	;	7B	 EDIV divr.rl, divd.rq, quo.wl, rem.wl				* * * 0 	iov, idvz
;8754	;
;8755	;	7A	 EMUL mulr.rl, muld.rl, add.rl, prod.wq 			* * 0 0
;8756	;
;8757	;	84	 MULB2 mulr.rb, prod.mb 					* * * 0 	iov
;8758	;	C4	 MULL2 mulr.rl, prod.ml 					* * * 0 	iov
;8759	;	A4	 MULW2 mulr.rw, prod.mw 					* * * 0 	iov
;8760	;
;8761	;	85	 MULB3 mulr.rb, muld.rb, prod.wb				* * * 0 	iov
;8762	;	C5	 MULL3 mulr.rl, muld.rl, prod.wl				* * * 0 	iov
;8763	;	A5	 MULW3 mulr.rw, muld.rw, prod.ww				* * * 0 	iov
;8764	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  269
;    MULDIV.MIC 	     Revision History									      /REV=
;															     MULDIV
;8765
;8766	;					CAUTION
;8767	;					-------
;8768	;
;8769	;	Ebox microcode for any instruction whose IROM entry contains a .ax or
;8770	;	.vx specifier followed immediately by a .rx, .mx, or .vx specifier may not
;8771	;	reference the source queue entries for this pair of specifiers in the
;8772	;	same microinstruction.	This restriction is necessary to avoid getting
;8773	;	the incorrect operand data for the second specifier of the pair if the
;8774	;	first specifier of the pair is auto-increment, auto-decrement, or auto-increment
;8775	;	deferred, and the second specifier of the pair is register mode using the
;8776	;	same register specified for the first specifier of the pair.  Because the Ibox
;8777	;	must write both the address operand to the MD, and the auto-inc/dec value
;8778	;	to the GPR, the Ebox may read the old value of the GPR if both specifiers
;8779	;	are referenced in the same microword.  In addition, a simultaneous reference
;8780	;	to these specifiers may cause an infinite Ibox RXS stall if the source
;8781	;	queue retire for the second GPR specifier arrives at the Ibox before
;8782	;	the scoreboard is incremented.
;8783	;
;8784	;	This restriction does not apply if, by context, it is known that the
;8785	;	second specifier of the pair is not register mode.
;8786	;
;8787	;	One instruction processed by this module is affected by this
;8788	;	restriction.  The following table lists the restriction for each instruction using
;8789	;	the notation [spec n; spec n+1] to denote a restriction in referencing the
;8790	;	source queue entries for these two specifiers in the same microinstruction.
;8791	;
;8792	;	Entry Point   Opcode   Mnemonic 		   Restriction
;8793	;	-----------   ------   -------- 	----------------------------------
;8794	;	EDIV..		7B	EDIV		[spec 3; spec 4]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  270
;    MULDIV.MIC 	     MULBn, MULWn, MULLn								      /REV=
;															     MULDIV
;8795	.TOC	"	MULBn, MULWn, MULLn"
;8796
;8797	;	These instructions multiply two integers.
;8798	;
;8799	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;8800	;	--------      ------	---------				----	-----		--------
;8801	;	MULB2		84	prod.mb <-- mulr.rb * prod.mb		2	rm/bb		MULBN..
;8802	;	MULW2		A4	prod.mw <-- mulr.rw * prod.mw		2	rm/ww		MULWN..
;8803	;	MULL2		C4	prod.ml <-- mulr.rl * prod.ml		2	rm/ll		MULLN..
;8804	;
;8805	;	MULB3		85	prod.wb <-- mulr.rb * muld.rb		3	rrw/bbb 	MULBN..
;8806	;	MULW3		A5	prod.ww <-- mulr.rw * muld.rw		3	rrw/www 	MULWN..
;8807	;	MULL3		C5	prod.wl <-- mulr.rl * muld.rl		3	rrw/lll 	MULLN..
;8808	;
;8809	;	Entry conditions:		(2 operand)	(3 operand)
;8810	;		source queue	=	mulr.rx 	mulr.rx   operand
;8811	;					prod.mx 	muld.rx   operand
;8812	;		dest queue	=	prod.mx 	prod.wx   result
;8813	;		branch queue	=	none
;8814	;		field queue	=	none
;8815	;		DL		=	data type of last (prod) operand
;8816	;		Ibox state	=	running
;8817	;		Mbox state	=	running
;8818	;
;8819	;	Exit conditions:
;8820	;		The PSL condition codes are set.
;8821	;		The result has been written to the destination memory location or register.
;8822	;
;8823	;	Condition codes:
;8824	;		N <-- product LSS 0
;8825	;		Z <-- product EQL 0
;8826	;		V <-- overflow			[Integer overflow trap enabled.]
;8827	;		C <-- 0
;8828	;
				;8829	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  271
;    MULDIV.MIC 	     MULBn, MULWn, MULLn								      /REV=
;															     MULDIV
				;8830
				;8831	;	MULBn operation:
				;8832	;
				;8833	;		dst.mb <-- src.rb * dst.mb	(2 operands)
				;8834	;		dst.wb <-- src1.rb * src2.rb	(3 operands)
				;8835
				;8836	MULBN..:
				;8837		;********** Hardware dispatch **********;
				;8838		Q <-- PASSA [S1], LONG, 		; get first operand (multiplier)
E 160  0082,6000,0880,0442 J 442;8839		[W1] <-- 000000[00]			; clear high-order result
				;8840
				;8841		;---------------------------------------;
				;8842		[W0] <-- [S1] LSH [24.], LONG,		; left justify second operand (multiplicand)
E 442  A001,5802,0480,45E6 B 4E6;8843		CASE [A.7-5] AT [MULBN.MULR.POS]	; break out on sign of multiplier
				;8844
				;8845	;= ALIGNLIST	011x	(MULBN.MULR.POS,	MULBN.MULR.NEG)
				;8846
				;8847	MULBN.MULR.NEG:
				;8848		;---------------------------------------; a<7> = 1:
			    p277;8849		[W1] <-- [W1] SMUL [W0], LONG,		; do first multiply step
E 4EE  0E02,0008,0820,22A2 S 2A2;8850		CALL [INT.MULT.7.STEPS] 		; W1<31:16> <-- Q<7:0> * W0<31:24>
				;8851							; >> No Q write last cycle
				;8852
				;8853		;---------------------------------------;
				;8854		[W1] <-- [W1] - [W0], LONG,		; adjust result for negative multiplier
				;8855							; >> No Q read this cycle
E 4EF  0A80,0008,0820,04E7 J 4E7;8856		GOTO [MULBN.CONT]			; join common flow
				;8857
				;8858	MULBN.MULR.POS:
				;8859		;---------------------------------------; a<7> = 0:
			    p277;8860		[W1] <-- [W1] SMUL [W0], LONG,		; do first multiply step
E 4E6  0E02,0008,0820,22A2 S 2A2;8861		CALL [INT.MULT.7.STEPS] 		; W1<31:16> <-- Q<7:0> * W0<31:24>
				;8862							; >> No Q write last cycle
				;8863
				;8864	MULBN.CONT:
				;8865		;---------------------------------------;
				;8866		Q&, [DST] <-- ZEXT [W1] RSH [16.],	; write byte result, save in Q
E 4E7  0003,D016,2400,0473 J 473;8867		LEN(DL) 				; Q & VA are written as long despite len(dl)
				;8868							; >> No Q read this cycle
				;8869
				;8870		;---------------------------------------;
E 473  0001,D812,0800,0475 J 475;8871		[W1] <-- ZEXT [W1] RSH [24.], LONG	; get result extension
				;8872
				;8873		;---------------------------------------;
				;8874		[WBUS] <-- [Q] LSH [24.], LEN(DL),	; set shifter sign to sign of result
			    p273;8875		SET PSL CC.IIII,			; set psl cc's
E 475  0001,5806,20AD,0481 J 481;8876		GOTO [MULX.CHECK.OVERFLOW]		; check overflow and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  272
;    MULDIV.MIC 	     MULBn, MULWn, MULLn								      /REV=
;															     MULDIV
				;8877
				;8878	;	MULWn operation:
				;8879	;
				;8880	;		dst.mw <-- src.rw * dst.mw	(2 operands)
				;8881	;		dst.ww <-- src1.rw * src2.rw	(3 operands)
				;8882
				;8883	MULWN..:
				;8884		;********** Hardware dispatch **********;
				;8885		Q <-- PASSA [S1], LONG, 		; get first operand (multiplier)
E 162  0082,6000,0880,0443 J 443;8886		[W1] <-- 000000[00]			; clear high-order result
				;8887
				;8888		;---------------------------------------;
				;8889		[W0] <-- [S1] LSH [16.], LONG,		; left justify second operand (multiplicand)
E 443  C001,5002,0480,46F6 B 4F6;8890		CASE [A.15-12] AT [MULWN.MULR.POS]	; break out on sign of multiplier
				;8891
				;8892	;= ALIGNLIST	011x	(MULWN.MULR.POS,	MULWN.MULR.NEG)
				;8893
				;8894	MULWN.MULR.NEG:
				;8895		;---------------------------------------; a<15> = 1:
			    p277;8896		[W1] <-- [W1] SMUL [W0], LONG,		; do first multiply step
E 4FE  0E02,0008,0820,22A1 S 2A1;8897		CALL [INT.MULT.15.STEPS]		; W1<31:0> <-- Q<15:0> * W0<31:16>
				;8898							; >> No Q write last cycle
				;8899
				;8900		;---------------------------------------;
				;8901		[W1] <-- [W1] - [W0], LONG,		; adjust result for negative multiplier
				;8902							; >> No Q read this cycle
E 4FF  0A80,0008,0820,04F7 J 4F7;8903		GOTO [MULWN.CONT]			; join common flow
				;8904
				;8905	MULWN.MULR.POS:
				;8906		;---------------------------------------; a<15> = 0:
			    p277;8907		[W1] <-- [W1] SMUL [W0], LONG,		; do first multiply step
E 4F6  0E02,0008,0820,22A1 S 2A1;8908		CALL [INT.MULT.15.STEPS]		; W1<31:0> <-- Q<15:0> * W0<31:16>
				;8909							; >> No Q write last cycle
				;8910
				;8911	MULWN.CONT:
				;8912		;---------------------------------------;
				;8913		VA <-- B [W1],				; save result
E 4F7  0081,D013,0800,0477 J 477;8914		[W1] <-- ZEXT [W1] RSH [16.], LONG	; extract extended result
				;8915							; >> No Q read last cycle
				;8916
				;8917		;---------------------------------------;
				;8918		[DST] <-- [VA], LEN(DL),		; write word result
				;8919		Q <-- [VA] LSH [16.],			; set shifter sign to sign of result
				;8920							; Q is written as long despite len(dl)
			    p273;8921		SET PSL CC.IIII,			; set psl cc's
E 477  0003,5004,24BD,0481 J 481;8922		GOTO [MULX.CHECK.OVERFLOW]		; check overflow and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  273
;    MULDIV.MIC 	     MULBn, MULWn, MULLn								      /REV=
;															     MULDIV
				;8923
				;8924	;	MULLn operation:
				;8925	;
				;8926	;		dst.ml <-- src.rl * dst.ml	(2 operands)
				;8927	;		dst.wl <-- src1.rl * src2.rl	(3 operands)
				;8928
				;8929	MULLN..:
				;8930		;********** Hardware dispatch **********;
				;8931		NOP NODEST, MULL,			; tell E-box this instr may still
				;8932							; execute even if F-box is disabled
E 164  2000,0000,0000,D11D B 11D;8933		CASE [FBOX.CONDITION] AT [MULL.HOT]	; case on F-box disabled
				;8934
				;8935	;= ALIGNLIST 110x	(MULL.HOT,		MULL.WARM)
				;8936
				;8937	MULL.HOT:
				;8938		;---------------------------------------;
				;8939		FBOX OPERAND A[S1] B[S2], LONG, 	; send operands to F-box
				;8940		FBOX DEST CHECK,			; update F-box scoreboard
E 11D  1002,4348,0080,1000 L	;8941		LAST CYCLE NO RETIRE			; decode next instruction
				;8942
				;8943	MULL.WARM:
				;8944		;---------------------------------------;
				;8945		Q <-- PASSA [S1], LONG, 		; get first operand (multiplier)
E 11F  0082,4048,0480,0415 J 415;8946		[W0] <-- B [S2] 			; get second operand (multiplicand)
				;8947
				;8948		;---------------------------------------;
			    p276;8949		[W1] <-- 0,				; clear W1 for multiply
E 415  E000,C002,0800,6796 C 496;8950		CALL CASE [A31.BQA.BNZ1] AT [INT.MULT.LONG.POS] ; case on sign of multiplier
				;8951							; W<31:0>'Q<31:0> <-- Q<31:0> * W0<31:0>
				;8952							; >> no Q write this cycle
				;8953							; >> call requires all 6 microstack locations
				;8954
				;8955		;---------------------------------------;
				;8956		[DST] <-- PASSA [Q], LONG,		; write longword result, set shifter sign
				;8957		VA <-- [Q],				; pass result through ALU for correct CC's
E 416  0000,4003,24AD,0481 J 481;8958		SET PSL CC.IIII 			; set psl.nz
				;8959
				;8960	MULX.CHECK.OVERFLOW:
				;8961		;---------------------------------------;
				;8962		[WBUS] <-- [SHIFT.SIGN] XOR [W1], LEN(DL), ; check extended result = sign ext of result
				;8963		SET PSL CC.PPJP,			; set psl.v on mismatch
E 481  0600,0014,239E,9800 L	;8964		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;8965
;8966	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  274
;    MULDIV.MIC 	     EMUL										      /REV=
;															     MULDIV
;8967	.TOC	"	EMUL"
;8968
;8969	;	This instruction multiplies two integers to produce a quadword.
;8970	;
;8971	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;8972	;	--------      ------	---------				----	-----		--------
;8973	;	EMUL		7A	prod.wq <-- mulr.rl * muld.rl + 	4     rrrw/lllq 	EMUL..
;8974	;					    sext(add.rl)
;8975	;
;8976	;	Entry conditions:
;8977	;		source queue	=	mulr.rl operand
;8978	;					muld.rl operand
;8979	;					add.rl	operand
;8980	;		dest queue	=	prod.wq result
;8981	;		branch queue	=	none
;8982	;		field queue	=	none
;8983	;		DL		=	QUAD
;8984	;		Ibox state	=	running
;8985	;		Mbox state	=	running
;8986	;
;8987	;	Exit conditions:
;8988	;		The PSL condition codes are set.
;8989	;		The result has been written to the destination memory location or register.
;8990	;
;8991	;	Condition codes:
;8992	;		N <-- product LSS 0
;8993	;		Z <-- product EQL 0
;8994	;		V <-- 0 			[Integer overflow trap disabled.]
;8995	;		C <-- 0
;8996	;
				;8997	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  275
;    MULDIV.MIC 	     EMUL										      /REV=
;															     MULDIV
				;8998
				;8999	;	EMUL operation:
				;9000	;
				;9001	;		prod.wq <-- mulr.rl * muld.rl + sext(add.rl)
				;9002
				;9003	EMUL..:
				;9004		;********** Hardware dispatch **********;
				;9005		Q <-- PASSA [S1], LONG, 		; get first operand (multiplier)
E 166  0082,4048,0480,0421 J 421;9006		[W0] <-- B [S2] 			; get second operand (multiplicand)
				;9007
				;9008		;---------------------------------------;
			    p276;9009		[W1] <-- [S1], LONG,			; get third operand (addend)
E 421  E000,0000,0880,6796 C 496;9010		CALL CASE [A31.BQA.BNZ1] AT [INT.MULT.LONG.POS] ; case on sign of multiplier
				;9011							; W1<31:0>'Q<31:0> <-- Q<31:0> * W0<31:0>
				;9012							;			       + W1<31:0>
				;9013							; >> no Q write this cycle
				;9014							; >> call requires all 6 microstack locations
				;9015
				;9016		;---------------------------------------;
				;9017		[DST] <-- [Q], LONG,			; write lower longword result
E 422  0000,0000,24AD,0482 J 482;9018		SET PSL CC.IIII 			; set psl.nz
				;9019
				;9020		;---------------------------------------;
				;9021		[DST] <-- [W1], LONG,			; write upper longword result
				;9022		SET PSL CC.IIIP.QUAD,			; set psl cc's based on 2nd LW
E 482  0000,0000,242E,1000 L	;9023		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  276
;    MULDIV.MIC 	     EMUL										      /REV=
;															     MULDIV
				;9024
				;9025	;	Subroutine to perform a longword multiply
				;9026	;
				;9027	;	Entry conditions:
				;9028	;		Q	=	multiplier
				;9029	;		W0	=	multiplicand
				;9030	;		W1	=	0 or addend
				;9031	;		Q not written in the calling microword
				;9032	;		Call case on sign of multiplier
				;9033	;
				;9034	;	Exit conditions:
				;9035	;		W1'Q	=	product, adjusted for sign
				;9036	;		Q not readable by return microword
				;9037	;
				;9038	;	*******************************************************************
				;9039	;	* WARNING: THIS SUBROUTINE REQUIRES ALL SIX MICROSTACK LOCATIONS, *
				;9040	;	* AND MAY NOT BE CALLED FROM A SUBROUTINE.			  *
				;9041	;	*******************************************************************
				;9042
				;9043	;= ALIGNLIST	011x	(INT.MULT.LONG.POS,	INT.MULT.LONG.NEG)
				;9044
				;9045	INT.MULT.LONG.POS:
				;9046		;---------------------------------------; a<31> = 0:
			    p277;9047		[W1] <-- [W1] SMUL [W0], LONG,		; do first multiply step
E 496  0E02,0008,0820,22A0 S 2A0;9048		CALL [INT.MULT.31.STEPS]		; W1<31:0>'Q<31:0> <-- Q<31:0> * W0<31:0>
				;9049							; >> No Q write last cycle
				;9050
				;9051	WAIT.ONE.CYCLE: 				; Single-cycle routine to wait
				;9052		;---------------------------------------; one cycle
E 497  0000,0000,2000,0800 R	;9053		RETURN					; >> No Q read this cycle
				;9054
				;9055	INT.MULT.LONG.NEG:
				;9056		;---------------------------------------; a<31> = 1:
			    p277;9057		[W1] <-- [W1] SMUL [W0], LONG,		; do first multiply step
E 49E  0E02,0008,0820,22A0 S 2A0;9058		CALL [INT.MULT.31.STEPS]		; W1<31:0>'Q<31:0> <-- Q<31:0> * W0<31:0>
				;9059							; >> No Q write last cycle
				;9060
				;9061		;---------------------------------------;
				;9062		[W1] <-- [W1] - [W0], LONG,		; adjust result for negative multiplier
E 49F  0A80,0008,0820,0800 R	;9063		RETURN					; return to caller
				;9064							; >> No Q read this cycle
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  277
;    MULDIV.MIC 	     EMUL										      /REV=
;															     MULDIV
				;9065
				;9066	;	Subroutines to perform 31, 15, 7, 3, or 1 multiply steps.
				;9067	;
				;9068	;	Entry conditions:
				;9069	;		Q	=	multiplier
				;9070	;		W0	=	multiplicand
				;9071	;		W1	=	0 or addend
				;9072	;		Q not written in the calling microword
				;9073	;
				;9074	;	Exit conditions:
				;9075	;		W1'Q	=	product, unadjusted for sign
				;9076	;		Q not readable by return microword
				;9077	;
				;9078	;	************************************************************************
				;9079	;	* WARNING: INT.MULT.31.STEPS REQUIRES 5 OF THE 6 MICROSTACK LOCATIONS, *
				;9080	;	* AND MAY NOT BE CALLED WHILE NESTED MORE THAN 1 LEVEL. 	       *
				;9081	;	************************************************************************
				;9082
				;9083	INT.MULT.31.STEPS:
				;9084		;---------------------------------------;
				;9085		[W1] <-- [W1] SMUL [W0], LONG,		; do signed multiply step
E 2A0  0E02,0008,0820,22A1 S 2A1;9086		CALL [INT.MULT.15.STEPS]		; call subroutine to do 15 steps
				;9087
				;9088	INT.MULT.15.STEPS:
				;9089		;---------------------------------------;
				;9090		[W1] <-- [W1] SMUL [W0], LONG,		; do signed multiply step
E 2A1  0E02,0008,0820,22A2 S 2A2;9091		CALL [INT.MULT.7.STEPS] 		; call subroutine to do 7 steps
				;9092							; fall through to do 7 more steps
				;9093
				;9094	INT.MULT.7.STEPS:
				;9095		;---------------------------------------;
				;9096		[W1] <-- [W1] SMUL [W0], LONG,		; do signed multiply step
E 2A2  0E02,0008,0820,22A3 S 2A3;9097		CALL [INT.MULT.3.STEPS] 		; call subroutine to do 3 steps
				;9098							; fall through to do 3 more steps
				;9099
				;9100	INT.MULT.3.STEPS:
				;9101		;---------------------------------------;
				;9102		[W1] <-- [W1] SMUL [W0], LONG,		; do signed multiply step
E 2A3  0E02,0008,0820,22A4 S 2A4;9103		CALL [INT.MULT.1.STEP]			; call subroutine to do 1 step
				;9104							; fall through to do 1 more step
				;9105
				;9106	INT.MULT.1.STEP:
				;9107		;---------------------------------------;
				;9108		[W1] <-- [W1] SMUL [W0], LONG,		; do signed multiply step
E 2A4  0E02,0008,0820,0800 R	;9109		RETURN
				;9110
;9111	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  278
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
;9112	.TOC	"	DIVBn, DIVWn, DIVLn"
;9113
;9114	;	These instructions divide two integers and return the quotient.
;9115	;
;9116	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;9117	;	--------      ------	---------				----	-----		--------
;9118	;	DIVB2		86	quo.mb <-- quo.mb / divr.rb		2	rm/bb		DIVBN..
;9119	;	DIVW2		A6	quo.mw <-- quo.mw / divr.rw		2	rm/ww		DIVWN..
;9120	;	DIVL2		C6	quo.ml <-- quo.ml / divr.rl		2	rm/ll		DIVLN..
;9121	;
;9122	;	DIVB3		87	quo.wb <-- divd.rb / divr.rb		3	rrw/bbb 	DIVBN..
;9123	;	DIVW3		A7	quo.ww <-- divd.rw / divr.rw		3	rrw/www 	DIVWN..
;9124	;	DIVL3		C7	quo.wl <-- divd.rl / divr.rl		3	rrw/lll 	DIVLN..
;9125	;
;9126	;	Entry conditions:		(2 operand)	(3 operand)
;9127	;		source queue	=	divr.rx 	divr.rx   operand
;9128	;					quo.mx		divd.rx   operand
;9129	;		dest queue	=	quo.mx		quo.wx	  result
;9130	;		branch queue	=	none
;9131	;		field queue	=	none
;9132	;		DL		=	data type of last (quo) operand
;9133	;		Ibox state	=	running
;9134	;		Mbox state	=	running
;9135	;
;9136	;	Exit conditions:
;9137	;		The PSL condition codes are set.
;9138	;		The result has been written to the destination memory location or register.
;9139	;
;9140	;	Condition codes:
;9141	;		N <-- product LSS 0
;9142	;		Z <-- product EQL 0
;9143	;		V <-- overflow or divide by zero	[Integer overflow trap enabled.]
;9144	;		C <-- 0
;9145	;
;9146	;	Notes:
;9147	;	    1)	Performance:  After the UDIV steps are finished, there is a NOP cycle
;9148	;		inserted before Q is read to meet a microcode restriction.  (Q is not
;9149	;		readable in the cycle immediately after a SMUL/UDIV instruction.)
;9150	;
				;9151	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  279
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
				;9152
				;9153	;	DIVBn operation:
				;9154	;
				;9155	;		quo.mb <-- quo.mb / divr.rb	(2 operand)
				;9156	;		quo.wb <-- divd.rb / divr.rb	(3 operand)
				;9157
				;9158	DIVBN..:
				;9159		;********** Hardware dispatch **********;
				;9160		[W0] <-- B [S1], LEN(DL),		; get divisor, zero ext, test cc's
				;9161		Q <-- PASSA [S2],			; get dividend, test msb
E 168  0082,4044,0490,0232 J 232;9162			sim cond [s34.000]
				;9163
				;9164		;---------------------------------------;
				;9165		[W2] <-- [Q], LEN(DL),			; save dividend, zero ext
			    p284;9166		Q <-- [Q] LSH [24.],			; left justify dividend
E 232  A003,5804,0CA0,6557 C 257;9167		CALL CASE [A.7-5] AT [IDIV.SETUP]	; case on divd sign to start divide
				;9168							;   get absolute value of divd and divr
				;9169							;   also save signs in state bits
				;9170
				;9171		;---------------------------------------;
			    p281;9172		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 233  0E82,0008,1040,040A J 40A;9173		GOTO [IDIV.8.STEPS]			; go do remaining 8 steps
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  280
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
				;9174
				;9175	;	DIVWn operation:
				;9176	;
				;9177	;		quo.mw <-- quo.mw / divr.rw	(2 operand)
				;9178	;		quo.ww <-- divd.rw / divr.rw	(3 operand)
				;9179
				;9180	DIVWN..:
				;9181		;********** Hardware dispatch **********;
				;9182		[W0] <-- B [S1], LEN(DL),		; get divisor, zero ext, test cc's
				;9183		Q <-- PASSA [S2],			; get dividend, test msb
E 16A  0082,4044,0490,0243 J 243;9184			sim cond [s34.000]
				;9185
				;9186		;---------------------------------------;
				;9187		[W2] <-- [Q], LEN(DL),			; save dividend, zero ext
			    p284;9188		Q <-- [Q] LSH [16.],			; left justify dividend
E 243  C003,5004,0CA0,6657 C 257;9189		CALL CASE [A.15-12] AT [IDIV.SETUP]	; case on divd sign to start divide
				;9190							;   get absolute value of divd and divr
				;9191							;   also save signs in state bits
				;9192
				;9193		;---------------------------------------;
			    p281;9194		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 244  0E82,0008,1040,0409 J 409;9195		GOTO [IDIV.16.STEPS]			; go do remaining 16 steps
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  281
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
				;9196
				;9197	;	DIVLn operation:
				;9198	;
				;9199	;		quo.ml <-- quo.ml / divr.rl	(2 operand)
				;9200	;		quo.wl <-- divd.rl / divr.rl	(3 operand)
				;9201
				;9202	DIVLN..:
				;9203		;********** Hardware dispatch **********;
				;9204		[W0] <-- B [S1], LEN(DL),		; get divisor, zero ext, test cc's
				;9205		Q <-- PASSA [S2],			; get dividend msb
E 16C  0082,4044,0490,0254 J 254;9206			sim cond [s34.000]
				;9207
				;9208		;---------------------------------------;
			    p284;9209		[W2] <-- [Q], LEN(DL),			; save dividend, zero ext
E 254  E000,0004,0CA0,6757 C 257;9210		CALL CASE [A31.BQA.BNZ1] AT [IDIV.SETUP] ; case on divd sign to start divide
				;9211							;   get absolute value of divd and divr
				;9212							;   also save signs in state bits
				;9213
				;9214		;---------------------------------------;
E 255  0E82,0008,1040,0408 J 408;9215		[W3] <-- [W3] UDIV [W0], LONG		; do divide step
				;9216
				;9217		;---------------------------------------;
			    p299;9218		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 408  0E82,0008,1040,22A6 S 2A6;9219		CALL [DIVIDE.15.STEPS]			; do 15 divide steps
				;9220
				;9221	; Enter here from DIVWn flow
				;9222
				;9223	IDIV.16.STEPS:
				;9224		;---------------------------------------;
			    p299;9225		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 409  0E82,0008,1040,22A7 S 2A7;9226		CALL [DIVIDE.7.STEPS]			; do 7 divide steps
				;9227
				;9228	; Enter here from DIVBn flow
				;9229
				;9230	IDIV.8.STEPS:
				;9231		;---------------------------------------;
			    p299;9232		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 40A  0E82,0008,1040,22A7 S 2A7;9233		CALL [DIVIDE.7.STEPS]			; do 7 divide steps
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  282
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
				;9234
				;9235	;	Integer divide, continued.
				;9236	;	Divide complete.  For no overflow cases, adjust sign of quotient.
				;9237
				;9238	;	At this point,
				;9239	;		W2	=	dividend
				;9240	;		Q	=	quotient
				;9241
				;9242		;---------------------------------------;
				;9243		NOP,					; >> Q not readable this cycle
E 40B  4000,0000,2000,4A48 B 448;9244		CASE [STATE.2-0] AT [IDIV.STATE.00]	; case on signs of divisor, dividend
				;9245
				;9246	;= ALIGNLIST *00x	(IDIV.STATE.00, 	IDIV.STATE.01,
				;9247	;=			 IDIV.STATE.10, 	IDIV.STATE.11)
				;9248	;  STATE<2> = 0 --> STATE<2:0> = 0??
				;9249
				;9250	IDIV.STATE.00:
				;9251		;---------------------------------------; divisor +, dividend +:
				;9252		[DST] <-- [Q], LEN(DL), 		; store quotient
				;9253		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 448  0000,0004,24AD,1000 L	;9254		LAST CYCLE				; decode next instruction (no overflow)
				;9255
				;9256	IDIV.STATE.01:
				;9257		;---------------------------------------; divisor +, dividend -:
			    p283;9258		[W0] <-- -[Q], LEN(DL), 		; negate quotient
E 44A  0D00,0054,0400,045C J 45C;9259		GOTO [IDIV.STATE.11.NO.OVERFLOW]	; go store result
				;9260
				;9261	IDIV.STATE.10:
				;9262		;---------------------------------------; divisor -, dividend +:
			    p283;9263		[W0] <-- -[Q], LEN(DL), 		; negate quotient
E 44C  0D00,0054,0400,045C J 45C;9264		GOTO [IDIV.STATE.11.NO.OVERFLOW]	; go store result
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  283
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
				;9265
				;9266	;	Integer divide, continued.
				;9267	;	Divide complete.  For -/-, test for result = largest negative number.
				;9268
				;9269	;	At this point,
				;9270	;		W0	=	negated quotient
				;9271	;		W2	=	dividend
				;9272	;		Q	=	quotient
				;9273	;		alu cc's =	set from quotient negation
				;9274
				;9275	IDIV.STATE.11:
				;9276		;---------------------------------------; divisor -, dividend -:
				;9277		NODST <-- -[Q], LEN(DL),		; negate quotient
			    p276;9278		[W0] <-- PASSB [Q],			; copy positive quotient to W0
E 44E  0D00,8056,0400,2497 S 497;9279		CALL [WAIT.ONE.CYCLE]			; wait for condition codes
				;9280
				;9281		;---------------------------------------;
				;9282		NOP,					; nothing to do...
E 44F  2000,0000,2000,415C B 45C;9283		CASE [ALU.NZV] AT [IDIV.STATE.11.NO.OVERFLOW]	; case on overflow
				;9284
				;9285	;= ALIGNLIST 110x	(IDIV.STATE.11.NO.OVERFLOW,	IDIV.STATE.11.OVERFLOW)
				;9286
				;9287	IDIV.STATE.11.NO.OVERFLOW:
				;9288		;---------------------------------------; alu.v = 0:
				;9289		[DST] <-- [W0], LEN(DL),		; store quotient
				;9290		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 45C  0000,0004,241D,1000 L	;9291		LAST CYCLE				; decode next instruction (no overflow)
				;9292
				;9293	IDIV.STATE.11.OVERFLOW:
				;9294		;---------------------------------------; alu.v = 1:
				;9295		[DST] <-- [W2], LEN(DL),		; store dividend as result
E 45E  0000,0004,243D,0484 J 484;9296		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;9297
				;9298	SET.PSL.V:
				;9299		;---------------------------------------;
				;9300		SET PSL(V),				; set psl.v
E 484  0080,2008,200E,9800 L	;9301		LAST CYCLE CHECK OVERFLOW		; decode next instruction
				;9302
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  284
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
				;9303
				;9304	;	Integer divide setup routine.
				;9305	;	This routine sets up the data path for an integer divide.
				;9306	;
				;9307	;	Entry conditions:
				;9308	;		W0	=	divisor
				;9309	;		W2	=	dividend
				;9310	;		Q	=	left justified dividend
				;9311	;		alu cc's =	set from divisor
				;9312	;
				;9313	;	Exit conditions:
				;9314	;		W0	=	!divisor!
				;9315	;		W2	=	dividend
				;9316	;		W3	=	0
				;9317	;		Q	=	!left justified dividend!
				;9318
				;9319	;= ALIGNLIST 011x	(IDIV.SETUP,		IDIV.SETUP.NEG)
				;9320
				;9321	IDIV.SETUP:
				;9322		;---------------------------------------; a<msb> = 0:
				;9323		[W3] <-- [Q], LONG,			; save left justified dividend
E 257  2000,0000,10A0,4181 B 281;9324		CASE [ALU.NZV] AT [IDIV.SETUP.DIVR.POS] ; case on divisor
				;9325
				;9326	IDIV.SETUP.NEG:
				;9327		;---------------------------------------; a<msb> = 1:
				;9328		[W3] <-- -[Q], LONG,			; negate left justified dividend
				;9329		STATE.0 <-- 1,				; flag negative dividend
E 25F  2D00,0050,1008,C181 B 281;9330		CASE [ALU.NZV] AT [IDIV.SETUP.DIVR.POS] ; case on divisor
				;9331
				;9332	;= ALIGNLIST 00xx	(IDIV.SETUP.DIVR.POS,	IDIV.SETUP.DIVR.ZERO,
				;9333	;=			 IDIV.SETUP.DIVR.NEG,				)
				;9334	;  ALU.NZVC set by move --> V = C = 0
				;9335
				;9336	IDIV.SETUP.DIVR.ZERO:
				;9337		;---------------------------------------; alu.nz = 01:
				;9338		[DST] <-- [W2], LEN(DL),		; result is dividend
E 285  0000,0004,243D,05BF J 5BF;9339		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;9340
				;9341	DIVIDE.BY.ZERO:
				;9342		;---------------------------------------;
				;9343		SET PSL(V),				; set psl.v
			    p122;9344		RETIRE INSTRUCTION,			; retire instruction
E 5BF  1080,6008,200E,8048 J 048;9345		GOTO [IE.DIVIDE.ERROR..]		; enter exception flows
				;9346
				;9347	IDIV.SETUP.DIVR.NEG:
				;9348		;---------------------------------------; alu.nz = 10:
				;9349		[W0] <-- -[W0], LEN(DL),		; negate divisor
E 289  0D00,000C,0409,0281 J 281;9350		STATE.1 <-- 1				; flag negative divisor
				;9351
				;9352	IDIV.SETUP.DIVR.POS:
				;9353		;---------------------------------------; alu.nz = 00:
				;9354		[W3] <-- [W3] - [W3], LONG,		; clear W3, set alu.c to prime divide loop
				;9355		Q <-- PASSA [W3],			; load !left justified dividend!
E 281  0A82,4020,1040,0800 R	;9356		RETURN					; return to caller
				;9357
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  285
;    MULDIV.MIC 	     DIVBn, DIVWn, DIVLn								      /REV=
;															     MULDIV
;9358	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  286
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
;9359	.TOC	"	EDIV"
;9360	;
;9361	;	This instruction divides two integers and returns both the quotient
;9362	;	and the remainder.
;9363	;
;9364	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;9365	;	--------      ------	---------				----	-----			--------
;9366	;	EDIV		7B	quo.v(m)l <-- divd.rq / divr.rl 	4	rrv(m)m/lqll		EDIV..
;9367	;				rem.wl <-- rem(divd.rq,divr.rl)
;9368	;
;9369	;	Entry conditions:
;9370	;		source queue	=	divr.rl operand
;9371	;					divd.rq operand
;9372	;					quo.ml	operand address (if memory)
;9373	;					rem.ml	operand
;9374	;		dest queue	=	quo.ml result  (if register)
;9375	;					rem.ml result
;9376	;		branch queue	=	none
;9377	;		field queue	=	one valid entry for third (quo) specifier
;9378	;		DL		=	LONG
;9379	;		Ibox state	=	stopped
;9380	;		Mbox state	=	running
;9381	;
;9382	;	Exit conditions:
;9383	;		The PSL condition codes are set.
;9384	;		The result has been written to the destination memory locations or registers.
;9385	;
;9386	;	Condition codes:
;9387	;		N <-- product LSS 0
;9388	;		Z <-- product EQL 0
;9389	;		V <-- overflow or divide by zero	[Integer overflow trap enabled.]
;9390	;		C <-- 0
;9391	;
;9392	;	Notes:
;9393	;		1.  Memory management:	The destination specifiers are coded as type modify
;9394	;		    to allow prechecking of accessibility.
;9395	;		2.  When the first destination is memory and the second destination is
;9396	;		    register, there must be a SYNCHRONIZE MBOX after the memory write.	If
;9397	;		    this is not done, the instruction may complete before the M-Box has a
;9398	;		    chance to report a memory management fault on the first destination.
;9399	;
				;9400	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  287
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9401
				;9402	;	EDIV operation:
				;9403	;
				;9404	;		quo.wl <-- divd.rq / divr.rl
				;9405	;		rem.wl <-- rem(divd.rq, divr.rl)
				;9406	;
				;9407	;
				;9408	;	The following simultaneous reference restriction exists for
				;9409	;	this entry point: [spec 3; spec 4].
				;9410
				;9411	EDIV..:
				;9412		;********** Hardware dispatch **********;
				;9413		[W0] <-- [S1], LONG,			; save divisor, test
				;9414		Q <-- PASSB [S2],			; get low dividend
E 16E  0002,8048,0480,0485 J 485;9415			sim cond k s4.[0]
				;9416
				;9417		;---------------------------------------;
				;9418		[W3] <-- [S1], LONG,			; save high dividend, test sign
E 485  0000,0000,1080,013E J 13E;9419			sim cond k s4.[0]
				;9420
				;9421		;---------------------------------------;
				;9422		VA <-- -[Q],				; negate low dividend if needed
				;9423		[W2] <-- PASSB [Q], LONG,		; save low dividend, test
E 13E  2D00,8053,0C00,41A1 B 1A1;9424		CASE [ALU.NZV] AT [EDIV.DIVR.POS]	; case on divisor test
				;9425
				;9426	;= ALIGNLIST 00xx	(EDIV.DIVR.POS, 	EDIV.DIVR.ZERO,
				;9427	;=			 EDIV.DIVR.NEG, 			)
				;9428	;  ALU.NZVC set by MOV --> V = C = 0
				;9429	;
				;9430	EDIV.DIVR.ZERO:
				;9431		;---------------------------------------; alu.nz = 01:
				;9432		[W0] <-- [W2], LONG,			; quotient result is low dividend
E 1A5  0000,0000,043D,0488 J 488;9433		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;9434
				;9435		;---------------------------------------;
				;9436		STATE.2 <-- 1,				; flag divide by zero
			    p294;9437		[W3] <-- 000000[00], LONG,		; remainder result is 0
E 488  0080,2000,1009,85BE J 5BE;9438		GOTO [EDIV.WRITE.RESULT]		; write result
				;9439
				;9440	EDIV.DIVR.NEG:
				;9441		;---------------------------------------; alu.nz = 10:
				;9442		[W0] <-- -[W0], LONG,			; negate divisor
			    p289;9443		STATE.1 <-- 1,				; flag divisor sign
E 1A9  2D00,0008,0409,41F6 B 1F6;9444		CASE [ALU.NZV] AT [EDIV.DIVD.POS]	; case on high dividend test
				;9445
				;9446	EDIV.DIVR.POS:
				;9447		;---------------------------------------; alu.nz = 00:
			    p289;9448		NOP,					; nothing to do...
E 1A1  2000,0000,2000,41F6 B 1F6;9449		CASE [ALU.NZV] AT [EDIV.DIVD.POS]	; case on high dividend test
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  288
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9450
				;9451	;	Extended divide, continued.
				;9452	;	Divisor sign processed, check dividend sign.
				;9453
				;9454	;	At this point,
				;9455	;		W0	=	!divisor!
				;9456	;		W2 = Q	=	low dividend
				;9457	;		W3	=	high dividend
				;9458	;		VA	=	- low dividend
				;9459	;		STATE<1> =	sign of divisor
				;9460
				;9461	;= ALIGNLIST 01xx	(EDIV.DIVD.POS, 	EDIV.DIVD.NEG)
				;9462	;  ALU.NZVC set by move --> V = C = 0
				;9463
				;9464	EDIV.DIVD.NEG:
				;9465		;---------------------------------------; alu.n = 1:
				;9466		Q <-- PASSA [VA], LONG, 		; negate low order dividend
				;9467		STATE.0 <-- 1,				; flag dividend sign
E 1FE  E002,4000,20B8,CFEA B 1EA;9468		CASE [SHF.NZ.INT] AT [EDIV.DIVD.NEG.NZ] ; case on low order dividend
				;9469
				;9470	;= ALIGNLIST 101x	(EDIV.DIVD.NEG.NZ,	EDIV.DIVD.NEG.Z)
				;9471
				;9472	EDIV.DIVD.NEG.NZ:
				;9473		;---------------------------------------; alu.z = 0:
			    p289;9474		[W3] <-- NOT [W3], LONG,		; complete negation of dividend
E 1EA  0D80,0020,1000,01F6 J 1F6;9475		GOTO [EDIV.DIVD.POS]			; join common flows
				;9476
				;9477	EDIV.DIVD.NEG.Z:
				;9478		;---------------------------------------; alu.z = 1:
			    p289;9479		[W3] <-- -[W3], LONG,			; complete negation of dividend
E 1EE  0D00,0020,1000,01F6 J 1F6;9480		GOTO [EDIV.DIVD.POS]			; join common flows
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  289
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9481
				;9482	;	Extended divide, continued.
				;9483	;	Perform overflow check, start divide.
				;9484
				;9485	;	At this point,
				;9486	;		W0	=	!divisor!
				;9487	;		W2	=	low dividend
				;9488	;		W3'Q	=	!dividend!
				;9489	;		STATE<1:0> =	signs of divisor, dividend
				;9490
				;9491	;	The following compare is intended to check whether divd < divr, that is,
				;9492	;	if divd - divr < 0 (--> alu.c = 0).  However, to start up the divide
				;9493	;	algorithm, alu.c must be 1.  Accordingly, divd - divr > 0 is calculated.
				;9494
				;9495	EDIV.DIVD.POS:
				;9496		;---------------------------------------; alu.nz = 00:
				;9497		[WBUS] <-- [W3] - [W0], LONG,		; compare of divd - divr
				;9498							; if ok, alu.c = 0
E 1F6  0A80,0008,2040,0489 J 489;9499			sim cond k s4.[0]
				;9500
				;9501		;---------------------------------------;
E 489  0A80,0020,2010,0514 J 514;9502		[WBUS] <-- [W0] - [W3], LONG		; make sure alu.c = 1 before first udiv step
				;9503
				;9504		;---------------------------------------;
			    p291;9505		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 514  4E82,0008,1040,425C B 55C;9506		CASE [ALU.NZC] AT [EDIV.NO.OVERFLOW]	; case on overflow test
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  290
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9507
				;9508	;	Extended divide, continued.
				;9509	;	Divide overflow.
				;9510
				;9511	;	At this point,
				;9512	;		W2	=	low dividend
				;9513
				;9514	;= ALIGNLIST 110x	(EDIV.NO.OVERFLOW,	EDIV.OVERFLOW)
				;9515
				;9516	EDIV.OVERFLOW:
				;9517		;---------------------------------------; alu.c = 1:
				;9518		[W0] <-- [W2], LONG,			; quotient result is low dividend
E 55E  0000,0000,043D,048A J 48A;9519		SET PSL CC.IIII 			; set psl cc's, psl map is iiii
				;9520
				;9521		;---------------------------------------;
E 48A  0080,2008,200E,848C J 48C;9522		SET PSL(V)				; set psl.v
				;9523
				;9524		;---------------------------------------;
			    p294;9525		[W3] <-- 000000[00], LONG,		; remainder result is 0
E 48C  0080,2000,1000,05BE J 5BE;9526		GOTO [EDIV.WRITE.RESULT]		; write result
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  291
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9527
				;9528	;	Extended divide, continued.
				;9529	;	Continue divide, first step (of 33) have been executed.
				;9530
				;9531	;	At this point,
				;9532	;		W0	=	!divisor!
				;9533	;		W2	=	low dividend
				;9534	;		W3'Q	=	!dividend!
				;9535	;		STATE<1:0> =	signs of divisor, dividend
				;9536
				;9537	EDIV.NO.OVERFLOW:
				;9538		;---------------------------------------; alu.c = 0:
			    p299;9539		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 55C  0E82,0008,1040,22A5 S 2A5;9540		CALL [DIVIDE.31.STEPS]			; do next 31 divide steps
				;9541
				;9542		;---------------------------------------;
E 55D  0001,8122,1320,0401 J 401;9543		[W3] <-- [K1]!![W3] RSH [1.], LONG	; undo last shift of remainder
				;9544							; >> Q not readable this cycle
				;9545
				;9546		;---------------------------------------;
				;9547		[W4] <-- -[Q], LONG,			; negate quotient to test for overflow
				;9548		Q <-- PASSB [Q],			; recycle quotient to test for overflow
			    p292;9549		CASE [ALU.NZC] AT [EDIV.REM.NEG],	; case on last step positive or negative
E 401  4D02,8050,1400,421D B 41D;9550			sim cond k s4.[0]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  292
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9551
				;9552	;	Extended divide, continued.
				;9553	;	Cleanup remainder, signs.
				;9554
				;9555	;	At this point,
				;9556	;		W0	=	!divisor!
				;9557	;		W2	=	low dividend
				;9558	;		W3	=	remainder with sign bit forced on
				;9559	;		W4	=	negated quotient
				;9560	;		Q	=	quotient
				;9561	;		STATE<1:0> =	sign of divisor, dividend
				;9562
				;9563	;= ALIGNLIST 110x	(EDIV.REM.NEG,		EDIV.REM.POS)
				;9564
				;9565	EDIV.REM.POS:
				;9566		;---------------------------------------; alu.c = 1:
				;9567		[W3] <-- [W3] ANDNOT [80]000000, LONG,	; fix up remainder from last divide step
E 41F  4480,3C00,1040,4A28 B 428;9568		CASE [STATE.2-0] AT [EDIV.STATE.00]	; case on signs of divisor, dividend
				;9569
				;9570	EDIV.REM.NEG:
				;9571		;---------------------------------------; alu.c = 0:
				;9572		[W3] <-- [W0] + [W3], LONG,		; fix up remainder from last divide step
E 41D  4880,0020,1010,4A28 B 428;9573		CASE [STATE.2-0] AT [EDIV.STATE.00]	; case on signs of divisor, dividend
				;9574
				;9575	;= ALIGNLIST *00x	(EDIV.STATE.00, 	EDIV.STATE.01,
				;9576	;=			 EDIV.STATE.10, 	EDIV.STATE.11)
				;9577	;  STATE<2> = 0 --> STATE<2:0> = 0??
				;9578
				;9579	EDIV.STATE.00:
				;9580		;---------------------------------------; divisor +, dividend +:
			    p293;9581		NOP,					; nothing to do...
E 428  E000,0000,2000,4F27 B 427;9582		CASE [SHF.NZ.INT] AT [EDIV.POS.NO.OVERFLOW] ; case on quotient geq 0
				;9583
				;9584	EDIV.STATE.01:
				;9585		;---------------------------------------; divisor +, dividend -:
			    p293;9586		[W3] <-- -[W3], LONG,			; negate remainder
E 42A  2D00,0020,1000,4113 B 413;9587		CASE [ALU.NZV] AT [EDIV.NEG.OVERFLOW]	; case on quotient leq 0
				;9588
				;9589	EDIV.STATE.10:
				;9590		;---------------------------------------; divisor -, dividend +:
			    p293;9591		NOP,					; nothing to do...
E 42C  2000,0000,2000,4113 B 413;9592		CASE [ALU.NZV] AT [EDIV.NEG.OVERFLOW]	; case on quotient leq 0
				;9593
				;9594	EDIV.STATE.11:
				;9595		;---------------------------------------; divisor -, dividend -:
			    p293;9596		[W3] <-- -[W3], LONG,			; negate remainder
E 42E  ED00,0020,1000,4F27 B 427;9597		CASE [SHF.NZ.INT] AT [EDIV.POS.NO.OVERFLOW] ; case on quotient geq 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  293
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9598
				;9599	;	Extended divide, continued.
				;9600	;	Overflow checks.
				;9601	;		If positive result expected, require result geq 0.
				;9602	;		If negative result expected, require result leq 0.
				;9603
				;9604	;	At this point,
				;9605	;		W3	=	remainder, sign adjusted
				;9606	;		W4	=	negated quotient
				;9607	;		Q	=	quotient
				;9608
				;9609	;= ALIGNLIST 011x	(EDIV.POS.NO.OVERFLOW,	EDIV.POS.OVERFLOW)
				;9610
				;9611	EDIV.POS.NO.OVERFLOW:
				;9612		;---------------------------------------; shf.n = 0:
				;9613		[W0] <-- [Q], LONG,			; save quotient in W0
			    p294;9614		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 427  0000,0000,04AD,05BE J 5BE;9615		GOTO [EDIV.WRITE.RESULT]		; write result
				;9616
				;9617	EDIV.POS.OVERFLOW:
				;9618		;---------------------------------------; shf.n = 1:
				;9619		[W0] <-- [W2], LONG,			; save quotient (low dividend) W0
			    p290;9620		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 42F  0000,0000,043D,055E J 55E;9621		GOTO [EDIV.OVERFLOW]			; join overflow code
				;9622
				;9623	;= ALIGNLIST 001x	(EDIV.NEG.OVERFLOW,	EDIV.NEG.ZERO,
				;9624	;=			 EDIV.NEG.NO.OVERFLOW,			)
				;9625
				;9626	EDIV.NEG.OVERFLOW:
				;9627		;---------------------------------------; alu.nz = 00:
				;9628		[W0] <-- [W2], LONG,			; save quotient (low dividend) in W0
			    p290;9629		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 413  0000,0000,043D,055E J 55E;9630		GOTO [EDIV.OVERFLOW]			; join overflow code
				;9631
				;9632	EDIV.NEG.ZERO:
				;9633		;---------------------------------------; alu.nz = 01:
				;9634		[W0] <-- [W4], LONG,			; save quotient in W0
			    p294;9635		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 417  0000,0000,045D,05BE J 5BE;9636		GOTO [EDIV.WRITE.RESULT]		; write result
				;9637
				;9638	EDIV.NEG.NO.OVERFLOW:
				;9639		;---------------------------------------; alu.nz = 10:
				;9640		[W0] <-- [W4], LONG,			; save quotient in W0
			    p294;9641		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 41B  0000,0000,045D,05BE J 5BE;9642		GOTO [EDIV.WRITE.RESULT]		; write result
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  294
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9643
				;9644	;	Extended divide, continued.
				;9645
				;9646	;	At this point,
				;9647	;		W3	=	remainder, sign adjusted
				;9648	;		W0	=	quotient
				;9649	;		STATE<2> =	divide by zero flag
				;9650
				;9651	;= ALIGNLIST 100x	(EDIV.MEM.DEST, 	EDIV.RMODE.DEST,
				;9652	;=					,	EDIV.WRITE.RESULT)
				;9653
				;9654	EDIV.WRITE.RESULT:
				;9655		;---------------------------------------; fq.vr = 11 (invalid)
E 5BE  4000,0000,2000,52B8 B 5B8;9656		CASE [FQ.VR] AT [EDIV.MEM.DEST] 	; wait for field queue to
				;9657							; indicate register or memory
				;9658
				;9659	EDIV.MEM.DEST:
				;9660		;---------------------------------------; fq.vr = 00 (valid, memory)
				;9661		VA <-- [S1], LONG,			; Quotient address to VA
				;9662							; >> no [spec 3; spec 4] reference
E 5B8  0000,0001,2080,048D J 48D;9663			sim addr [ea.3]
				;9664
				;9665		;---------------------------------------;
				;9666		MEM (VA)&, [WBUS] <-- PASSB [W0], LONG, ; write quotient to memory
E 48D  0064,800A,2080,0490 J 490;9667		ACCESS A [S1]				; check accessablility of remainder dest.
				;9668
				;9669		;---------------------------------------;
				;9670		SYNCHRONIZE MBOX,			; make sure this memory ref didn't fault
			    p298;9671							;   see notes at beginning of ediv
E 490  0020,0000,2000,0524 J 524;9672		GOTO [EDIV.DEST.CONTINUED]		; finish writing result
				;9673
				;9674	EDIV.RMODE.DEST:
				;9675		;---------------------------------------; fq.vr = 01 (valid, register)
				;9676		ACCESS A [S1], LONG,			; select GPR number and pitch SL entry
E 5BA  0001,DC7A,0880,0491 J 491;9677		[W1] <-- ZEXT [RN.MODE.OPCODE] RSH [28.] ; right justify register number
				;9678							; >> no [spec 3; spec 4] reference
				;9679
				;9680		;---------------------------------------;
				;9681		[WBUS] <-- B [W1],			; set up register number for case
E 491  0080,0010,2080,0127 J 127;9682		ACCESS A [S1]				; check accessablility of remainder dest.
				;9683
				;9684		;---------------------------------------;
				;9685		[WBUS] <-- B [W1],			; set up register number for case
E 127  8080,0010,2000,4441 B 141;9686		CASE [B.5-3] AT [EDIV.RMODE.LOW]	; case on msb of register number
				;9687
				;9688	;= ALIGNLIST xx0x	(EDIV.RMODE.LOW,	EDIV.RMODE.HIGH)
				;9689	;  register number is 4 bits, zero extended --> b<5:3> = 00?
				;9690
				;9691	EDIV.RMODE.LOW:
				;9692		;---------------------------------------;
			    p296;9693		NOP,					; nothing to do
E 141  6000,0000,2000,43E1 B 1E1;9694		CASE [B.2-0] AT [EDIV.RMODE.R0] 	; case on register number
				;9695
				;9696	EDIV.RMODE.HIGH:
				;9697		;---------------------------------------;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  295
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
			    p297;9698		NOP,					; nothing to do
E 143  6000,0000,2000,43F1 B 1F1;9699		CASE [B.2-0] AT [EDIV.RMODE.R8] 	; case on register number
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  296
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9700
				;9701	;	Extended divide, continued.
				;9702	;	Write Quotent.
				;9703
				;9704	;	At this point,
				;9705	;		W3	=	remainder, sign adjusted
				;9706	;		W0	=	quotient, sign adjusted
				;9707
				;9708	;= ALIGNLIST 000x	(EDIV.RMODE.R0, 	EDIV.RMODE.R1,
				;9709	;=			 EDIV.RMODE.R2, 	EDIV.RMODE.R3,
				;9710	;=			 EDIV.RMODE.R4, 	EDIV.RMODE.R5,
				;9711	;=			 EDIV.RMODE.R6, 	EDIV.RMODE.R7)
				;9712
				;9713	EDIV.RMODE.R0:
				;9714		;---------------------------------------;
			    p298;9715		[R0] <-- [W0], LONG,			; write quotent to register
E 1E1  0000,0000,4010,0524 J 524;9716		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9717
				;9718	EDIV.RMODE.R1:
				;9719		;---------------------------------------;
			    p298;9720		[R1] <-- [W0], LONG,			; write quotent to register
E 1E3  0000,0000,4410,0524 J 524;9721		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9722
				;9723	EDIV.RMODE.R2:
				;9724		;---------------------------------------;
			    p298;9725		[R2] <-- [W0], LONG,			; write quotent to register
E 1E5  0000,0000,4810,0524 J 524;9726		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9727
				;9728	EDIV.RMODE.R3:
				;9729		;---------------------------------------;
			    p298;9730		[R3] <-- [W0], LONG,			; write quotent to register
E 1E7  0000,0000,4C10,0524 J 524;9731		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9732
				;9733	EDIV.RMODE.R4:
				;9734		;---------------------------------------;
			    p298;9735		[R4] <-- [W0], LONG,			; write quotent to register
E 1E9  0000,0000,5010,0524 J 524;9736		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9737
				;9738	EDIV.RMODE.R5:
				;9739		;---------------------------------------;
			    p298;9740		[R5] <-- [W0], LONG,			; write quotent to register
E 1EB  0000,0000,5410,0524 J 524;9741		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9742
				;9743	EDIV.RMODE.R6:
				;9744		;---------------------------------------;
			    p298;9745		[R6] <-- [W0], LONG,			; write quotent to register
E 1ED  0000,0000,5810,0524 J 524;9746		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9747
				;9748	EDIV.RMODE.R7:
				;9749		;---------------------------------------;
			    p298;9750		[R7] <-- [W0], LONG,			; write quotent to register
E 1EF  0000,0000,5C10,0524 J 524;9751		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  297
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9752
				;9753	;	Extended divide, continued.
				;9754	;	Write Quotent.
				;9755
				;9756	;	At this point,
				;9757	;		W3	=	remainder, sign adjusted
				;9758	;		W0	=	quotient, sign adjusted
				;9759
				;9760	;= ALIGNLIST 000x	(EDIV.RMODE.R8, 	EDIV.RMODE.R9,
				;9761	;=			 EDIV.RMODE.R10,	EDIV.RMODE.R11,
				;9762	;=			 EDIV.RMODE.R12,	EDIV.RMODE.R13,
				;9763	;=			 EDIV.RMODE.R14,	EDIV.RMODE.R15)
				;9764
				;9765	EDIV.RMODE.R8:
				;9766		;---------------------------------------;
			    p298;9767		[R8] <-- [W0], LONG,			; write quotent to register
E 1F1  0000,0000,6010,0524 J 524;9768		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9769
				;9770	EDIV.RMODE.R9:
				;9771		;---------------------------------------;
			    p298;9772		[R9] <-- [W0], LONG,			; write quotent to register
E 1F3  0000,0000,6410,0524 J 524;9773		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9774
				;9775	EDIV.RMODE.R10:
				;9776		;---------------------------------------;
			    p298;9777		[R10] <-- [W0], LONG,			; write quotent to register
E 1F5  0000,0000,6810,0524 J 524;9778		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9779
				;9780	EDIV.RMODE.R11:
				;9781		;---------------------------------------;
			    p298;9782		[R11] <-- [W0], LONG,			; write quotent to register
E 1F7  0000,0000,6C10,0524 J 524;9783		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9784
				;9785	EDIV.RMODE.R12:
				;9786		;---------------------------------------;
			    p298;9787		[R12] <-- [W0], LONG,			; write quotent to register
E 1F9  0000,0000,7010,0524 J 524;9788		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9789
				;9790	EDIV.RMODE.R13:
				;9791		;---------------------------------------;
			    p298;9792		[R13] <-- [W0], LONG,			; write quotent to register
E 1FB  0000,0000,7410,0524 J 524;9793		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9794
				;9795	EDIV.RMODE.R14:
				;9796		;---------------------------------------;
			    p298;9797		[SP] <-- [W0], LONG,			; write quotent to register
E 1FD  0000,0000,7810,0524 J 524;9798		GOTO [EDIV.DEST.CONTINUED]		; go write remainder to DST
				;9799
				;9800	EDIV.RMODE.R15:
			    p127;9801		;---------------------------------------;
E 1FF  0000,0000,2000,003C J 03C;9802		RESERVED OPERAND FAULT			; reserved operand fault for PC dest.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  298
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9803
				;9804
				;9805	EDIV.DEST.CONTINUED:
				;9806		;---------------------------------------;
				;9807		[DST] <-- [W3], LONG,			; write remainder
E 524  4000,0000,2440,4AB7 B 5B7;9808		CASE [STATE.2-0] AT [EDIV.DONE] 	; case on divide by zero flag
				;9809
				;9810	;= ALIGNLIST 011x	(EDIV.DONE,		DIVIDE.BY.ZERO)
				;9811	;  STATE<2> indicates divide by zero if set
				;9812	;
				;9813
				;9814	EDIV.DONE:
				;9815		;---------------------------------------;
				;9816		RESTART IBOX,				; restart IBOX spec queue
E 5B7  0000,0000,2004,1800 L	;9817		LAST CYCLE CHECK OVERFLOW		; last cycle
				;9818
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  299
;    MULDIV.MIC 	     EDIV										      /REV=
;															     MULDIV
				;9819
				;9820	;	Subroutines to perform 31, 15, 7, 3, or 1 divide steps.
				;9821	;
				;9822
				;9823	;	Entry conditions:
				;9824	;		W0	=	!divisor!
				;9825	;		W3'Q	=	!dividend!
				;9826	;
				;9827	;	Exit conditions:
				;9828	;		W3	=	remainder
				;9829	;		Q	=	quotient
				;9830	;		Q not readable by return microword
				;9831	;
				;9832	;	**********************************************************************
				;9833	;	* WARNING: DIVIDE.31.STEPS REQUIRES 5 OF THE 6 MICROSTACK LOCATIONS, *
				;9834	;	* AND MAY NOT BE CALLED WHILE NESTED MORE THAN 1 LEVEL. 	     *
				;9835	;	**********************************************************************
				;9836
				;9837	DIVIDE.31.STEPS:
				;9838		;---------------------------------------;
				;9839		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 2A5  0E82,0008,1040,22A6 S 2A6;9840		CALL [DIVIDE.15.STEPS]			; do next 15 divide steps
				;9841
				;9842	DIVIDE.15.STEPS:
				;9843		;---------------------------------------;
				;9844		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 2A6  0E82,0008,1040,22A7 S 2A7;9845		CALL [DIVIDE.7.STEPS]			; do next 7 divide steps
				;9846
				;9847	DIVIDE.7.STEPS:
				;9848		;---------------------------------------;
				;9849		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 2A7  0E82,0008,1040,22A8 S 2A8;9850		CALL [DIVIDE.3.STEPS]			; do next 3 divide steps
				;9851
				;9852	DIVIDE.3.STEPS:
				;9853		;---------------------------------------;
				;9854		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
E 2A8  0E82,0008,1040,22A9 S 2A9;9855		CALL [DIVIDE.1.STEP]			; do next 1 divide step
				;9856
				;9857	DIVIDE.1.STEP:
				;9858		;---------------------------------------;
				;9859		[W3] <-- [W3] UDIV [W0], LONG,		; do divide step
				;9860		RETURN, 				; return to caller
E 2A9  0E82,0008,1040,0800 R	;9861			sim cond k s4.[1]
				;9862
				;9863	;= END MULDIV
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  300
;   CALLRET.MIC 	     CALLRET.MIC -- Procedure Call Instructions 					      /REV=
;
				;9864	.TOC	"CALLRET.MIC -- Procedure Call Instructions"
				;9865	.TOC	"Revision 1.1"
				;9866
				;9867	;	Bob Supnik
				;9868
;9869	.nobin
;9870	;****************************************************************************
;9871	;*									    *
;9872	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;9873	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;9874	;*  ALL RIGHTS RESERVED.						    *
;9875	;*									    *
;9876	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;9877	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;9878	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;9879	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;9880	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;9881	;*  TRANSFERRED.							    *
;9882	;*									    *
;9883	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;9884	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;9885	;*  CORPORATION.							    *
;9886	;*									    *
;9887	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;9888	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;9889	;*									    *
;9890	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  301
;   CALLRET.MIC 	     Revision History									      /REV=
;
;9891	.TOC	"	Revision History"
;9892
;9893	; Edit	  Date	 Who	     Description
;9894	; ---- --------- ---	---------------------
;9895	;    1 09-Sep-90 GMU	Symptom: LOAD PC not synchronized with entry to
;9896	;				 exception flows if a reserved operand
;9897	;				 fault was detected in mask bits <15:12>.
;9898	;			Cure:	 Add SYNCHRONIZE MBOX on every exit to
;9899	;				 the reserved instruction fault handler
;9900	;				 in the CASE targets at CALLG.MASK.xxx
;9901	;				 and CALLS.MASK.xxx.
;9902	; (1)0 19-Jul-90 GMU	Initial production microcode.
;9903	;
;9904	; Begin version 1.0 here
;9905	;   16 18-Jul-90 GMU	Update with Bob's review comments.
;9906	;   15 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;9907	;   14 30-Apr-90 GMU	Note sync requirement after LOAD PC.
;9908	;   13 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;9909	;   12 29-Mar-90 DGM	Update comments
;9910	;   11 27-Mar-90 DGM	Update comments
;9911	;   10 22-Mar-90 DGM	Update comments
;9912	;    9 08-Feb-90 GMU	Don't trash PSL<7:0> until after all memory references
;9913	;			are checked (can trash PSL<T> too early).
;9914	;    8 16-Jan-90 DGM	Change alignment for A31.BQA.BZ1 case
;9915	;    7	9-Oct-89 DGM	Update CALLS/G for new Ibox (only single assists)
;9916	;    6	2-Oct-89 DGM	In RET (.S), zero out upper 3 bytes of #arguments from stack
;9917	;    5 21-Sep-89 GMU	Convert DL writes of PSL to PSL.B0 destinations.
;9918	;    4 19-Sep-89 DGM	Fix bug in RET - value of FP incorrect
;9919	;    3 13-Sep-89 GMU	Sync with Mbox delivery of GPR data on exit from RET.
;9920	;    2	6-Sep-89 DGM	Fix bug in RET - first microinstruction: was LSH 29, now RSH 30
;9921	;			Fix bug in CALLS - push entire LW of first arg, not just low byte
;9922	;    1 17-Aug-89 GMU	Remove split dispatch for CALLG.
;9923	; (0)0 17-Jul-87 RMS	Trial microcode.
;9924
				;9925	.bin
				;9926	;= BEGIN CALLRET
;9927	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  302
;   CALLRET.MIC 	     Revision History									      /REV=
;															    CALLRET
;9928
;9929	;	This module implements the procedure call class.
;9930	;	The instructions in this class are:
;9931	;
;9932	;	Opcode	 Instruction							N Z V C 	Exceptions
;9933	;	------	 -----------							------- 	----------
;9934	;
;9935	;	FA	 CALLG arglist.ab, dst.ab, {-(SP).w*}				0 0 0 0 	rsv
;9936	;
;9937	;	FB	 CALLS numarg.rl, dst.ab, {-(SP).w*}				0 0 0 0 	rsv
;9938	;
;9939	;	04	 RET {(SP)+.r*} 						* * * * 	rsv
;9940	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  303
;   CALLRET.MIC 	     Revision History									      /REV=
;															    CALLRET
;9941
;9942	;	These instructions implement a generalized procedure call and return facility.
;9943	;	The principal data structure involved is the stack frame.
;9944	;	CALLS and CALLG build a stack frame in the following format:
;9945	;
;9946	;
;9947	;	+---------------------------------------------------------------+
;9948	;	|		  condition handler (initially 0)		|  +0	<-- SP,FP on exit
;9949	;	+---+-+-+-----------------------+--------------------+----------+
;9950	;	|SPA|S|0|   entry mask<11:0>	|   saved PSW<15:5>  | 0 0 0 0 0|  +4	SPA = # bytes to force stack alignment
;9951	;	+---+-+-+-----------------------+--------------------+----------+	S   = 0 for CALLG, 1 for CALLS
;9952	;	|			    saved AP				|  +8
;9953	;	+---------------------------------------------------------------+
;9954	;	|			    saved FP				|  +12
;9955	;	+---------------------------------------------------------------+
;9956	;	|			    saved PC				|  +16
;9957	;	+---------------------------------------------------------------+
;9958	;	|			    saved R0 (...)			|  +20
;9959	;	+---------------------------------------------------------------+
;9960	;		.						.
;9961	;		.	(according to entry mask<11:0>) 	.
;9962	;		.						.
;9963	;	+---------------------------------------------------------------+
;9964	;	|			    saved R11 (...)			|
;9965	;	+---------------+-----------------------------------------------+
;9966	;	| #args (CALLS) |	(0-3 bytes needed to align stack)	|
;9967	;	+---------------+-----------------------------------------------+
;9968	;	|		|	0	0	0	(CALLS) 	|
;9969	;	+---------------+-----------------------------------------------+
;9970	;
;9971	;	RET expects to find this structure based at the frame pointer (FP).
;9972
;9973	;	For CALLG and CALLS, the entry mask specifies the new settings of DV and IV,
;9974	;	and also which registers are to be saved on entry:
;9975	;
;9976	;	 15 14 13 12 11 			      0
;9977	;	+--+--+-----+----------------------------------+
;9978	;	|DV|IV| MBZ |		register mask	       |
;9979	;	+--+--+-----+----------------------------------+
;9980	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  304
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
;9981	.TOC	"	CALLG, CALLS"
;9982
;9983	;	These instructions invoke a procedure with a general (a stack based) argument list.
;9984	;
;9985	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;9986	;	--------      ------	---------				----	-----		--------
;9987	;	CALLG		FA	call procedure with general arg list	2	aa/bb		CALLX..
;9988	;	CALLS		FB	call procedure with stack arg list	2	ra/lb		CALLX..
;9989	;
;9990	;	Entry conditions:		  (CALLG)			 (CALLS)
;9991	;		source queue	=	arglist.ab operand		numarg.rl operand
;9992	;					dst.ab (proc addr) operand	dst.ab (proc addr) operand
;9993	;					(implicit spec) current PC	(implicit spec) current PC
;9994	;		dest queue	=	none
;9995	;		branch queue	=	none
;9996	;		field queue	=	none
;9997	;		DL		=	forced to WORD by the IROM
;9998	;		Ibox state	=	stopped
;9999	;		Mbox state	=	running
;10000	;
;10001	;	Exit conditions:
;10002	;		The procedure stack frame has been created.
;10003	;		SP, FP point to the new top of stack.
;10004	;		AP points to the argument list.
;10005	;		PC points to the first instruction of the procedure (entry+2).
;10006	;		PSW<7,5> are equal to mask<15,14>.
;10007	;		PSW<6,3:0> are clear.
;10008	;
;10009	;	Condition codes:
;10010	;		N <-- 0
;10011	;		Z <-- 0
;10012	;		V <-- 0 		[Integer overflow trap disabled.]
;10013	;		C <-- 0
;10014	;
;10015	;	Notes:
;10016	;		1.  Performance:  The S+PSW_EX function saves 2 cycles in CALLS, 3 cycles in CALLG.
;10017	;		2.  Memory management:	The source queue is emptied (except for the implicit current
;10018	;		    PC specifier, which cannot fault) before the start of Ebox I/O.
;10019	;		3.  Memory management:	The final write must coincide with the write check done
;10020	;		    at the start of the instruction and thus cannot incur a memory management error.
;10021	;		4.  If the dispatches for CALLS and CALLG were merged, 3 microwords could be saved.
;10022	;
				;10023	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  305
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10024
				;10025	;	CALLG/CALLS operation:
				;10026	;
				;10027	;		Read the procedure entry mask.
				;10028	;		Calculate the new SP (longword aligned).
				;10029	;		Make sure that the stack frame will be accessible.
				;10030	;		If CALLS, push the number of arguments onto the stack.
				;10031	;		The call frame is pushed onto the stack in reverse order (condition
				;10032	;		handler first, etc.) to take advantage of optimized, consecutive writes.
				;10033	;		Push conditon handler, saved SPA/S0/mask/PSW, AP, FP, PC.
				;10034	;		Push the registers specified by the procedure entry mask.
				;10035	;		Update PSW traps, clear condition codes.
				;10036	;		Update PC, AP, FP, SP.
				;10037
				;10038	CALLX..:
				;10039		;********** Hardware dispatch **********;
				;10040		Q <-- PASSB [S1],			; [1] save arglist/numarg
				;10041		VA <-- [S2],				; get procedure (mask) address
E 170  0042,8045,0C90,0492 J 492;10042		[W2] <-- MEM (VA), LEN(DL)		; read mask from memory
				;10043
				;10044		;---------------------------------------;
				;10045		[WBUS] <-- [VA] + 000000[02], LONG,	; [2] calculate new PC value
				;10046		LOAD PC,				; load new PC value
				;10047							; >> LOAD PC: sync required before exit
E 492  08A4,2010,20B2,0493 J 493;10048		DL <-- BYTE				; set dl = byte
				;10049
				;10050		;---------------------------------------;
E 493  0480,2018,09E0,0227 J 227;10051		[W1] <-- [SP] ANDNOT 000000[03], LONG	; [3] longword align stack
				;10052
				;10053		;---------------------------------------;
				;10054		[W0] <-- B [Q], LONG,			; [4] save arglist/numarg
				;10055		Q <-- [W2] LSH [18.],			; shift entry mask left 18
				;10056							; test A<15:12> (entry mask)
				;10057							; load pop counter from A<13:0>
				;10058		CASE [OPCODE.2-0] AT [CALLG],		; case on opcode
E 227  8083,5250,0430,4C35 B 235;10059			sim cond [s3.callx]
				;10060
				;10061	;= ALIGNLIST	x10x	(CALLG, 		CALLS)
				;10062	;  Opcodes = FA, FB --> opcode<2:0> = 01?
				;10063
				;10064	CALLG:
				;10065		;---------------------------------------; opcode<0> = 0:
				;10066		[W1] <-- (-[POP.COUNT] + [W1]), LONG,	; [5] calculate aligned SP - mask_bits_set*4
			    p306;10067		CASE [A.15-12] AT [CALLG.MASK.000],	; case on mask<15:14,13+12>
E 235  CA00,0010,0B80,46E1 B 2E1;10068			sim cond k s3.[0]
				;10069
				;10070	CALLS:
				;10071		;---------------------------------------; opcode<0> = 1:
				;10072		[W1] <-- (-[POP.COUNT] + [W1]), LONG,	; [5] calculate aligned SP - mask_bits_set*4
			    p308;10073		CASE [A.15-12] AT [CALLS.MASK.000],	; case on mask<15:14,13+12>
E 237  CA00,0010,0B80,46F0 B 2F0;10074			sim cond k s3.[0]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  306
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10075
				;10076	;	CALLG, continued.
				;10077	;	Probe stack, continue mask construction.
				;10078	;	Probe byte at SP-4, guaranteed to be written for any alignment
				;10079
				;10080	;	At this point,
				;10081	;		W0	=	arglist
				;10082	;		W1	=	aligned SP - mask_bits_set * 4
				;10083	;		Q	=	mask shfl 18
				;10084
				;10085	;= ALIGNLIST 000x	(CALLG.MASK.000,	CALLG.MASK.001,
				;10086	;=			 CALLG.MASK.010,	CALLG.MASK.011,
				;10087	;=			 CALLG.MASK.100,	CALLG.MASK.101,
				;10088	;=			 CALLG.MASK.110,	CALLG.MASK.111)
				;10089
				;10090	CALLG.MASK.000:
				;10091		;---------------------------------------; a<15:14,13+12> = 000:
				;10092		WCHK (VA)&, VA <-- [SP] - 4, LEN(DL),	; [6] check current stack address
				;10093							; >> sync with LOAD PC
				;10094		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
			    p310;10095		GOTO [CALLG.WRITE.COND],		; go write condition handler
E 2E1  0CE3,8255,21E0,0494 J 494;10096			sim addr [sp] - k
				;10097
				;10098	CALLG.MASK.001:
				;10099		;---------------------------------------; a<15:14,13+12> = 001:
			    p127;10100		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2E3  0020,0000,2000,003C J 03C;10101		SYNCHRONIZE MBOX			; sync with LOAD PC
				;10102
				;10103	CALLG.MASK.010:
				;10104		;---------------------------------------; a<15:14,13+12> = 010:
				;10105		WCHK (VA)&, VA <-- [SP] - 4, LEN(DL),	; [6] check current stack address
				;10106							; >> sync with LOAD PC
				;10107		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
				;10108		STATE.0 <-- 1,				; set flag for iv
			    p310;10109		GOTO [CALLG.WRITE.COND],		; go write condition handler
E 2E5  0CE3,8255,21E8,8494 J 494;10110			sim addr [sp] - k
				;10111
				;10112	CALLG.MASK.011:
				;10113		;---------------------------------------; a<15:14,13+12> = 011:
			    p127;10114		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2E7  0020,0000,2000,003C J 03C;10115		SYNCHRONIZE MBOX			; >> sync with LOAD PC
				;10116
				;10117	CALLG.MASK.100:
				;10118		;---------------------------------------; a<15:14,13+12> = 100:
				;10119		WCHK (VA)&, VA <-- [SP] - 4, LEN(DL),	; [6] check current stack address
				;10120							; >> sync with LOAD PC
				;10121		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
				;10122		STATE.1 <-- 1,				; set flag for dv
			    p310;10123		GOTO [CALLG.WRITE.COND],		; go write condition handler
E 2E9  0CE3,8255,21E9,0494 J 494;10124			sim addr [sp] - k
				;10125
				;10126	CALLG.MASK.101:
				;10127		;---------------------------------------; a<15:14,13+12> = 101:
			    p127;10128		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2EB  0020,0000,2000,003C J 03C;10129		SYNCHRONIZE MBOX			; >> sync with LOAD PC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  307
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10130
				;10131	CALLG.MASK.110:
				;10132		;---------------------------------------; a<15:14,13+12> = 110:
				;10133		WCHK (VA)&, VA <-- [SP] - 4, LEN(DL),	; [6] check current stack address
				;10134							; >> sync with LOAD PC
				;10135		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
				;10136		STATE.2 <-- 1,				; set flag for dv+iv
			    p310;10137		GOTO [CALLG.WRITE.COND],		; go write condition handler
E 2ED  0CE3,8255,21E9,8494 J 494;10138			sim addr [sp] - k
				;10139
				;10140	CALLG.MASK.111:
				;10141		;---------------------------------------; a<15:14,13+12> = 111:
			    p127;10142		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2EF  0020,0000,2000,003C J 03C;10143		SYNCHRONIZE MBOX			; >> sync with LOAD PC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  308
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10144
				;10145	;	CALLS, continued.
				;10146	;	Probe stack, continue mask construction.
				;10147	;	Probe byte at SP-1, where #arguments will start.
				;10148
				;10149	;	At this point,
				;10150	;		W0	=	#arguments
				;10151	;		W1	=	aligned SP - mask_bits_set * 4
				;10152	;		Q	=	mask shfl 18
				;10153
				;10154	;= ALIGNLIST 000x	(CALLS.MASK.000,	CALLS.MASK.001,
				;10155	;=			 CALLS.MASK.010,	CALLS.MASK.011,
				;10156	;=			 CALLS.MASK.100,	CALLS.MASK.101,
				;10157	;=			 CALLS.MASK.110,	CALLS.MASK.111)
				;10158
				;10159	CALLS.MASK.000:
				;10160		;---------------------------------------; a<15:14,13+12> = 000:
				;10161		WCHK (VA)&, VA <-- [SP] - 1, LEN(DL),	; [6] check current stack address
				;10162							; >> sync with LOAD PC
				;10163		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
			    p310;10164		GOTO [CALLS.WRITE.COND],		; go write condition handler
E 2F0  0B63,8255,21E0,0495 J 495;10165			sim addr [sp] - k
				;10166
				;10167	CALLS.MASK.001:
				;10168		;---------------------------------------; a<15:14,13+12> = 001:
			    p127;10169		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2F2  0020,0000,2000,003C J 03C;10170		SYNCHRONIZE MBOX			; >> sync with LOAD PC
				;10171
				;10172	CALLS.MASK.010:
				;10173		;---------------------------------------; a<15:14,13+12> = 010:
				;10174		WCHK (VA)&, VA <-- [SP] - 1, LEN(DL),	; [6] check current stack address
				;10175							; >> sync with LOAD PC
				;10176		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
				;10177		STATE.0 <-- 1,				; set flag for iv
			    p310;10178		GOTO [CALLS.WRITE.COND],		; go write condition handler
E 2F4  0B63,8255,21E8,8495 J 495;10179			sim addr [sp] - k
				;10180
				;10181	CALLS.MASK.011:
				;10182		;---------------------------------------; a<15:14,13+12> = 011:
			    p127;10183		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2F6  0020,0000,2000,003C J 03C;10184		SYNCHRONIZE MBOX			; >> sync with LOAD PC
				;10185
				;10186	CALLS.MASK.100:
				;10187		;---------------------------------------; a<15:14,13+12> = 100:
				;10188		WCHK (VA)&, VA <-- [SP] - 1, LEN(DL),	; [6] check current stack address
				;10189							; >> sync with LOAD PC
				;10190		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
				;10191		STATE.1 <-- 1,				; set flag for dv
			    p310;10192		GOTO [CALLS.WRITE.COND],		; go write condition handler
E 2F8  0B63,8255,21E9,0495 J 495;10193			sim addr [sp] - k
				;10194
				;10195	CALLS.MASK.101:
				;10196		;---------------------------------------; a<15:14,13+12> = 101:
			    p127;10197		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2FA  0020,0000,2000,003C J 03C;10198		SYNCHRONIZE MBOX			; >> sync with LOAD PC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  309
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10199
				;10200	CALLS.MASK.110:
				;10201		;---------------------------------------; a<15:14,13+12> = 110:
				;10202		WCHK (VA)&, VA <-- [SP] - 1, LEN(DL),	; [6] check current stack address
				;10203							; >> sync with LOAD PC
				;10204		Q <-- [SP]!![Q] RSH [2],		; spa/00/mask/0
				;10205		STATE.2 <-- 1,				; set flag for dv+iv
			    p310;10206		GOTO [CALLS.WRITE.COND],		; go write condition handler
E 2FC  0B63,8255,21E9,8495 J 495;10207			sim addr [sp] - k
				;10208
				;10209	CALLS.MASK.111:
				;10210		;---------------------------------------; a<15:14,13+12> = 111:
			    p127;10211		RESERVED OPERAND FAULT, 		; [6] mbz not zero, fault
E 2FE  0020,0000,2000,003C J 03C;10212		SYNCHRONIZE MBOX			; >> sync with LOAD PC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  310
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10213
				;10214	;	CALLx, continued.
				;10215	;	Write standard stack header.
				;10216
				;10217	;	At this point,
				;10218	;		W0	=	#arguments
				;10219	;		W1	=	aligned SP - mask_bits_set * 4
				;10220	;		Q	=	spa/00/mask/0
				;10221	;		STATE<2:0> =	iv, dv, iv+dv set
				;10222
				;10223	CALLG.WRITE.COND:
				;10224		;---------------------------------------; CALLG:
				;10225		VA <-- [W1] - 000000[20.],		; [7] calculate addr of new top of stack
				;10226		MEM (VA)&, [WBUS] <-- 0, LONG,		; write zero to top of stack
				;10227		GOTO [CALLX.WRITE.MASK],		; join common code
E 494  0AE4,E0A3,2020,0498 J 498;10228			sim addr [sp.extent]
				;10229
				;10230	CALLS.WRITE.COND:
				;10231		;---------------------------------------; CALLS:
				;10232		VA <-- [W1] - 000000[24.],		; [7] calculate addr of new top of stack
				;10233		MEM (VA)&, [WBUS] <-- 0, LONG,		; write zero to top of stack
				;10234		GOTO [CALLX.WRITE.MASK],		; join common code
E 495  0AE4,E0C3,2020,0498 J 498;10235			sim addr [sp.extent]
				;10236
				;10237	CALLX.WRITE.MASK:
				;10238		;---------------------------------------;
E 498  0500,0050,0F70,0499 J 499;10239		[W2] <-- [S+PSW_EX] OR [Q], LONG	; [8] mask/s0/spa/psw<7:5> ONLY
				;10240
				;10241		;---------------------------------------;
				;10242		VA <-- [VA] + 4,			; [9] calculate next stack address
				;10243		MEM (VA)&, [WBUS] <-- PASSB [W2], LONG, ; write spa/s0/mask/psw to stack
E 499  0C64,801B,20BA,849A J 49A;10244		MPU <-- B.29..16 [W2]			; load mask proc unit from B<29:16>
				;10245
				;10246		;---------------------------------------;
				;10247		VA <-- [VA] + 4,			; [10] calculate next stack address
E 49A  0C64,80E3,20B0,049B J 49B;10248		MEM (VA)&, [WBUS] <-- PASSB [AP], LONG	; write AP to stack
				;10249
				;10250		;---------------------------------------;
				;10251		VA <-- [VA] + 4,			; [11] calculate next stack address
E 49B  0C64,80EB,20B0,0335 J 335;10252		MEM (VA)&, [WBUS] <-- PASSB [FP], LONG	; write FP to stack
				;10253
				;10254		;---------------------------------------;
				;10255		VA <-- [VA] + 4,			; [12] calculate next stack address
			    p311;10256		MEM (VA)&, [WBUS] <-- PASSB [S1], LONG, ; write current PC to stack
E 335  0C64,8043,20B0,48B0 B 3B0;10257		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  311
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10258
				;10259	;	CALLx, continued.
				;10260	;	Process mask bits<6:0>.
				;10261
				;10262	;	At this point,
				;10263	;		W0	=	#arguments
				;10264	;		W1	=	SP - mask_bits_set * 4, longword aligned
				;10265	;		MPU	=	s'mask
				;10266	;		STATE<2:0> =	iv, dv, iv+dv set
				;10267
				;10268	;= ALIGNLIST 000x	(CALLX.0_6.0,	CALLX.0_6.1,	CALLX.0_6.2,	CALLX.0_6.3,
				;10269	;=			 CALLX.0_6.4,	CALLX.0_6.5,	CALLX.0_6.6,	CALLX.0_6.NEXT)
				;10270
				;10271	CALLX.0_6.0:
				;10272		;---------------------------------------; mask<0> = 1:
				;10273		VA <-- [VA] + 4,			; [13+] calculate next stack address
				;10274		MEM (VA)&, [WBUS] <-- PASSB [R0], LONG, ; write register to stack
E 3B0  0C64,8083,20B0,48B0 B 3B0;10275		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;10276
				;10277	CALLX.0_6.1:
				;10278		;---------------------------------------; mask<1> = 1:
				;10279		VA <-- [VA] + 4,			; [13+] calculate next stack address
				;10280		MEM (VA)&, [WBUS] <-- PASSB [R1], LONG, ; write register to stack
E 3B2  0C64,808B,20B0,48B0 B 3B0;10281		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;10282
				;10283	CALLX.0_6.2:
				;10284		;---------------------------------------; mask<2> = 1:
				;10285		VA <-- [VA] + 4,			; [13+] calculate next stack address
				;10286		MEM (VA)&, [WBUS] <-- PASSB [R2], LONG, ; write register to stack
E 3B4  0C64,8093,20B0,48B0 B 3B0;10287		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;10288
				;10289	CALLX.0_6.3:
				;10290		;---------------------------------------; mask<3> = 1:
				;10291		VA <-- [VA] + 4,			; [13+] calculate next stack address
				;10292		MEM (VA)&, [WBUS] <-- PASSB [R3], LONG, ; write register to stack
E 3B6  0C64,809B,20B0,48B0 B 3B0;10293		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;10294
				;10295	CALLX.0_6.4:
				;10296		;---------------------------------------; mask<4> = 1:
				;10297		VA <-- [VA] + 4,			; [13+] calculate next stack address
				;10298		MEM (VA)&, [WBUS] <-- PASSB [R4], LONG, ; write register to stack
E 3B8  0C64,80A3,20B0,48B0 B 3B0;10299		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;10300
				;10301	CALLX.0_6.5:
				;10302		;---------------------------------------; mask<5> = 1:
				;10303		VA <-- [VA] + 4,			; [13+] calculate next stack address
				;10304		MEM (VA)&, [WBUS] <-- PASSB [R5], LONG, ; write register to stack
E 3BA  0C64,80AB,20B0,48B0 B 3B0;10305		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;10306
				;10307	CALLX.0_6.6:
				;10308		;---------------------------------------; mask<6> = 1:
				;10309		VA <-- [VA] + 4,			; [13+] calculate next stack address
				;10310		MEM (VA)&, [WBUS] <-- PASSB [R6], LONG, ; write register to stack
E 3BC  0C64,80B3,20B0,48B0 B 3B0;10311		CASE [MPU.0-6] AT [CALLX.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;10312
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  312
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10313	CALLX.0_6.NEXT:
				;10314		;---------------------------------------; mask<6:0> = 0:
				;10315		[PSL] <-- [PSL] ANDNOT 000000[0EF],	; [13+] clear PSL<7:5,3:0>
			    p313;10316		LONG,					; >> PSL change, <tp,fpd,t> unaffected
E 3BE  2480,2778,30C0,49B1 B 3B1;10317		CASE [MPU.7-13] AT [CALLX.7_13.7]	; case on mask<13:7>, reset rightmost bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  313
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10318
				;10319	;	CALLx, continued.
				;10320	;	Process mask bits<13:7>
				;10321
				;10322	;	At this point,
				;10323	;		W0	=	#arguments
				;10324	;		W1	=	SP - mask_bits_set * 4, longword aligned
				;10325	;		MPU	=	s'mask
				;10326	;		STATE<2:0> =	iv, dv, iv+dv set
				;10327
				;10328	;= ALIGNLIST 000x	(CALLX.7_13.7,	CALLX.7_13.8,	CALLX.7_13.9,	CALLX.7_13.10,
				;10329	;=			 CALLX.7_13.11, CALLX.7_13.12,	CALLX.7_13.S,	CALLX.7_13.G)
				;10330
				;10331	CALLX.7_13.7:
				;10332		;---------------------------------------; mask<7> = 1:
				;10333		VA <-- [VA] + 4,			; [14+] calculate next stack address
				;10334		MEM (VA)&, [WBUS] <-- PASSB [R7], LONG, ; write register to stack
E 3B1  2C64,80BB,20B0,49B1 B 3B1;10335		CASE [MPU.7-13] AT [CALLX.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;10336
				;10337	CALLX.7_13.8:
				;10338		;---------------------------------------; mask<8> = 1:
				;10339		VA <-- [VA] + 4,			; [14+] calculate next stack address
				;10340		MEM (VA)&, [WBUS] <-- PASSB [R8], LONG, ; write register to stack
E 3B3  2C64,80C3,20B0,49B1 B 3B1;10341		CASE [MPU.7-13] AT [CALLX.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;10342
				;10343	CALLX.7_13.9:
				;10344		;---------------------------------------; mask<9> = 1:
				;10345		VA <-- [VA] + 4,			; [14+] calculate next stack address
				;10346		MEM (VA)&, [WBUS] <-- PASSB [R9], LONG, ; write register to stack
E 3B5  2C64,80CB,20B0,49B1 B 3B1;10347		CASE [MPU.7-13] AT [CALLX.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;10348
				;10349	CALLX.7_13.10:
				;10350		;---------------------------------------; mask<10> = 1:
				;10351		VA <-- [VA] + 4,			; [14+] calculate next stack address
				;10352		MEM (VA)&, [WBUS] <-- PASSB [R10], LONG,; write register to stack
E 3B7  2C64,80D3,20B0,49B1 B 3B1;10353		CASE [MPU.7-13] AT [CALLX.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;10354
				;10355	CALLX.7_13.11:
				;10356		;---------------------------------------; mask<11> = 1:
				;10357		VA <-- [VA] + 4,			; [14+] calculate next stack address
				;10358		MEM (VA)&, [WBUS] <-- PASSB [R11], LONG,; write register to stack
E 3B9  2C64,80DB,20B0,49B1 B 3B1;10359		CASE [MPU.7-13] AT [CALLX.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;10360
				;10361	CALLX.7_13.12:
			    p135;10362		;---------------------------------------; mask<12> = 1:
E 3BB  0080,3018,A400,0038 J 038;10363		MACHINE CHECK [MCHK.CANT.GET.HERE]	; [14+] should never get here
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  314
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10364
				;10365	;	CALLx, continued.
				;10366	;	Registers pushed, update FP, AP.
				;10367
				;10368	;	At this point,
				;10369	;		W0	=	#arguments
				;10370	;		W1	=	SP - mask_bits_set * 4, longword aligned
				;10371	;		STATE<2:0> =	iv, dv, iv+dv set
				;10372
				;10373	CALLX.7_13.S:
				;10374		;---------------------------------------; mask<13> = 1:
				;10375		VA <-- [SP] - 4,			; [14+] calc addr of decremented stack
				;10376		MEM (VA)&, [WBUS] <-- PASSB [W0], LONG, ; write #arguments to stack
E 3BD  0CE4,800B,21E0,049C J 49C;10377			sim addr [sp] - k
				;10378
				;10379		;---------------------------------------;
E 49C  0A80,20C0,7420,0147 J 147;10380		[FP] <-- [W1] - 000000[24.], LONG	; [15+] update FP
				;10381							; >> GPR write, all SQ references complete
				;10382
				;10383		;---------------------------------------;
			    p315;10384		[AP] <-- [SP] - 4, LONG,		; [16+] update AP
E 147  4C80,0000,71E0,4AB1 B 1B1;10385		CASE [STATE.2-0] AT [CALLX.PSW.000]	; case on state flags to update PSW
				;10386
				;10387	CALLX.7_13.G:
				;10388		;---------------------------------------; mask<13:7> = 0:
E 3BF  0A80,20A0,7420,0151 J 151;10389		[FP] <-- [W1] - 000000[20.], LONG	; [14+] update FP
				;10390
				;10391		;---------------------------------------;
			    p315;10392		[AP] <-- [W0], LONG,			; [15+] update AP
E 151  4000,0000,7010,4AB1 B 1B1;10393		CASE [STATE.2-0] AT [CALLX.PSW.000]	; case on state flags to update PSW
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  315
;   CALLRET.MIC 	     CALLG, CALLS									      /REV=
;															    CALLRET
				;10394
				;10395	;	CALLx, continued.
				;10396	;	Update PSW, SP.
				;10397
				;10398	;	At this point,
				;10399	;		STATE<2:0> =	iv, dv, iv+dv set
				;10400
				;10401	;= ALIGNLIST 000x	(CALLX.PSW.000, CALLX.PSW.001,	CALLX.PSW.010,	,
				;10402	;=			 CALLX.PSW.100, 	,		,	)
				;10403
				;10404	CALLX.PSW.001:
				;10405		;---------------------------------------; state<0> = 1:
				;10406		[PSL] <-- [PSL] OR 000000[20], LONG,	; [16+] set PSL<iv>
				;10407							; >> PSL change, <tp,fpd,t> unaffected
E 1B3  0500,2100,30C0,01B1 J 1B1;10408		GOTO [CALLX.PSW.000]			; go finish instruction
				;10409
				;10410	CALLX.PSW.010:
				;10411		;---------------------------------------; state<1> = 1:
				;10412		[PSL] <-- [PSL] OR 000000[80], LONG,	; [16+] set PSL<dv>
				;10413							; >> PSL change, <tp,fpd,t> unaffected
E 1B5  0500,2400,30C0,01B1 J 1B1;10414		GOTO [CALLX.PSW.000]			; go finish instruction
				;10415
				;10416	CALLX.PSW.100:
				;10417		;---------------------------------------; state<2> = 1:
				;10418		[PSL] <-- [PSL] OR 000000[0A0], LONG,	; [16+] set PSL<dv,iv>
				;10419							; >> PSL change, <tp,fpd,t> unaffected
E 1B9  0500,2500,30C0,01B1 J 1B1;10420		GOTO [CALLX.PSW.000]			; go finish instruction
				;10421
				;10422	CALLX.PSW.000:
				;10423		;---------------------------------------; state<2:0> = 000:
				;10424		[SP] <-- [FP], LONG,			; [16/17+] update SP
				;10425		RESTART IBOX,				; restart suspended Ibox
E 1B1  0000,0000,79D4,1000 L	;10426		LAST CYCLE				; decode next instruction
				;10427
;10428	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  316
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
;10429	.TOC	"	RET"
;10430
;10431	;	This instruction returns from a procedure called by CALLG or CALLS.
;10432	;
;10433	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;10434	;	--------      ------	---------				----	-----		--------
;10435	;	RET		04	return from procedure			0	--		RET..
;10436	;
;10437	;	Entry conditions:
;10438	;		source queue	=	(implicit specifier) spa/s0/mask/psw @ fp+4
;10439	;				=	(implicit specifier) return PC @ fp+16
;10440	;		dest queue	=	none
;10441	;		branch queue	=	none
;10442	;		field queue	=	none
;10443	;		DL		=	BYTE
;10444	;		Ibox state	=	stopped, has updated the PC
;10445	;		Mbox state	=	running
;10446	;		FP		=	base of stack frame
;10447	;
;10448	;	Exit conditions:
;10449	;		The procedure stack frame has been removed from the stack.
;10450	;		SP points to the new top of stack.
;10451	;		PSW<7:0>, PC, FP, AP are restored from the stack frame.
;10452	;		R0...R11 are restored from the stack frame, if specified by the mask.
;10453	;
;10454	;	Condition codes:
;10455	;		N <-- saved PSW<3>
;10456	;		Z <-- saved PSW<2>
;10457	;		V <-- saved PSW<1>		[Integer overflow trap disabled.]
;10458	;		C <-- saved PSW<0>
;10459	;
;10460	;	Notes:
;10461	;		1.  Performance:  The implicit specifiers allow the Ibox to start prefetching at the
;10462	;		    return address.
;10463	;		2.  Memory management:	For CALLG, the PC operand must be read before FP or SP is modified
;10464	;		    to guarantee instruction restartability in the case of no registers restored.  For CALLS,
;10465	;		    reading the number of arguments covers this case.
;10466	;		3.  Memory management:	A SYNCHRONIZE MBOX is needed to guarantee that any memory management
;10467	;		    error in reading the general registers is made visible before either SP or FP is altered.
;10468	;		4.  Memory management: PSL<7:0> may not be overwritten until all stack reads have been
;10469	;		    checked for accessability because doing so may clear PSL<T>, which would cause the instruction
;10470	;		    to which RET returns not to trace fault.
;10471	;
				;10472	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  317
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10473
				;10474	;	RET operation:
				;10475	;
				;10476	;		Pop the SPA/S0/mask/PSW longword from the stack.
				;10477	;		Pop AP, FP, and PC from the stack.
				;10478	;		Pop R0...R11 as specified by the mask.
				;10479	;		Set the PSW, update PC and SP, exit.
				;10480
				;10481	RET..:
				;10482		;********** Hardware dispatch **********;
				;10483		[W0] <-- B [S1], LONG,			; [1] save spa/s0/mask/psw operand
				;10484		Q <-- [K1]!![S1] RSH [30.],		; create 1'spa = spa + 4
				;10485		MPU <-- B.29..16 [S1],			; load mask proc unit from mask
E 172  0083,9E40,072A,8304 J 304;10486			sim cond k s3.[1]
				;10487
				;10488		;---------------------------------------;
				;10489		VA <-- [FP] + 000000[08.],		; [2] calculate stack top + 8
				;10490		[W1] <-- MEM (VA), LONG,		; read AP from stack
				;10491		DL <-- BYTE,				; set dl = byte for later
				;10492		CASE [A31.BQA.BNZ1] AT [RET.CONT],	; case on new psw<15:8> = 0
E 304  E8C0,2041,09D2,470C B 30C;10493			sim addr [sp] + k
				;10494
				;10495	;= ALIGNLIST 110x	(RET.CONT,	RET.RSRV)
				;10496
				;10497	RET.RSRV:
			    p127;10498		;---------------------------------------; b<15:8> <> 0:
E 30E  0000,0000,2000,003C J 03C;10499		RESERVED OPERAND FAULT			; [3] mbz not zero, fault
				;10500
				;10501	RET.CONT:
				;10502		;---------------------------------------; b<15:8> = 0:
				;10503		VA <-- [VA] + 4,			; [3] calculate stack top + 12
			    p318;10504		[W2] <-- MEM (VA), LONG,		; read FP from stack
E 30C  0C40,0001,0CB0,4801 B 301;10505		CASE [MPU.0-6] AT [RET.1ST.0_6.0]	; case on mask<6:0>, reset rightmost bit
				;10506							; account for skipped PC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  318
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10507
				;10508	;	RET, continued.
				;10509	;	Process mask bits<6:0>, first case.
				;10510	;	VA is pointing at saved FP (requires increment by 8, not 4).
				;10511
				;10512	;	NOTE: The VAX Restart bit will be cleared on the first memory read to a GPR
				;10513	;	because the GPR appears in the DEST field.
				;10514
				;10515	;	At this point,
				;10516	;		W0	=	spa/s0/mask/psw
				;10517	;		W1	=	new ap
				;10518	;		W2	=	new fp
				;10519	;		Q	=	1'spa = spa + 4
				;10520	;		VA	=	fp + 12
				;10521
				;10522	;= ALIGNLIST 000x	(RET.1ST.0_6.0, RET.1ST.0_6.1,	RET.1ST.0_6.2,	RET.1ST.0_6.3,
				;10523	;=			 RET.1ST.0_6.4, RET.1ST.0_6.5,	RET.1ST.0_6.6,	RET.1ST.0_6.NEXT)
				;10524
				;10525	RET.1ST.0_6.0:
				;10526		;---------------------------------------; mask<0> = 1:
				;10527		VA <-- [VA] + 000000[08.],		; [4] calculate first register address
			    p320;10528		[R0] <-- MEM (VA), LONG,		; read register
E 301  08C0,2041,40B0,4820 B 320;10529		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10530
				;10531	RET.1ST.0_6.1:
				;10532		;---------------------------------------; mask<1> = 1:
				;10533		VA <-- [VA] + 000000[08.],		; [4] calculate first register address
			    p320;10534		[R1] <-- MEM (VA), LONG,		; read register
E 303  08C0,2041,44B0,4820 B 320;10535		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10536
				;10537	RET.1ST.0_6.2:
				;10538		;---------------------------------------; mask<2> = 1:
				;10539		VA <-- [VA] + 000000[08.],		; [4] calculate first register address
			    p320;10540		[R2] <-- MEM (VA), LONG,		; read register
E 305  08C0,2041,48B0,4820 B 320;10541		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10542
				;10543	RET.1ST.0_6.3:
				;10544		;---------------------------------------; mask<3> = 1:
				;10545		VA <-- [VA] + 000000[08.],		; [4] calculate first register address
			    p320;10546		[R3] <-- MEM (VA), LONG,		; read register
E 307  08C0,2041,4CB0,4820 B 320;10547		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10548
				;10549	RET.1ST.0_6.4:
				;10550		;---------------------------------------; mask<4> = 1:
				;10551		VA <-- [VA] + 000000[08.],		; [4] calculate first register address
			    p320;10552		[R4] <-- MEM (VA), LONG,		; read register
E 309  08C0,2041,50B0,4820 B 320;10553		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10554
				;10555	RET.1ST.0_6.5:
				;10556		;---------------------------------------; mask<5> = 1:
				;10557		VA <-- [VA] + 000000[08.],		; [4] calculate first register address
			    p320;10558		[R5] <-- MEM (VA), LONG,		; read register
E 30B  08C0,2041,54B0,4820 B 320;10559		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10560
				;10561	RET.1ST.0_6.6:
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  319
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10562		;---------------------------------------; mask<6> = 1:
				;10563		VA <-- [VA] + 000000[08.],		; [4] calculate first register address
			    p320;10564		[R6] <-- MEM (VA), LONG,		; read register
E 30D  08C0,2041,58B0,4820 B 320;10565		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10566
				;10567	RET.1ST.0_6.NEXT:
				;10568		;---------------------------------------; mask<6:0> = 0:
			    p322;10569		VA <-- [VA] + 4,			; [4] correct VA for skipped
E 30F  2C00,0001,20B0,4910 B 310;10570		CASE [MPU.7-13] AT [RET.7_13.7] 	; case on mask<13:7>, reset rightmost bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  320
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10571
				;10572	;	RET, continued.
				;10573	;	Process mask bits<6:0>, not first case.
				;10574
				;10575	;	At this point,
				;10576	;		W0	=	spa/s0/mask/psw
				;10577	;		W1	=	new ap
				;10578	;		W2	=	new fp
				;10579	;		Q	=	1'spa = spa + 4
				;10580
				;10581	;= ALIGNLIST 000x	(RET.0_6.0,	RET.0_6.1,	RET.0_6.2,	RET.0_6.3,
				;10582	;=			 RET.0_6.4,	RET.0_6.5,	RET.0_6.6,	RET.0_6.NEXT)
				;10583
				;10584	RET.0_6.0:
				;10585		;---------------------------------------; mask<0> = 1:
				;10586		VA <-- [VA] + 4,			; [5+] calculate next stack address
				;10587		[R0] <-- MEM (VA), LONG,		; read register
E 320  0C40,0001,40B0,4820 B 320;10588		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10589
				;10590	RET.0_6.1:
				;10591		;---------------------------------------; mask<1> = 1:
				;10592		VA <-- [VA] + 4,			; [5+] calculate next stack address
				;10593		[R1] <-- MEM (VA), LONG,		; read register
E 322  0C40,0001,44B0,4820 B 320;10594		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10595
				;10596	RET.0_6.2:
				;10597		;---------------------------------------; mask<2> = 1:
				;10598		VA <-- [VA] + 4,			; [5+] calculate next stack address
				;10599		[R2] <-- MEM (VA), LONG,		; read register
E 324  0C40,0001,48B0,4820 B 320;10600		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10601
				;10602	RET.0_6.3:
				;10603		;---------------------------------------; mask<3> = 1:
				;10604		VA <-- [VA] + 4,			; [5+] calculate next stack address
				;10605		[R3] <-- MEM (VA), LONG,		; read register
E 326  0C40,0001,4CB0,4820 B 320;10606		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10607
				;10608	RET.0_6.4:
				;10609		;---------------------------------------; mask<4> = 1:
				;10610		VA <-- [VA] + 4,			; [5+] calculate next stack address
				;10611		[R4] <-- MEM (VA), LONG,		; read register
E 328  0C40,0001,50B0,4820 B 320;10612		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10613
				;10614	RET.0_6.5:
				;10615		;---------------------------------------; mask<5> = 1:
				;10616		VA <-- [VA] + 4,			; [5+] calculate next stack address
				;10617		[R5] <-- MEM (VA), LONG,		; read register
E 32A  0C40,0001,54B0,4820 B 320;10618		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10619
				;10620	RET.0_6.6:
				;10621		;---------------------------------------; mask<6> = 1:
				;10622		VA <-- [VA] + 4,			; [5+] calculate next stack address
				;10623		[R6] <-- MEM (VA), LONG,		; read register
E 32C  0C40,0001,58B0,4820 B 320;10624		CASE [MPU.0-6] AT [RET.0_6.0]		; case on mask, reset rightmost bit
				;10625
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  321
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10626	RET.0_6.NEXT:
			    p322;10627		;---------------------------------------; mask<6:0> = 0:
E 32E  2000,0000,2000,4910 B 310;10628		CASE [MPU.7-13] AT [RET.7_13.7] 	; [5+] case on mask<13:7>, reset rightmost bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  322
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10629
				;10630	;	RET, continued.
				;10631	;	Process mask bits<13:7>.
				;10632
				;10633	;	At this point,
				;10634	;		W0	=	spa/s0/mask/psw
				;10635	;		W1	=	new ap
				;10636	;		W2	=	new fp
				;10637	;		Q	=	spa + 4
				;10638
				;10639	;= ALIGNLIST 000x	(RET.7_13.7,	RET.7_13.8,	RET.7_13.9,	RET.7_13.10,
				;10640	;=			 RET.7_13.11,	RET.7_13.12,	RET.7_13.S,	RET.7_13.G)
				;10641
				;10642	RET.7_13.7:
				;10643		;---------------------------------------; mask<7> = 1:
				;10644		VA <-- [VA] + 4,			; [6+] calculate next stack address
				;10645		[R7] <-- MEM (VA), LONG,		; read register
E 310  2C40,0001,5CB0,4910 B 310;10646		CASE [MPU.7-13] AT [RET.7_13.7] 	; case on mask, reset rightmost bit
				;10647
				;10648	RET.7_13.8:
				;10649		;---------------------------------------; mask<8> = 1:
				;10650		VA <-- [VA] + 4,			; [6+] calculate next stack address
				;10651		[R8] <-- MEM (VA), LONG,		; read register
E 312  2C40,0001,60B0,4910 B 310;10652		CASE [MPU.7-13] AT [RET.7_13.7] 	; case on mask, reset rightmost bit
				;10653
				;10654	RET.7_13.9:
				;10655		;---------------------------------------; mask<9> = 1:
				;10656		VA <-- [VA] + 4,			; [6+] calculate next stack address
				;10657		[R9] <-- MEM (VA), LONG,		; read register
E 314  2C40,0001,64B0,4910 B 310;10658		CASE [MPU.7-13] AT [RET.7_13.7] 	; case on mask, reset rightmost bit
				;10659
				;10660	RET.7_13.10:
				;10661		;---------------------------------------; mask<10> = 1:
				;10662		VA <-- [VA] + 4,			; [6+] calculate next stack address
				;10663		[R10] <-- MEM (VA), LONG,		; read register
E 316  2C40,0001,68B0,4910 B 310;10664		CASE [MPU.7-13] AT [RET.7_13.7] 	; case on mask, reset rightmost bit
				;10665
				;10666	RET.7_13.11:
				;10667		;---------------------------------------; mask<11> = 1:
				;10668		VA <-- [VA] + 4,			; [6+] calculate next stack address
				;10669		[R11] <-- MEM (VA), LONG,		; read register
E 318  2C40,0001,6CB0,4910 B 310;10670		CASE [MPU.7-13] AT [RET.7_13.7] 	; case on mask, reset rightmost bit
				;10671
				;10672	RET.7_13.12:
				;10673		;---------------------------------------; mask<12> = 1:
				;10674		NOP,					; [6+] this bit should be zero, but...
E 31A  2000,0000,2000,4910 B 310;10675		CASE [MPU.7-13] AT [RET.7_13.7] 	; case on mask, reset rightmost bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  323
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10676
				;10677	;	RET, continued.
				;10678	;	Mask bits processed, finish instruction.
				;10679
				;10680	;	At this point,
				;10681	;		W0	=	spa/s0/mask/psw
				;10682	;		W1	=	new ap
				;10683	;		W2	=	new fp
				;10684	;		Q	=	spa + 4
				;10685	;		VA	=	last location popped off stack
				;10686
				;10687	RET.7_13.G:
				;10688		;---------------------------------------; mask<13:7> = 0:
				;10689		[W3] <-- MEM (VA), LONG,		; [7+] re-do last GPR read to
				;10690							; sync Mbox GPR read with
			    p324;10691							; restart Ibox
E 31E  0040,0000,1000,24A3 S 4A3;10692		CALL [RET.SYNC.UPDATE.PSL]		; [8+] sync with mbox, update psl<7:0>
				;10693
				;10694		;---------------------------------------;
				;10695		[AP] <-- [W1], LONG,			; [9+] write new AP
E 31F  0000,0000,7020,04A1 J 4A1;10696		GOTO [RET.UPDATE.FP.SP] 		; go update registers
				;10697
				;10698	RET.7_13.S:
				;10699		;---------------------------------------; mask<13> = 1:
				;10700		VA <-- [VA] + [Q],			; [7+] calc running stk + spa + 4
				;10701		[W3] <-- MEM (VA), LEN(DL),		; read #arguments from stack
			    p324;10702		CALL [RET.SYNC.UPDATE.PSL],		; [8+] sync with mbox, update psl<7:0>
E 31C  08C0,0055,10B0,24A3 S 4A3;10703			sim addr [sp.extent]
				;10704
				;10705		;---------------------------------------;
				;10706		VA <-- [VA] + 4,			; [9+] increment VA over last pop
E 31D  0C00,8013,70B0,049D J 49D;10707		[AP] <-- PASSB [W1], LONG		; write new AP
				;10708
				;10709		;---------------------------------------;
E 49D  0400,27F8,1040,04A0 J 4A0;10710		[W3] <-- [W3] AND 000000[0FF]		; [10+] zero out un-needed bytes
				;10711
				;10712		;---------------------------------------;
E 4A0  0003,4200,2040,04A1 J 4A1;10713		Q <-- [W3] LSH [2], LONG		; [11+] multiply #args * 4
				;10714
				;10715	RET.UPDATE.FP.SP:
				;10716		;---------------------------------------;
E 4A1  0880,0050,78B0,04A2 J 4A2;10717		[SP] <-- [VA] + [Q], LONG		; [10/12+] sp = end of stack + spa/#args*4+4
				;10718
				;10719		;---------------------------------------;
				;10720		[FP] <-- [W2], LONG,			; [11/13+] set fp
				;10721		ACCESS B [W3],				; sync with last GPR read
			    p333;10722		RESTART IBOX,				; restart suspended Ibox
E 4A2  0000,0020,7434,0180 J 180;10723		GOTO [LAST.CYCLE]			; wait for psl to settle, decode
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  324
;   CALLRET.MIC 	     RET										      /REV=
;															    CALLRET
				;10724
				;10725	;	Single-cycle subroutine to update PSL<7:0>, toss the implicit PC
				;10726	;	specifier, and synchronize with any outstanding memory management
				;10727	;	exceptions.  The SYNCHRONIZE MBOX is required such that psl<7:0>
				;10728	;	(in particular, psl<t>) is not updated until the final memory
				;10729	;	management exception is resolved.  This also guarantees that the
				;10730	;	caller will not see any memory management exceptions.
				;10731
				;10732	RET.SYNC.UPDATE.PSL:
				;10733		;---------------------------------------;
				;10734		SYNCHRONIZE MBOX,			; resolve mmgt exceptions
				;10735		[PSL.B0] <-- [W0], LEN(DL),		; load new psl<7:0>
				;10736		ACCESS B [S1],				; toss implicit PC specifer
E 4A3  0020,0044,3410,0800 R	;10737		RETURN					; return to caller
				;10738
				;10739	;= END CALLRET
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  325
;      MISC.MIC 	     MISC.MIC -- Miscellaneous Instructions						      /REV=
;
				;10740	.TOC	"MISC.MIC -- Miscellaneous Instructions"
				;10741	.TOC	"Revision 1.0"
				;10742
				;10743	;	Bob Supnik
				;10744
;10745	.nobin
;10746	;****************************************************************************
;10747	;*									    *
;10748	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;10749	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;10750	;*  ALL RIGHTS RESERVED.						    *
;10751	;*									    *
;10752	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;10753	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;10754	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;10755	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;10756	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;10757	;*  TRANSFERRED.							    *
;10758	;*									    *
;10759	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;10760	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;10761	;*  CORPORATION.							    *
;10762	;*									    *
;10763	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;10764	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;10765	;*									    *
;10766	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  326
;      MISC.MIC 	     Revision History									      /REV=
;
;10767	.TOC	"	Revision History"
;10768
;10769	; Edit	  Date	 Who	     Description
;10770	; ---- --------- ---	---------------------
;10771	; (1)0 20-Jul-90 GMU	Initial production microcode.
;10772	;
;10773	; Begin version 1.0 here
;10774	;   12 19-Jul-90 GMU	Update with Bob's review comments.
;10775	;   11 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;10776	;   10 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;10777	;    9 22-Mar-90 DGM	Update comments and fix sync mbox bug in POPR
;10778	;    8 16-Jan-90 DGM	Change alignment for A31.BQA.BZ1 case
;10779	;    7 13-Dec-89 GMU	Fix bug in BIxPSW.
;10780	;    6 17-Nov-89 DGM	Avoid referencing PSL before the third cycle of BIxPSW
;10781	;			Also do general cleanup on code and comments.
;10782	;    5 07-Nov-89 GMU	Complete RESET CPU interface.
;10783	;    4 05-Oct-89 GMU	Add missing RESET CPU to BPT and XFC entry points.
;10784	;    3 28-Sep-89 GMU	Avoid referencing PSL before the third cycle of
;10785	;			BIxPSW and MOVPSL.
;10786	;    2 13-Sep-89 GMU	Correctly synchronize return of GPR data with
;10787	;			restart of Ibox.
;10788	;    1 24-Aug-89 DGM	Fix 2 bugs in PUSHR code
;10789	; (0)0 20-Jul-87 RMS	Trial microcode.
;10790
				;10791	.bin
				;10792	;= BEGIN MISC
;10793	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  327
;      MISC.MIC 	     Revision History									      /REV=
;															       MISC
;10794
;10795	;	This module implements the miscellaneous instruction class.
;10796	;	Instructions in this class are:
;10797	;
;10798	;	Opcode	 Instruction							N Z V C 	Exceptions
;10799	;	------	 -----------							------- 	----------
;10800	;
;10801	;	B9	 BICPSW mask.rw 						* * * * 	rsv
;10802	;
;10803	;	B8	 BISPSW mask.rw 						* * * * 	rsv
;10804	;
;10805	;	03	 BPT {-(KSP).w*}						0 0 0 0
;10806	;
;10807	;	00	 HALT {-(KSP).w*}						- - - - 	prv
;10808	;
;10809	;	0A	 INDEX subscript.rl, low.rl, high.rl, size.rl, indexin.rl,	* * 0 0 	sub
;10810	;		 indexout.wl
;10811	;
;10812	;	DC	 MOVPSL dst.wl							- - - -
;10813	;
;10814	;	01	 NOP								- - - -
;10815	;
;10816	;	BA	 POPR mask.rw, {(SP)+.r*}					- - - -
;10817	;
;10818	;	BB	 PUSHR mask.rw, {-(SP).w*}					- - - -
;10819	;
;10820	;	FC	 XFC {unspecified operands}					0 0 0 0
;10821	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  328
;      MISC.MIC 	     BPT, XFC										      /REV=
;															       MISC
;10822	.TOC	"	BPT, XFC"
;10823
;10824	;	These instructions cause an immediate fault through a dedicated SCB vector.
;10825	;
;10826	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;10827	;	--------      ------	---------				----	-----		--------
;10828	;	BPT		03	breakpoint fault			0	--		BPT..
;10829	;
;10830	;	XFC		FC	customer reserved instruction fault	0	--		XFC..
;10831	;
;10832	;	Entry conditions:
;10833	;		source queue	=	none
;10834	;		dest queue	=	none
;10835	;		branch queue	=	none
;10836	;		field queue	=	none
;10837	;		DL		=	BYTE
;10838	;		Ibox state	=	stopped
;10839	;		Mbox state	=	running
;10840	;
;10841	;	Exit conditions:
;10842	;		The next microstate is IE.FAULT.COMMON.
;10843	;
;10844	;	Condition codes:
;10845	;		N <-- 0
;10846	;		Z <-- 0
;10847	;		V <-- 0 		[Integer overflow disabled.]
;10848	;		C <-- 0
;10849	;
				;10850	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  329
;      MISC.MIC 	     BPT, XFC										      /REV=
;															       MISC
				;10851
				;10852	;	BPT operation:
				;10853	;
				;10854	;		initiate breakpoint fault
				;10855	;
				;10856	;	Entered by Ibox initial dispatch.
				;10857
				;10858	BPT..:
				;10859		;********** Hardware dispatch **********;
				;10860		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;10861		RESET CPU,				; abort current operations
				;10862		CALL [IE.CLEANUP.CPU],			; cleanup CPU state,
			    p159;10863							; PSL<TP> = 0, SAVEPC = BPC
E 184  0002,BA00,2006,22D7 S 2D7;10864			sim exception
				;10865
				;10866		;---------------------------------------;
				;10867		VA <-- [SCBB] + 000000[SCB.BPT],	; offset into SCB for BPT instruction
				;10868		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p129;10869		GOTO [IE.FAULT.COMMON], 		; join common code
E 185  08D0,2161,0A60,0286 J 286;10870			sim addr [scb]
				;10871
				;10872
				;10873	;	XFC operation:
				;10874	;
				;10875	;		initiate customer reserved instruction fault
				;10876	;
				;10877	;	Entered by Ibox initial dispatch.
				;10878
				;10879	XFC..:
				;10880		;********** Hardware dispatch **********;
				;10881		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;10882		RESET CPU,				; abort current operations
				;10883		CALL [IE.CLEANUP.CPU],			; cleanup CPU state,
			    p159;10884							; PSL<TP> = 0, SAVEPC = BPC
E 186  0002,BA00,2006,22D7 S 2D7;10885			sim exception
				;10886
				;10887		;---------------------------------------;
				;10888		VA <-- [SCBB] + 000000[SCB.XFC],	; offset into SCB for XFC instruction
				;10889		[W1] <-- MEM.SCB (VA), LONG,		; read SCB vector
			    p129;10890		GOTO [IE.FAULT.COMMON], 		; join common code
E 187  08D0,20A1,0A60,0286 J 286;10891			sim addr [scb]
				;10892
;10893	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  330
;      MISC.MIC 	     HALT										      /REV=
;															       MISC
;10894	.TOC	"	HALT"
;10895
;10896	;	This instruction halts the processor if the current mode is kernel.
;10897	;
;10898	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;10899	;	--------      ------	---------				----	-----		--------
;10900	;	HALT		00	if (curr mode neq kernel) then		0	--		HALT..
;10901	;				   (reserved instruction fault)
;10902	;				   else (halt restart)
;10903	;
;10904	;	Entry conditions:
;10905	;		source queue	=	none
;10906	;		dest queue	=	none
;10907	;		branch queue	=	none
;10908	;		field queue	=	none
;10909	;		DL		=	BYTE
;10910	;		Ibox state	=	stopped
;10911	;		Mbox state	=	running
;10912	;
;10913	;	Exit conditions:
;10914	;		The next microstate is CONSOLE.HALT (kernel mode)
;10915	;		or IE.RSVD.OPCODE (non-kernel mode).
;10916	;
;10917	;	Condition codes:
;10918	;		N <-- N
;10919	;		Z <-- Z
;10920	;		V <-- V 		[Integer overflow trap disabled.]
;10921	;		C <-- C
;10922	;
				;10923	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  331
;      MISC.MIC 	     HALT										      /REV=
;															       MISC
				;10924
				;10925	;	HALT operation:
				;10926	;
				;10927	;		if PSL<cur_mode> is kernel, then halt processor,
				;10928	;		else initiate reserved instruction fault
				;10929
				;10930	HALT..:
				;10931		;********** Hardware dispatch **********;
				;10932		NOP,					; nothing to do
E 182  A000,0000,2000,4D29 B 129;10933		CASE [PSL.26-24] AT [HALT.00]		; case on PSL<cur_mode>
				;10934
				;10935	;= ALIGNLIST 100x	(HALT.00,	HALT.01,	HALT.10,	HALT.11)
				;10936
				;10937	HALT.00:
				;10938		;---------------------------------------; psl<25:24> = 00 (kernel):
E 129  1000,4000,2000,04A4 J 4A4;10939		RETIRE INSTRUCTION			; retire HALT instruction before halt
				;10940							; delay before CONSOLE HALT until
				;10941							; PSL<TP> is valid
				;10942
			    p.84;10943		;---------------------------------------;
E 4A4  0500,2830,A4C0,0034 J 034;10944		CONSOLE HALT [ERR.HLTINS]		; go to console halt routine
				;10945
				;10946	HALT.01:
			    p126;10947		;---------------------------------------; psl<25:24> = 01 (executive):
E 12B  0000,0000,2000,0100 J 100;10948		RESERVED INSTRUCTION FAULT		; not in kernel mode, fault
				;10949
				;10950	HALT.10:
			    p126;10951		;---------------------------------------; psl<25:24> = 10 (supervisor):
E 12D  0000,0000,2000,0100 J 100;10952		RESERVED INSTRUCTION FAULT		; not in kernel mode, fault
				;10953
				;10954	HALT.11:
			    p126;10955		;---------------------------------------; psl<25:24> = 11 (user):
E 12F  0000,0000,2000,0100 J 100;10956		RESERVED INSTRUCTION FAULT		; not in kernel mode, fault
				;10957
;10958	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  332
;      MISC.MIC 	     NOP										      /REV=
;															       MISC
;10959	.TOC	"	NOP"
;10960
;10961	;	This instruction performs no operation.
;10962	;
;10963	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;10964	;	--------      ------	---------				----	-----		--------
;10965	;	NOP		01	no operation				0	--		NOP..
;10966	;
;10967	;	Entry conditions:
;10968	;		source queue	=	none
;10969	;		dest queue	=	none
;10970	;		branch queue	=	none
;10971	;		field queue	=	none
;10972	;		DL		=	BYTE
;10973	;		Ibox state	=	running
;10974	;		Mbox state	=	running
;10975	;
;10976	;	Exit conditions:
;10977	;		Machine state is unchanged.
;10978	;
;10979	;	Condition codes:
;10980	;		N <-- N
;10981	;		Z <-- Z
;10982	;		V <-- V 		[Integer overflow trap disabled.]
;10983	;		C <-- C
;10984	;
				;10985	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  333
;      MISC.MIC 	     NOP										      /REV=
;															       MISC
				;10986
				;10987	;	NOP operation:
				;10988	;
				;10989	;		decode next instruction
				;10990
				;10991	LAST.CYCLE:
				;10992	NOP..:
				;10993		;********** Hardware dispatch **********;
				;10994		NOP,					; nothing to do
E 180  0000,0000,2000,1000 L	;10995		LAST CYCLE				; decode next instruction
				;10996
;10997	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  334
;      MISC.MIC 	     INDEX										      /REV=
;															       MISC
;10998	.TOC	"	INDEX"
;10999
;11000	;	This instruction computes the index into a subscripted array.
;11001	;	The indexin operand is added to the subscript operand and the sum
;11002	;	multiplied by the size of the operand.	The indexout operand is replaced
;11003	;	by the result.	If the subscript operand is less than the low operand or
;11004	;	greater than the high operand, a subscript range trap is taken.
;11005	;
;11006	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;11007	;	--------      ------	---------				----	-----			--------
;11008	;	INDEX		0A	indexout.wl <-- 			6	rrrrrw/llllll		INDEX..
;11009	;					(indexin.rl+subscript.rl)*size.rl
;11010	;					if (subscript.rl LSS lowlimit.rl) OR
;11011	;					   (subscript.rl GTR highlimit.rl) THEN subscript range trap
;11012	;
;11013	;	Entry conditions:
;11014	;		source queue	=	subscript.rl operand
;11015	;					low.rl operand
;11016	;					high.rl operand
;11017	;					size.rl operand
;11018	;					indexin.rl operand
;11019	;		dest queue	=	indexout.wl result
;11020	;		branch queue	=	none
;11021	;		field queue	=	none
;11022	;		DL		=	LONG
;11023	;		Ibox state	=	running
;11024	;		Mbox state	=	running
;11025	;
;11026	;	Exit conditions:
;11027	;		The PSL condition codes are set.
;11028	;		The result has been stored in the destination memory location or register.
;11029	;		If a subscript range trap occured, a VAX TRAP REQUEST is pending.
;11030	;
;11031	;	Condition codes:
;11032	;		N <-- indexout LSS 0
;11033	;		Z <-- indexout EQL 0
;11034	;		V <-- 0 		[Integer overflow trap disabled.]
;11035	;		C <-- 0
;11036	;
				;11037	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  335
;      MISC.MIC 	     INDEX										      /REV=
;															       MISC
				;11038
				;11039	;	INDEX operation:
				;11040	;
				;11041	;		indexout.wl <-- (indexin.rl+subscript.rl)*size.rl
				;11042	;		if (subscript.rl LSS lowlimit.rl) OR
				;11043	;		   (subscript.rl GTR highlimit.rl) THEN subscript range trap
				;11044
				;11045	INDEX..:
				;11046		;********** Hardware dispatch **********;
				;11047		NODST <-- [S1] - [S2], LONG,		; [1] compare subscript:low limit
				;11048		[W1] <-- PASSA [S1],			; save subscript operand
E 188  0A80,404A,0880,04A5 J 4A5;11049			sim cond k s4.[0]
				;11050
				;11051		;---------------------------------------;
				;11052		[WBUS] <-- [S1] - [W1], LONG,		; [2] compare high limit:subscript
E 4A5  0A80,0010,2080,0400 J 400;11053			sim cond k s4.[0]
				;11054
				;11055		;---------------------------------------;
				;11056		[WBUS] <-- [S1] XOR 000000[01], LONG,	; [3] test for size=1
				;11057		Q <-- PASSA [S1],			; and save size operand
E 400  2602,6008,2080,4104 B 404;11058		CASE [ALU.NZV] AT [INDEX.LOW.LIMIT.00]	; case on low limit test from [1]
				;11059
				;11060	;= ALIGNLIST 010x	(INDEX.LOW.LIMIT.00,	INDEX.LOW.LIMIT.01,
				;11061	;=			 INDEX.LOW.LIMIT.10,	INDEX.LOW.LIMIT.11)
				;11062
				;11063	INDEX.LOW.LIMIT.00:
				;11064		;---------------------------------------; alu.nv = 00:
			    p336;11065		[W0] <-- [S1] + [W1], LONG,		; [4] compute subscript + indexin
E 404  2880,0010,0480,4105 B 405;11066		CASE [ALU.NZV] AT [INDEX.HIGH.LIMIT.00] ; case on high limit test from [2]
				;11067
				;11068	INDEX.LOW.LIMIT.01:
				;11069		;---------------------------------------; alu.nv = 01:
			    p336;11070		[W0] <-- [S1] + [W1], LONG,		; [4] compute subscript + indexin
E 406  0880,0010,0480,0407 J 407;11071		GOTO [INDEX.HIGH.LIMIT.01]		; go to high error case
				;11072
				;11073	INDEX.LOW.LIMIT.10:
				;11074		;---------------------------------------; alu.nv = 10:
			    p336;11075		[W0] <-- [S1] + [W1], LONG,		; [4] compute subscript + indexin
E 40C  0880,0010,0480,040D J 40D;11076		GOTO [INDEX.HIGH.LIMIT.10]		; go to high error case
				;11077
				;11078	INDEX.LOW.LIMIT.11:
				;11079		;---------------------------------------; alu.nv = 11:
			    p336;11080		[W0] <-- [S1] + [W1], LONG,		; [4] compute subscript + indexin
E 40E  2880,0010,0480,4105 B 405;11081		CASE [ALU.NZV] AT [INDEX.HIGH.LIMIT.00] ; case on high limit test from [2]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  336
;      MISC.MIC 	     INDEX										      /REV=
;															       MISC
				;11082
				;11083	;	INDEX, continued.
				;11084	;	Finish high limit check, setup for multiply.
				;11085
				;11086	;	At this point,
				;11087	;		W0	=	subscript + indexin
				;11088	;		Q	=	size
				;11089	;		DST	=	destination pointer
				;11090	;		ALU.Z	=	1 if size=1
				;11091
				;11092	;= ALIGNLIST 010x	(INDEX.HIGH.LIMIT.00,	INDEX.HIGH.LIMIT.01,
				;11093	;=			 INDEX.HIGH.LIMIT.10,	INDEX.HIGH.LIMIT.11)
				;11094
				;11095	INDEX.HIGH.LIMIT.00:
				;11096		;---------------------------------------; alu.nv = 00:
			    p337;11097		[W1] <-- 000000[00], LONG,		; [5] clear W1 for multiply routine
E 405  2080,2000,0800,4118 B 418;11098		CASE [ALU.NZV] AT [INDEX.MULTIPLY]	; check for size=1 from [3]
				;11099
				;11100	INDEX.HIGH.LIMIT.01:
				;11101		;---------------------------------------; alu.nv = 01:
				;11102		[W1] <-- 000000[00], LONG,		; [5] clear W1 for multiply routine
			    p337;11103		STATE.1 <-- 1,				; indicate subscript error
E 407  0080,2000,0809,0418 J 418;11104		GOTO [INDEX.MULTIPLY]			; do multiply and exit
				;11105
				;11106	INDEX.HIGH.LIMIT.10:
				;11107		;---------------------------------------; alu.nv = 10:
				;11108		[W1] <-- 000000[00], LONG,		; [5] clear W1 for multiply routine
			    p337;11109		STATE.1 <-- 1,				; indicate subscript error
E 40D  0080,2000,0809,0418 J 418;11110		GOTO [INDEX.MULTIPLY]			; do multiply and exit
				;11111
				;11112	INDEX.HIGH.LIMIT.11:
				;11113		;---------------------------------------; alu.nv = 11:
			    p337;11114		[W1] <-- 000000[00], LONG,		; [5] clear W1 for multiply routine
E 40F  2080,2000,0800,4118 B 418;11115		CASE [ALU.NZV] AT [INDEX.MULTIPLY]	; check for size=1 from [3]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  337
;      MISC.MIC 	     INDEX										      /REV=
;															       MISC
				;11116
				;11117	;	INDEX, continued.
				;11118	;	Do multiply, store result
				;11119
				;11120	;	At this point,
				;11121	;		W0	=	subscript + indexin
				;11122	;		Q	=	size
				;11123	;		shift.sign =	set from Q
				;11124
				;11125	;= ALIGNLIST 10xx	(INDEX.MULTIPLY,	INDEX.SIZE.EQL.1)
				;11126	;  ALU.NZV set from XOR --> V = C = 0
				;11127
				;11128	INDEX.SIZE.EQL.1:
				;11129		;---------------------------------------; alu.z = 1:
				;11130		[DST] <-- [W0], LONG,			; [6] store result
				;11131		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 41C  0000,0000,241D,1000 L	;11132		LAST CYCLE				; decode next instruction
				;11133
				;11134
				;11135	INDEX.MULTIPLY:
				;11136		;---------------------------------------; alu.z = 0:
				;11137		[W1] <-- [W1] SMUL [W0], LONG,		; [6] do first multiply step
			    p277;11138							; >> No Q write in previous cycle
E 418  0E02,0008,0820,22A0 S 2A0;11139		CALL [INT.MULT.31.STEPS]		; [7-37] do next 31 multiply steps
				;11140							; >> call requires 5 microstack locations
				;11141
				;11142		;---------------------------------------;
E 419  4000,0000,2000,4A1A B 41A;11143		CASE [STATE.2-0] AT [INDEX.DEST]	; [38] case on subscript error
				;11144							; don't care about fixing up,
				;11145							; high-order 32 bits not used
				;11146							; >> No Q read this cycle
				;11147
				;11148	;= ALIGNLIST 101x	(INDEX.DEST,		INDEX.ERROR)
				;11149
				;11150	INDEX.DEST:
				;11151		;---------------------------------------;
				;11152		[DST] <-- [Q], LONG,			; [39] store result
				;11153		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 41A  0000,0000,24AD,1000 L	;11154		LAST CYCLE				; decode next instruction
				;11155
				;11156
				;11157	INDEX.ERROR:
				;11158		;---------------------------------------;
				;11159		[DST] <-- [Q], LONG,			; [39] store result
				;11160		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
			    p122;11161		RETIRE INSTRUCTION,			; retire instruction
E 41E  1000,4000,24AD,0044 J 044;11162		GOTO [IE.SUBSCRIPT.ERROR..]		; join error flows
				;11163
;11164	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  338
;      MISC.MIC 	     BICPSW, BISPSW									      /REV=
;															       MISC
;11165	.TOC	"	BICPSW, BISPSW"
;11166
;11167	;	These instructions operate on the trap enable and condition code bits of the PSW.
;11168	;
;11169	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;11170	;	--------      ------	---------				----	-----		--------
;11171	;	BISPSW		B8	psw <-- psw or src.rw			1	r/w		BIXPSW..
;11172	;				  if (src.rw<15:8> neq 0) then (reserved operand fault)
;11173	;
;11174	;	BICPSW		B9	psw <-- psw and not src.rw		1	r/w		BIXPSW..
;11175	;				  if (src.rw<15:8> neq 0) then (reserved operand fault)
;11176	;
;11177	;	Entry conditions:
;11178	;		source queue	=	src.rw operand
;11179	;		dest queue	=	none
;11180	;		branch queue	=	none
;11181	;		field queue	=	none
;11182	;		DL		=	WORD
;11183	;		Ibox state	=	running
;11184	;		Mbox state	=	running
;11185	;
;11186	;	Exit conditions:
;11187	;		If src<15:8> = 0, PSW<7:0> have been updated.
;11188	;
;11189	;	Condition codes:
;11190	;		(BISPSW)		(BICPSW)
;11191	;		N <-- N or src<3>	N <-- N andnot src<3>
;11192	;		Z <-- Z or src<2>	Z <-- Z andnot src<2>
;11193	;		V <-- V or src<1>	V <-- V andnot src<1>	[Integer overflow trap disabled.]
;11194	;		C <-- C or src<0>	C <-- C andnot src<0>
;11195	;
;11196	;	Notes:
;11197	;		1.  Memory management:	PSW is not altered until the source list has been emptied.
;11198
				;11199	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  339
;      MISC.MIC 	     BICPSW, BISPSW									      /REV=
;															       MISC
				;11200
				;11201	;	BIxPSW operation:
				;11202	;
				;11203	;		if src<15:8> = 0, then PSL<7:0> <-- PSL<7:0> or/andnot src<7:0>
				;11204	;			else initiate reserved operand fault
				;11205
				;11206	BIXPSW..:
				;11207		;********** Hardware dispatch **********;
				;11208		[W0] <-- B [S1], LEN(DL),		; [1] zext operand, test bits<15:8>
				;11209		CASE [OPCODE.2-0] AT [BISPSW],		; case on opcode
				;11210							; >> no PSL read this cycle
E 200  8080,0044,0400,4C11 B 211;11211			sim cond k s3.[1]
				;11212
				;11213	;= ALIGNLIST xx0x	(BISPSW,		BICPSW)
				;11214	;  Opcodes = B8, B9 --> opcode<2:0> = 00?
				;11215
				;11216	BISPSW:
				;11217		;---------------------------------------; opcode<0> = 0:
				;11218		[PSL.B0] <-- [PSL] OR [W0], LONG,	; [2] combine values to PSL<7:0>
				;11219							; >> PSL change, no decode for 3 cycles
				;11220		Q <-- PASSA [PSL],			; save current PSL
			    p417;11221							; >> PSL reference OK because PSL<tp> not used
E 211  E502,4008,34C0,478C B 28C;11222		CASE [A31.BQA.BNZ1] AT [INTERRUPT.STATE.CHANGE] ; case on src<15:8> = 0
				;11223
				;11224	BICPSW:
				;11225		;---------------------------------------; opcode<0> = 1:
				;11226		[PSL.B0] <-- [PSL] ANDNOT [W0], LONG,	; [2] combine values to PSL<7:0>
				;11227							; >> PSL change, no decode for 3 cycles
				;11228		Q <-- PASSA [PSL],			; save current PSL
			    p417;11229							; >> PSL reference OK because PSL<tp> not used
E 213  E482,4008,34C0,478C B 28C;11230		CASE [A31.BQA.BNZ1] AT [INTERRUPT.STATE.CHANGE] ; case on src<15:8> = 0
				;11231
				;11232	;= ALIGNLIST 110x	(INTERRUPT.STATE.CHANGE,	BIXPSW.RSRV)
				;11233
				;11234	BIXPSW.RSRV:
				;11235		;---------------------------------------; b<15:8> <> 0:
				;11236		[PSL.B0] <-- [Q], LONG, 		; [3] restore previous value of PSL
			    p376;11237							; >> PSL change, no decode for 3 cycles
E 28E  0000,0000,34A0,05CB J 5CB;11238		GOTO [RESERVED.OPERAND.FAULT]		; invoke reserved operand fault
				;11239
;11240	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  340
;      MISC.MIC 	     MOVPSL										      /REV=
;															       MISC
;11241	.TOC	"	MOVPSL"
;11242
;11243	;	This instruction copies the PSL to a destination operand.
;11244	;
;11245	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;11246	;	--------      ------	---------				----	-----		--------
;11247	;	MOVPSL		DC	dst.wl <-- PSL				1	w/l		MOVPSL..
;11248	;
;11249	;	Entry conditions:
;11250	;		source queue	=	none
;11251	;		dest queue	=	dst.wl result
;11252	;		branch queue	=	none
;11253	;		field queue	=	none
;11254	;		DL		=	LONG
;11255	;		Ibox state	=	running
;11256	;		Mbox state	=	running
;11257	;
;11258	;	Exit conditions:
;11259	;		The PSL is stored in the destination memory location or register.
;11260	;
;11261	;	Condition codes:
;11262	;		N <-- N
;11263	;		Z <-- Z
;11264	;		V <-- V 		[Integer overflow trap disabled.]
;11265	;		C <-- C
;11266	;
				;11267	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  341
;      MISC.MIC 	     MOVPSL										      /REV=
;															       MISC
				;11268
				;11269	;	MOVPSL operation:
				;11270	;
				;11271	;		dst.wl <-- PSL
				;11272
				;11273	MOVPSL..:
				;11274		;********** Hardware dispatch **********;
			    p276;11275		NOP,					; can't read PSL here
E 18A  0000,0000,2000,2497 S 497;11276		CALL [WAIT.ONE.CYCLE]			; PSL<tp> not valid in first 2 cycles
				;11277
				;11278		;---------------------------------------;
				;11279		[DST] <-- [PSL], LONG,			; store PSL in destination
E 18B  0000,0000,24C0,1000 L	;11280		LAST CYCLE				; decode next instruction
				;11281
;11282	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  342
;      MISC.MIC 	     POPR										      /REV=
;															       MISC
;11283	.TOC	"	POPR"
;11284	;
;11285	;	This instruction pops multiple registers off the stack.
;11286	;
;11287	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;11288	;	--------      ------	---------				----	-----		--------
;11289	;	POPR		BA	pop registers based on mask.rw		1	r/w		POPR..
;11290	;
;11291	;	Entry conditions:
;11292	;		source queue	=	mask.rw operand
;11293	;		dest queue	=	none
;11294	;		branch queue	=	none
;11295	;		field queue	=	none
;11296	;		DL		=	WORD
;11297	;		Ibox state	=	stopped
;11298	;		Mbox state	=	running
;11299	;
;11300	;	Exit conditions:
;11301	;		The specified registers have been popped.
;11302	;
;11303	;	Condition codes:
;11304	;		N <-- N
;11305	;		Z <-- Z
;11306	;		V <-- V 		[Integer overflow trap disabled.]
;11307	;		C <-- C
;11308	;
;11309	;	Notes:
;11310	;		1.  Memory management:	The source list is emptied before the start of E-box I/O.
;11311	;		2.  Memory management:	The initial probe read and the first successful read guarantee
;11312	;		    that the stack is accessible before any state is altered.  The probe read not
;11313	;		    be explicitly checked; the first read makes errors from the probe read visible.
;11314	;		3.  Memory management:	A SYNCHRONIZE MBOX is needed to guarantee that the reads to the
;11315	;		    general registers have completed before instruction complete.
;11316	;
				;11317	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  343
;      MISC.MIC 	     POPR										      /REV=
;															       MISC
				;11318
				;11319	;	POPR operation:
				;11320	;
				;11321	;		for n = 0 to 14
				;11322	;			if mask<n> = 1 then Rn <-- (SP)+
				;11323
				;11324	POPR..:
				;11325		;********** Hardware dispatch **********;
				;11326		[WBUS] <-- [S1] + [S1], LEN(DL),	; [1] shift mask left 1, test<14:0> = 0
				;11327							; test A<14>, load pop cnt from A<13:0>
				;11328		Q <-- [S1] LSH [16.],			; shift mask left 16
				;11329		DL <-- BYTE,				; set dl = byte
E 18E  0883,5044,2082,0500 J 500;11330			sim cond [s34.mask14]
				;11331
				;11332		;---------------------------------------;
				;11333		[W1] <-- [POP.COUNT] - 1, LONG, 	; [2] get mask_bits_set*4 - 1
			    p344;11334		MPU <-- B.29..16 [Q],			; load MPU from mask
E 500  CB00,0050,0B8A,C60A B 50A;11335		CASE [A.15-12] AT [POPR.NO.SP]		; case on a<14>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  344
;      MISC.MIC 	     POPR										      /REV=
;															       MISC
				;11336
				;11337	;	POPR, continued.
				;11338	;	(SP not in mask) Check for zero mask.  Read new top of stack.
				;11339	;		Population counter is correct.
				;11340	;	(SP in mask) Read new top of stack (new SP).
				;11341	;		Population counter is low by 4 bytes.
				;11342
				;11343	;	At this point,
				;11344	;		W1	=	mask_bits_set*4 - 1
				;11345	;		MPU	=	mask
				;11346	;		alu.z	=	set from mask<14:0>
				;11347
				;11348	;= ALIGNLIST 101x	(POPR.NO.SP,		POPR.SP)
				;11349
				;11350	POPR.NO.SP:
				;11351		;---------------------------------------; a<14> = 0:
				;11352		[W2] <-- [SP] + [W1] + 1, LONG, 	; [3] new SP will be SP + mask_bits_set*4
E 50A  2900,0010,0DE0,4102 B 502;11353		CASE [ALU.NZV] AT [POPR.NOT.ZERO]	; case on mask<14:0> = 0
				;11354
				;11355	;= ALIGNLIST x01x	(POPR.NOT.ZERO, 	POPR.ZERO)
				;11356	;  Bit<14> = 0 by earlier test --> ALU.N = 0
				;11357
				;11358	POPR.ZERO:
				;11359		;---------------------------------------; alu.z = 1:
				;11360		RESTART IBOX,				; [4] restart suspended I-box
E 506  0000,0000,2004,1000 L	;11361		LAST CYCLE				; decode next instruction
				;11362
				;11363	POPR.NOT.ZERO:
				;11364		;---------------------------------------; alu.z = 0:
				;11365		VA <-- [SP] + [W1],			; [4] calc last byte of stack
				;11366		[W0] <-- MEM (VA), LEN(DL),		; read farthest extent byte of stack
				;11367		GOTO [POPR.SET.VA],			; go set VA for stack pop
E 502  08C0,0015,05E0,04A6 J 4A6;11368			sim addr [sp.extent]
				;11369
				;11370	POPR.SP:
				;11371		;---------------------------------------; a<14> = 1:
				;11372		VA <-- [SP] + [W1] + 1, 		; [3] calc location of new SP
				;11373		[W2] <-- MEM (VA), LONG,		; read farthest extent longword of stack
E 50E  0940,0011,0DE0,04A6 J 4A6;11374			sim addr [sp.extent]
				;11375
				;11376	POPR.SET.VA:
				;11377		;---------------------------------------;
				;11378		VA <-- [SP],				; [4/5] also check other end of stack
E 4A6  0040,0001,11E0,0337 J 337;11379		[W3] <-- MEM (VA), LONG 		; read top longword of stack
				;11380
				;11381		;---------------------------------------;
				;11382		VA <-- [SP] - 4, LONG,			; [5/6] preset stack pointer for pop
			    p345;11383		CASE [MPU.0-6] AT [POPR.0_6.0], 	; case on mask<6:0>, reset rightmost bit
E 337  0C80,0001,21E0,48C0 B 3C0;11384			sim addr [sp] - k
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  345
;      MISC.MIC 	     POPR										      /REV=
;															       MISC
				;11385
				;11386	;	POPR, continued.
				;11387	;	Process mask bits<6:0>.
				;11388
				;11389	;	NOTE: The VAX Restart bit will be cleared on the first memory read to a GPR
				;11390	;	because the GPR appears in the DEST field.
				;11391
				;11392	;	At this point,
				;11393	;		W0	=	target of read if SP not in mask
				;11394	;		W1	=	mask_bits_set*4 - 1
				;11395	;		W2	=	new SP
				;11396	;		W3	=	target of read of top of stack
				;11397
				;11398	;= ALIGNLIST 000x	(POPR.0_6.0,	POPR.0_6.1,	POPR.0_6.2,	POPR.0_6.3,
				;11399	;=			 POPR.0_6.4,	POPR.0_6.5,	POPR.0_6.6,	POPR.0_6.NEXT)
				;11400
				;11401	POPR.0_6.0:
				;11402		;---------------------------------------; mask<0> = 1:
				;11403		VA <-- [VA] + 4,			; calc next stack location
				;11404		[R0] <-- MEM (VA), LONG,		; read register
E 3C0  0C40,0001,40B0,48C0 B 3C0;11405		CASE [MPU.0-6] AT [POPR.0_6.0]		; case on mask, reset rightmost bit
				;11406
				;11407	POPR.0_6.1:
				;11408		;---------------------------------------; mask<1> = 1:
				;11409		VA <-- [VA] + 4,			; calc next stack location
				;11410		[R1] <-- MEM (VA), LONG,		; read register
E 3C2  0C40,0001,44B0,48C0 B 3C0;11411		CASE [MPU.0-6] AT [POPR.0_6.0]		; case on mask, reset rightmost bit
				;11412
				;11413	POPR.0_6.2:
				;11414		;---------------------------------------; mask<2> = 1:
				;11415		VA <-- [VA] + 4,			; calc next stack location
				;11416		[R2] <-- MEM (VA), LONG,		; read register
E 3C4  0C40,0001,48B0,48C0 B 3C0;11417		CASE [MPU.0-6] AT [POPR.0_6.0]		; case on mask, reset rightmost bit
				;11418
				;11419	POPR.0_6.3:
				;11420		;---------------------------------------; mask<3> = 1:
				;11421		VA <-- [VA] + 4,			; calc next stack location
				;11422		[R3] <-- MEM (VA), LONG,		; read register
E 3C6  0C40,0001,4CB0,48C0 B 3C0;11423		CASE [MPU.0-6] AT [POPR.0_6.0]		; case on mask, reset rightmost bit
				;11424
				;11425	POPR.0_6.4:
				;11426		;---------------------------------------; mask<4> = 1:
				;11427		VA <-- [VA] + 4,			; calc next stack location
				;11428		[R4] <-- MEM (VA), LONG,		; read register
E 3C8  0C40,0001,50B0,48C0 B 3C0;11429		CASE [MPU.0-6] AT [POPR.0_6.0]		; case on mask, reset rightmost bit
				;11430
				;11431	POPR.0_6.5:
				;11432		;---------------------------------------; mask<5> = 1:
				;11433		VA <-- [VA] + 4,			; calc next stack location
				;11434		[R5] <-- MEM (VA), LONG,		; read register
E 3CA  0C40,0001,54B0,48C0 B 3C0;11435		CASE [MPU.0-6] AT [POPR.0_6.0]		; case on mask, reset rightmost bit
				;11436
				;11437	POPR.0_6.6:
				;11438		;---------------------------------------; mask<6> = 1:
				;11439		VA <-- [VA] + 4,			; calc next stack location
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  346
;      MISC.MIC 	     POPR										      /REV=
;															       MISC
			    p345;11440		[R6] <-- MEM (VA), LONG,		; read register
E 3CC  0C40,0001,58B0,48C0 B 3C0;11441		CASE [MPU.0-6] AT [POPR.0_6.0]		; case on mask, reset rightmost bit
				;11442
				;11443	POPR.0_6.NEXT:
				;11444		;---------------------------------------; mask<6:0> = 0:
			    p347;11445		NOP,					; done with this group
E 3CE  2000,0000,2000,49C1 B 3C1;11446		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask<13:7>, reset rightmost bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  347
;      MISC.MIC 	     POPR										      /REV=
;															       MISC
				;11447
				;11448	;	POPR, continued.
				;11449	;	Process mask bits<13:7>.
				;11450
				;11451	;	At this point,
				;11452	;		W0	=	target of read if SP not in mask
				;11453	;		W2	=	new SP
				;11454	;		W3	=	target of read of top of stack
				;11455
				;11456	;= ALIGNLIST 000x	(POPR.7_13.7,	POPR.7_13.8,	POPR.7_13.9,	POPR.7_13.10,
				;11457	;=			 POPR.7_13.11,	POPR.7_13.12,	POPR.7_13.13,	POPR.7_13.DONE)
				;11458
				;11459	POPR.7_13.7:
				;11460		;---------------------------------------; mask<7> = 1:
				;11461		VA <-- [VA] + 4,			; calc next stack location
				;11462		[R7] <-- MEM (VA), LONG,		; read register
E 3C1  2C40,0001,5CB0,49C1 B 3C1;11463		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask, reset rightmost bit
				;11464
				;11465	POPR.7_13.8:
				;11466		;---------------------------------------; mask<8> = 1:
				;11467		VA <-- [VA] + 4,			; calc next stack location
				;11468		[R8] <-- MEM (VA), LONG,		; read register
E 3C3  2C40,0001,60B0,49C1 B 3C1;11469		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask, reset rightmost bit
				;11470
				;11471	POPR.7_13.9:
				;11472		;---------------------------------------; mask<9> = 1:
				;11473		VA <-- [VA] + 4,			; calc next stack location
				;11474		[R9] <-- MEM (VA), LONG,		; read register
E 3C5  2C40,0001,64B0,49C1 B 3C1;11475		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask, reset rightmost bit
				;11476
				;11477	POPR.7_13.10:
				;11478		;---------------------------------------; mask<10> = 1:
				;11479		VA <-- [VA] + 4,			; calc next stack location
				;11480		[R10] <-- MEM (VA), LONG,		; read register
E 3C7  2C40,0001,68B0,49C1 B 3C1;11481		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask, reset rightmost bit
				;11482
				;11483	POPR.7_13.11:
				;11484		;---------------------------------------; mask<11> = 1:
				;11485		VA <-- [VA] + 4,			; calc next stack location
				;11486		[R11] <-- MEM (VA), LONG,		; read register
E 3C9  2C40,0001,6CB0,49C1 B 3C1;11487		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask, reset rightmost bit
				;11488
				;11489	POPR.7_13.12:
				;11490		;---------------------------------------; mask<12> = 1:
				;11491		VA <-- [VA] + 4,			; calc next stack location
				;11492		[R12] <-- MEM (VA), LONG,		; read register
E 3CB  2C40,0001,70B0,49C1 B 3C1;11493		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask, reset rightmost bit
				;11494
				;11495	POPR.7_13.13:
				;11496		;---------------------------------------; mask<13> = 1:
				;11497		VA <-- [VA] + 4,			; calc next stack location
				;11498		[R13] <-- MEM (VA), LONG,		; read register
E 3CD  2C40,0001,74B0,49C1 B 3C1;11499		CASE [MPU.7-13] AT [POPR.7_13.7]	; case on mask, reset rightmost bit
				;11500
				;11501	POPR.7_13.DONE:
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  348
;      MISC.MIC 	     POPR										      /REV=
;															       MISC
				;11502		;---------------------------------------; mask<13:7> = 0:
				;11503		ACCESS B [W0],				; touch read destination
				;11504		ACCESS A [W3],				; touch read destination
E 3CF  0040,0008,0840,04A7 J 4A7;11505		[W1] <-- MEM (VA), LONG 		; re-do last stack reference
				;11506							; to sync delivery with restart
				;11507							; ibox
				;11508
				;11509		;---------------------------------------;
				;11510		[SP] <-- [W2], LONG,			; update SP
				;11511		ACCESS B [W1],				; sync with last GPR read
				;11512		RESTART IBOX,				; restart suspended I-box
E 4A7  0000,0010,7834,1000 L	;11513		LAST CYCLE				; decode next instruction
				;11514
;11515	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  349
;      MISC.MIC 	     PUSHR										      /REV=
;															       MISC
;11516	.TOC	"	PUSHR"
;11517	;
;11518	;	This instruction pushes multiple registers onto the stack.
;11519	;
;11520	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;11521	;	--------      ------	---------				----	-----		--------
;11522	;	PUSHR		BB	push registers based on mask.rw 	1	r/w		PUSHR..
;11523	;
;11524	;	Entry conditions:
;11525	;		source queue	=	mask.rw operand
;11526	;		dest queue	=	none
;11527	;		branch queue	=	none
;11528	;		field queue	=	none
;11529	;		DL		=	WORD
;11530	;		Ibox state	=	stopped
;11531	;		Mbox state	=	running
;11532	;
;11533	;	Exit conditions:
;11534	;		The specified registers have been pushed.
;11535	;
;11536	;	Condition codes:
;11537	;		N <-- N
;11538	;		Z <-- Z
;11539	;		V <-- V 		[Integer overflow trap disabled.]
;11540	;		C <-- C
;11541	;
;11542	;	Notes:
;11543	;		1.  Memory management:	The source list is emptied before the start of E-box I/O.
;11544	;		2.  Memory management:	The initial write check, plus the first successful write, guarantee
;11545	;		    the accessibility of the stack.
;11546	;		3.  Memory management:	If there is only one register pushed, then a memory management error
;11547	;		    from that write might not be reported before instruction complete.	Accordingly, a
;11548	;		    redundant write check is done at the end, to force reporting of any previous errors.
;11549	;
				;11550	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  350
;      MISC.MIC 	     PUSHR										      /REV=
;															       MISC
				;11551
				;11552	;	PUSHR operation.
				;11553	;
				;11554	;		for n = 0 to 14
				;11555	;			if mask<n> = 1 then -(SP) <-- Rn
				;11556
				;11557	PUSHR..:
				;11558		;********** Hardware dispatch **********;
				;11559		[WBUS] <-- [S1] + [S1], LEN(DL),	; [1] shift mask left 1, test<14:0> = 0
				;11560							; test A<14>, load pop cnt from A<13:0>
				;11561		Q <-- [S1] LSH [16.],			; shift mask left 16
				;11562		DL <-- BYTE,				; set dl = byte
E 18C  0883,5044,2082,0501 J 501;11563			sim cond [s34.mask14]
				;11564
				;11565		;---------------------------------------;
				;11566		[W1] <-- [POP.COUNT] + 4, LONG, 	; [2] get mask_bits_set*4 + 4
			    p351;11567		MPU <-- B.29..16 [Q],			; load MPU from mask
E 501  CC00,0050,0B8A,C60B B 50B;11568		CASE [A.15-12] AT [PUSHR.NO.SP] 	; case on SP in mask
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  351
;      MISC.MIC 	     PUSHR										      /REV=
;															       MISC
				;11569
				;11570	;	PUSHR, continued.
				;11571	;	(SP not in mask) Check for zero mask.  Write check end of stack.
				;11572	;		Population counter is correct.
				;11573	;	(SP in mask) Write check new top of stack.  Write end of stack.
				;11574	;		Population counter is low by 4 bytes.
				;11575
				;11576	;	At this point,
				;11577	;		W1	=	mask_bits_set*4 + 4
				;11578	;		alu.z	=	set from mask<14:0>
				;11579
				;11580	;= ALIGNLIST 101x	(PUSHR.NO.SP,	PUSHR.SP)
				;11581
				;11582	PUSHR.NO.SP:
				;11583		;---------------------------------------; a<14> = 0:
				;11584		NOP,					; [3] must test for zero mask first
E 50B  2000,0000,2000,4103 B 503;11585		CASE [ALU.NZV] AT [PUSHR.NOT.ZERO]	; case on mask<14:0> = 0
				;11586
				;11587	;= ALIGNLIST x01x	(PUSHR.NOT.ZERO,	PUSHR.ZERO)
				;11588	;  Bit<14> = 0 by earlier test --> ALU.N = 0
				;11589
				;11590	RESTART.IBOX:
				;11591	PUSHR.ZERO:
				;11592		;---------------------------------------; alu.z = 1:
				;11593		RESTART IBOX,				; [4] restart suspended I-box
E 507  0000,0000,2004,1000 L	;11594		LAST CYCLE				; decode next instruction
				;11595
				;11596	PUSHR.NOT.ZERO:
				;11597		;---------------------------------------;
				;11598		WCHK (VA)&, VA <-- [SP] - 1, LEN(DL),	; [4] write check end of stack
E 503  0B60,0005,21E0,0313 J 313;11599			sim addr [sp] - k
				;11600
				;11601		;---------------------------------------;
				;11602		VA&, [W2] <-- [SP] - [W1], LONG,	; [5] preset to SP - mask_bits_set*4 - 4
			    p352;11603		CASE [MPU.0-6] AT [PUSHR.0_6.0],	; case on mask<6:0>, reset rightmost bit
E 313  0A80,0011,0DE0,4880 B 380;11604			sim addr [sp.extent]
				;11605
				;11606	PUSHR.SP:
				;11607		;---------------------------------------; a<14> = 1:
				;11608		WCHK (VA)&, VA&, [W2] <-- [SP] - [W1],	; [3] write chk top of stk (-4 for SP)
				;11609		LEN(DL),
E 50F  0AE0,0015,0DE0,04A8 J 4A8;11610			sim addr [sp.extent]
				;11611
				;11612		;---------------------------------------;
				;11613		VA <-- [SP] - 4,			; [4] calculate last location to be pushed
				;11614		MEM (VA)&, [WBUS] <-- PASSB [SP], LONG, ; write stack to end of stack
E 4A8  0CE4,80F3,21E0,0319 J 319;11615			sim addr [sp] - k
				;11616
				;11617		;---------------------------------------;
				;11618		VA&, [W2] <-- [VA] - [W1], LONG,	; [5] preset to SP - mask_bits_set*4 - 8
			    p352;11619		CASE [MPU.0-6] AT [PUSHR.0_6.0],	; case on mask<6:0>, reset rightmost bit
E 319  0A80,0011,0CB0,4880 B 380;11620			sim addr [sp.extent]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  352
;      MISC.MIC 	     PUSHR										      /REV=
;															       MISC
				;11621
				;11622	;	PUSHR, continued.
				;11623	;	Process mask bits<6:0>.
				;11624
				;11625	;	At this point,
				;11626	;		W2	=	new SP - 4
				;11627
				;11628	;= ALIGNLIST 000x	(PUSHR.0_6.0,	PUSHR.0_6.1,	PUSHR.0_6.2,	PUSHR.0_6.3,
				;11629	;=			 PUSHR.0_6.4,	PUSHR.0_6.5,	PUSHR.0_6.6,	PUSHR.0_6.NEXT)
				;11630
				;11631	PUSHR.0_6.0:
				;11632		;---------------------------------------; mask<0> = 1:
				;11633		VA <-- [VA] + 4,			; calculate next stack location
				;11634		MEM (VA)&, [WBUS] <-- PASSB [R0], LONG, ; write register to stack
E 380  0C64,8083,20B0,4880 B 380;11635		CASE [MPU.0-6] AT [PUSHR.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;11636
				;11637	PUSHR.0_6.1:
				;11638		;---------------------------------------; mask<1> = 1:
				;11639		VA <-- [VA] + 4,			; calculate next stack location
				;11640		MEM (VA)&, [WBUS] <-- PASSB [R1], LONG, ; write register to stack
E 382  0C64,808B,20B0,4880 B 380;11641		CASE [MPU.0-6] AT [PUSHR.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;11642
				;11643	PUSHR.0_6.2:
				;11644		;---------------------------------------; mask<2> = 1:
				;11645		VA <-- [VA] + 4,			; calculate next stack location
				;11646		MEM (VA)&, [WBUS] <-- PASSB [R2], LONG, ; write register to stack
E 384  0C64,8093,20B0,4880 B 380;11647		CASE [MPU.0-6] AT [PUSHR.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;11648
				;11649	PUSHR.0_6.3:
				;11650		;---------------------------------------; mask<3> = 1:
				;11651		VA <-- [VA] + 4,			; calculate next stack location
				;11652		MEM (VA)&, [WBUS] <-- PASSB [R3], LONG, ; write register to stack
E 386  0C64,809B,20B0,4880 B 380;11653		CASE [MPU.0-6] AT [PUSHR.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;11654
				;11655	PUSHR.0_6.4:
				;11656		;---------------------------------------; mask<4> = 1:
				;11657		VA <-- [VA] + 4,			; calculate next stack location
				;11658		MEM (VA)&, [WBUS] <-- PASSB [R4], LONG, ; write register to stack
E 388  0C64,80A3,20B0,4880 B 380;11659		CASE [MPU.0-6] AT [PUSHR.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;11660
				;11661	PUSHR.0_6.5:
				;11662		;---------------------------------------; mask<5> = 1:
				;11663		VA <-- [VA] + 4,			; calculate next stack location
				;11664		MEM (VA)&, [WBUS] <-- PASSB [R5], LONG, ; write register to stack
E 38A  0C64,80AB,20B0,4880 B 380;11665		CASE [MPU.0-6] AT [PUSHR.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;11666
				;11667	PUSHR.0_6.6:
				;11668		;---------------------------------------; mask<6> = 1:
				;11669		VA <-- [VA] + 4,			; calculate next stack location
				;11670		MEM (VA)&, [WBUS] <-- PASSB [R6], LONG, ; write register to stack
E 38C  0C64,80B3,20B0,4880 B 380;11671		CASE [MPU.0-6] AT [PUSHR.0_6.0] 	; case on mask<6:0>, reset rightmost bit
				;11672
				;11673	PUSHR.0_6.NEXT:
				;11674		;---------------------------------------; mask<6:0> = 0:
				;11675		NOP,					; done with this group
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  353
;      MISC.MIC 	     PUSHR										      /REV=
;			    p354											       MISC
E 38E  2000,0000,2000,4981 B 381;11676		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  354
;      MISC.MIC 	     PUSHR										      /REV=
;															       MISC
				;11677
				;11678	;	PUSHR, continued.
				;11679	;	Process mask bits<13:7>
				;11680
				;11681	;	At this point,
				;11682	;		W2	=	new SP - 4
				;11683
				;11684	;= ALIGNLIST 000x	(PUSHR.7_13.7,	PUSHR.7_13.8,	PUSHR.7_13.9,	PUSHR.7_13.10,
				;11685	;=			 PUSHR.7_13.11, PUSHR.7_13.12,	PUSHR.7_13.13,	PUSHR.7_13.DONE)
				;11686
				;11687	PUSHR.7_13.7:
				;11688		;---------------------------------------; mask<7> = 1:
				;11689		VA <-- [VA] + 4,			; calculate next stack location
				;11690		MEM (VA)&, [WBUS] <-- PASSB [R7], LONG, ; write register to stack
E 381  2C64,80BB,20B0,4981 B 381;11691		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;11692
				;11693	PUSHR.7_13.8:
				;11694		;---------------------------------------; mask<8> = 1:
				;11695		VA <-- [VA] + 4,			; calculate next stack location
				;11696		MEM (VA)&, [WBUS] <-- PASSB [R8], LONG, ; write register to stack
E 383  2C64,80C3,20B0,4981 B 381;11697		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;11698
				;11699	PUSHR.7_13.9:
				;11700		;---------------------------------------; mask<9> = 1:
				;11701		VA <-- [VA] + 4,			; calculate next stack location
				;11702		MEM (VA)&, [WBUS] <-- PASSB [R9], LONG, ; write register to stack
E 385  2C64,80CB,20B0,4981 B 381;11703		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;11704
				;11705	PUSHR.7_13.10:
				;11706		;---------------------------------------; mask<10> = 1:
				;11707		VA <-- [VA] + 4,			; calculate next stack location
				;11708		MEM (VA)&, [WBUS] <-- PASSB [R10], LONG,	; write register to stack
E 387  2C64,80D3,20B0,4981 B 381;11709		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;11710
				;11711	PUSHR.7_13.11:
				;11712		;---------------------------------------; mask<11> = 1:
				;11713		VA <-- [VA] + 4,			; calculate next stack location
				;11714		MEM (VA)&, [WBUS] <-- PASSB [R11], LONG,	; write register to stack
E 389  2C64,80DB,20B0,4981 B 381;11715		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;11716
				;11717	PUSHR.7_13.12:
				;11718		;---------------------------------------; mask<12> = 1:
				;11719		VA <-- [VA] + 4,			; calculate next stack location
				;11720		MEM (VA)&, [WBUS] <-- PASSB [R12], LONG,	; write register to stack
E 38B  2C64,80E3,20B0,4981 B 381;11721		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;11722
				;11723	PUSHR.7_13.13:
				;11724		;---------------------------------------; mask<13> = 1:
				;11725		VA <-- [VA] + 4,			; calculate next stack location
				;11726		MEM (VA)&, [WBUS] <-- PASSB [R13], LONG,	; write register to stack
E 38D  2C64,80EB,20B0,4981 B 381;11727		CASE [MPU.7-13] AT [PUSHR.7_13.7]	; case on mask<13:7>, reset rightmost bit
				;11728
				;11729	PUSHR.7_13.DONE:
				;11730		;---------------------------------------; mask<13:7> = 0:
				;11731		SYNCHRONIZE MBOX,			; stall until previous writes pass
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  355
;      MISC.MIC 	     PUSHR										      /REV=
;															       MISC
				;11732							; memory management checks
				;11733		[SP] <-- [W2] + 4, LONG,		; update SP
				;11734		RESTART IBOX,				; restart suspended I-box
E 38F  0C20,0000,7834,1000 L	;11735		LAST CYCLE				; decode next instruction
				;11736
				;11737	;= END MISC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  356
;     QUEUE.MIC 	     QUEUE.MIC -- Queue Instructions							      /REV=
;
				;11738	.TOC	"QUEUE.MIC -- Queue Instructions"
				;11739	.TOC	"Revision 1.1"
				;11740
				;11741	;	Bob Supnik
				;11742
;11743	.nobin
;11744	;****************************************************************************
;11745	;*									    *
;11746	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;11747	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;11748	;*  ALL RIGHTS RESERVED.						    *
;11749	;*									    *
;11750	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;11751	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;11752	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;11753	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;11754	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;11755	;*  TRANSFERRED.							    *
;11756	;*									    *
;11757	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;11758	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;11759	;*  CORPORATION.							    *
;11760	;*									    *
;11761	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;11762	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;11763	;*									    *
;11764	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  357
;     QUEUE.MIC 	     Revision History									      /REV=
;
;11765	.TOC	"	Revision History"
;11766
;11767	; Edit	  Date	 Who	     Description
;11768	; ---- --------- ---	---------------------
;11769	;    1 13-Nov-90 GMU	Symptom: Ibox enters infinite RXS stall on a REMQUE
;11770	;				 whose two specifiers are auto-xcrement and
;11771	;				 GPR, with identical register values.  The
;11772	;				 stall is due to a simultaneous reference of
;11773	;				 these two specifiers by the microcode, which
;11774	;				 causes the Ibox to see a source queue retire
;11775	;				 for the GPR before the scoreboard is incremented,
;11776	;				 which causes the scoreboard to decrement below
;11777	;				 zero.
;11778	;			Cure:	 Separate the queue references for the two
;11779	;				 specifiers such that they are in different
;11780	;				 microinstructions.
;11781	; (1)0 22-Jul-90 GMU	Initial production microcode.
;11782	;
;11783	; Begin version 1.0 here
;11784	;   11 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;11785	;   10 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;11786	;    9 24-Apr-90 GMU	Sync with write check before exiting instruction in
;11787	;			REMQUE empty case.
;11788	;    8 26-Mar-90 GMU	Sync with outstanding memory references before setting
;11789	;			or clearing state<3>
;11790	;    7 22-Mar-90 DGM	Update comments
;11791	;    6 03-Feb-90 GMU	Document simultaneous reference restrictions.
;11792	;    5 16-Jan-90 DGM	Change field queue alignment
;11793	;    4 11-Oct-89 GMU	Add missing [B-C] quad alignment check at REMQTI.SINGLE.
;11794	;    3	4-Oct-89 DGM	Fix bug in REMQxI - queue busy & R-mode didn't use DST queue entry
;11795	;    2 24-Aug-89 GMU	Fix INSQUE condition code test.
;11796	;    1 17-Aug-89 GMU	convert split dispatches to field queue.
;11797	; (0)0 17-Jul-87 RMS	Trial microcode.
;11798
				;11799	.bin
				;11800	;= BEGIN QUEUE
;11801	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  358
;     QUEUE.MIC 	     Revision History									      /REV=
;															      QUEUE
;11802
;11803	;	This module implements the queue class instructions.
;11804	;	The instructions in this class are:
;11805	;
;11806	;	Opcode	 Instruction							N Z V C 	Exceptions
;11807	;	------	 -----------							------- 	----------
;11808	;
;11809	;	5C	 INSQHI entry.ab, header.aq					0 * 0 * 	rsv
;11810	;
;11811	;	5D	 INSQTI entry.ab, header.aq					0 * 0 * 	rsv
;11812	;
;11813	;	0E	 INSQUE entry.ab, pred.ab					* * 0 *
;11814	;
;11815	;	5E	 REMQHI header.aq, addr.wl					0 * * * 	rsv
;11816	;
;11817	;	5F	 REMQTI header.aq, addr.wl					0 * * * 	rsv
;11818	;
;11819	;	0F	 REMQUE entry.ab, addr.wl					* * * *
;11820	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  359
;     QUEUE.MIC 	     Revision History									      /REV=
;															      QUEUE
;11821
;11822	;					CAUTION
;11823	;					-------
;11824	;
;11825	;	Ebox microcode for any instruction whose IROM entry contains a .ax or
;11826	;	.vx specifier followed immediately by a .rx, .mx, or .vx specifier may not
;11827	;	reference the source queue entries for this pair of specifiers in the
;11828	;	same microinstruction.	This restriction is necessary to avoid getting
;11829	;	the incorrect operand data for the second specifier of the pair if the
;11830	;	first specifier of the pair is auto-increment, auto-decrement, or auto-increment
;11831	;	deferred, and the second specifier of the pair is register mode using the
;11832	;	same register specified for the first specifier of the pair.  Because the Ibox
;11833	;	must write both the address operand to the MD, and the auto-inc/dec value
;11834	;	to the GPR, the Ebox may read the old value of the GPR if both specifiers
;11835	;	are referenced in the same microword.  In addition, a simultaneous reference
;11836	;	to these specifiers may cause an infinite Ibox RXS stall if the source
;11837	;	queue retire for the second GPR specifier arrives at the Ibox before
;11838	;	the scoreboard is incremented.
;11839	;
;11840	;	This restriction does not apply if, by context, it is known that the
;11841	;	second specifier of the pair is not register mode.
;11842	;
;11843	;	Several of the instructions processed by this module are affected by this
;11844	;	restriction.  The following table lists the restriction for each instruction using
;11845	;	the notation [spec n; spec n+1] to denote a restriction in referencing the
;11846	;	source queue entries for these two specifiers in the same microinstruction.
;11847	;
;11848	;	Entry Point   Opcode   Mnemonic 		   Restriction
;11849	;	-----------   ------   -------- 	----------------------------------
;11850	;	INSQXI..	5C	INSQHI		none
;11851	;			5D	INSQTI		none
;11852	;
;11853	;	INSQUE..	0E	INSQUE		none
;11854	;
;11855	;	REMQXI..	5E	REMQHI		[spec 1; spec 2]
;11856	;			5F	REMQTI		[spec 1; spec 2]
;11857	;
;11858	;	REMQUE..	0F	REMQUE		[spec 1; spec 2]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  360
;     QUEUE.MIC 	     INSQUE										      /REV=
;															      QUEUE
;11859	.TOC	"	INSQUE"
;11860
;11861	;	This instruction inserts a queue element into a queue.
;11862	;
;11863	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;11864	;	--------      ------	---------				----	-----		--------
;11865	;	INSQUE		0E	if {all memory accesses ok} then	2	aa/bb		INSQUE..
;11866	;					(entry) <-- (pred)
;11867	;					(entry+4) <-- pred
;11868	;					((pred)+4) <-- entry
;11869	;					(pred) <-- entry
;11870	;
;11871	;	Entry conditions:
;11872	;		source queue	=	entry.ab operand
;11873	;					pred.ab operand
;11874	;		dest queue	=	none
;11875	;		branch queue	=	none
;11876	;		field queue	=	none
;11877	;		DL		=	BYTE
;11878	;		Ibox state	=	running
;11879	;		Mbox state	=	stopped
;11880	;
;11881	;	Exit conditions:
;11882	;		The entry has been inserted in the queue.
;11883	;		The PSL condition codes are set.
;11884	;
;11885	;	Condition codes:
;11886	;		N <-- (entry) LSS (entry+4)
;11887	;		Z <-- (entry) EQL (entry+4)
;11888	;		V <-- 0 			[Integer overflow trap cannot occur.]
;11889	;		C <-- (entry) LSSU (entry+4)
;11890	;
;11891	;	Notes:
;11892	;		1.  Memory management:	The source queue is emptied before the start of E-box I/O.
;11893	;		2.  Memory management:	The last write has been previously checked.  Therefore, it guarantees
;11894	;		    that memory management errors are made visible before instruction completion.
;11895	;
;11896
				;11897	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  361
;     QUEUE.MIC 	     INSQUE										      /REV=
;															      QUEUE
				;11898
				;11899	;	INSQUE operation:
				;11900	;
				;11901	;		Read the predecessor's forward pointer. 	(pred)
				;11902	;		Check to see if all writes will succeed.
				;11903	;		Update the successor's backward pointer.	((pred)+4) <-- entry
				;11904	;		Update the predecessor's forward pointer.	(pred) <-- entry
				;11905	;		Update the entry's forward pointer.		(entry) <-- (pred)
				;11906	;		Compare the predecessor's forward pointer	(pred) : pred
				;11907	;		and the predecessor address.
				;11908	;		Update the entry's backward pointer.		(entry+4) <-- pred
				;11909
				;11910	INSQUE..:
				;11911		;********** Hardware dispatch **********;
				;11912		VA <-- B [S2],				; [1] VA <-- pred
				;11913		[W0] <-- MEM.WCHK (VA), LONG,		; read and write check pred
				;11914		Q <-- PASSA [S1],			; get entry
E 190  00C6,4049,0480,04A9 J 4A9;11915			sim addr [ea.2]
				;11916
				;11917		;---------------------------------------;
				;11918		WCHK (VA)&, VA&, [W1] <-- B [Q], LONG,	; [2] write check entry, save address
				;11919		Q <-- PASSA [VA],			; transfer pred address
E 4A9  00E2,4051,08B0,04AA J 4AA;11920			sim addr [ea.1]
				;11921
				;11922		;---------------------------------------;
				;11923		WCHK (VA)&, VA <-- [VA] + 4, LONG,	; [3] write check entry, second longword
E 4AA  0C60,8053,0CB0,04AB J 4AB;11924		[W2] <-- PASSB [Q]			; save pred address
				;11925
				;11926		;---------------------------------------;
				;11927		VA <-- [W0] + 4,			; [4] VA <-- (pred)+4
				;11928		MEM (VA)&, [WBUS] <-- PASSB [W1], LONG, ; ((pred)+4) <-- entry
E 4AB  0C64,8013,2010,04B0 J 4B0;11929			sim addr [queue.1]
				;11930
				;11931		;---------------------------------------;
				;11932		VA <-- [W2],				; [5] VA <-- pred, previously checked
				;11933		MEM (VA)&, [WBUS] <-- PASSB [W1], LONG, ; (pred) <-- entry, cannot fail
E 4B0  0064,8013,2030,04B1 J 4B1;11934			sim addr [ea.2]
				;11935
				;11936		;---------------------------------------;
				;11937		VA <-- [W1],				; [6] VA <-- entry, previously checked
				;11938		MEM (VA)&, [WBUS] <-- PASSB [W0], LONG, ; (entry) <-- (pred), cannot fail
E 4B1  0064,800B,2020,04B2 J 4B2;11939			sim addr [ea.1]
				;11940
				;11941		;---------------------------------------;
				;11942		VA <-- [VA] + 4,			; [7] VA <-- entry+4, previously checked
				;11943		MEM (VA)&, [WBUS] <-- PASSB [W2], LONG, ; (entry+4) <-- pred, cannot fail
E 4B2  0C64,801B,20B4,84B3 J 4B3;11944		RESTART MBOX				; resume operand processing
				;11945
				;11946		;---------------------------------------;
				;11947		[WBUS] <-- [W0] - [W2], LONG,		; [8] compare (entry):(entry+4)
				;11948		SET PSL CC.JIZJ,			; set psl cc's, psl map is jizj
E 4B3  0A80,0018,201C,9000 L	;11949		LAST CYCLE				; decode next instruction
				;11950
;11951	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  362
;     QUEUE.MIC 	     REMQUE										      /REV=
;															      QUEUE
;11952	.TOC	"	REMQUE"
;11953
;11954	;	This instruction removes a queue element from a queue.
;11955	;
;11956	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;11957	;	--------      ------	---------				----	-----		--------
;11958	;	REMQUE		0F	if {all memory accesses ok} then	2	am/bl		REMQUE..
;11959	;					((entry+4)) <-- (entry)
;11960	;					((entry)+4) <-- (entry+4)
;11961	;					(addr) <-- entry
;11962	;
;11963	;	Entry conditions:
;11964	;		source queue	=	entry.ab operand
;11965	;					addr.ml operand
;11966	;		dest queue	=	addr.ml result
;11967	;		branch queue	=	none
;11968	;		field queue	=	none
;11969	;		DL		=	LONG
;11970	;		Ibox state	=	running
;11971	;		Mbox state	=	stopped
;11972	;
;11973	;	Exit conditions:
;11974	;		The entry has been removed from the queue.
;11975	;		The PSL condition codes are set.
;11976	;
;11977	;	Condition codes:
;11978	;		N <-- (entry) LSS (entry+4)
;11979	;		Z <-- (entry) EQL (entry+4)
;11980	;		V <-- entry EQL (entry+4)	[Integer overflow trap disabled.]
;11981	;		C <-- (entry) LSSU (entry+4)
;11982	;
;11983	;	Notes:
;11984	;		1.  Memory management:	The destination operand is type modify to guarantee write accessibility.
;11985	;		1.  Memory management:	The source queue is emptied before the start of E-box I/O.
;11986	;		2.  Memory management:	The last E-box write has been previously checked.  Therefore, it guarantees
;11987	;		    that memory management errors are made visible before instruction completion.
;11988	;
				;11989	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  363
;     QUEUE.MIC 	     REMQUE										      /REV=
;															      QUEUE
				;11990
				;11991	;	REMQUE operation:
				;11992	;
				;11993	;		Read the entry's backward pointer.		(entry+4)
				;11994	;		Read the entry's forward pointer.		(entry)
				;11995	;		Compare the entry's forward and backward	(entry) : (entry+4)
				;11996	;		pointers.
				;11997	;		Set psl.v if the queue is empty.		entry : (entry+4)
				;11998	;		Check to see if all writes will succeed.
				;11999	;		Update the successor's backward pointer.	((entry)+4) <-- (entry+4)
				;12000	;		Update the predecessor's forward pointer.	((entry+4)) <-- (entry)
				;12001	;		Update the destination. 			(dst) <-- entry
				;12002
				;12003	;	The following simultaneous reference restriction exists for
				;12004	;	this entry point: [spec 1; spec 2].
				;12005
				;12006	REMQUE..:
				;12007		;********** Hardware dispatch **********;
				;12008		VA <-- [S1] + 4,			; [1] VA <-- entry+4
				;12009		[W1] <-- MEM (VA), LONG,		; read predecessor
				;12010		Q <-- PASSA [S1],			; save entry address
				;12011							; >> no [spec 1; spec 2] reference
E 192  0C42,4001,0880,04B4 J 4B4;12012			sim addr [ea.1] + k
				;12013
				;12014		;---------------------------------------;
				;12015		VA <-- [VA] - 4,			; [2] VA <-- entry
				;12016		[W0] <-- MEM (VA), LONG,		; read successor
E 4B4  0CC0,0041,04B0,04B5 J 4B5;12017		ACCESS B [S1]				; access destination, check faults
				;12018
				;12019		;---------------------------------------;
				;12020		[WBUS] <-- [Q] XOR [W1], LONG,		; [3] compare entry : (entry+4)
E 4B5  0600,0010,20A0,04B6 J 4B6;12021			sim cond [s4.queue.empty]
				;12022
				;12023		;---------------------------------------;
				;12024		[WBUS] <-- [W0] - [W1], LONG,		; [4] compare (entry) : (entry+4)
E 4B6  0A80,0010,201C,8345 J 345;12025		SET PSL CC.JIZJ 			; set psl cc's, psl map is jizj
				;12026
				;12027		;---------------------------------------;
				;12028		WCHK (VA)&, VA <-- [W1], LONG,		; [5] write check (entry+4)
				;12029		[W2] <-- PASSB [Q],			; save entry address
			    p364;12030		CASE [ALU.NZV] AT [REMQUE.WRITE],	; case on queue empty
E 345  2060,8053,0C20,4179 B 379;12031			sim addr [queue.1]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  364
;     QUEUE.MIC 	     REMQUE										      /REV=
;															      QUEUE
				;12032
				;12033	;	REMQUE, continued.
				;12034	;	Destination is register.
				;12035	;	Write checks complete, write ((entry)+4), ((entry+4)), and destination.
				;12036
				;12037	;	At this point,
				;12038	;		W0	=	(entry)
				;12039	;		W1	=	(entry+4)
				;12040	;		W2	=	entry
				;12041
				;12042	;= ALIGNLIST 10xx	(REMQUE.WRITE,		REMQUE.EMPTY)
				;12043	;  ALU.NZVC set by XOR --> V = C = 0
				;12044
				;12045	REMQUE.EMPTY:
				;12046		;---------------------------------------; alu.z = 1:
				;12047		SET PSL(V),				; [6] set psl.v
				;12048		SYNCHRONIZE MBOX,			; sync with outstanding write check
E 37D  00A0,2008,200E,84B9 J 4B9;12049		GOTO [REMQUE.DEST]			; go write to destination
				;12050
				;12051	REMQUE.WRITE:
				;12052		;---------------------------------------; alu.z = 0:
				;12053		VA <-- [W0] + 4,			; [6] VA <-- (entry)+4
				;12054		MEM (VA)&, [WBUS] <-- PASSB [W1], LONG, ; ((entry)+4) <-- (entry+4)
E 379  0C64,8013,2010,04B7 J 4B7;12055			sim addr [queue.2]
				;12056
				;12057		;---------------------------------------;
				;12058		VA <-- [W1],				; [7] VA <-- (entry+4), previously checked
				;12059		MEM (VA)&, [WBUS] <-- PASSB [W0], LONG, ; ((entry+4)) <-- (entry), cannot fail
E 4B7  0064,800B,2020,04B9 J 4B9;12060			sim addr [queue.1]
				;12061
				;12062	REMQUE.DEST:
				;12063		;---------------------------------------;
				;12064		[DST] <-- [W2], LONG,			; [7,8] write entry addr to destination
				;12065		RESTART MBOX,				; resume operand processing
E 4B9  0000,0000,2434,9000 L	;12066		LAST CYCLE				; decode next instruction
				;12067
;12068	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  365
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
;12069	.TOC	"	INSQxI"
;12070
;12071	;	These instructions insert an entry at the head or tail of an interlocked,
;12072	;	self-relative queue.
;12073	;
;12074	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;12075	;	--------      ------	---------				----	-----		--------
;12076	;	INSQHI		5C	see next page				2	aa/bq		INSQXI..
;12077	;	INSQTI		5D	see next page				2	aa/bq		INSQXI..
;12078	;
;12079	;	Entry conditions:
;12080	;		source queue	=	entry.ab operand
;12081	;					header.aq operand
;12082	;		dest queue	=	none
;12083	;		branch queue	=	none
;12084	;		field queue	=	none
;12085	;		DL		=	QUAD
;12086	;		Ibox state	=	running
;12087	;		Mbox state	=	stopped
;12088	;
;12089	;	Exit conditions:
;12090	;		The entry has been inserted in the queue.
;12091	;		The PSL condition codes are set.
;12092	;
;12093	;	Condition codes:
;12094	;		N <-- 0
;12095	;		Z <-- if insertion succeeded then (entry) EQL (entry+4) else 0
;12096	;		V <-- 0 		[Integer overflow trap cannot occur.]
;12097	;		C <-- if insertion succeeded then 0 else 1
;12098	;
;12099	;	Notes:
;12100	;		1.  Memory management:	The source queue is emptied before the start of E-box I/O.
;12101	;		2.  Memory management:	The only unchecked write is followed by a previously checked
;12102	;		    write, which guarantees that memory management errors are made visible before
;12103	;		    instruction completion.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  366
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
;12104
;12105	;	INSQxI operation:
;12106	;
;12107	;		tmp1 <-- (header) interlocked
;12108	;		if tmp1<0> = 1 then
;12109	;			(header) <-- tmp1 release interlock
;12110	;			psl cc <-- 0001 and EXIT
;12111	;		else if {any memory access cannot complete} then
;12112	;			{initiate memory management exception}
;12113	;			{release secondary interlock}
;12114	;		else	{insert entry at head/tail of queue}
;12115	;			{release secondary interlock}
;12116	;
;12117	;	The actual insertion process is best understood pictorially:
;12118	;
;12119	;	BEFORE				AFTER INSQHI			AFTER INSQTI
;12120	;
;12121	;	H:	A-H			H:	D-H	W		H:	A-H	W to release interlock
;12122	;	H+4:	C-H			H+4:	C-H			H+4:	D-H	W
;12123	;
;12124	;	A:	B-A			A:	B-A			A:	B-A
;12125	;	A+4:	H-A			A+4:	D-A	W		A+4:	H-A
;12126	;
;12127	;	B:	C-B			B:	C-B			B:	C-B
;12128	;	B+4:	A-B			B+4:	A-B			B+4:	A-B
;12129	;
;12130	;	C:	H-C			C:	H-C			C:	D-C	W
;12131	;	C+4:	B-C			C+4:	B-C			C+4:	B-C
;12132	;
;12133	;	D:	---			D:	A-D	W		D:	H-D	W
;12134	;	D+4:	---			D+4:	H-D	W		D+4:	C-D	W
;12135	;
;12136	;	Note that the queue header, the entry to be inserted, and all the intermediate entries
;12137	;	that are "touched" in any way must be QUADWORD aligned.  In addition, the header and
;12138	;	the entry must not be equal.
;12139	;
;12140	;	For INSQHI, H, A+4, D, and D+4 must be WRITEABLE.
;12141	;	For INSQTI, H+4, C, D, and D+4 must be WRITEABLE.
;12142	;
				;12143	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  367
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12144
				;12145	;	INSQxI.
				;12146	;	Read header, interlocked, check alignment of header, entry.
				;12147	;	Because interlocked read bypasses the Pcache, many cycles
				;12148	;	can be filled before the data will be available.
				;12149
				;12150	INSQXI..:
				;12151		;********** Hardware dispatch **********;
				;12152		WCHK (VA)&, VA&, [W1] <-- B [S1], LONG, ; [1] write check, save entry address
				;12153							; test entry address for quad aligned
				;12154		Q <-- PASSA [S2],			; save header address
			    p368;12155			sim cond k s3.[2],
E 194  00E2,4041,0890,0525 J 525;12156			sim addr [ea.1]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  368
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12157
				;12158	;	Interlocked queue, continued.
				;12159	;	Common code for all interlocked queue instructions to do basic checks
				;12160	;	and obtain software lock.
				;12161	;
				;12162	;	At this point,
				;12163	;		W1	=	entry address (INSQxi) write-checked
				;12164	;			=	destination address (REMQxI), write checked if memory
				;12165	;		Q	=	header address
				;12166
				;12167	IQ.ACQUIRE.LOCK:
				;12168		;---------------------------------------;
				;12169		VA <-- [Q] ANDNOT 000000[07],		; [2] force header quad aligned
				;12170		[W2] <-- MEM.LOCK (VA), LONG,		; read header fore ptr [A-H]
				;12171							; acquire hardware interlock
				;12172							; >> sync with previous WCHK
			    p371;12173		CASE [A31.BQA.BNZ1] AT [IQ.D.NOT.QA],	; case on entry address quad aligned
E 525  E4CC,2039,0CA0,47CA B 5CA;12174			sim addr [queue.hdr]
				;12175
				;12176	;= ALIGNLIST 101x	(IQ.D.NOT.QA,	IQ.D.QA)
				;12177
				;12178	IQ.D.QA:
				;12179		;---------------------------------------; b<2:0> = 000:
				;12180		[W4] <-- (-[W1] + [Q]), LONG,		; [3] W4 = H-D, test for header = entry
				;12181							; test header for quad aligned
E 5CE  0A00,0050,1420,0111 J 111;12182			sim cond [s34.queue]
				;12183
				;12184		;---------------------------------------;
			    p371;12185		[W0] <-- [Q], LONG,			; [4] save header address
E 111  E000,0000,04A0,477A B 17A;12186		CASE [A31.BQA.BNZ1] AT [IQ.H.NOT.QA]	; case on header address quad aligned
				;12187
				;12188	;= ALIGNLIST 101x	(IQ.H.NOT.QA,	IQ.H.QA)
				;12189
				;12190	IQ.H.QA:
				;12191		;---------------------------------------; b<2:0> = 000:
				;12192		[W3] <-- [W0] + [W2], LONG,		; [5] W3 = H + (A-H) = A, test A-H<2:0>
				;12193							; >> sync with read lock from [2]
				;12194		CASE [ALU.NZV] AT [IQ.NOT.EQUAL],	; case on header = entry
E 17E  2880,0018,1010,417B B 17B;12195			sim cond k s3.[0]
				;12196
				;12197	;= ALIGNLIST 101x	(IQ.NOT.EQUAL,	IQ.EQUAL)
				;12198
				;12199	IQ.NOT.EQUAL:
				;12200		;---------------------------------------; alu.z = 0:
				;12201		[WBUS] <-- [W2], LONG,			; [6] test [A-H] for zero (empty queue)
				;12202		STATE.3 <-- 1,				; set software interlock flag
				;12203							; >> state<3> change, no SQ reference last cycle
				;12204							; >> state<3> change, sync with possible MME fault
				;12205							; >> done in [5]
			    p369;12206		CASE [B.2-0] AT [IQ.SET.000],		; case on header<2:0>
E 17B  7001,8000,2030,4331 B 131;12207			sim cond [s4.queue.empty]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  369
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12208
				;12209	;	IQ instructions, continued.
				;12210	;	Empty queue, entry alignment, and header alignment checked.
				;12211	;	Ready to set software interlock.
				;12212
				;12213	;	At this point,
				;12214	;		W0 = VA =	address of header [H]
				;12215	;		W1	=	INSQxI: address of entry [D]
				;12216	;				REMQxi: address of destination, if memory
				;12217	;		W2	=	header forward pointer [A-H]
				;12218	;		W3	=	address of queue head [A]
				;12219	;		W4	=	H-D
				;12220	;		STATE<3> =	1 (software interlock flag)
				;12221
				;12222	;= ALIGNLIST 000x	(IQ.SET.000,	IQ.SET.001,	IQ.SET.010,	IQ.SET.011,
				;12223	;=			 IQ.SET.100,	IQ.SET.101,	IQ.SET.110,	IQ.SET.111)
				;12224
				;12225	IQ.SET.000:
				;12226		;---------------------------------------; b<2:0> = 000:
				;12227		MEM.UNLOCK (VA)&, [WBUS] <-- [W2] OR 000000[01], ; [7] set swre interlock, release hwre lock
			    p374;12228		LONG,					; ; previously checked, cannot fault
E 131  856C,2008,2030,4C49 B 149;12229		CASE [OPCODE.2-0] AT [INSQHI.CONT]	; branch into different instruction flows
				;12230
				;12231	IQ.SET.001:
				;12232		;---------------------------------------; b<2:0> = 001:
				;12233		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; [7] release hardware interlock
				;12234		LONG,					; ; previously checked, cannot fault
E 133  806C,0000,2030,4C9A B 19A;12235		CASE [OPCODE.2-0] AT [INSQI.BUSY]	; case on INSQxI vs REMQxI
				;12236
				;12237	;= ALIGNLIST 101x	(INSQI.BUSY,	REMQI.BUSY)
				;12238
				;12239	INSQI.BUSY:
				;12240		;---------------------------------------; opcode<1> = 0:
				;12241		[WBUS] <-- 000000[02] - [K1], LONG,	; [8] iiii on 2 - 1 = 0001
			    p370;12242		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 19A  0A00,2010,232D,0107 J 107;12243		GOTO [REMQI.BUSY.M]			; go clear state bits
				;12244
				;12245	REMQI.BUSY:
				;12246		;---------------------------------------; opcode<1> = 1:
				;12247		[WBUS] <-- [80]000000 - [K1], LONG,	; [8] iiii on 80000000 - 1 = 0011
				;12248		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 19E  4A00,3C00,232D,4A05 B 105;12249		CASE [STATE.2-0] AT [REMQI.BUSY.R]	; case on register vs memory destination
				;12250
				;12251	;= ALIGNLIST xx0x	(REMQI.BUSY.R,		REMQI.BUSY.M)
				;12252	;  STATE<2:1> = 00 --> STATE<2:0> = 00?
				;12253
				;12254	REMQI.BUSY.R:
				;12255		;---------------------------------------; state<0> = 0:
				;12256		[DST] <-- [S1], LONG,			; [9] remove sq and dq entries,
				;12257							; don't change register value
				;12258		STATE.3-0 <-- 0,			; clear state flags
				;12259							; >> state<3> change, sync with possible MME fault
			    p370;12260							; >> done in [5]
E 105  0000,0000,2488,04BB J 4BB;12261		GOTO [RESTART.MBOX]			; go restart suspended M-box
				;12262
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  370
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12263	REMQI.BUSY.M:
				;12264		;---------------------------------------; state<0> = 1:
				;12265		STATE.3-0 <-- 0,			; [9] clear state flags
				;12266							; >> state<3> change, sync with possible MME fault
				;12267							; >> done in [5]
E 107  0000,0000,2008,04BB J 4BB;12268		GOTO [RESTART.MBOX]			; go restart suspended M-box
				;12269
				;12270	RESTART.MBOX:
				;12271		;---------------------------------------;
				;12272		RESTART MBOX,				; restart operand processing
E 4BB  0000,0000,2004,9000 L	;12273		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  371
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12274
				;12275	;	IQ instructions, continued.
				;12276	;	Reserved operand exception.
				;12277	;	Release hardware interlock and fault.
				;12278
				;12279	;	At this point,
				;12280	;		W2	=	header forward pointer [A-H]
				;12281	;		VA	=	address of header [H]
				;12282	;		STATE<3> =	0
				;12283
				;12284	IQ.D.NOT.QA:
				;12285		;---------------------------------------; b<2:0> <> 000:
				;12286		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; release hardware interlock
				;12287		LONG,					; previously checked, cannot fault
				;12288		STATE.3-0 <-- 0,			; clear software interlock flag
			    p376;12289							; >> state<3> not set now, so no sync required
E 5CA  006C,0000,2038,05CB J 5CB;12290		GOTO [RESERVED.OPERAND.FAULT]		; entry (header) not quad aligned, fault
				;12291
				;12292	IQ.H.NOT.QA:
				;12293		;---------------------------------------; b<2:0> <> 000:
				;12294		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; release hardware interlock
				;12295		LONG,					; previously checked, cannot fault
				;12296		STATE.3-0 <-- 0,			; clear software interlock flag
			    p376;12297							; >> state<3> not set now, so no sync required
E 17A  006C,0000,2038,05CB J 5CB;12298		GOTO [RESERVED.OPERAND.FAULT]		; header not quad aligned, fault
				;12299
				;12300	IQ.EQUAL:
				;12301		;---------------------------------------; alu.z = 0:
				;12302		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; release hardware interlock
				;12303		LONG,					; previously checked, cannot fault
				;12304		STATE.3-0 <-- 0,			; clear software interlock flag
			    p376;12305							; >> state<3> not set now, so no sync required
E 17F  006C,0000,2038,05CB J 5CB;12306		GOTO [RESERVED.OPERAND.FAULT]		; header = entry (dst), fault
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  372
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12307
				;12308	;	IQ instructions, continued.
				;12309	;	Header misformed.
				;12310	;	Release hardware interlock and fault.
				;12311
				;12312	;	At this point,
				;12313	;		W2	=	header forward pointer [A-H]
				;12314	;		VA	=	address of header [H]
				;12315	;		STATE<3> =	1
				;12316
				;12317	IQ.SET.010:
				;12318		;---------------------------------------; b<2:0> = 010:
				;12319		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; [7] release hardware interlock
				;12320		LONG,					; previously checked, cannot fault
				;12321		STATE.3-0 <-- 0,			; clear software interlock flag
				;12322							; >> state<3> change, sync with possible MME fault
			    p376;12323							; >> done in [5]
E 135  006C,0000,2038,05CB J 5CB;12324		GOTO [RESERVED.OPERAND.FAULT]		; exit thru exception code
				;12325
				;12326	IQ.SET.011:
				;12327		;---------------------------------------; b<2:0> = 011:
				;12328		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; [7] release hardware interlock
				;12329		LONG,					; previously checked, cannot fault
				;12330		STATE.3-0 <-- 0,			; clear software interlock flag
				;12331							; >> state<3> change, sync with possible MME fault
			    p376;12332							; >> done in [5]
E 137  006C,0000,2038,05CB J 5CB;12333		GOTO [RESERVED.OPERAND.FAULT]		; exit thru exception code
				;12334
				;12335	IQ.SET.100:
				;12336		;---------------------------------------; b<2:0> = 100:
				;12337		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; [7] release hardware interlock
				;12338		LONG,					; previously checked, cannot fault
				;12339		STATE.3-0 <-- 0,			; clear software interlock flag
				;12340							; >> state<3> change, sync with possible MME fault
			    p376;12341							; >> done in [5]
E 139  006C,0000,2038,05CB J 5CB;12342		GOTO [RESERVED.OPERAND.FAULT]		; exit thru exception code
				;12343
				;12344	IQ.SET.101:
				;12345		;---------------------------------------; b<2:0> = 101:
				;12346		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; [7] release hardware interlock
				;12347		LONG,					; previously checked, cannot fault
				;12348		STATE.3-0 <-- 0,			; clear software interlock flag
				;12349							; >> state<3> change, sync with possible MME fault
			    p376;12350							; >> done in [5]
E 13B  006C,0000,2038,05CB J 5CB;12351		GOTO [RESERVED.OPERAND.FAULT]		; exit thru exception code
				;12352
				;12353	IQ.SET.110:
				;12354		;---------------------------------------; b<2:0> = 110:
				;12355		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; [7] release hardware interlock
				;12356		LONG,					; previously checked, cannot fault
				;12357		STATE.3-0 <-- 0,			; clear software interlock flag
				;12358							; >> state<3> change, sync with possible MME fault
			    p376;12359							; >> done in [5]
E 13D  006C,0000,2038,05CB J 5CB;12360		GOTO [RESERVED.OPERAND.FAULT]		; exit thru exception code
				;12361
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  373
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12362	IQ.SET.111:
				;12363		;---------------------------------------; b<2:0> = 111:
				;12364		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; [7] release hardware interlock
				;12365		LONG,					; previously checked, cannot fault
				;12366		STATE.3-0 <-- 0,			; clear software interlock flag
				;12367							; >> state<3> change, sync with possible MME fault
			    p376;12368							; >> done in [5]
E 13F  006C,0000,2038,05CB J 5CB;12369		GOTO [RESERVED.OPERAND.FAULT]		; exit thru exception code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  374
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12370
				;12371	;	INSQHI, continued.
				;12372	;	Secondary interlock acquired, header and entry quad aligned.
				;12373	;	Establish access to queue head's back pointer.
				;12374	;	Update pointers (A+4), (D), and (D+4).
				;12375	;
				;12376	;	Note: This flow depends on INTEXC microcode to release the software
				;12377	;	      interlock if a memory management fault occurs.
				;12378	;
				;12379	;	At this point,
				;12380	;		W0	=	address of header [H]
				;12381	;		W1	=	address of entry [D]
				;12382	;		W2	=	header forward pointer [A-H]
				;12383	;		W3	=	address of queue head [A]
				;12384	;		W4	=	H-D
				;12385	;		STATE<3> =	1 (software interlock flag)
				;12386	;
				;12387	;	Checks completed:
				;12388	;		D verified writable and quadword aligned => D+4 is writable
				;12389	;		H verified writable and quadword aligned => H+4 is writable
				;12390	;		A quadword aligned
				;12391
				;12392	;= ALIGNLIST 100x	(INSQHI.CONT,	INSQTI.CONT,
				;12393	;=			 REMQHI.CONT,	REMQTI.CONT)
				;12394
				;12395	INSQHI.CONT:
				;12396		;---------------------------------------; opcode<1:0> = 00:
				;12397		VA <-- [W3] + 4, LONG,			; [8] VA <-- A+4
E 149  0C00,0001,2040,04C1 J 4C1;12398			sim addr [queue.1]
				;12399
				;12400	INSQTI.EMPTY.CONT:
				;12401		;---------------------------------------;
				;12402		MEM (VA)&, [WBUS] <-- [W1] - [W3],	; [9] (A+4) <-- [D-A], only unchecked write
E 4C1  0AE4,0020,2020,04C2 J 4C2;12403		LONG					;
				;12404
				;12405		;---------------------------------------;
				;12406		VA <-- [W1],				; [10] VA <-- D, previously checked
				;12407		[WBUS] <-- PASSB [W2], LONG,		; test for previously empty queue
				;12408		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 4C2  0000,801B,202D,04C3 J 4C3;12409			sim addr [ea.1]
				;12410
				;12411		;---------------------------------------;
				;12412		MEM (VA)&, [WBUS] <-- [W3] - [W1],	; [11] (D) <-- [A-D], cannot fail
				;12413							; >> sync with possible MME fault from [9]
E 4C3  0AE4,0010,2040,04C4 J 4C4;12414		LONG					;
				;12415
				;12416		;---------------------------------------;
				;12417		VA <-- [VA] + 4,			; [12] VA <-- D+4, previously checked
E 4C4  0C64,802B,20B0,04C5 J 4C5;12418		MEM (VA)&, [WBUS] <-- PASSB [W4], LONG	; (D+4) <-- [H-D], cannot fail
				;12419
				;12420		;---------------------------------------;
			    p378;12421		[W2] <-- [W1] - [W0], LONG,		; [13] new header = [D-H]
E 4C5  0A80,0008,0C20,04CD J 4CD;12422		GOTO [IQ.EXIT]				; go rewrite hdr and release lock
				;12423							; >> no sync with possible MME fault this cycle
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  375
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12424
				;12425	;	INSQTI, continued.
				;12426	;	Secondary interlock acquired, header and entry quad aligned.
				;12427	;	Check for queue empty.
				;12428	;	Establish quad alignment of tail.
				;12429	;	Establish access to queue tail's forward pointer.
				;12430	;
				;12431	;	Note: This flow depends on INTEXC microcode to release the software
				;12432	;	      interlock if a memory management or reserved operand fault occurs.
				;12433
				;12434	;	At this point,
				;12435	;		W0	=	address of header [H]
				;12436	;		W1	=	address of entry [D]
				;12437	;		W2	=	header forward pointer [A-H]
				;12438	;		W3	=	address of queue head [A]
				;12439	;		W4	=	H-D
				;12440	;		STATE<3> =	1 (software interlock flag)
				;12441	;
				;12442	;	Checks completed:
				;12443	;		D verified writable and quadword aligned => D+4 is writable
				;12444	;		H verified writable and quadword aligned => H+4 is writable
				;12445	;		A quadword aligned
				;12446
				;12447	INSQTI.CONT:
				;12448		;---------------------------------------; opcode<1:0> = 01:
				;12449		VA <-- [W0] + 4,			; [8] VA <-- H+4, previously checked
				;12450		[W5] <-- MEM (VA), LONG,		; read header back pointer [C-H], cannot fail
				;12451		CASE [ALU.NZV] AT [INSQTI.NOT.EMPTY],	; case on queue empty
E 14B  2C40,0001,1810,4169 B 169;12452			sim addr [ea.2] + k
				;12453
				;12454	;= ALIGNLIST 10xx	(INSQTI.NOT.EMPTY,	INSQTI.EMPTY)
				;12455	;  ALU.NZV set by MOVE --> V = C = 0
				;12456
				;12457	INSQTI.EMPTY:
				;12458		;---------------------------------------; alu.z = 1:
				;12459		VA <-- [W3] + 4, LONG,			; [9] VA <-- A+4 = H+4
			    p374;12460		GOTO [INSQTI.EMPTY.CONT],		; more efficient to treat this as INSQHI
E 16D  0C00,0001,2040,04C1 J 4C1;12461			sim addr [queue.1]
				;12462
				;12463	INSQTI.NOT.EMPTY:
				;12464		;---------------------------------------; alu.z = 0:
E 169  0A80,0008,1020,04C9 J 4C9;12465		[W3] <-- [W1] - [W0], LONG		; [9] precalculate D-H, for later
				;12466
				;12467		;---------------------------------------;
				;12468		VA <-- [W0] + [W5],			; [10] get address of tail C = H + [C-H]
				;12469							; test if C-H quad aligned
				;12470		[WBUS] <-- PASSB [W5], LONG,		; test for previously empty queue
				;12471		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
				;12472			sim cond k s3.[2],
E 4C9  0880,8033,201D,0526 J 526;12473			sim addr [queue.1]
				;12474
				;12475		;---------------------------------------;
			    p376;12476		[W5] <-- [VA] - [W1], LONG,		; [11] calculate C-D
E 526  EA80,0010,18B0,47CB B 5CB;12477		CASE [A31.BQA.BNZ1] AT [INSQTI.C.NOT.QA] ; case on [C-H] quad aligned
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  376
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12478
				;12479	;	INSQTI, continued.
				;12480	;	Tail quad alignment and writability verified.
				;12481	;	Update pointers (C), (H+4), (D), and (D+4).
				;12482
				;12483	;	At this point,
				;12484	;		W0	=	address of header [H]
				;12485	;		W1	=	address of entry [D]
				;12486	;		W2	=	header forward pointer [A-H]
				;12487	;		W3	=	D-H
				;12488	;		W4	=	H-D
				;12489	;		W5	=	C-D
				;12490	;		VA	=	address of queue tail [C]
				;12491	;		STATE<3> =	1 (software interlock flag)
				;12492	;		psl cc's =	?<empty queue>00
				;12493	;
				;12494	;	Checks completed:
				;12495	;		D verified writable and quadword aligned => D+4 is writable
				;12496	;		H verified writable and quadword aligned => H+4 is writable
				;12497	;		A quadword aligned
				;12498	;		C quadword aligned
				;12499
				;12500	;= ALIGNLIST 101x	(INSQTI.C.NOT.QA,	INSQTI.C.QA)
				;12501
				;12502	RESERVED.OPERAND.FAULT:
				;12503	INSQTI.C.NOT.QA:
			    p127;12504		;---------------------------------------; b<2:0> <> 000:
E 5CB  0000,0000,2000,003C J 03C;12505		RESERVED OPERAND FAULT			; [12] go to exception processing code
				;12506							; fault handler will unlock header and
				;12507							; clear state<3>
				;12508
				;12509	INSQTI.C.QA:
				;12510		;---------------------------------------; b<2:0> = 000:
				;12511		MEM (VA)&, [WBUS] <-- (-[VA] + [W1]),	; [12] (C) <-- [D-C], only unchecked write
E 5CF  0A64,0010,20B0,04CA J 4CA;12512		LONG					;
				;12513
				;12514		;---------------------------------------;
				;12515		VA <-- [W0] + 4,			; [13] VA <-- H+4, previously checked
				;12516		MEM (VA)&, [WBUS] <-- PASSB [W3], LONG, ; (H+4) <-- [D-H], cannot fail
				;12517							; >> sync with possible MME fault from [12]
E 4CA  0C64,8023,2010,04CB J 4CB;12518			sim addr [ea.2] + k
				;12519
				;12520		;---------------------------------------;
				;12521		VA <-- [W1],				; [14] VA <-- D, previously checked
				;12522		MEM (VA)&, [WBUS] <-- PASSB [W4], LONG, ; (D) <-- [H-D], cannot fail
E 4CB  0064,802B,2020,04CC J 4CC;12523			sim addr [ea.1]
				;12524
				;12525		;---------------------------------------;
				;12526		VA <-- [VA] + 4,			; [15] VA <-- D+4, previously checked
			    p378;12527		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG, ; (D+4) <-- [C-D], cannot fail
E 4CC  0C64,8033,20B0,04CD J 4CD;12528		GOTO [IQ.EXIT]				; go rewrite header and exit
				;12529							; >> no sync with possible MME fault this cycle
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  377
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12530
				;12531	;	IQ instructions, continued.
				;12532	;	Common exit for remove queue interlocked instructions.
				;12533	;	Write destination, update header and release software interlock.
				;12534	;
				;12535	;	At this point,
				;12536	;		W0	=	address of header [H]
				;12537	;		W1	=	address of destination, if REMQxI memory
				;12538	;		W2	=	new header
				;12539	;		W3	=	address of entry removed (REMQxI only)
				;12540	;		STATE<3> =	1
				;12541
				;12542	;= ALIGNLIST xx0x	(REMQXI.WRITE.R,	REMQXI.WRITE.M)
				;12543	;  STATE<2:1> = 00 --> STATE<2:0> = 00?
				;12544
				;12545	;	Note: Synchronization with possible MME fault may have occurred
				;12546	;	in the previous cycle.	STATE<3> may not be cleared in REMQXI.WRITE.R
				;12547	;	or REMQXI.WRITE.M.
				;12548
				;12549	REMQXI.WRITE.R:
				;12550		;---------------------------------------; state<0> = 0:
				;12551		[DST] <-- [W3], LONG,			; write entry address to destination
			    p378;12552		ACCESS B [S1],				; throw away destination sq entry
E 109  0000,0040,2440,04CD J 4CD;12553		GOTO [IQ.EXIT]				; join common exit flows
				;12554							; >> no change to state<3> this cycle
				;12555							; >> no sync with possible MME fault this cycle
				;12556
				;12557	REMQXI.WRITE.M:
				;12558		;---------------------------------------; state<0> = 1:
				;12559		VA <-- [W1],				; VA <-- destination, previously checked
				;12560		MEM (VA)&, [WBUS] <-- PASSB [W3], LONG, ; write entry address to destination
				;12561		GOTO [IQ.EXIT], 			; join common exit flows
				;12562							; >> no change to state<3> this cycle
			    p378;12563							; >> no sync with possible MME fault this cycle
E 10B  0064,8023,2020,04CD J 4CD;12564			sim addr [ea.2]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  378
;     QUEUE.MIC 	     INSQxI										      /REV=
;															      QUEUE
				;12565
				;12566	;	IQ instructions, continued.
				;12567	;	Common exit for interlocked queue instructions.
				;12568	;	Update header and release software interlock.
				;12569	;
				;12570	;	At this point,
				;12571	;		W0	=	address of header [H]
				;12572	;		W2	=	new header
				;12573	;		STATE<3> =	1
				;12574	;
				;12575	;	For INSQxI, the PSL CC's were set by testing the OLD header fore or back pointer
				;12576	;	so that psl.z = queue was empty, psl.vc = 00, psl.n = ?.
				;12577	;	For REMQxI, the PSL CC's were set by testing the NEW header fore or back pointer
				;12578	;	so that psl.z = queue is empty, psl.vc = 0, psl.n = ?.
				;12579	;
				;12580	;	Note: Because state<3> is cleared this cycle, synchronization with
				;12581	;	any possible MME fault must have been done earlier than the previous
				;12582	;	microinstruction.
				;12583
				;12584	IQ.EXIT:
				;12585		;---------------------------------------;
				;12586		VA <-- [W0],				; VA <-- H, previously checked
				;12587		[W1] <-- MEM.LOCK (VA), LONG,		; read header, acquire hardware interlock
				;12588		ACCESS B [W5],				; touch W5 in case never accessed
				;12589		STATE.3-0 <-- 0,			; clear software interlock flag
				;12590							; >> state<3> change, sync with possible MME fault
				;12591							; >> done before previous cycle
E 4CD  004C,0031,0818,04D0 J 4D0;12592			sim addr [queue.hdr]
				;12593
				;12594		;---------------------------------------;
E 4D0  0480,2048,30C0,04D1 J 4D1;12595		[PSL] <-- [PSL] ANDNOT 000000[9], LONG	; clear psl.n, psl.c
				;12596
				;12597		;---------------------------------------;
				;12598		MEM.UNLOCK (VA)&, [WBUS] <-- [W2],	; release hardware interlock, update header
				;12599		LONG,					; previously checked, cannot fail
				;12600		ACCESS B [W1],				; touch W1 here to sync read lock
				;12601		RESTART MBOX,				; resume operand processing
E 4D1  006C,0010,2034,9000 L	;12602		LAST CYCLE				; go decode next instruction
				;12603
;12604	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  379
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
;12605	.TOC	"	REMQxI"
;12606
;12607	;	These instructions remove an entry from the head or tail of an interlocked,
;12608	;	self-relative queue.
;12609	;
;12610	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;12611	;	--------      ------	---------				----	-----			--------
;12612	;	REMQHI		5E	see next page				2o	av{m1}/ql		REMQXI..
;12613	;	REMQTI		5F	see next page				2o	av{m1}/ql		REMQXI..
;12614	;
;12615	;	Entry conditions:
;12616	;		source queue	=	header.aq operand
;12617	;					dest.vl operand (if register)
;12618	;					address of dest.vl operand (if memory)
;12619	;		dest queue	=	dest.vl result (if register)
;12620	;		branch queue	=	none
;12621	;		field queue	=	one valid entry for dest.vl specifier
;12622	;		DL		=	LONG
;12623	;		Ibox state	=	running
;12624	;		Mbox state	=	stopped
;12625	;
;12626	;	Exit conditions:
;12627	;		The entry has been removed from the queue.
;12628	;		The PSL condition codes are set.
;12629	;
;12630	;	Condition codes:
;12631	;		N <-- 0
;12632	;		Z <-- if removal succeeded then {queue now empty} else 0
;12633	;		V <-- if {no entry removed} then 1 else 0	[Integer overflow trap disabled.]
;12634	;		C <-- if removal succeeded then 0 else 1
;12635	;
;12636	;	Notes:
;12637	;		1.  Memory management:	The source queue is emptied before the start of E-box I/O.
;12638	;		2.  Memory management:	The only unchecked write is followed by a previously checked
;12639	;		    write, or a write check retry, which guarantees that memory management errors are
;12640	;		    made visible before instruction completion.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  380
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
;12641
;12642	;	REMQxI operation:
;12643	;
;12644	;		tmp1 <-- (header) interlocked
;12645	;		if tmp1<0> = 1 then
;12646	;			(header) <-- tmp1 release interlock
;12647	;			psl cc <-- 0011 and EXIT
;12648	;		else if {any memory access cannot complete} then
;12649	;			{release secondary interlock}
;12650	;			{initiate memory management exception}
;12651	;		else if {queue now empty} then
;12652	;			{release secondary interlock}
;12653	;			alu.nzvc <-- 0010 and EXIT
;12654	;		else	{insert entry at head/tail of queue}
;12655	;			{release secondary interlock}
;12656	;
;12657	;	The actual removal process is best understood pictorially:
;12658	;
;12659	;	BEFORE				AFTER REMQHI			AFTER REMQTI
;12660	;
;12661	;	H:	A-H			H:	B-H	W		H:	A-H	W to release interlock
;12662	;	H+4:	C-H			H+4:	C-H			H+4:	B-H	W
;12663	;
;12664	;	A:	B-A			A:	B-A	R		A:	B-A
;12665	;	A+4:	H-A			A+4:	H-A			A+4:	H-A
;12666	;
;12667	;	B:	C-B			B:	C-B			B:	H-B	W
;12668	;	B+4:	A-B			B+4:	H-B	W		B+4:	A-B
;12669	;
;12670	;	C:	H-C			C:	H-C			C:	H-C
;12671	;	C+4:	B-C			C+4:	B-C			C+4:	B-C	R
;12672	;
;12673	;	Note that the queue header, the entry to be inserted, and all the intermediate entries
;12674	;	that are "touched" in any way must be QUADWORD aligned.  In addition, the header and
;12675	;	the destination must not be equal.
;12676	;
;12677	;	For REMQHI, H and B+4 must be WRITEABLE, A must be READABLE.
;12678	;	For REMQTI, H+4 and B must be WRITEABLE, C+4 must be READABLE.
;12679	;
				;12680	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  381
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
				;12681
				;12682	;	REMQxI.
				;12683	;	Read header, interlocked, check alignment of header.
				;12684	;	Because interlocked read bypasses the cache, many cycles
				;12685	;	can be filled before the data will be available.
				;12686	;
				;12687	;	Note: Constraints for REMQXI.., REXQXI.R, and REMQXI.M are
				;12688	;	done in ALIGN.MIC.
				;12689	;
				;12690	;	CAUTION: Do not change the order of reference to the
				;12691	;	source queue in the entry point below without
				;12692	;	reading the explanation at the beginning of this module.
				;12693	;
				;12694	;	The following simultaneous reference restriction exists for
				;12695	;	this entry point: [spec 1; spec 2].
				;12696
				;12697	REMQXI..:
				;12698		;********** Hardware dispatch **********; fq.vr = 11 (invalid)
E 276  4000,0000,2000,5270 B 270;12699		CASE [FQ.VR] AT [REMQXI.M]		; wait for field queue to
				;12700							; indicate register or memory
				;12701	REMQXI.R:
				;12702		;---------------------------------------; fq.vr = 01 (valid, register)
				;12703		[W1] <-- NOT [S1], LONG,		; [1] guarantee "dest addr" ne header
				;12704		Q <-- PASSB [S1],			; save header address
				;12705							; test for header quad aligned
				;12706		GOTO [IQ.ACQUIRE.LOCK], 		; go acquire hardware lock
				;12707							; note: destination sq entry is left on the
				;12708							; sq until end of flow
			    p368;12709							; >> no [spec 1; spec 2] reference
E 272  0D82,8040,0800,0525 J 525;12710			sim cond k s3.[2]
				;12711
				;12712	REMQXI.M:
				;12713		;---------------------------------------; fq.vr = 00 (valid, memory)
				;12714		WCHK (VA)&, VA&, [W1] <-- [S2], LONG,	; [1] write check, save destination
				;12715		Q <-- PASSB [S1],			; save header address
				;12716							; test for header quad aligned
				;12717		STATE.0 <-- 1,				; flag memory destination
				;12718		GOTO [IQ.ACQUIRE.LOCK], 		; go acquire hardware lock
				;12719							; >> [spec 1; spec 2] reference OK
				;12720							; >> because spec 2 not a GPR
			    p368;12721			sim cond k s3.[2],
E 270  0062,8041,0898,8525 J 525;12722			sim addr [ea.2]
				;12723
				;12724	;	At IQ.ACQUIRE.LOCK, the B port operand (the header) is checked for
				;12725	;	quad alignment as though it were the INSQxI entry;  then Q is
				;12726	;	checked again as the header.  In addition, a test is made for header
				;12727	;	= W1 = destination address (guaranteed to fail if register).
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  382
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
				;12728
				;12729	;	REMQHI, continued.
				;12730	;	Secondary interlock acquired, header quad aligned.
				;12731	;	Check for empty queue and quad alignment of [B-A].
				;12732	;
				;12733	;	Note: This flow depends on INTEXC microcode to release the software
				;12734	;	      interlock if a memory management or reserved operand fault occurs.
				;12735
				;12736	;	At this point,
				;12737	;		W0	=	address of header [H]
				;12738	;		W1	=	address of destination, if memory
				;12739	;		W2	=	header forward pointer [A-H]
				;12740	;		W3	=	address of queue head [A]
				;12741	;		STATE<3> =	1 (software interlock flag)
				;12742	;		alu cc's =	queue header = 0
				;12743	;
				;12744	;	Checks completed:
				;12745	;		destination verified writable if memory
				;12746	;		H verified writable and quadword aligned => H+4 is writable
				;12747	;		A quadword aligned
				;12748
				;12749	REMQHI.CONT:
				;12750		;---------------------------------------; opcode<1:0> = 10:
				;12751		VA <-- [W3],				; [8] VA <-- A, unchecked
				;12752		[W5] <-- MEM (VA), LONG,		; read head fore pointer [B-A]
				;12753		CASE [ALU.NZV] AT [REMQHI.NOT.EMPTY],	; case on queue empty
E 14D  2040,0001,1840,4178 B 178;12754			sim addr [queue.1]
				;12755
				;12756	;= ALIGNLIST 10xx	(REMQHI.NOT.EMPTY,	REMQHI.EMPTY)
				;12757	;  ALU.NZVC set by MOVE --> V = C = 0
				;12758
				;12759	REMQHI.EMPTY:
				;12760		;---------------------------------------; alu.z = 1:
				;12761		[PSL] <-- [PSL] OR 000000[06], LONG,	; [9] set psl.zv
			    p377;12762		SYNCHRONIZE MBOX,			; sync with possible MME fault from [8]
E 17C  4520,2030,30C0,4A09 B 109;12763		CASE [STATE.2-0] AT [REMQXI.WRITE.R]	; case on register vs memory destination
				;12764
				;12765	REMQHI.NOT.EMPTY:
				;12766		;---------------------------------------; alu.z = 0:
				;12767		[W4] <-- [W3] + [W5], LONG,		; [9] B = A + [B-A], test B-A quad aligned
				;12768							; >> sync with read from [8]
E 178  0880,0030,1440,0527 J 527;12769			sim cond k s3.[2]
				;12770
				;12771		;---------------------------------------;
			    p383;12772		[W5] <-- [W0] - [W4], LONG,		; [10] calculate [H-B]
E 527  EA80,0028,1810,47DA B 5DA;12773		CASE [A31.BQA.BNZ1] AT [REMQHI.B.NOT.QA] ; case on [B-A] quad aligned
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  383
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
				;12774
				;12775	;	REMQHI, continued.
				;12776	;	Update pointer (B+4).
				;12777
				;12778	;	At this point,
				;12779	;		W0	=	address of header [H]
				;12780	;		W1	=	address of destination, if memory
				;12781	;		W2	=	header forward pointer [A-H]
				;12782	;		W3	=	address of old queue head [A]
				;12783	;		W4	=	address of new queue head [B]
				;12784	;		W5	=	H-B
				;12785	;		STATE<3> =	1 (software interlock flag)
				;12786	;
				;12787	;	Checks completed:
				;12788	;		destination verified writable if memory
				;12789	;		H verified writable and quadword aligned => H+4 is writable
				;12790	;		A quadword aligned
				;12791	;		B quadword aligned
				;12792
				;12793	;= ALIGNLIST 101x	(REMQHI.B.NOT.QA,	REMQHI.B.QA)
				;12794
				;12795	REMQHI.B.NOT.QA:
			    p127;12796		;---------------------------------------; b<2:0> <> 000:
E 5DA  0000,0000,2000,003C J 03C;12797		RESERVED OPERAND FAULT			; [11] go to exception processing code
				;12798							; fault handler will release lock and
				;12799							; clear state<3>
				;12800
				;12801	REMQHI.B.QA:
				;12802		;---------------------------------------; b<2:0> = 000:
				;12803		VA <-- [W4] + 4,			; [11] VA <-- B+4
				;12804		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG, ; (B+4) <-- [H-B], only unchecked write
				;12805		SET PSL CC.IIII,			; set psl.z if single entry, psl map is iiii
E 5DE  0C64,8033,205D,0113 J 113;12806			sim addr [queue.2]
				;12807
				;12808		;---------------------------------------;
				;12809		WCHK (VA)&,				; [12] recheck, force reporting of mem mgt errors
			    p377;12810		[W2] <-- [W4] - [W0], LONG,		; new header = [B-H]
E 113  4AE0,0008,0C50,4A09 B 109;12811		CASE [STATE.2-0] AT [REMQXI.WRITE.R]	; case on register vs memory destination
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  384
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
				;12812
				;12813	;	REMQTI, continued.
				;12814	;	Secondary interlock acquired, header quad aligned.
				;12815	;	Check for empty queue and quad alignment of [C-H] and [B-C].
				;12816	;
				;12817	;	Note: This flow depends on INTEXC microcode to release the software
				;12818	;	      interlock if a memory management or reserved operand fault occurs.
				;12819
				;12820	;	At this point,
				;12821	;		W0	=	address of header [H]
				;12822	;		W1	=	address of destination, if memory
				;12823	;		W2	=	header forward pointer [A-H]
				;12824	;		W3	=	address of queue head [A]
				;12825	;		STATE<3> =	1 (software interlock flag)
				;12826	;		alu cc's =	queue header = 0
				;12827	;
				;12828	;	Checks completed:
				;12829	;		destination verified writable if memory
				;12830	;		H verified writable and quadword aligned => H+4 is writable
				;12831	;		A quadword aligned
				;12832
				;12833	REMQTI.CONT:
				;12834		;---------------------------------------; opcode<1:0> = 11:
				;12835		VA <-- [W0] + 4,			; [8] VA <-- H+4, previously checked
				;12836		[W5] <-- MEM (VA), LONG,		; read header back pointer [C-H]
				;12837		CASE [ALU.NZV] AT [REMQTI.NOT.EMPTY],	; case on queue empty
E 14F  2C40,0001,1810,4179 B 179;12838			sim addr [ea.1] + k
				;12839
				;12840	;= ALIGNLIST 10xx	(REMQTI.NOT.EMPTY,	REMQTI.EMPTY)
				;12841	;  ALU.NZVC set by MOVE --> V = C = 0
				;12842
				;12843	REMQTI.EMPTY:
				;12844		;---------------------------------------; alu.z = 1:
			    p377;12845		[PSL] <-- [PSL] OR 000000[06], LONG,	; [9] set psl.zv
E 17D  4500,2030,30C0,4A09 B 109;12846		CASE [STATE.2-0] AT [REMQXI.WRITE.R]	; case on register vs memory destination
				;12847
				;12848	REMQTI.NOT.EMPTY:
				;12849		;---------------------------------------; alu.z = 0:
				;12850		[W3] <-- [W0] + [W5], LONG,		; [9] C = H + [C-H], test C-A quad aligned
E 179  0880,0030,1010,0528 J 528;12851			sim cond k s3.[2]
				;12852
				;12853		;---------------------------------------;
				;12854		[WBUS] <-- [W2] XOR [W5], LONG, 	; [10] test if fore pointer = back pointer
				;12855		CASE [A31.BQA.BNZ1] AT [REMQTI.C.NOT.QA], ; case on C-A quad aligned
E 528  E600,0030,2030,47DB B 5DB;12856			sim cond [s4.queue.single]
				;12857
				;12858	;= ALIGNLIST 101x	(REMQTI.C.NOT.QA,	REMQTI.C.QA)
				;12859
				;12860	REMQTI.C.NOT.QA:
			    p127;12861		;---------------------------------------; b<2:0> <> 000:
E 5DB  0000,0000,2000,003C J 03C;12862		RESERVED OPERAND FAULT			; [11] C-A not quad aligned, fault
				;12863							; fault handler will release lock
				;12864							; and clear state<3>
				;12865
				;12866	REMQTI.C.QA:
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  385
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
				;12867		;---------------------------------------; b<2:0> = 000:
				;12868		VA <-- [W3] + 4,			; [11] VA <-- C+4
				;12869		[W4] <-- MEM (VA), LONG,		; read tail back pointer (C+4)
E 5DF  0C40,0001,1440,0103 J 103;12870			sim addr [queue.1]
				;12871
				;12872		;---------------------------------------;
				;12873		VA&, [W4] <-- [W3] + [W4], LONG,	; [12] B = C + [B-C], test B-C quad aligned
				;12874		CASE [ALU.NZV] AT [REMQTI.MULTI],	; check for single entry case
			    p386;12875			sim cond k s3.[2],
E 103  2880,0029,1440,4159 B 159;12876			sim addr [queue.2]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  386
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
				;12877
				;12878	;	REMQTI, continued.
				;12879	;	More than one entry in the queue, write pointer (B), update (H+4).
				;12880
				;12881	;	At this point,
				;12882	;		W0	=	address of header [H]
				;12883	;		W1	=	address of destination, if memory
				;12884	;		W2	=	header forward pointer [A-H]
				;12885	;		W3	=	address of old queue tail [C]
				;12886	;		W4 = VA =	address of new queue tail [B]
				;12887	;		STATE<3> =	1 (software interlock flag)
				;12888	;
				;12889	;	Checks completed:
				;12890	;		destination verified writable if memory
				;12891	;		H verified writable and quadword aligned => H+4 is writable
				;12892	;		A quadword aligned
				;12893	;		C quadword aligned
				;12894
				;12895	;= ALIGNLIST 10xx	(REMQTI.MULTI,	REMQTI.SINGLE)
				;12896	;  ALU.NZVC set by XOR --> V = C = 0
				;12897
				;12898	REMQTI.MULTI:
				;12899		;---------------------------------------; alu.z = 0:
				;12900		[W5] <-- [W4] - [W0], LONG,		; [13] calculate B-H
E 159  EA80,0008,1850,475B B 15B;12901		CASE [A31.BQA.BNZ1] AT [REMQTI.B.NOT.QA] ; case on B-C quad aligned
				;12902
				;12903	;= ALIGNLIST 101x	(REMQTI.B.NOT.QA,	REMQTI.B.QA)
				;12904
				;12905	REMQTI.B.NOT.QA:
			    p127;12906		;---------------------------------------; b<2:0> <> 000:
E 15B  0000,0000,2000,003C J 03C;12907		RESERVED OPERAND FAULT			; [14] B-C not quad aligned, fault
				;12908							; fault handler will release lock
				;12909							; and clear state<3>
				;12910
				;12911	REMQTI.B.QA:
				;12912		;---------------------------------------; b<2:0> = 000:
E 15F  0AE4,0028,2010,0115 J 115;12913		MEM (VA)&, [WBUS] <-- [W0] - [W4], LONG ; [14] (B) <-- [H-B], only unchecked write
				;12914
				;12915		;---------------------------------------;
				;12916		VA <-- [W0] + 4,			; [15] VA <-- H+4, previously checked
				;12917		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG, ; (H+4) <-- [B-H], cannot fail
				;12918							; >> sync with possible MME fault from [14]
				;12919		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
			    p377;12920		CASE [STATE.2-0] AT [REMQXI.WRITE.R],	; case on register vs memory destination
E 115  4C64,8033,201D,4A09 B 109;12921			sim addr [ea.1] + k
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  387
;     QUEUE.MIC 	     REMQxI										      /REV=
;															      QUEUE
				;12922
				;12923	;	REMQTI, continued.
				;12924	;	Single entry, write pointer (B), update (H+4).
				;12925
				;12926	;	At this point,
				;12927	;		W0	=	address of header [H]
				;12928	;		W1	=	address of destination, if memory
				;12929	;		W2	=	header forward pointer [A-H]
				;12930	;		W3	=	address of old queue tail [C]
				;12931	;		W4 = VA =	address of new queue tail [B]
				;12932	;		STATE<3> =	1 (software interlock flag)
				;12933	;
				;12934	;	Checks completed:
				;12935	;		destination verified writable if memory
				;12936	;		H verified writable and quadword aligned => H+4 is writable
				;12937	;		A quadword aligned
				;12938	;		C quadword aligned
				;12939	;
				;12940	;	If the queue contained only a single entry, then entry B is actually
				;12941	;	the header H.  We must NOT update pointer (B), that is, (H), because
				;12942	;	this would CLEAR the secondary interlock bit using a non-interlocked
				;12943	;	read-modify-write sequence.
				;12944
				;12945	REMQTI.SINGLE:
				;12946		;---------------------------------------; alu.z = 1:
E 15D  E000,0000,2000,476B B 16B;12947		CASE [A31.BQA.BNZ1] AT [REMQTI.SINGLE.B.NOT.QA] ; [13] case on B-C quad aligned
				;12948
				;12949	;= ALIGNLIST 101x	(REMQTI.SINGLE.B.NOT.QA, REMQTI.SINGLE.B.QA)
				;12950
				;12951	REMQTI.SINGLE.B.NOT.QA:
			    p127;12952		;---------------------------------------; b<2:0> <> 000:
E 16B  0000,0000,2000,003C J 03C;12953		RESERVED OPERAND FAULT			; [14] B-C not quad aligned, fault
				;12954							; fault handler will release lock
				;12955							; and clear state<3>
				;12956
				;12957	REMQTI.SINGLE.B.QA:
				;12958		;---------------------------------------; b<2:0> = 000:
				;12959		VA <-- [W0] + 4,			; [14] VA <-- H+4, previously checked
				;12960		MEM (VA)&, [W2] <-- PASSB 000000[00],	; (H+4) <-- 0, cannot fail
				;12961		LONG,					; new header is 0
				;12962		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
			    p377;12963		CASE [STATE.2-0] AT [REMQXI.WRITE.R],	; case on register vs memory destination
E 16F  4C64,A003,0C1D,4A09 B 109;12964			sim addr [ea.1] + k
				;12965
				;12966	;= END QUEUE
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  388
;     OPSYS.MIC 	     OPSYS.MIC -- Operating System Support Instructions 				      /REV=
;
				;12967	.TOC	"OPSYS.MIC -- Operating System Support Instructions"
				;12968	.TOC	"Revision 1.6"
				;12969
				;12970	;	Mike Uhler, Bob Supnik
				;12971
;12972	.nobin
;12973	;****************************************************************************
;12974	;*									    *
;12975	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;12976	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;12977	;*  ALL RIGHTS RESERVED.						    *
;12978	;*									    *
;12979	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;12980	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;12981	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;12982	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;12983	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;12984	;*  TRANSFERRED.							    *
;12985	;*									    *
;12986	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;12987	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;12988	;*  CORPORATION.							    *
;12989	;*									    *
;12990	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;12991	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;12992	;*									    *
;12993	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  389
;     OPSYS.MIC 	     Revision History									      /REV=
;
;12994	.TOC	"	Revision History"
;12995
;12996	; Edit	  Date	 Who	     Description
;12997	; ---- --------- ---	---------------------
;12998	;    6 07-Nov-91 GMU	Symptom: REI does a RESTART IBOX before updating SP
;12999	;				 for the new mode.  If the Ibox were to get
;13000	;				 started at the instruction that is the
;13001	;				 target of the REI before the Ebox updated
;13002	;				 SP, the wrong value of SP would be used.
;13003	;				 Because of the timing involved, this is not
;13004	;				 a bug (SP is guaranteed to be updated before
;13005	;				 the first possible time that the Ibox can
;13006	;				 reference SP).
;13007	;			Cure:	 Add comments to REI to reflect the timing
;13008	;				 restrictions to prevent any future code
;13009	;				 changes from introducing a bug.
;13010	;    5 07-Aug-91 GMU	Symptom: Missing comma in the code at
;13011	;				 MTPR.OR.INT.SYS created two microinstructions
;13012	;				 rather than the desired one microinstruction.
;13013	;				 Because of the code flow involved, this caused
;13014	;				 no functional failures, but added an unnecessary
;13015	;				 microinstruction to the control store and
;13016	;				 an additional cycle to the flow.
;13017	;			Cure:	 Add the missing comma at MTPR.OR.INT.SYS.
;13018	;    4 15-May-91 GMU	Symptom: When a TBIA, TBIS, TB TAG FILL, or TB PTE
;13019	;				 FILL is injected into the EM latch, it may
;13020	;				 be started by the Mbox and then aborted.
;13021	;				 However, the Mbox does not abort the effects
;13022	;				 of these command based on S5 abort.  The
;13023	;				 result is that the Mbox can enter an infinte
;13024	;				 TB miss loop if the command invalidates the
;13025	;				 TB entry that maps the PTE in a double miss
;13026	;				 sequence.
;13027	;			Cure:	 Insert a SYNCHRONIZE MBOX or other Mbox
;13028	;				 request in the microinstruction immediately
;13029	;				 preceding the TBIA, TBIS, TB TAG FILL, or
;13030	;				 TB PTE FILL command unless other synchronization
;13031	;				 is known to guarantee that the Mbox can not be
;13032	;				 in a TB miss sequence.
;13033	;    3 17-Feb-91 GMU	Symptom: The Mbox modification to support the VAX
;13034	;				 S1 space ECO is easier if the microcode
;13035	;				 biases the P1BR and P1LR values when reading or
;13036	;				 writing those registers.
;13037	;			Cure:	 Use P1BR.BIAS, P1LR.BIAS.SHIFTED, and
;13038	;				 P1LR.BIAS.UNSHIFTED to bias the architectural
;13039	;				 values of P1BR and P1LR when writing or reading
;13040	;				 the Mbox registers.  This includes Mbox register
;13041	;				 writes in LDPCTX and MTPR, and Mbox register
;13042	;				 reads in MFPR.
;13043	;    2 28-Jan-91 GMU	Symptom: MFPR reads of the SID processor register
;13044	;				 do no include microcode patch information
;13045	;				 if the patchable control store is loaded
;13046	;				 and enabled.
;13047	;			Cure:	 Update MFPR reads of the SID processor
;13048	;				 register to return the microcode patch
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  390
;     OPSYS.MIC 	     Revision History									      /REV=
;
;13049	;				 revision number in bits <13:9> and the
;13050	;				 non-standard patch flag in bit <8>.  This
;13051	;				 information is returned only if the
;13052	;				 patchable control store is enabled.
;13053	;    1 09-Sep-90 GMU	Symptom: LOAD PC not synchronized with entry to
;13054	;				 exception flows in CHMx with fault on
;13055	;				 second probe.
;13056	;			Cure:	 Add SYNCHRONIZE MBOX in PROBE fault exit
;13057	;				 from CHMx at CHM.2ND.PROBE.FAIL.
;13058	;			Symptom: LOAD PC not synchronized with entry to
;13059	;				 console halt flows in REI.
;13060	;			Cure:	 Add SYNCHRONIZE MBOX in console halt
;13061	;				 entry at REI.FROM.101..111.
;13062	;			Symptom: Missing CWB during REI to I-stack (no
;13063	;				 AST delivery possible).  This also
;13064	;				 resulted in failure to synchronize with
;13065	;				 the previous LOAD PC.
;13066	;			Cure:	 Add CWB (and implicit LOAD PC synchronization)
;13067	;				 to REI to I-stack exit path at REI.NEW.INTER.
;13068	; (1)0 31-Jul-90 GMU	Initial production microcode.
;13069	;
;13070	; Begin version 1.0 here
;13071	;   54 31-Jul-90 GMU	Supply the entire tag and PTE value in VA for
;13072	;			TB tag fill and TB PTE fill commands to the Mbox.
;13073	;   53 21-Jul-90 GMU	Update with Bob's review comments.
;13074	;   52 19-Jul-90 GMU	Add INTSYS IPR to allow direct software access to INT.SYS.
;13075	;   51 17-Jul-90 GMU	Clear PMF interrupt request if PMF counters are
;13076	;			explicitly cleared.
;13077	;   50 01-Jul-90 GMU	Add support for performance monitoring facility.
;13078	;   49 25-Jun-90 GMU	Do SYNCHRONIZE MBOX before PSL change in REI to
;13079	;			avoid changing PSL<CURMOD> out from under possible
;13080	;			Mbox request in the EM latch.
;13081	;   48 05-Jun-90 GMU	Add clear write buffer back in REI code.
;13082	;   47 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;13083	;   46 07-May-90 GMU	Remove read reference to PCSCR.
;13084	;   45 03-May-90 GMU	Remove unused label.
;13085	;   44 01-May-90 GMU	Uncomment references to CWB IPR.
;13086	;   43 30-Apr-90 GMU	Sync with Mbox after LOAD PC.
;13087	;   42 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;13088	;   41 23-Apr-90 GMU	Remove artifact for an external vector unit interface.
;13089	;   40 18-Apr-90 GMU	Pad at the end of MTPR write to ECR and PCSCR to
;13090	;			all time for the change to propagate.
;13091	;   39 29-Mar-90 DGM	Update comments
;13092	;   38 27-Mar-90 DGM	Update comments
;13093	;   37 18-Mar-90 GMU	Rename JTAGCR to PCSCR.
;13094	;   36 26-Feb-90 GMU	Fix incorrect reference to ASTLVL in REI, update
;13095	;			headers.
;13096	;   35 23-Feb-90 GMU	Rewrite MxPR code, correct references to ASTLVL.
;13097	;   34 12-Feb-90 GMU	Account for the 9-bit shift required when referencing
;13098	;			IPR.MMAPEN, IPR.MSLR, IPR.MP0LR, and IPR.MP1LR.
;13099	;   33 19-Jan-90 GMU	Add the CPUID IPR.
;13100	;   32 19-Jan-90 GMU	FLUSH BRANCH PREDICTION CACHE -> FLUSH BRANCH PREDICTION TABLE.
;13101	;   31 15-Jan-90 JFB	Update MFPR comment to indicate Ibox suspension
;13102	;   30 10-Jan-90 GMU	Update interrupt section interface to reflect new
;13103	;			design.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  391
;     OPSYS.MIC 	     Revision History									      /REV=
;
;13104	;   29 10-Jan-90 GMU	Change final specifier for MFPR from .wl to .ml to
;13105	;			guarantee that the Ibox is fully stopped before it
;13106	;			sees an IPR read.
;13107	;   28	8-Jan-90 DGM	Remove all ALU SEXT and ZEXT functions
;13108	;   27 21-Dec-89 GMU	Add temporary support for cache IPR access via
;13109	;			MxPR.
;13110	;   26 13-Dec-89 GMU	Add SYNCHRONIZE MBOX at MTPR exit to guarantee
;13111	;			synchronization between a possible Ibox IPR write and
;13112	;			another Ibox IPR write or LOAD PC that may happen
;13113	;			in the next flow.
;13114	;   25 06-Dec-89 GMU	Rename FLUSH BPC to FLUSH BRANCH PREDICTION CACHE.
;13115	;   24 01-Dec-89 GMU	Update MxPR ICCS to check ECR<7> to determine if
;13116	;			the interval timer is a subset or full implementation.
;13117	;   23 30-Nov-89 GMU	Fix REI bug introduced by edit 21.
;13118	;   22 28-Nov-89 GMU	Remove edit 20.
;13119	;   21 20-Nov-89 RMS	Save cycle in REI.
;13120	;   20 20-Nov-89 DGM	Force SCBB to be page aligned.
;13121	;   19 17-Nov-89 GMU	Convert LOAD NEW PC macro to LOAD PC, remove
;13122	;			SYNC FBOX.
;13123	;   18 11-Nov-89 GMU	Fix AST delivery bug in new REI.
;13124	;   17 10-Nov-89 GMU	Merge in Bob's new REI code.
;13125	;   16 07-Nov-89 GMU	Complete RESET CPU interface.
;13126	;   15 23-Oct-89 GMU	Clean up interface with IE.MEMMGT routine.
;13127	;   14 18-Oct-89 GMU	Do physical rather than virtual reads from and writes
;13128	;			to the PCB in LDPCTX/SVPCTX.
;13129	;   13 18-Oct-89 GMU	Re-add edit 10.
;13130	;   12	9-Oct-89 GMU	Update comment on call to REINITIALIZE.CPU
;13131	;   11	3-Oct-89 DB	Fix MXPR.EXT.CONT to LSH [2] (was [3]).
;13132	;   10	2-Oct-89 GMU	Remove set of PSL CCs for MTPR (except for TBCHK).
;13133	;    9	2-Oct-89 DGM	Fix MTPR.58 (TBIS)  was "<-- [W0]"  now "<-- [W1]"
;13134	;    8 29-Sep-89 GMU	Set the corret SISR bit in REI delivery of an AST.
;13135	;    7 28-Sep-89 GMU	Add one NOP to the start of the REI flow to
;13136	;			make PSL read valid.
;13137	;    6 28-Sep-89 GMU	Add TBCHK microcode.
;13138	;    5 21-Sep-89 GMU	Fix exit from all MFPR flows to restart Ibox.
;13139	;    4 20-Sep-89 GMU	Add MxPR support for JTAGCR, ECR, MTBTAG and MTBPTE
;13140	;			IPRs.
;13141	;    3 11-Sep-89 GMU	Change PROBE macro names.
;13142	;    2 08-Sep-89 GMU	Removed REI adjustment of SP (Ibox does it).
;13143	;    1 14-Aug-89 GMU	Update LDPCTX/SVPCTX/MxPR.
;13144	;    0 21-Jul-87 RMS	Trial microcode.
;13145
				;13146	.bin
				;13147	;= BEGIN OPSYS
;13148	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  392
;     OPSYS.MIC 	     Revision History									      /REV=
;															      OPSYS
;13149
;13150	;	This module implements the operating system support class instructions.
;13151	;	The instructions in this class are:
;13152	;
;13153	;	Opcode	 Instruction							N Z V C 	Exceptions
;13154	;	------	 -----------							------- 	----------
;13155	;
;13156	;	BD	 CHME param.rw, {-(ySP).w*}					0 0 0 0 	IS abort
;13157	;	BC	 CHMK param.rw, {-(ySP).w*}					0 0 0 0 	IS abort
;13158	;	BE	 CHMS param.rw, {-(ySP).w*}					0 0 0 0 	IS abort
;13159	;	BF	 CHMU param.rw, {-(ySP).w*}					0 0 0 0 	IS abort
;13160	;		 Where y=MINU(x, PSL<current_mode>)
;13161	;
;13162	;	06	 LDPCTX {PCB.r*, -(KSP).w*}					- - - - 	rsv, prv
;13163	;
;13164	;	DB	 MFPR procreg.rl, dst.wl					* * 0 - 	rsv, prv
;13165	;
;13166	;	DA	 MTPR src.rl, procreg.rl					* * 0 - 	rsv, prv
;13167	;
;13168	;	0C	 PROBER mode.rb, len.rw, base.ab				0 * 0 -
;13169	;	0D	 PROBEW mode.rb, len.rw, base.ab				0 * 0 -
;13170	;
;13171	;	02	 REI {(SP)+.r*} 						* * * * 	rsv
;13172	;
;13173	;	07	 SVPCTX {(SP)+.r*, PCB.w*}					- - - - 	prv
;13174	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  393
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
;13175	.TOC	"	CHMx"
;13176
;13177	;	These instructions initiate a change mode exception.
;13178	;
;13179	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;13180	;	--------      ------	---------				----	-----		--------
;13181	;	CHMK		BC	initiate change to kernel exception	1	r/w		CHMK..
;13182	;	CHME		BD	initiate change to executive exception	1	r/w		CHME..
;13183	;	CHMS		BE	initiate change to supervisor exception 1	r/w		CHMS..
;13184	;	CHMU		BF	initiate change to user exception	1	r/w		CHMU..
;13185	;
;13186	;	Entry conditions:
;13187	;		source queue	=	param.rw operand (not zero extended)
;13188	;					current PC (implicit specifier)
;13189	;		dest queue	=	none
;13190	;		branch queue	=	none
;13191	;		field queue	=	none
;13192	;		DL		=	WORD
;13193	;		Ibox state	=	stopped
;13194	;		Mbox state	=	running
;13195	;
;13196	;	Exit conditions:
;13197	;		Exception taken through CHMx vector in SCB.
;13198	;		PSL	=	0'min(opcode<1:0>, cur_mode)'cur_mode'ipl'0
;13199	;		Stack frame:
;13200	;
;13201	;		+---------------------------------------------------------------+
;13202	;		|			  sext(operand) 			|  CHMx argument
;13203	;		+---------------------------------------------------------------+
;13204	;		|				PC				|
;13205	;		+---------------------------------------------------------------+
;13206	;		|				PSL				|
;13207	;		+---------------------------------------------------------------+
;13208	;
;13209	;	Condition codes:
;13210	;		N <-- 0
;13211	;		Z <-- 0
;13212	;		V <-- 0 		[Integer overflow trap disabled.]
;13213	;		C <-- 0
;13214	;
;13215	;	Notes:
;13216	;		1.  Memory management:	The source list is emptied (except for the implicit current
;13217	;		    PC specifier, which cannot fault) before machine state is altered.
;13218	;		2.  Memory management:	SP is updated before stack writes in case of machine check.
;13219	;
				;13220	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  394
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13221
				;13222	;	CHMx operation:
				;13223	;
				;13224	;		tmp2 <-- minu(tmp1, PSL<cur_mode>)
				;13225	;		if {PSL<is> = 1} then {chm_on_int_stack_abort}
				;13226	;		PSL<cur_mode>_sp <-- SP
				;13227	;		tmp4 <-- tmp2_sp
				;13228	;		probe.write from tmp4 - 1 to tmp4 - 12. with mode = tmp2
				;13229	;		PSL <-- 0'tmp2'cur_mode'ipl'0
				;13230	;		-(SP) <--old PSL
				;13231	;		-(SP) <-- PC
				;13232	;		-(SP) <-- sext(operand.rw)
				;13233	;		PC <-- M[SCBB + 40 + opcode<1:0>*4]
				;13234
				;13235	CHMK..:
				;13236		;********** Hardware dispatch **********;
				;13237		VA <-- [SCBB] + 000000[SCB.CHMK],	; calc addr of SCB vector
				;13238		[W1] <-- MEM.SCB (VA), LONG,		; start read of SCB vector
			    p395;13239		CASE [PSL.26-24] AT [CHM.FROM.KERNEL],	; case on current mode
E 210  A8D0,2201,0A60,4D01 B 201;13240			sim addr [scb]
				;13241
				;13242	CHME..:
				;13243		;********** Hardware dispatch **********;
				;13244		VA <-- [SCBB] + 000000[SCB.CHME],	; calc addr of SCB vector
				;13245		[W1] <-- MEM.SCB (VA), LONG,		; start read of SCB vector
			    p395;13246		CASE [PSL.26-24] AT [CHM.FROM.KERNEL],	; case on current mode
E 212  A8D0,2221,0A60,4D01 B 201;13247			sim addr [scb]
				;13248
				;13249	CHMS..:
				;13250		;********** Hardware dispatch **********;
				;13251		VA <-- [SCBB] + 000000[SCB.CHMS],	; calc addr of SCB vector
				;13252		[W1] <-- MEM.SCB (VA), LONG,		; start read of SCB vector
			    p395;13253		CASE [PSL.26-24] AT [CHM.FROM.KERNEL],	; case on current mode
E 214  A8D0,2241,0A60,4D01 B 201;13254			sim addr [scb]
				;13255
				;13256	CHMU..:
				;13257		;********** Hardware dispatch **********;
				;13258		VA <-- [SCBB] + 000000[SCB.CHMU],	; calc addr of SCB vector
				;13259		[W1] <-- MEM.SCB (VA), LONG,		; start read of SCB vector
			    p395;13260		CASE [PSL.26-24] AT [CHM.FROM.KERNEL],	; case on current mode
E 216  A8D0,2261,0A60,4D01 B 201;13261			sim addr [scb]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  395
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13262
				;13263	;	CHMx, continued.
				;13264	;	Save current stack pointer, break out on instruction if needed.
				;13265
				;13266	;	At this point,
				;13267	;		W1	=	SCB vector
				;13268
				;13269	;= ALIGNLIST 000x	(CHM.FROM.KERNEL,	CHM.FROM.EXEC,
				;13270	;=			 CHM.FROM.SUPER,	CHM.FROM.USER,
				;13271	;=			 CHM.FROM.INT,		CHM.FROM.101,
				;13272	;=			 CHM.FROM.110,		CHM.FROM.111)
				;13273
				;13274	CHM.FROM.KERNEL:
				;13275		;---------------------------------------; psl<26:24> = 000:
E 201  0000,0000,81E0,04D2 J 4D2;13276		[KSP] <-- [SP], LONG			; save SP in KSP
				;13277
				;13278		;---------------------------------------;
				;13279		VA <-- [KSP] - 1, LONG, 		; new stack is KSP
				;13280		Q&, [MMGT.MODE] <-- PASSB 000000[00],	; cur, prv mode = ker, ker
			    p399;13281		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 4D2  0B02,A003,DA00,04D3 J 4D3;13282			sim addr [sp]
				;13283
				;13284	CHM.FROM.EXEC:
				;13285		;---------------------------------------; psl<26:24> = 001:
			    p396;13286		[ESP] <-- [SP], LONG,			; save SP in ESP
E 203  8000,0000,85E0,4C28 B 228;13287		CASE [OPCODE.2-0] AT [CHMK.FROM.EXEC]	; case on opcode
				;13288
				;13289	CHM.FROM.SUPER:
				;13290		;---------------------------------------; psl<26:24> = 010:
			    p397;13291		[SSP] <-- [SP], LONG,			; save SP in SSP
E 205  8000,0000,89E0,4C29 B 229;13292		CASE [OPCODE.2-0] AT [CHMK.FROM.SUPER]	; case on opcode
				;13293
				;13294	CHM.FROM.USER:
				;13295		;---------------------------------------; psl<26:24> = 011:
			    p398;13296		[USP] <-- [SP], LONG,			; save SP in USP
E 207  8000,0000,8DE0,4C38 B 238;13297		CASE [OPCODE.2-0] AT [CHMK.FROM.USER]	; case on opcode
				;13298
				;13299	CHM.FROM.INT:
			    p.84;13300		;---------------------------------------; psl<26:24> = 100:
E 209  0500,2850,A4C0,0034 J 034;13301		CONSOLE HALT [ERR.CHMFI]		; CHMx on IS, invoke console
				;13302
				;13303	CHM.FROM.101:
			    p.84;13304		;---------------------------------------; psl<26:24> = 101:
E 20B  0500,2850,A4C0,0034 J 034;13305		CONSOLE HALT [ERR.CHMFI]		; CHMx on IS, invoke console
				;13306
				;13307	CHM.FROM.110:
			    p.84;13308		;---------------------------------------; psl<26:24> = 110:
E 20D  0500,2850,A4C0,0034 J 034;13309		CONSOLE HALT [ERR.CHMFI]		; CHMx on IS, invoke console
				;13310
				;13311	CHM.FROM.111:
			    p.84;13312		;---------------------------------------; psl<26:24> = 111:
E 20F  0500,2850,A4C0,0034 J 034;13313		CONSOLE HALT [ERR.CHMFI]		; CHMx on IS, invoke console
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  396
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13314
				;13315	;	CHMx, continued.
				;13316	;	Opcode breakout from executive mode.
				;13317	;	Kernel changes to kernel, all others to executive.
				;13318
				;13319	;	At this point,
				;13320	;		W1	=	SCB vector
				;13321
				;13322	;= ALIGNLIST 100x	(CHMK.FROM.EXEC,	CHME.FROM.EXEC,
				;13323	;=			 CHMS.FROM.EXEC,	CHMU.FROM.EXEC)
				;13324
				;13325	CHMK.FROM.EXEC:
				;13326		;---------------------------------------; opcode<1:0> = 00:
				;13327		VA <-- [KSP] - 1, LONG, 		; new stack is KSP
				;13328		Q&, [MMGT.MODE] <-- PASSB 000000[01],	; cur, prv mode = ker, exec
			    p399;13329		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 228  0B02,A00B,DA00,04D3 J 4D3;13330			sim addr [sp]
				;13331
				;13332	CHME.FROM.EXEC:
				;13333		;---------------------------------------; opcode<1:0> = 01:
				;13334		VA <-- [ESP] - 1, LONG, 		; new stack is ESP
				;13335		Q&, [MMGT.MODE] <-- PASSB 000000[05],	; cur, prv mode = exec, exec
			    p399;13336		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 22A  0B02,A02B,DA10,04D3 J 4D3;13337			sim addr [sp]
				;13338
				;13339	CHMS.FROM.EXEC:
				;13340		;---------------------------------------; opcode<1:0> = 10:
				;13341		VA <-- [ESP] - 1, LONG, 		; new stack is ESP
				;13342		Q&, [MMGT.MODE] <-- PASSB 000000[05],	; cur, prv mode = exec, exec
			    p399;13343		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 22C  0B02,A02B,DA10,04D3 J 4D3;13344			sim addr [sp]
				;13345
				;13346	CHMU.FROM.EXEC:
				;13347		;---------------------------------------; opcode<1:0> = 11:
				;13348		VA <-- [ESP] - 1, LONG, 		; new stack is ESP
				;13349		Q&, [MMGT.MODE] <-- PASSB 000000[05],	; cur, prv mode = exec, exec
			    p399;13350		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 22E  0B02,A02B,DA10,04D3 J 4D3;13351			sim addr [sp]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  397
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13352
				;13353	;	CHMx, continued.
				;13354	;	Opcode breakout from supervisor mode.
				;13355	;	Kernel changes to kernel, executive to exec, others to supervisor.
				;13356
				;13357	;	At this point,
				;13358	;		W1	=	SCB vector
				;13359
				;13360	;= ALIGNLIST 100x	(CHMK.FROM.SUPER,	CHME.FROM.SUPER,
				;13361	;=			 CHMS.FROM.SUPER,	CHMU.FROM.SUPER)
				;13362
				;13363	CHMK.FROM.SUPER:
				;13364		;---------------------------------------; opcode<1:0> = 00:
				;13365		VA <-- [KSP] - 1, LONG, 		; new stack is KSP
				;13366		Q&, [MMGT.MODE] <-- PASSB 000000[02],	; cur, prv mode = ker, super
			    p399;13367		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 229  0B02,A013,DA00,04D3 J 4D3;13368			sim addr [sp]
				;13369
				;13370	CHME.FROM.SUPER:
				;13371		;---------------------------------------; opcode<1:0> = 01:
				;13372		VA <-- [ESP] - 1, LONG, 		; new stack is ESP
				;13373		Q&, [MMGT.MODE] <-- PASSB 000000[06],	; cur, prv mode = exec, super
			    p399;13374		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 22B  0B02,A033,DA10,04D3 J 4D3;13375			sim addr [sp]
				;13376
				;13377	CHMS.FROM.SUPER:
				;13378		;---------------------------------------; opcode<1:0> = 10:
				;13379		VA <-- [SSP] - 1, LONG, 		; new stack is SSP
				;13380		Q&, [MMGT.MODE] <-- PASSB 000000[0A],	; cur, prv mode = super, super
			    p399;13381		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 22D  0B02,A053,DA20,04D3 J 4D3;13382			sim addr [sp]
				;13383
				;13384	CHMU.FROM.SUPER:
				;13385		;---------------------------------------; opcode<1:0> = 11:
				;13386		VA <-- [SSP] - 1, LONG, 		; new stack is SSP
				;13387		Q&, [MMGT.MODE] <-- PASSB 000000[0A],	; cur, prv mode = super, super
			    p399;13388		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 22F  0B02,A053,DA20,04D3 J 4D3;13389			sim addr [sp]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  398
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13390
				;13391	;	CHMx, continued.
				;13392	;	Opcode breakout from user mode.
				;13393	;	Kernel changes to kernel, executive to exec, supervisor to super, user to user.
				;13394
				;13395	;	At this point,
				;13396	;		W1	=	SCB vector
				;13397
				;13398	;= ALIGNLIST 100x	(CHMK.FROM.USER,	CHME.FROM.USER,
				;13399	;=			 CHMS.FROM.USER,	CHMU.FROM.USER)
				;13400
				;13401	CHMK.FROM.USER:
				;13402		;---------------------------------------; opcode<1:0> = 00:
				;13403		VA <-- [KSP] - 1, LONG, 		; new stack is KSP
				;13404		Q&, [MMGT.MODE] <-- PASSB 000000[03],	; cur, prv mode = ker, user
			    p399;13405		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 238  0B02,A01B,DA00,04D3 J 4D3;13406			sim addr [sp]
				;13407
				;13408	CHME.FROM.USER:
				;13409		;---------------------------------------; opcode<1:0> = 01:
				;13410		VA <-- [ESP] - 1, LONG, 		; new stack is ESP
				;13411		Q&, [MMGT.MODE] <-- PASSB 000000[07],	; cur, prv mode = exec, user
			    p399;13412		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 23A  0B02,A03B,DA10,04D3 J 4D3;13413			sim addr [sp]
				;13414
				;13415	CHMS.FROM.USER:
				;13416		;---------------------------------------; opcode<1:0> = 10:
				;13417		VA <-- [SSP] - 1, LONG, 		; new stack is SSP
				;13418		Q&, [MMGT.MODE] <-- PASSB 000000[0B],	; cur, prv mode = super, user
			    p399;13419		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 23C  0B02,A05B,DA20,04D3 J 4D3;13420			sim addr [sp]
				;13421
				;13422	CHMU.FROM.USER:
				;13423		;---------------------------------------; opcode<1:0> = 11:
				;13424		VA <-- [USP] - 1, LONG, 		; new stack is USP
				;13425		Q&, [MMGT.MODE] <-- PASSB 000000[0F],	; cur, prv mode = user, user
			    p399;13426		GOTO [CHM.1ST.PROBE],			; go probe new stack
E 23E  0B02,A07B,DA30,04D3 J 4D3;13427			sim addr [sp]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  399
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13428
				;13429	;	CHMx, continued.
				;13430	;	Probe new stack.
				;13431
				;13432	;	At this point,
				;13433	;		W1	=	SCB vector
				;13434	;		Q<3:0>	=	new current mode'previous mode
				;13435	;		VA	=	new SP - 1
				;13436
				;13437	CHM.1ST.PROBE:
				;13438		;---------------------------------------;
				;13439		[W0] <-- PROBE.W.MODE (VA), LEN(DL),	; probe new SP - 1
E 4D3  007F,5604,04A0,04D4 J 4D4;13440		Q <-- [Q] LSH [22.]			; position new PSL<cur_mod,prv_mod>
				;13441
				;13442		;---------------------------------------;
				;13443		VA <-- [VA] - 000000[11.],		; calc new SP - 12
E 4D4  0AFC,205D,10B0,04D5 J 4D5;13444		[W3] <-- PROBE.W.MODE (VA), LEN(DL)	; probe
				;13445
				;13446		;---------------------------------------;
E 4D5  0400,30F8,0CC0,04D6 J 4D6;13447		[W2] <-- [PSL] AND 00[1F]0000, LONG	; isolate PSL<ipl>
				;13448
				;13449		;---------------------------------------;
E 4D6  0500,0050,0C30,04D7 J 4D7;13450		[W2] <-- [W2] OR [Q], LONG		; complete new PSL
				;13451
				;13452		;---------------------------------------;
				;13453		[W4] <-- B [S2], LONG,			; get current PC
E 4D7  0083,5048,1480,04D8 J 4D8;13454		Q <-- [S1] LSH [16.]			; set shifter sign to sign of argument
				;13455
				;13456		;---------------------------------------;
				;13457		[W5] <-- [PSL], LONG,			; save current psl
				;13458		ACCESS B [W0],				; test results of first probe
E 4D8  0000,0008,18C0,0504 J 504;13459			sim cond k s3.[2]
				;13460
				;13461		;---------------------------------------;
				;13462		[PSL] <-- [W2], LONG,			; update PSL = cur'prv + psl<ipl>
				;13463							; >> PSL change, no decode for 3 cycles
				;13464		ACCESS B [W3],				; test results of second probe
			    p401;13465		CASE [A31.BQA.BNZ1] AT [CHM.1ST.PROBE.FAIL], ; case on results of first probe
E 504  E000,0020,3030,471A B 51A;13466			sim cond k s3.[2]
				;13467
				;13468	CHM.1ST.PROBE.OK:
				;13469		;---------------------------------------; b<2:0> = 0:
				;13470		[WBUS] <-- [W1] ANDNOT 000000[03], LONG, ; longword align new PC
				;13471		LOAD PC,				; and load it
			    p401;13472							; >> LOAD PC: sync required before exit
E 51E  E4A4,2018,2020,471B B 51B;13473		CASE [A31.BQA.BNZ1] AT [CHM.2ND.PROBE.FAIL]	; case on results of second probe
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  400
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13474
				;13475	;	CHMx, continued.
				;13476	;	Stack probed, PSL, PC updated.
				;13477	;	Push operand, PC, PSL on stack.
				;13478
				;13479	;	At this point,
				;13480	;		W1	=	SCB vector
				;13481	;		W4	=	current PC
				;13482	;		W5	=	old PSL
				;13483	;		Q	=	sext (argument)
				;13484	;		VA	=	new SP - 12
				;13485
				;13486	CHM.2ND.PROBE.OK:
				;13487		;---------------------------------------; b<2:0> = 0:
E 51F  0001,9052,1390,04D9 J 4D9;13488		[W3] <-- SEXT [Q] RSH [16.], LONG	; sign extend argument
				;13489
				;13490		;---------------------------------------;
E 4D9  0000,0000,78B0,04DC J 4DC;13491		[SP] <-- [VA], LONG			; load new stack pointer
				;13492							; >> GPR write, all SQ references complete
				;13493
				;13494		;---------------------------------------;
E 4DC  0064,0000,2040,04DD J 4DD;13495		MEM (VA)&, [WBUS] <-- [W3], LONG	; write sext (argument) to stack top
				;13496							; >> sync with LOAD PC
				;13497
				;13498		;---------------------------------------;
				;13499		VA <-- [VA] + 4,			; increment stack pointer
E 4DD  0C64,802B,20B0,04E0 J 4E0;13500		MEM (VA)&, [WBUS] <-- PASSB [W4], LONG	; write current PC to stack
				;13501
				;13502		;---------------------------------------;
				;13503		VA <-- [VA] + 4,			; increment stack pointer
				;13504		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG, ; write previous PSL to stack
				;13505		RESTART IBOX,				; restart suspended I-box
E 4E0  0C64,8033,20B4,1000 L	;13506		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  401
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13507
				;13508	;	CHMx, continued.
				;13509	;	First probe failed.  Status is correct, VA is wrong, PSL has been clobbered.
				;13510
				;13511	;	At this point,
				;13512	;		VA	=	probe address - 11
				;13513	;		W5	=	old PSL
				;13514
				;13515	;= ALIGNLIST 101x	(CHM.1ST.PROBE.FAIL,	CHM.1ST.PROBE.OK)
				;13516
				;13517	CHM.1ST.PROBE.FAIL:
				;13518		;---------------------------------------; b<2:0> <> 0:
E 51A  0880,2059,20B0,051B J 51B;13519		VA <-- [VA] + 000000[11.]		; restore VA with faulting address
				;13520
				;13521	;	Second probe failed. Status is correct, VA is correct, PSL has been clobbered.
				;13522
				;13523	;	At this point,
				;13524	;		VA	=	probe address
				;13525	;		W5	=	old PSL
				;13526
				;13527	;= ALIGNLIST 101x	(CHM.2ND.PROBE.FAIL,	CHM.2ND.PROBE.OK)
				;13528
				;13529	CHM.2ND.PROBE.FAIL:
				;13530		;---------------------------------------; b<2:0> <> 0:
				;13531		[PSL] <-- [W5], LONG,			; restore PSL
				;13532							; >> PSL change, no decode for 3 cycles
				;13533		SYNCHRONIZE MBOX,			; >> sync with LOAD PC
			    p402;13534		STATE.2 <-- 1,				; flag write reference
E 51B  0020,0000,3069,8173 J 173;13535		GOTO [CHMX.PROBEX.MM.FAULT]		; join common fault flow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  402
;     OPSYS.MIC 	     CHMx										      /REV=
;															      OPSYS
				;13536
				;13537	;	Memory management fault from CHMx or PROBEx.
				;13538	;	Reset the CPU and join common memory management fault flows in
				;13539	;	INTEXC.MIC.
				;13540	;
				;13541	;	At this point,
				;13542	;		VA	=	faulting address
				;13543	;		MMGT.MODE =	reference mode
				;13544	;		STATE<2> =	0 if probe read failure,
				;13545	;				1 if probe write failure
				;13546
				;13547	CHMX.PROBEX.MM.FAULT:
				;13548		;---------------------------------------;
				;13549		[W4] <-- [VA], LONG,			; save faulting address
				;13550		Q <-- PASSB [PSL.TP]000000,		; mask to clear PSL<TP>
				;13551		RESET CPU,				; abort current operations
				;13552		CALL [IE.CLEANUP.CPU],			; cleanup CPU state,
			    p159;13553							; PSL<TP> = 0, SAVEPC = BPC
E 173  0002,BA00,14B6,22D7 S 2D7;13554			sim exception
				;13555
				;13556	;	Note: The following TBIS can not cause an infinite loop
				;13557	;	in the Mbox because the preceding RESET CPU and read of
				;13558	;	backup PC guarantee that there are no TB miss sequences
				;13559	;	in progress when the command enters the EM latch.
				;13560
				;13561		;---------------------------------------;
				;13562		VA <-- [W4],				; reload VA with faulting address
				;13563		TB INVALIDATE SINGLE,			; and invalidate the entry from the TB
			    p115;13564							; >> TB INVALIDATE, implicit sync performed
E 174  4010,0001,2050,4AD7 B 1D7;13565		CASE [STATE.2-0] AT [IE.MEMMGT.R]	; case on read vs. write into common flows
				;13566
;13567	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  403
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
;13568	.TOC	"	REI"
;13569
;13570	;	This instruction returns from an exception or interrupt.
;13571	;
;13572	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;13573	;	--------      ------	---------				----	-----		--------
;13574	;	REI		02	return from exception or interrupt	0	 --		REI..
;13575	;
;13576	;	Entry conditions:
;13577	;		source queue	=	new PC from stack (implicit specifier)
;13578	;					new PSL from stack (implicit specifier)
;13579	;		dest queue	=	none
;13580	;		branch queue	=	none
;13581	;		field queue	=	none
;13582	;		DL		=	unpredictable
;13583	;		Ibox state	=	stopped
;13584	;		Mbox state	=	running
;13585	;
;13586	;	Exit conditions:
;13587	;		New PC and PSL are popped from the stack.
;13588	;
;13589	;	Condition codes:
;13590	;		N <-- saved PSL<3>
;13591	;		Z <-- saved PSL<2>
;13592	;		V <-- saved PSL<1>		[Integer overflow trap disabled.]
;13593	;		C <-- saved PSL<0>
;13594	;
;13595	;	Notes:
;13596	;		1.  Performance:  Creating an implicit specifier allows the I-box to prefetch the new
;13597	;		    PC and PSL.
;13598	;		2.  Memory management:	Both longwords popped from the stack are checked for accessibility
;13599	;		    before any machine state is altered.
;13600	;
;13601	;				**** WARNING ****
;13602	;	Timing restriction:
;13603	;		A RESTART IBOX is done at the microinstructions in the 8-way
;13604	;		case at the labels REI.FROM.xxx before SP is updated with
;13605	;		the new mode SP at the 5-way case at the labels REI.NEW.xxx.
;13606	;		If the Ibox were to get started on the instruction at the
;13607	;		target of the REI before SP is updated by the Ebox, the
;13608	;		wrong value of SP will be used.  Because of both the pipeline
;13609	;		latency involved in the Ibox, and because the instruction
;13610	;		fetch is known to miss in the VIC (REI flushes the VIC),
;13611	;		the delay to the next instruction is known to be longer than
;13612	;		the delay to update SP in the Ebox.  This relationship depends
;13613	;		on the fact that there are no S3 or S4 stalls in the microwords
;13614	;		between the one that does the RESTART IBOX, and the one that
;13615	;		updates SP.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  404
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
;13616
;13617	;	For reference, the layout of the PSL is as follows:
;13618	;
;13619	;	 3 3 2 2 2 2 2 2 2 2 2 2       1 1
;13620	;	 1 0 9 8 7 6 5 4 3 2 1 0       6 5	       8 7 6 5 4 3 2 1 0
;13621	;	+-+-+---+-+-+---+---+-+---------+---------------+-+-+-+-+-+-+-+-+
;13622	;	| | |	|F| |	|   |M| 	|		| | | | | | | | |
;13623	;	|C|T|	|P|I|CUR|PRV|B| 	|		|D|F|I| | | | | | :PSL
;13624	;	|M|P|MBZ|D|S|MOD|MOD|Z|   IPL	|      MBZ	|V|U|V|T|N|Z|V|C|
;13625	;	+-+-+---+-+-+---+---+-+---------+---------------+-+-+-+-+-+-+-+-+
;13626	;
;13627	;	The new PSL is checked in hardware against the following rules:
;13628	;
;13629	;	let	tmp	=	new PSL popped off the stack
;13630	;	let	PSL	=	current PSL
;13631	;
;13632	;	Rule	SRM formulation 		    Comment
;13633	;	----	--------------- 		    -------
;13634	;	1	tmp<26> = 1 => tmp<20:16> > 0	    tmp<is> = 1 => tmp<ipl> > 0
;13635	;	2	tmp<20:16> > 0 => tmp<25:24> = 0    tmp<ipl> > 0 => tmp<cur_mode> = ker
;13636	;	3	tmp<25:24> LEQ tmp<23:22>	    tmp<cur_mode> LEQ tmp<prv_mode>
;13637	;	4	tmp<31,29:28,21,15:8> = 0	    tmp<mbz> = 0
;13638	;	5	tmp<25:24> GEQ PSL<25:24>	    tmp<cur_mode> GEQ PSL<cur_mode>
;13639	;	6	tmp<26> LEQ PSL<26>		    tmp<is> LEQ tmp<is>
;13640	;	7	tmp<20:16> LEQ PSL<20:16>	    tmp<ipl> LEQ PSL<ipl>
;13641	;
;13642	;	The following rule need not be explicitly checked (see the latest SRM):
;13643	;
;13644	;	8	tmp<26> = 1 => tmp<25:24> = 0	    tmp<is> = 1 => tmp<cur_mode> = ker
				;13645	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  405
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13646
				;13647	;	REI operation:
				;13648	;
				;13649	;		tmp1 <-- (SP)+
				;13650	;		tmp2 <-- (SP)+
				;13651	;		validity check tmp2
				;13652	;		PSL <-- tmp2 or PSL<30>
				;13653	;		PC <-- tmp1
				;13654	;		save current stack pointer
				;13655	;		if PSL<26> = 0 then load new stack pointer, check for AST's
				;13656
				;13657	REI..:
				;13658		;********** Hardware dispatch **********;
				;13659		[W0] <-- [S1],				; [1] get new PC
				;13660		Q <-- PASSB [S2], LONG, 		; get new PSL
E 198  0002,8048,0480,04E1 J 4E1;13661			sim cond k s4.[1]
				;13662
				;13663		;---------------------------------------;
				;13664		[W1] <-- B [Q], 			; [2] save new PSL
E 4E1  0083,D350,0800,04E2 J 4E2;13665		Q <-- ZEXT [Q] RSH [19.], LONG		; shift tmp<26:24> to Q<7:5>
				;13666
				;13667	;	(To kernel) Test rule #8:		tmp<31,29:28,21,15:8> = 0.
				;13668	;	(To other)  Test rules #5, 8:		tmp<31,29:28,21:16,15:8> = 0.
				;13669
				;13670		;---------------------------------------;
				;13671		ACCESS A [Q],				; [3] test Q<7:5> = tmp<26:24>
E 4E2  0001,C812,14A0,0226 J 226;13672		[W4] <-- ZEXT [W1] RSH [8.], LONG	; clear tmp<7:0>
				;13673
				;13674		;---------------------------------------;
			    p406;13675		[W4] <-- [W4] ANDNOT 00[4F]0000, LONG,	; [4] clear tmp<30,27:24>
E 226  A480,3278,1450,45C0 B 2C0;13676		CASE [A.7-5] AT [REI.TO.KERNEL] 	; case on tmp<26:24> from [3]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  406
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13677
				;13678	;	REI, continued.
				;13679	;	REI to kernel (kernel stack), rule #8 tested.
				;13680
				;13681	;	Check rule #1:			tmp<cur_mode> GEQ PSL<cur_mode>.
				;13682	;	Rule #2 can be skipped: 	tmp<is> LEQ PSL<is>.
				;13683	;	Rule #3 can be skipped: 	tmp<is> = 1 => tmp<cur_mode> = kernel.
				;13684	;	Rule #4 can be skipped: 	tmp<is> = 1 => tmp<ipl> > 0.
				;13685	;	Rule #5 can be skipped: 	tmp<ipl> > 0 => tmp<cur_mode> = kernel.
				;13686	;	Rule #6 can be skipped: 	tmp<cur_mode> LEQ tmp<prv_mode>.
				;13687	;	Test, check rule #7:		tmp<ipl> LEQ PSL<ipl>.
				;13688	;	Test, check rule #8:		tmp<mbz> = 0.
				;13689
				;13690	;	At this point,
				;13691	;		W0	=	new PC
				;13692	;		W1	=	new PSL
				;13693	;		W4	=	new PSL with bits<30,27:24,7:0> clear, right shifted 8
				;13694
				;13695	;= ALIGNLIST 000x	(REI.TO.KERNEL, REI.TO.EXEC,	REI.TO.SUPER,	REI.TO.USER,
				;13696	;=			 REI.TO.INT,	REI.TO.101,	REI.TO.110,	REI.TO.111)
				;13697
				;13698	REI.TO.KERNEL:
				;13699		;---------------------------------------; a<7:5> = 000:
				;13700		[WBUS] <-- [W4] ANDNOT 0000[0DF]00,	; [5] clear tmp<23:22,20:16>
			    p418;13701		LONG,					; all remaining bits must be zero
E 2C0  A480,2EF8,2050,6DD8 C 2D8;13702		CALL CASE [PSL.26-24] AT [REI.TO.KERNEL.FROM.KERNEL] ; case on PSL<25:24>,
				;13703							; [6] isolate tmp<ipl>
				;13704
				;13705		;---------------------------------------; psl<25:24> = 00:
				;13706		[W5] <-- [PSL] AND 00[1F]0000, LONG,	; [7] isolate PSL<ipl>
E 2C1  2400,30F8,18C0,41CB B 2CB;13707		CASE [ALU.NZV] AT [REI.TO.KERNEL.RULE.8.BAD]	; case on tmp<mbz> test from [5]
				;13708
				;13709	;= ALIGNLIST 10xx	(REI.TO.KERNEL.RULE.8.BAD,	REI.TO.KERNEL.RULE.8.OK)
				;13710	;  ALU.NZVC set by ANDNOT --> V = C = 0
				;13711
				;13712	REI.TO.KERNEL.RULE.8.BAD:
			    p127;13713		;---------------------------------------; alu.z = 0:
E 2CB  0000,0000,2000,003C J 03C;13714		RESERVED OPERAND FAULT			; [8] tmp<mbz> ne 0, fault
				;13715
				;13716	REI.TO.KERNEL.RULE.8.OK:
				;13717		;---------------------------------------; alu.z = 1:
			    p407;13718		[WBUS] <-- [W5] - [W4], LONG,		; [8] compare PSL<ipl> : tmp<ipl>
E 2CF  0A80,0028,2060,01FC J 1FC;13719		GOTO [REI.RULE.5.8.OK]			; skip rule #5
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  407
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13720
				;13721	;	REI, continued.
				;13722	;	REI to executive, rule #8 tested.
				;13723
				;13724	;	Check rule #1:			tmp<cur_mode> GEQ PSL<cur_mode>.
				;13725	;	Rule #2 can be skipped: 	tmp<is> LEQ PSL<is>.
				;13726	;	Rule #3 can be skipped: 	tmp<is> = 1 => tmp<cur_mode> = kernel.
				;13727	;	Rule #4 can be skipped: 	tmp<is> = 1 => tmp<ipl> > 0.
				;13728	;	Test, check rule #5:		tmp<cur_mode> NEQ 0 => tmp<ipl> = 0.
				;13729	;	Test rule #6:			tmp<cur_mode> LEQ tmp<prv_mode>.
				;13730	;	Rule #7 can be skipped: 	tmp<ipl> LEQ PSL<ipl>.
				;13731	;	Test, check rule #8:		tmp<mbz> = 0.
				;13732
				;13733	;	At this point,
				;13734	;		W0	=	new PC
				;13735	;		W1	=	new PSL
				;13736	;		W4	=	new PSL with bits<30,27:24,7:0> clear, right shifted 8
				;13737
				;13738	REI.TO.EXEC:
				;13739		;---------------------------------------; a<7:5> = 001:
				;13740		[W4] <-- [W4] ANDNOT 0000[0C0]00, LONG, ; [5] clear tmp<23:22>, remaining bits mbz
E 2C2  A480,2E00,1450,4DBB B 2BB;13741		CASE [PSL.26-24] AT [REI.TO.EXEC.FROM.KERNEL.EXEC]	; case on PSL<25:24>
				;13742
				;13743	;= ALIGNLIST 101x	(REI.TO.EXEC.FROM.KERNEL.EXEC,	REI.TO.EXEC.FROM.SUPER.USER)
				;13744
				;13745	REI.TO.EXEC.FROM.KERNEL.EXEC:
				;13746		;---------------------------------------; psl<25:24> = 0x:
				;13747		[W5] <-- [W1] AND 00[0C0]0000, LONG,	; [6] isolate tmp<prv_mode>
E 2BB  0400,3600,1820,0153 J 153;13748		GOTO [REI.TO.EXEC.CONT] 		; continue
				;13749
				;13750	REI.TO.EXEC.FROM.SUPER.USER:
			    p127;13751		;---------------------------------------; psl<25:24> = 1x:
E 2BF  0000,0000,2000,003C J 03C;13752		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;13753
				;13754	REI.TO.EXEC.CONT:
				;13755		;---------------------------------------;
				;13756		[WBUS] <-- [W5] - 00[040]0000, LONG,	; [7] compare tmp<prv_mode> : tmp<cur_mode>
E 153  2A80,3200,2060,41F8 B 1F8;13757		CASE [ALU.NZV] AT [REI.RULE.5.8.BAD]	; case on tmp<mbz+ipl> from cycle [5]
				;13758
				;13759	;= ALIGNLIST 10xx	(REI.RULE.5.8.BAD,	REI.RULE.5.8.OK)
				;13760	;  ALU.NZVC set by ANDNOT  --> V = C = 0
				;13761
				;13762	REI.RULE.5.8.BAD:
			    p127;13763		;---------------------------------------; alu.z = 0:
E 1F8  0000,0000,2000,003C J 03C;13764		RESERVED OPERAND FAULT			; [8] tmp<mbz+ipl> ne 0 when tmp<cur_mode> > 0, fault
				;13765
				;13766	REI.RULE.5.8.OK:
				;13767		;---------------------------------------; alu.z = 1:
				;13768		[W5] <-- [PSL] AND [40]000000,		; [8,9] isolate PSL<tp>
			    p412;13769		Q <-- PASSA [PSL], LONG,		; save current PSL
E 1FC  0402,7A00,18C0,0403 J 403;13770		GOTO [REI.CHECK.LAST.RULE]		; go check last rule
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  408
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13771
				;13772	;	REI, continued.
				;13773	;	REI to supervisor, rule #8 tested.
				;13774
				;13775	;	Check rule #1:			tmp<cur_mode> GEQ PSL<cur_mode>.
				;13776	;	Rule #2 can be skipped: 	tmp<is> LEQ PSL<is>.
				;13777	;	Rule #3 can be skipped: 	tmp<is> = 1 => tmp<cur_mode> = kernel.
				;13778	;	Rule #4 can be skipped: 	tmp<is> = 1 => tmp<ipl> > 0.
				;13779	;	Test, check rule #5:		tmp<cur_mode> NEQ 0 => tmp<ipl> = 0.
				;13780	;	Test rule #6:			tmp<cur_mode> LEQ tmp<prv_mode>.
				;13781	;	Rule #7 can be skipped: 	tmp<ipl> LEQ PSL<ipl>.
				;13782	;	Test, check rule #8:		tmp<mbz> = 0.
				;13783
				;13784	;	At this point,
				;13785	;		W0	=	new PC
				;13786	;		W1	=	new PSL
				;13787	;		W4	=	new PSL with bits<30,27:24,7:0> clear, right shifted 8
				;13788
				;13789	REI.TO.SUPER:
				;13790		;---------------------------------------; a<7:5> = 010:
				;13791		[W4] <-- [W4] ANDNOT 0000[0C0]00, LONG, ; [5] clear tmp<23:22>, remaining bits mbz
E 2C4  A480,2E00,1450,4DD9 B 2D9;13792		CASE [PSL.26-24] AT [REI.TO.SUPER.FROM.KERNEL]	; case on PSL<25:24>
				;13793
				;13794	;= ALIGNLIST 100x	(REI.TO.SUPER.FROM.KERNEL,	REI.TO.SUPER.FROM.EXEC,
				;13795	;=			 REI.TO.SUPER.FROM.SUPER,	REI.TO.SUPER.FROM.USER)
				;13796
				;13797	REI.TO.SUPER.FROM.KERNEL:
				;13798		;---------------------------------------; psl<25:24> = 00:
				;13799		[W5] <-- [W1] AND 00[0C0]0000, LONG,	; [6] isolate tmp<prv_mode>
E 2D9  0400,3600,1820,0155 J 155;13800		GOTO [REI.TO.SUPER.CONT]		; continue
				;13801
				;13802	REI.TO.SUPER.FROM.EXEC:
				;13803		;---------------------------------------; psl<25:24> = 01:
				;13804		[W5] <-- [W1] AND 00[0C0]0000, LONG,	; [6] isolate tmp<prv_mode>
E 2DB  0400,3600,1820,0155 J 155;13805		GOTO [REI.TO.SUPER.CONT]		; continue
				;13806
				;13807	REI.TO.SUPER.FROM.SUPER:
				;13808		;---------------------------------------; psl<25:24> = 10:
				;13809		[W5] <-- [W1] AND 00[0C0]0000, LONG,	; [6] isolate tmp<prv_mode>
E 2DD  0400,3600,1820,0155 J 155;13810		GOTO [REI.TO.SUPER.CONT]		; continue
				;13811
				;13812	REI.TO.SUPER.FROM.USER:
			    p127;13813		;---------------------------------------; psl<25:24> = 11:
E 2DF  0000,0000,2000,003C J 03C;13814		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;13815
				;13816	REI.TO.SUPER.CONT:
				;13817		;---------------------------------------;
			    p407;13818		[WBUS] <-- [W5] - 00[080]0000, LONG,	; [7] compare tmp<prv_mode> : tmp<cur_mode>
E 155  2A80,3400,2060,41F8 B 1F8;13819		CASE [ALU.NZV] AT [REI.RULE.5.8.BAD]	; case on tmp<mbz+ipl> from cycle [5]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  409
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13820
				;13821	;	REI, continued.
				;13822	;	REI to user, rule #8 tested.
				;13823
				;13824	;	Rule #1 can be skipped: 	tmp<cur_mode> GEQ PSL<cur_mode>.
				;13825	;	Rule #2 can be skipped: 	tmp<is> LEQ PSL<is>.
				;13826	;	Rule #3 can be skipped: 	tmp<is> = 1 => tmp<cur_mode> = kernel.
				;13827	;	Rule #4 can be skipped: 	tmp<is> = 1 => tmp<ipl> > 0.
				;13828	;	Test, check rule #5:		tmp<cur_mode> NEQ 0 => tmp<ipl> = 0.
				;13829	;	Test rule #6:			tmp<cur_mode> LEQ tmp<prv_mode>.
				;13830	;	Rule #7 can be skipped: 	tmp<ipl> LEQ PSL<ipl>.
				;13831	;	Test, check rule #8:		tmp<mbz> = 0.
				;13832
				;13833	;	At this point,
				;13834	;		W0	=	new PC
				;13835	;		W1	=	new PSL
				;13836	;		W4	=	new PSL with bits<30,27:24,7:0> clear, right shifted 8
				;13837
				;13838	REI.TO.USER:
				;13839		;---------------------------------------; a<7:5> = 011:
E 2C6  0480,2E00,1450,04E3 J 4E3;13840		[W4] <-- [W4] ANDNOT 0000[0C0]00, LONG	; [5] clear tmp<23:22>, remaining bits mbz
				;13841
				;13842		;---------------------------------------;
E 4E3  0400,3600,1820,0157 J 157;13843		[W5] <-- [W1] AND 00[0C0]0000, LONG	; [6] isolate tmp<prv_mode>
				;13844
				;13845		;---------------------------------------;
			    p407;13846		[WBUS] <-- [W5] - 00[0C0]0000, LONG,	; [7] compare tmp<prv_mode> : tmp<cur_mode>
E 157  2A80,3600,2060,41F8 B 1F8;13847		CASE [ALU.NZV] AT [REI.RULE.5.8.BAD]	; case on tmp<mbz+ipl> from cycle [5]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  410
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13848
				;13849	;	REI, continued.
				;13850	;	REI to kernel interrupt stack, rule #8 tested.
				;13851
				;13852	;	Check rule #1:			tmp<cur_mode> GEQ PSL<cur_mode>.
				;13853	;	Check rule #2:			tmp<is> LEQ PSL<is>.
				;13854	;	Rule #3 can be skipped: 	tmp<is> = 1 => tmp<cur_mode> = kernel.
				;13855	;	Check rule #4:			tmp<is> = 1 => tmp<ipl> > 0.
				;13856	;	Rule #5 can be skipped: 	tmp<ipl> > 0 => tmp<cur_mode> = kernel.
				;13857	;	Rule #6 can be skipped: 	tmp<cur_mode> LEQ tmp<prv_mode>.
				;13858	;	Test, check rule #7:		tmp<ipl> LEQ PSL<ipl>.
				;13859	;	Check rule #8:			tmp<mbz> = 0.
				;13860
				;13861	;	At this point,
				;13862	;		W0	=	new PC
				;13863	;		W1	=	new PSL
				;13864	;		W4	=	new PSL with bits<30,27:24,7:0> clear, right shifted 8
				;13865
				;13866	REI.TO.INT:
				;13867		;---------------------------------------; a<7:5> = 100:
				;13868		[WBUS] <-- [W4] ANDNOT 0000[0DF]00,	; [5] clear tmp<23:22,20:16>
			    p418;13869		LONG,					; all remaining bits must be zero
E 2C8  A480,2EF8,2050,6DD0 C 2D0;13870		CALL CASE [PSL.26-24] AT [REI.TO.KI.FROM.KERNEL] ; case on PSL<26:24>
				;13871							; [6] isolate tmp<ipl>
				;13872
				;13873		;---------------------------------------; psl<25:24> = 00:
				;13874		[W5] <-- [PSL] AND 00[1F]0000, LONG,	; [7] isolate PSL<ipl>
E 2C9  2400,30F8,18C0,41E8 B 2E8;13875		CASE [ALU.NZV] AT [REI.TO.INT.RULE.8.BAD]	; case on tmp<mbz> test from [5]
				;13876
				;13877	;= ALIGNLIST 10xx	(REI.TO.INT.RULE.8.BAD, REI.TO.INT.RULE.8.OK)
				;13878	;  ALU.NZVC set by ANDNOT --> V = C = 0
				;13879
				;13880	REI.TO.INT.RULE.8.BAD:
			    p127;13881		;---------------------------------------; alu.z = 0:
E 2E8  0000,0000,2000,003C J 03C;13882		RESERVED OPERAND FAULT			; [8] tmp<mbz> ne 0, fault
				;13883
				;13884	REI.TO.INT.RULE.8.OK:
				;13885		;---------------------------------------; alu.z = 1:
				;13886		[WBUS] <-- [W5] - [W4], LONG,		; [8] compare PSL<ipl> : tmp<ipl>
E 2EC  2A80,0028,2060,4130 B 230;13887		CASE [ALU.NZV] AT [REI.TO.INT.RULE.4.OK]	; case on tmp<ipl> test from [6]
				;13888
				;13889	;= ALIGNLIST x0xx	(REI.TO.INT.RULE.4.OK,	REI.TO.INT.RULE.4.BAD)
				;13890	;  ALU.NZVC set by AND with mask<31> = 0 --> N = V = C = 0
				;13891
				;13892	REI.TO.INT.RULE.4.OK:
				;13893		;---------------------------------------; alu.z = 0:
				;13894		[W5] <-- [PSL] AND [40]000000,		; [9] isolate PSL<tp>
			    p412;13895		Q <-- PASSA [PSL], LONG,		; save current PSL
E 230  0402,7A00,18C0,0403 J 403;13896		GOTO [REI.CHECK.LAST.RULE]		; go test last rule
				;13897
				;13898	REI.TO.INT.RULE.4.BAD:
			    p127;13899		;---------------------------------------; alu.z = 1:
E 234  0000,0000,2000,003C J 03C;13900		RESERVED OPERAND FAULT			; [9] tmp<ipl> = 0 when tmp<is> = 1
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  411
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13901
				;13902	;	REI, continued.
				;13903	;	New psl<26:24> invalid, fault.
				;13904
				;13905	REI.TO.101:
			    p127;13906		;---------------------------------------; a<7:5> = 101:
E 2CA  0000,0000,2000,003C J 03C;13907		RESERVED OPERAND FAULT			; [6] tmp<26:24> invalid, fault
				;13908
				;13909	REI.TO.110:
			    p127;13910		;---------------------------------------; a<7:5> = 110:
E 2CC  0000,0000,2000,003C J 03C;13911		RESERVED OPERAND FAULT			; [6] tmp<26:24> invalid, fault
				;13912
				;13913	REI.TO.111:
			    p127;13914		;---------------------------------------; a<7:5> = 111:
E 2CE  0000,0000,2000,003C J 03C;13915		RESERVED OPERAND FAULT			; [6] tmp<26:24> invalid, fault
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  412
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13916
				;13917	;	REI, continued.
				;13918	;	All rules (except last) validated.
				;13919	;	Load new PSL and PC, check last rule, check for AST.
				;13920
				;13921	;	At this point,
				;13922	;		W0	=	new PC
				;13923	;		W1	=	new PSL
				;13924	;		W4<20:16> =	new IPL (from kernel), 0 (from others)
				;13925	;		W5	=	old PSL<tp>
				;13926	;		Q	=	old PSL
				;13927
				;13928	;	Note:	Cycle counts are for new current_mode = exec, super, user;
				;13929	;		count for kernel is 1 greater.
				;13930
				;13931	REI.CHECK.LAST.RULE:
				;13932		;---------------------------------------;
				;13933		SYNCHRONIZE MBOX,			; [9] sync EM latch command with PSL change
				;13934		[PSL] <-- [W1] OR [W5], LONG,		; load new PSL + old PSL<tp>
				;13935							; >> Int sys change, no decode for 4 cycles
				;13936		FLUSH VIC,				; flush virtual instruction cache
				;13937							; >> FLUSH VIC: LOAD PC required
E 403  3520,C030,3020,4166 B 466;13938		CASE [ALU.NZV] AT [REI.VALID]		; case on prv_mode or ipl test from [7,8]
				;13939
				;13940	;= ALIGNLIST 011x	(REI.VALID,		REI.RSRV)
				;13941
				;13942	REI.RSRV:
				;13943		;---------------------------------------; alu.n  = 1:
				;13944		[PSL] <-- [Q], LONG,			; [10] restore original PSL
			    p127;13945							; >> Int sys change, no decode for 4 cycles
E 46E  0000,0000,30A0,003C J 03C;13946		RESERVED OPERAND FAULT			; reserved operand fault
				;13947
				;13948	REI.VALID:
				;13949		;---------------------------------------; alu.n = 0:
				;13950		[WBUS] <-- B [W0], LONG,		; [10] load new PC
				;13951		Q <-- [W1] LSH [5.],			; put new PSL<cur_mode> in <31:29>
				;13952		LOAD PC,				; restart prefetching
				;13953							; >> LOAD PC: queues must be empty
			    p413;13954							; >> LOAD PC: sync required before exit
E 466  A0A7,4508,2020,4D51 B 451;13955		CASE [PSL.26-24] AT [REI.FROM.KERNEL]	; case on PREVIOUS psl<cur_mode>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  413
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;13956
				;13957	;	REI, continued.
				;13958	;	Stack popped, new PC, PSL stored.
				;13959	;	Save stack pointer
				;13960	;
				;13961	;	At this point,
				;13962	;		Q	=	PSL<CUR_MOD> in bits <31:29>, other bits junk
				;13963
				;13964	;= ALIGNLIST 000x	(REI.FROM.KERNEL,	REI.FROM.EXEC,
				;13965	;=			 REI.FROM.SUPER,	REI.FROM.USER,
				;13966	;=			 REI.FROM.INTER,	REI.FROM.101,
				;13967	;=			 REI.FROM.110,		REI.FROM.111)
				;13968
				;13969	REI.FROM.KERNEL:
				;13970		;---------------------------------------; psl<26:24> = 000:
				;13971		[KSP] <-- [SP], LONG,			; [11] save Ibox-adjusted SP in per process stack
			    p415;13972		RESTART IBOX,				; restart suspending Ibox
E 451  0000,0000,81E4,04E4 J 4E4;13973		GOTO [REI.TEST.AST]			; go test for AST delivery
				;13974
				;13975	REI.FROM.EXEC:
				;13976		;---------------------------------------; psl<26:24> = 001:
				;13977		[ESP] <-- [SP], LONG,			; [11] save Ibox-adjusted SP in per process stack
			    p415;13978		RESTART IBOX,				; restart suspending Ibox
E 453  0000,0000,85E4,04E4 J 4E4;13979		GOTO [REI.TEST.AST]			; go test for AST delivery
				;13980
				;13981	REI.FROM.SUPER:
				;13982		;---------------------------------------; psl<26:24> = 010:
				;13983		[SSP] <-- [SP], LONG,			; [11] save Ibox-adjusted SP in per process stack
			    p415;13984		RESTART IBOX,				; restart suspending Ibox
E 455  0000,0000,89E4,04E4 J 4E4;13985		GOTO [REI.TEST.AST]			; go test for AST delivery
				;13986
				;13987	REI.FROM.USER:
				;13988		;---------------------------------------; psl<26:24> = 011:
				;13989		[USP] <-- [SP], LONG,			; [11] save Ibox-adjusted SP in per process stack
			    p415;13990		RESTART IBOX,				; restart suspending Ibox
E 457  0000,0000,8DE4,04E4 J 4E4;13991		GOTO [REI.TEST.AST]			; go test for AST delivery
				;13992
				;13993	REI.FROM.INTER:
				;13994		;---------------------------------------; psl<26:24> = 100:
				;13995		[ISP] <-- [SP], LONG,			; [11] save Ibox-adjusted SP in per process stack
			    p415;13996		RESTART IBOX,				; restart suspending Ibox
E 459  0000,0000,91E4,04E4 J 4E4;13997		GOTO [REI.TEST.AST]			; go test for AST delivery
				;13998
				;13999	REI.FROM.101:
				;14000		;---------------------------------------; psl<26:24> = 101:
			    p.84;14001		CONSOLE HALT [ERR.REI.PSL.26-24.101],	; [11] impossible PSL value, die
E 45B  0520,28E8,A4C0,0034 J 034;14002		SYNCHRONIZE MBOX			; >> sync with LOAD PC
				;14003
				;14004	REI.FROM.110:
				;14005		;---------------------------------------; psl<26:24> = 110:
			    p.84;14006		CONSOLE HALT [ERR.REI.PSL.26-24.101],	; [11] impossible PSL value, die
E 45D  0520,28E8,A4C0,0034 J 034;14007		SYNCHRONIZE MBOX			; >> sync with LOAD PC
				;14008
				;14009	REI.FROM.111:
				;14010		;---------------------------------------; psl<26:24> = 111:
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  414
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
			    p.84;14011		CONSOLE HALT [ERR.REI.PSL.26-24.101],	; [11] impossible PSL value, die
E 45F  0520,28E8,A4C0,0034 J 034;14012		SYNCHRONIZE MBOX			; >> sync with LOAD PC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  415
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;14013
				;14014	;	REI, continued.
				;14015	;	Stack pointer saved, test for AST delivery, load new stack pointer.
				;14016	;	The Ibox has been restarted and no stalls may occur before the new
				;14017	;	mode SP has been updated or the instruction at the target of the REI
				;14018	;	may read an inccorect SP value.
				;14019	;
				;14020	;	At this point,
				;14021	;		Q	=	PSL<CUR_MOD> in bits <31:29>, other bits junk
				;14022	;
				;14023	;	The AST delivery calculation is done by subtracting ASTLVL,
				;14024	;	left justified in <31:29> and zero-filled, from the new mode,
				;14025	;	also left justified in <31:29>, but with trailing junk.  The test is
				;14026	;
				;14027	;		if new mode >= ASTLVL, then deliver AST.
				;14028	;
				;14029	;	The calculation can be done with trailing junk because
				;14030	;
				;14031	;		new mode + 1 > new mode with junk >= new mode, always.
				;14032	;
				;14033	;	If new mode without junk >= ASTLVL, then
				;14034	;	   new mode with junk >= ASTLVL.
				;14035	;	If new mode without junk < ASTLVL, then
				;14036	;	   new mode with junk < ASTLVL.
				;14037
				;14038
				;14039	REI.TEST.AST:
				;14040		;---------------------------------------;
E 4E4  0400,3F00,0A50,0236 J 236;14041		[W1] <-- [ASTLVL] AND [0E0]000000, LONG ; [12] mask ASTLVL to 3 bits
				;14042							; >> RESTART IBOX done, no stalls
				;14043
				;14044		;---------------------------------------;
				;14045		[WBUS] <-- (-[W1] + [Q]), LONG, 	; [13] check for AST delivery
				;14046							; >> RESTART IBOX done, no stalls
				;14047		CASE [PSL.26-24] AT [REI.NEW.KERNEL],	; case on new PSL<cur_mode>
E 236  AA00,0050,2020,4D91 B 291;14048			sim cond k s4.[0]
				;14049
				;14050
				;14051	;= ALIGNLIST 000x	(REI.NEW.KERNEL,	REI.NEW.EXEC,
				;14052	;=			 REI.NEW.SUPER, 	REI.NEW.USER,
				;14053	;=			 REI.NEW.INTER)
				;14054	;  New psl<26:24> = 101, 110, 111 previously tested.
				;14055
				;14056	REI.NEW.KERNEL:
				;14057		;---------------------------------------; psl<26:24> = 000:
				;14058		[SP] <-- [KSP], LONG,			; [14] load new stack pointer
			    p417;14059							; >> RESTART IBOX done, no stalls
E 291  0000,0000,7A00,052A J 52A;14060		GOTO [REI.CHECK.AST]			; check for ast delivery
				;14061
				;14062	REI.NEW.EXEC:
				;14063		;---------------------------------------; psl<26:24> = 001:
				;14064		[SP] <-- [ESP], LONG,			; [14] load new stack pointer
			    p417;14065							; >> RESTART IBOX done, no stalls
E 293  0000,0000,7A10,052A J 52A;14066		GOTO [REI.CHECK.AST]			; check for ast delivery
				;14067
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  416
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;14068	REI.NEW.SUPER:
				;14069		;---------------------------------------; psl<26:24> = 010:
				;14070		[SP] <-- [SSP], LONG,			; [14] load new stack pointer
			    p417;14071							; >> RESTART IBOX done, no stalls
E 295  0000,0000,7A20,052A J 52A;14072		GOTO [REI.CHECK.AST]			; check for ast delivery
				;14073
				;14074	REI.NEW.USER:
				;14075		;---------------------------------------; psl<26:24> = 011:
				;14076		[SP] <-- [USP], LONG,			; [14] load new stack pointer
			    p417;14077							; >> RESTART IBOX done, no stalls
E 297  0000,0000,7A30,052A J 52A;14078		GOTO [REI.CHECK.AST]			; check for ast delivery
				;14079
				;14080	;	An S4 stall may occur on the CWB write in the following instruction,
				;14081	;	but only if the LOAD PC also stalls.  In that case, the Ibox has not
				;14082	;	yet even received the new PC, so the stall is OK.  In all other
				;14083	;	cases, the CWB write can not stall with respect to the RESTART IBOX.
				;14084
				;14085	REI.NEW.INTER:
				;14086		;---------------------------------------; psl<26:24> = 100:
				;14087		VA <-- K10.[IPR.CWB],			; [14] push writes out of the chip
				;14088		MEM.PR (VA)&,				; >> sync with LOAD PC
				;14089							; >> RESTART IBOX done, S4 stall OK
			    p417;14090		[SP] <-- PASSA [ISP], LONG,		; load new stack pointer
E 299  00F4,6883,7A41,05EC J 5EC;14091		GOTO [REI.NO.AST]			; no ast delivery for interrupt stack
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  417
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;14092
				;14093	;	REI, continued.
				;14094	;	Check AST delivery, push writes out of the chip
				;14095
				;14096	REI.CHECK.AST:
				;14097		;---------------------------------------; alu.c = 0:
				;14098		VA <-- K10.[IPR.CWB],			; [15] push writes out of the chip
				;14099		MEM.PR (VA)&, [WBUS] <-- PASSA [K0], LONG, ; >> sync with LOAD PC
E 52A  40F4,6883,2311,42EC B 5EC;14100		CASE [ALU.NZC] AT [REI.NO.AST]		; check for ast delivery
				;14101
				;14102	;= ALIGNLIST 110x	(REI.NO.AST,		REI.DELIVER.AST)
				;14103
				;14104	REI.NO.AST:
				;14105		;---------------------------------------; alu.c = 0:
E 5EC  0000,0000,2000,1000 L	;14106		LAST CYCLE				; [16] do next instruction
				;14107
				;14108	REI.DELIVER.AST:
				;14109		;---------------------------------------;
				;14110		[INT.SYS] <-- [INT.SYS] OR 000000[04],	; [16] set SISR<2>
				;14111		LONG,					; >> Int sys change, no decode for 4 cycles
E 5EE  0500,2020,C300,028C J 28C;14112		GOTO [INTERRUPT.STATE.CHANGE]		; wait for change, then do next instruction
				;14113
				;14114	;	Exit point for events which change the state of the
				;14115	;	interrupt system, and must therefore delay until the
				;14116	;	change is seen.
				;14117
				;14118	INTERRUPT.STATE.CHANGE:
			    p163;14119		;---------------------------------------; b<15:8> = 0:
E 28C  0000,0000,2000,22B7 S 2B7;14120		CALL [WAIT.TWO.CYCLES]
				;14121
				;14122		;---------------------------------------;
E 28D  0000,0000,2000,1000 L	;14123		LAST CYCLE				; do next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  418
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;14124
				;14125	;	Subroutine to validate current PSL if returning to kernel mode,
				;14126	;	kernel stack, or interrupt stack.
				;14127	;
				;14128	;	Entry conditions:
				;14129	;		W1	=	new PSL
				;14130	;
				;14131	;	Exit conditions:
				;14132	;		W4	=	new IPL, isolated in bits<20:16>
				;14133	;		reserved operand fault if illegal new mode
				;14134	;
				;14135	;	Note: the following two ALIGNLISTs are redundant in the sense
				;14136	;	that they constrain four microwords in an identical manner.
				;14137	;	They are required only to keep the allocation and microcode
				;14138	;	checks from flagging an error.
				;14139
				;14140	;= ALIGNLIST	000x	(REI.TO.KI.FROM.KERNEL, REI.TO.KI.FROM.EXEC,
				;14141	;=			 REI.TO.KI.FROM.SUPER,	REI.TO.KI.FROM.USER,
				;14142	;=			 REI.TO.KI.FROM.INT,	REI.TO.KI.FROM.101,
				;14143	;=			 REI.TO.KI.FROM.110,	REI.TO.KI.FROM.111)
				;14144	;
				;14145	;= ALIGNLIST	100x	(REI.TO.KERNEL.FROM.KERNEL, REI.TO.KERNEL.FROM.EXEC,
				;14146	;=			 REI.TO.KERNEL.FROM.SUPER,  REI.TO.KERNEL.FROM.USER)
				;14147
				;14148	REI.TO.KI.FROM.KERNEL:
			    p127;14149		;---------------------------------------; psl<26:24> = 000:, fault
E 2D0  0000,0000,2000,003C J 03C;14150		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;14151
				;14152	REI.TO.KI.FROM.EXEC:
			    p127;14153		;---------------------------------------; psl<26:24> = 001:, fault
E 2D2  0000,0000,2000,003C J 03C;14154		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;14155
				;14156	REI.TO.KI.FROM.SUPER:
			    p127;14157		;---------------------------------------; psl<26:24> = 010:, fault
E 2D4  0000,0000,2000,003C J 03C;14158		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;14159
				;14160	REI.TO.KI.FROM.USER:
			    p127;14161		;---------------------------------------; psl<26:24> = 011:, fault
E 2D6  0000,0000,2000,003C J 03C;14162		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;14163
				;14164	REI.TO.KI.FROM.INT:
				;14165	REI.TO.KERNEL.FROM.KERNEL:
				;14166		;---------------------------------------; psl<26:24> = 100:, fault
				;14167		[W4] <-- [W1] AND 00[1F]0000, LONG,	; [6] isolate tmp<ipl>
E 2D8  0400,30F8,1420,0800 R	;14168		RETURN					; return to caller
				;14169
				;14170	REI.TO.KI.FROM.101:
				;14171	REI.TO.KERNEL.FROM.EXEC:
			    p127;14172		;---------------------------------------; psl<26:24> = 101:, fault
E 2DA  0000,0000,2000,003C J 03C;14173		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;14174
				;14175	REI.TO.KI.FROM.110:
				;14176	REI.TO.KERNEL.FROM.SUPER:
			    p127;14177		;---------------------------------------; psl<26:24> = 110:, fault
E 2DC  0000,0000,2000,003C J 03C;14178		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  419
;     OPSYS.MIC 	     REI										      /REV=
;															      OPSYS
				;14179
				;14180	REI.TO.KI.FROM.111:
				;14181	REI.TO.KERNEL.FROM.USER:
			    p127;14182		;---------------------------------------; psl<26:24> = 111:, fault
E 2DE  0000,0000,2000,003C J 03C;14183		RESERVED OPERAND FAULT			; [6] tmp<cur_mode> < PSL<cur_mode>, fault
				;14184
;14185	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  420
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
;14186	.TOC	"	LDPCTX"
;14187
;14188	;	This instruction restores the principal CPU registers from the current process control block.
;14189	;
;14190	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;14191	;	--------      ------	---------				----	-----		--------
;14192	;	LDPCTX		06	restore process context 		0	 --		LDPCTX..
;14193	;
;14194	;	Entry conditions:
;14195	;		source queue	=	none
;14196	;		dest queue	=	none
;14197	;		branch queue	=	none
;14198	;		field queue	=	none
;14199	;		DL		=	unpredictable
;14200	;		Ibox state	=	stopped
;14201	;		Mbox state	=	running
;14202	;
;14203	;	Exit conditions:
;14204	;		Process context is restored from PCB.
;14205	;		New PC and PSL are pushed on the stack.
;14206	;
;14207	;	Condition codes:
;14208	;		N <-- N
;14209	;		Z <-- Z
;14210	;		V <-- V 		[Integer overflow trap disabled.]
;14211	;		C <-- C
;14212	;
;14213	;	Notes:
;14214	;		1.  Performance:  Reserved operand checking on the memory management operands adds
;14215	;		    words and microcycles.
;14216	;		2.  Memory management:	A SYNCHRONIZE MBOX is needed after reading the general registers
;14217	;		    to guarantee that errors are made visible before the PSL is altered and the stacks
;14218	;		    swapped.
;14219	;		3.  Memory management:	If not on the interrupt stack (an SRM violation), a machine
;14220	;		    check will cause the previous process' (kernel) SP to be stored in the current
;14221	;		    process KSP.
;14222	;		4.  Memory management:	SP is not updated from KSP prior to the final stack pushes;
;14223	;		    this is identical to Aquarius.
;14224	;
				;14225	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  421
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14226
				;14227	;	LDPCTX operation:
				;14228	;
				;14229	;		Check for kernel mode.
				;14230	;		Restore per process stack pointers.
				;14231	;		Restore R0-R13.
				;14232	;		Restore memory management parameters.
				;14233	;		Switch to kernel stack.
				;14234	;		Push new PC,PSL on new kernel stack.
				;14235
				;14236	LDPCTX..:
				;14237		;********** Hardware dispatch **********;
			    p422;14238		NOP,					; nothing to do
E 208  A000,0000,2000,4D18 B 218;14239		CASE [PSL.26-24] AT [LDPCTX.FROM.KERNEL]	; if not kernel mode, fault
				;14240
				;14241	;= ALIGNLIST 100x	(LDPCTX.FROM.KERNEL,	LDPCTX.FROM.EXEC,
				;14242	;=			 LDPCTX.FROM.SUPER,	LDPCTX.FROM.USER)
				;14243
				;14244	LDPCTX.FROM.EXEC:
			    p126;14245		;---------------------------------------; psl<25:24> = 01:
E 21A  0000,0000,2000,0100 J 100;14246		RESERVED INSTRUCTION FAULT		; reserved instruction fault
				;14247
				;14248	LDPCTX.FROM.SUPER:
			    p126;14249		;---------------------------------------; psl<25:24> = 10:
E 21C  0000,0000,2000,0100 J 100;14250		RESERVED INSTRUCTION FAULT		; reserved instruction fault
				;14251
				;14252	LDPCTX.FROM.USER:
			    p126;14253		;---------------------------------------; psl<25:24> = 11:
E 21E  0000,0000,2000,0100 J 100;14254		RESERVED INSTRUCTION FAULT		; reserved instruction fault
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  422
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14255
				;14256	;	LDPCTX, continued.
				;14257	;	Processor in kernel mode.
				;14258	;	Start restore of stack pointers and GPRs.
				;14259
				;14260	;	NOTE: The VAX Restart bit will be cleared on the first memory read to a GPR
				;14261	;	because the GPR appears in the DEST field.
				;14262
				;14263	LDPCTX.FROM.KERNEL:
				;14264		;---------------------------------------; psl<25:24> = 00:
				;14265		VA <-- [PCBB],				; VA <-- PCBB
				;14266		[W0] <-- MEM.PCB (VA), LONG,		; start read for KSP (PCB)
			    p429;14267		CALL [LDPCTX.READ.3.LONGWORDS], 	; read ESP, SSP, and USP into W1 - W3
E 218  0050,0001,0670,2536 S 536;14268			sim addr [pcb]
				;14269
				;14270		;---------------------------------------;
				;14271		VA <-- [VA] + 4,			; calculate next PCB address
				;14272		[R0] <-- MEM.PCB (VA), LONG,		; restore register
E 219  0C50,0009,40B0,04E5 J 4E5;14273		ACCESS B [W0]				; check mem mgt on PCB
				;14274
				;14275		;---------------------------------------;
				;14276		VA <-- [VA] + 4,			; calculate next PCB address
E 4E5  0C50,0001,44B0,04E8 J 4E8;14277		[R1] <-- MEM.PCB (VA), LONG		; restore register
				;14278
				;14279		;---------------------------------------;
				;14280		VA <-- [VA] + 4,			; calculate next PCB address
E 4E8  0C50,0001,48B0,04E9 J 4E9;14281		[R2] <-- MEM.PCB (VA), LONG		; restore register
				;14282
				;14283		;---------------------------------------;
				;14284		VA <-- [VA] + 4,			; calculate next PCB address
E 4E9  0C50,0001,4CB0,04EA J 4EA;14285		[R3] <-- MEM.PCB (VA), LONG		; restore register
				;14286
				;14287		;---------------------------------------;
				;14288		VA <-- [VA] + 4,			; calculate next PCB address
E 4EA  0C50,0001,50B0,04EB J 4EB;14289		[R4] <-- MEM.PCB (VA), LONG		; restore register
				;14290
				;14291		;---------------------------------------;
				;14292		VA <-- [VA] + 4,			; calculate next PCB address
E 4EB  0C50,0001,54B0,04EC J 4EC;14293		[R5] <-- MEM.PCB (VA), LONG		; restore register
				;14294
				;14295		;---------------------------------------;
			    p423;14296		VA <-- [VA] + 4,			; calculate next PCB address
E 4EC  0C50,0001,58B0,04ED J 4ED;14297		[R6] <-- MEM.PCB (VA), LONG		; restore register
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  423
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14298
				;14299	;	LDPCTX, continued.
				;14300	;	Continue restore of stack pointers and GPRs.
				;14301
				;14302	;	At this point,
				;14303	;		W0	=	new ksp
				;14304	;		W1	=	new esp
				;14305	;		W2	=	new ssp
				;14306	;		W3	=	new usp
				;14307
				;14308		;---------------------------------------;
				;14309		VA <-- [VA] + 4,			; calculate next PCB address
E 4ED  0C50,0001,5CB0,04F0 J 4F0;14310		[R7] <-- MEM.PCB (VA), LONG		; restore register
				;14311
				;14312		;---------------------------------------;
				;14313		VA <-- [VA] + 4,			; calculate next PCB address
E 4F0  0C50,0001,60B0,04F1 J 4F1;14314		[R8] <-- MEM.PCB (VA), LONG		; restore register
				;14315
				;14316		;---------------------------------------;
				;14317		VA <-- [VA] + 4,			; calculate next PCB address
E 4F1  0C50,0001,64B0,04F2 J 4F2;14318		[R9] <-- MEM.PCB (VA), LONG		; restore register
				;14319
				;14320		;---------------------------------------;
				;14321		VA <-- [VA] + 4,			; calculate next PCB address
E 4F2  0C50,0001,68B0,04F3 J 4F3;14322		[R10] <-- MEM.PCB (VA), LONG		; restore register
				;14323
				;14324		;---------------------------------------;
				;14325		VA <-- [VA] + 4,			; calculate next PCB address
E 4F3  0C50,0001,6CB0,04F4 J 4F4;14326		[R11] <-- MEM.PCB (VA), LONG		; restore register
				;14327
				;14328		;---------------------------------------;
				;14329		VA <-- [VA] + 4,			; calculate next PCB address
E 4F4  0C50,0001,70B0,04F5 J 4F5;14330		[R12] <-- MEM.PCB (VA), LONG		; restore register
				;14331
				;14332		;---------------------------------------;
				;14333		VA <-- [VA] + 4,			; calculate next PCB address
E 4F5  0C50,0001,74B0,04F8 J 4F8;14334		[R13] <-- MEM.PCB (VA), LONG		; restore register
				;14335
				;14336		;---------------------------------------;
				;14337		VA <-- [VA] + 4,			; calculate next PCB address
E 4F8  0C50,0001,14B0,04F9 J 4F9;14338		[W4] <-- MEM.PCB (VA), LONG		; read new pc
				;14339
				;14340		;---------------------------------------;
			    p424;14341		VA <-- [VA] + 4,			; calculate next PCB address
E 4F9  0C50,0001,18B0,04FA J 4FA;14342		[W5] <-- MEM.PCB (VA), LONG		; read new psl
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  424
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14343
				;14344	;	LDPCTX, continued.
				;14345	;	Finish restore of stack pointers, restore memory management parameters.
				;14346
				;14347	;	At this point,
				;14348	;		W0	=	new ksp
				;14349	;		W1	=	new esp
				;14350	;		W2	=	new ssp
				;14351	;		W3	=	new usp
				;14352	;		W4	=	new pc
				;14353	;		W5	=	new psl
				;14354
				;14355	;	Note: The following TBIP can not cause an infinite loop
				;14356	;	in the Mbox because the preceding MEM.PCB read acts as
				;14357	;	a synchronization point before the TBIP.  The two Mbox
				;14358	;	requests flow thru the pipe back-to-back because the
				;14359	;	access of W0 below can not stall because the read is
				;14360	;	executed many cycles before and one of the MEM.PCB reads
				;14361	;	would have caused an EM latch stall until the data is
				;14362	;	returned to W0.
				;14363
				;14364		;---------------------------------------;
				;14365		[KSP] <-- [W0], LONG,			; restore KSP
E 4FA  0014,0000,8010,04FB J 4FB;14366		TB INVALIDATE PROCESS			; invalidate process entries in TB
				;14367							; >> TB INVALIDATE, implicit sync performed
				;14368
				;14369		;---------------------------------------;
				;14370		[ESP] <-- B [W1], LONG, 		; restore ESP
E 4FB  1081,0010,8400,04FC J 4FC;14371		FLUSH BRANCH PREDICTION TABLE		; flush I-box branch prediction table
				;14372
				;14373		;---------------------------------------;
E 4FC  0000,0000,8830,04FD J 4FD;14374		[SSP] <-- [W2], LONG			; restore SSP
				;14375
				;14376		;---------------------------------------;
E 4FD  0080,0020,8C00,0365 J 365;14377		[USP] <-- B [W3], LONG			; restore USP
				;14378
				;14379		;---------------------------------------;
				;14380		VA <-- [VA] + 4,			; calculate next PCB address
			    p429;14381		[W0] <-- MEM.PCB (VA), LONG,		; start read for P0LR
E 365  0C50,0001,04B0,2536 S 536;14382		CALL [LDPCTX.READ.3.LONGWORDS]		; read rest of mem mgt into W1 - W3
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  425
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14383
				;14384	;	LDPCTX, continued.
				;14385	;	Entire PCB read.
				;14386	;	Now restore memory management registers.
				;14387
				;14388	;	At this point,
				;14389	;		W0	=	new p0br
				;14390	;		W1	=	new ast/p0lr
				;14391	;		W2	=	new p1br
				;14392	;		W3	=	new pme/p1lr
				;14393	;		W4	=	new pc
				;14394	;		W5	=	new psl
				;14395
				;14396	;	Note that ALL reserved operand checking has been omitted.
				;14397	;	Where mbz's might cause damage, they are cleared.
				;14398
				;14399		;---------------------------------------;
				;14400		VA <-- K10.[IPR.MP0BR], 		; write P0BR
				;14401		MEM.PR (VA)&, [WBUS] <-- PASSA [W0],	; to M-box
				;14402		LONG,					;
E 366  00F4,7C03,2011,0374 J 374;14403			sim addr [k]
				;14404
				;14405		;---------------------------------------;
				;14406		VA <-- K10.[IPR.MP0LR], 		; load P0LR address
				;14407		[W0] <-- PASSA [W1],			; move P0LR data to W0
			    p429;14408		CALL [SHIFT.AND.WRITE.PXLR],		; shift and write data to Mbox
E 374  0080,7C23,0421,2541 S 541;14409			sim addr [k]
				;14410
				;14411		;---------------------------------------;
E 375  0A80,3400,0C30,0531 J 531;14412		[W2] <-- [W2] - 00[P1BR.BIAS]0000, LONG ; pre-bias P1BR
				;14413
				;14414		;---------------------------------------;
				;14415		VA <-- K10.[IPR.MP1BR], 		; write P1BR
				;14416		MEM.PR (VA)&, [WBUS] <-- PASSA [W2],	; to M-box
				;14417		LONG,					;
E 531  00F4,7C43,2031,0532 J 532;14418			sim addr [k]
				;14419
				;14420		;---------------------------------------;
E 532  0880,3100,1040,037A J 37A;14421		[W3] <-- [W3] + 00[P1LR.BIAS.UNSHIFTED]0000, LONG ; pre-bias P1LR
				;14422
				;14423		;---------------------------------------;
				;14424		VA <-- K10.[IPR.MP1LR], 		; load P1LR address
				;14425		[W0] <-- PASSA [W3],			; move P1LR data to W0
			    p429;14426		CALL [SHIFT.AND.WRITE.PXLR],		; shift and write data to Mbox
E 37A  0080,7C63,0441,2541 S 541;14427			sim addr [k]
				;14428
				;14429		;---------------------------------------;
E 37B  0001,4502,0820,0533 J 533;14430		[W1] <-- [W1] LSH [5.]			; left justify AST
				;14431
			    p426;14432		;---------------------------------------;
E 533  0001,0312,0A50,0047 J 047;14433		[W1] <-- [ASTLVL]!![W1] LSH [3.], LONG	; merge CPUID, AST
				;14434
				;14435		;---------------------------------------;
				;14436		[ASTLVL] <-- [W1] RROT [3.], LONG,	; reposition data and store
				;14437		SYNCHRONIZE MBOX,			; synchronize MBOX to make errors visible
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  426
;     OPSYS.MIC 	     LDPCTX										      /REV=
;			    p427											      OPSYS
E 047  A021,8312,9420,4DF2 B 0F2;14438		CASE [PSL.26-24] AT [LDPCTX.KERNEL.STK] ; if not on int stack, already on kernel
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  427
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14439
				;14440	;	LDPCTX, continued.
				;14441	;	General registers and memory management restored.
				;14442	;	Switch from interrupt to kernel stack.
				;14443	;	Push new PC, PSL on kernel stack and exit.
				;14444
				;14445	;	At this point,
				;14446	;		W3<31>	=	pme
				;14447	;		W4	=	new pc
				;14448	;		W5	=	new psl
				;14449
				;14450	;	The CASE above is unnecessary per the latest revision of the
				;14451	;	SRM, since LDPCTX is undefined if not executed from the interrupt
				;14452	;	stack.	However, since it costs nothing in space or time, it
				;14453	;	is left in to insure bug-for-bug compatibility with other machines.
				;14454
				;14455	;= ALIGNLIST 0xxx	(LDPCTX.KERNEL.STK,	LDPCTX.INT.STK)
				;14456	;  mode = kernel --> PSL<25:24> = 00
				;14457
				;14458	LDPCTX.INT.STK:
				;14459		;---------------------------------------; psl<26> = 1:
E 0FA  0480,3820,30C0,0534 J 534;14460		[PSL] <-- [PSL] ANDNOT [04]000000, LONG ; clear PSL<is>
				;14461							; >> PSL change, no decode for 3 cycles
				;14462
				;14463		;---------------------------------------;
E 534  0000,0000,91E0,00F2 J 0F2;14464		[ISP] <-- [SP], LONG			; save current stack pointer as ISP
				;14465
				;14466	LDPCTX.KERNEL.STK:
				;14467		;---------------------------------------; psl<26> = 0:
				;14468		VA <-- [KSP] - 4,			; decrement new stack
				;14469		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG, ; push PSL on stack
			    p139;14470		CALL [WRITE.W4.PREV],			; push PC on stack
E 0F2  0CE4,8033,2200,2267 S 267;14471			sim addr [sp]
				;14472
				;14473		;---------------------------------------;
E 0F3  0A80,2040,7A00,0535 J 535;14474		[SP] <-- [KSP] - 000000[08.], LONG	; switch to new stack, update
				;14475
				;14476		;---------------------------------------;
			    p428;14477		VA <-- K10.[IPR.CWB],			; push writes out of the chip
E 535  00F4,6883,2041,0515 J 515;14478		MEM.PR (VA)&, [WBUS] <-- PASSA [W3], LONG ; test pme
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  428
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14479
				;14480	;	LDPCTX, continued.
				;14481	;	All operations complete except for PME update.	This code is also
				;14482	;	used as a common exit path from MTPR to the PME processor register.
				;14483	;
				;14484	;	At this point,
				;14485	;		PME tested on Abus<31> in previous cycle
				;14486
				;14487	LDPCTX.MTPR.UPDATE.PME:
				;14488		;---------------------------------------;
				;14489		[WBUS] <-- [ECR] AND 00[ECR.PMF.ENABLE]0000, ; test current state of pme
E 515  E400,3008,23A0,4757 B 557;14490		CASE [A31.BQA.BNZ1] AT [LDPCTX.MTPR.PME.0] ; case on new pme value
				;14491
				;14492	;= ALIGNLIST	011x	(LDPCTX.MTPR.PME.0,	LDPCTX.MTPR.PME.1)
				;14493
				;14494	LDPCTX.MTPR.PME.0:
				;14495		;---------------------------------------; a<31> = 0:
				;14496		[ECR] <-- [ECR] ANDNOT 00[ECR.PMF.ENABLE]0000, ; disable counters
			    p496;14497		LONG,
E 557  0480,3008,EBA0,2177 S 177;14498		CALL [UPDATE.PMF.COUNTERS]		; update the memory counters
				;14499
				;14500		;---------------------------------------;
				;14501		RESTART IBOX,				; restart suspended Ibox,
E 558  0000,0000,2004,1000 L	;14502		LAST CYCLE				; decode next instruction
				;14503
				;14504	LDPCTX.MTPR.PME.1:
				;14505		;---------------------------------------; a<31> = 0:
				;14506		[ECR] <-- [ECR] OR 00[ECR.PMF.ENABLE]0000, ; enable pmf counters
				;14507		LONG,
				;14508		RESTART IBOX,				; restart Ibox
E 55F  0500,3008,EBA4,1000 L	;14509		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  429
;     OPSYS.MIC 	     LDPCTX										      /REV=
;															      OPSYS
				;14510
				;14511	;	LDPCTX subroutines.
				;14512
				;14513	;	LDPCTX.READ.3.LONGWORDS reads three longwords from the PCB, storing
				;14514	;	the data into W1 - W3.
				;14515
				;14516	LDPCTX.READ.3.LONGWORDS:
				;14517		;---------------------------------------;
				;14518		VA <-- [VA] + 4,			; calculate next PCB address
E 536  0C50,0001,08B0,0537 J 537;14519		[W1] <-- MEM.PCB (VA), LONG		; restore register
				;14520
				;14521		;---------------------------------------;
				;14522		VA <-- [VA] + 4,			; calculate next PCB address
E 537  0C50,0001,0CB0,0540 J 540;14523		[W2] <-- MEM.PCB (VA), LONG		; restore register
				;14524
				;14525		;---------------------------------------;
				;14526		VA <-- [VA] + 4,			; calculate next PCB address
				;14527		[W3] <-- MEM.PCB (VA), LONG,		; restore register
E 540  0C50,0001,10B0,0800 R	;14528		RETURN					; return to caller
				;14529
				;14530
				;14531	;	SHIFT.AND.WRITE.PXLR shifts the PxLR data left by 9 bits, then
				;14532	;	writes it to the Mbox.
				;14533	;
				;14534	;	At this point,
				;14535	;		W0	=	Right-justified data to write
				;14536	;		VA	=	IPR address of the register
				;14537
				;14538	SHIFT.AND.WRITE.PXLR:
				;14539		;---------------------------------------;
				;14540		MEM.PR (VA)&, [WBUS] <-- [W0] LSH [9.], ; shift value and
				;14541		LONG,					; write to Mbox
E 541  0075,4902,2010,0800 R	;14542		RETURN					; return to caller
				;14543
;14544	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  430
;     OPSYS.MIC 	     SVPCTX										      /REV=
;															      OPSYS
;14545	.TOC	"	SVPCTX"
;14546
;14547	;	This instruction saves the principal CPU registers in the current process control block.
;14548	;
;14549	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;14550	;	--------      ------	---------				----	-----		--------
;14551	;	SVPCTX		07	restore process context 		0	 --		SVPCTX..
;14552	;
;14553	;	Entry conditions:
;14554	;		source queue	=	new PC from stack (implicit specifier)
;14555	;					new PSL from stack (implicit specifier)
;14556	;		dest queue	=	none
;14557	;		branch queue	=	none
;14558	;		field queue	=	none
;14559	;		DL		=	unpredictable
;14560	;		Ibox state	=	stopped
;14561	;		Mbox state	=	running
;14562	;
;14563	;	Exit conditions:
;14564	;		Process context is saved in PCB.
;14565	;		New PC and PSL are pushed on the stack.
;14566	;
;14567	;	Condition codes:
;14568	;		N <-- N
;14569	;		Z <-- Z
;14570	;		V <-- V 		[Integer overflow trap disabled.]
;14571	;		C <-- C
;14572	;
;14573	;	Notes:
;14574	;		1.  Performance:  Creating an implicit specifier allows the I-box to prefetch the new
;14575	;		    the new PC and PSL.
;14576	;		2.  Memory management:	Both stack reads are checked before machine sate is altered.
;14577	;		3.  Memory management:	The CLEAR WRITE BUFFERS guarantees that memory management errors
;14578	;		    are made visible before instruction completion.
;14579	;
				;14580	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  431
;     OPSYS.MIC 	     SVPCTX										      /REV=
;															      OPSYS
				;14581
				;14582	;	SVPCTX operation:
				;14583	;
				;14584	;		Check for kernel mode.
				;14585	;		Pop current PC, PSL from stack.
				;14586	;		Switch to interrupt stack.
				;14587	;		Save per process stack pointers.
				;14588	;		Save R0-R13.
				;14589	;		Push current PC, PSL.
				;14590
				;14591	SVPCTX..:
				;14592		;********** Hardware dispatch **********;
				;14593		NOP,					; sync with Fbox for PSL
				;14594							; read later
E 20A  A000,0000,2000,4D39 B 239;14595		CASE [PSL.26-24] AT [SVPCTX.FROM.KERNEL] ; if not kernel mode, fault
				;14596
				;14597
				;14598	;= ALIGNLIST 100x	(SVPCTX.FROM.KERNEL,	SVPCTX.FROM.EXEC,
				;14599	;=			 SVPCTX.FROM.SUPER,	SVPCTX.FROM.USER)
				;14600
				;14601	SVPCTX.FROM.EXEC:
			    p126;14602		;---------------------------------------; psl<25:24> = 01:
E 23B  0000,0000,2000,0100 J 100;14603		RESERVED INSTRUCTION FAULT		; reserved instruction fault
				;14604
				;14605	SVPCTX.FROM.SUPER:
			    p126;14606		;---------------------------------------; psl<25:24> = 10:
E 23D  0000,0000,2000,0100 J 100;14607		RESERVED INSTRUCTION FAULT		; reserved instruction fault
				;14608
				;14609	SVPCTX.FROM.USER:
			    p126;14610		;---------------------------------------; psl<25:24> = 11:
E 23F  0000,0000,2000,0100 J 100;14611		RESERVED INSTRUCTION FAULT		; reserved instruction fault
				;14612
				;14613	SVPCTX.FROM.KERNEL:
				;14614		;---------------------------------------; psl<25:24> = 00:
				;14615		[W4] <-- [S1], LONG,			; get PC popped from stack
E 239  0002,8048,1480,004A J 04A;14616		Q <-- PASSB [S2]			; get PSL popped from stack
				;14617
				;14618		;---------------------------------------;
				;14619		VA <-- [PCBB],				; load PCBB into VA
				;14620		[W5] <-- PASSB [Q], LONG,		; save popped PSL
			    p432;14621		CASE [PSL.26-24] AT [SVPCTX.ON.KERNEL.STACK], ; case on PSL<is>
E 04A  A000,8053,1A70,4D55 B 055;14622			sim addr [pcb]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  432
;     OPSYS.MIC 	     SVPCTX										      /REV=
;															      OPSYS
				;14623
				;14624	;	SVPCTX, continued.
				;14625	;	Processor in kernel mode on kernel stack.
				;14626	;	Save current SP, modify PSL, load new SP.
				;14627
				;14628	;	At this point,
				;14629	;		W4	=	pc to save
				;14630	;		W5	=	psl to save
				;14631	;		VA	=	PCBB
				;14632
				;14633	;= ALIGNLIST 0xxx	(SVPCTX.ON.KERNEL.STACK, SVPCTX.SAVE.STATE.IN.PCB)
				;14634	;  PSL<25:24> = 00 from above --> PSL<26:24> = ?00
				;14635
				;14636	SVPCTX.ON.KERNEL.STACK:
				;14637		;---------------------------------------; psl<is> = 0:
				;14638		NODST <-- [PSL] AND 00[1F]0000, LONG,	; test PSL<ipl>
				;14639		[W0] <-- PASSA [PSL],			; save current PSL
E 055  0400,70FA,04C0,0542 J 542;14640			sim cond k s4.[0]
				;14641
				;14642		;---------------------------------------;
E 542  0000,0000,81E0,0175 J 175;14643		[KSP] <-- [SP], LONG			; save current stack in KSP
				;14644
				;14645		;---------------------------------------;
				;14646		[SP] <-- [ISP], LONG,			; switch to interrupt stack
E 175  2000,0000,7A40,4191 B 191;14647		CASE [ALU.NZV] AT [SVPCTX.IPL.NOT.ZERO] ; case on PSL<ipl> = 0
				;14648
				;14649	;= ALIGNLIST x0xx	(SVPCTX.IPL.NOT.ZERO,	SVPCTX.IPL.ZERO)
				;14650	;  ALU.NZVC set by AND with mask<31> = 0 --> N = V = C = 0
				;14651
				;14652	SVPCTX.IPL.ZERO:
				;14653		;---------------------------------------; alu.z = 1:
E 195  0500,3008,0410,0191 J 191;14654		[W0] <-- [W0] OR 00[01]0000, LONG	; PSL<ipl> = 0, force it to 1
				;14655
				;14656	SVPCTX.IPL.NOT.ZERO:
				;14657		;---------------------------------------; alu.z = 0:
				;14658		[PSL] <-- [W0] OR [04]000000, LONG,	; set PSL<is>
			    p433;14659							; >> Int sys change, no decode for 4 cycles
E 191  0500,3820,3010,005D J 05D;14660		GOTO [SVPCTX.SAVE.STATE.IN.PCB] 	; go save state in PCB
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  433
;     OPSYS.MIC 	     SVPCTX										      /REV=
;															      OPSYS
				;14661
				;14662	;	SVPCTX, continued.
				;14663	;	Processor on interrupt stack, PSL modified.
				;14664	;	Write the process state to the PCB.
				;14665
				;14666	;	At this point,
				;14667	;		W4	=	pc to save
				;14668	;		W5	=	psl to save
				;14669	;		VA	=	PCBB
				;14670
				;14671	SVPCTX.SAVE.STATE.IN.PCB:
				;14672		;---------------------------------------; psl<is> = 1:
E 05D  0070,0000,2200,0370 J 370;14673		MEM.PCB (VA)&, [WBUS] <-- [KSP], LONG	; save KSP
				;14674
				;14675		;---------------------------------------;
			    p436;14676		[W1] <-- [ESP], LONG,			; get ESP
E 370  0000,0000,0A10,255A S 55A;14677		CALL [WRITE.W1.PCB.NEXT]		; save
				;14678
				;14679		;---------------------------------------;
			    p436;14680		[W1] <-- [SSP], LONG,			; get SSP
E 371  0000,0000,0A20,255A S 55A;14681		CALL [WRITE.W1.PCB.NEXT]		; save
				;14682
				;14683		;---------------------------------------;
			    p436;14684		[W1] <-- [USP], LONG,			; get USP
E 372  0000,0000,0A30,255A S 55A;14685		CALL [WRITE.W1.PCB.NEXT]		; save
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  434
;     OPSYS.MIC 	     SVPCTX										      /REV=
;															      OPSYS
				;14686
				;14687	;	SVPCTX, continued.
				;14688	;	Stack pointers saved, save R0 - R6.
				;14689
				;14690	;	At this point,
				;14691	;		W4	=	pc to save
				;14692	;		W5	=	psl to save
				;14693
				;14694		;---------------------------------------;
				;14695		VA <-- [VA] + 4,			; calculate next PCB address
E 373  0C70,8083,20B0,0543 J 543;14696		MEM.PCB (VA)&, [WBUS] <-- PASSB [R0], LONG ; save register
				;14697
				;14698		;---------------------------------------;
				;14699		VA <-- [VA] + 4,			; calculate next PCB address
E 543  0C70,808B,20B0,0544 J 544;14700		MEM.PCB (VA)&, [WBUS] <-- PASSB [R1], LONG ; save register
				;14701
				;14702		;---------------------------------------;
				;14703		VA <-- [VA] + 4,			; calculate next PCB address
E 544  0C70,8093,20B0,0545 J 545;14704		MEM.PCB (VA)&, [WBUS] <-- PASSB [R2], LONG ; save register
				;14705
				;14706		;---------------------------------------;
				;14707		VA <-- [VA] + 4,			; calculate next PCB address
E 545  0C70,809B,20B0,0547 J 547;14708		MEM.PCB (VA)&, [WBUS] <-- PASSB [R3], LONG ; save register
				;14709
				;14710		;---------------------------------------;
				;14711		VA <-- [VA] + 4,			; calculate next PCB address
E 547  0C70,80A3,20B0,0548 J 548;14712		MEM.PCB (VA)&, [WBUS] <-- PASSB [R4], LONG ; save register
				;14713
				;14714		;---------------------------------------;
				;14715		VA <-- [VA] + 4,			; calculate next PCB address
E 548  0C70,80AB,20B0,054A J 54A;14716		MEM.PCB (VA)&, [WBUS] <-- PASSB [R5], LONG ; save register
				;14717
				;14718		;---------------------------------------;
			    p435;14719		VA <-- [VA] + 4,			; calculate next PCB address
E 54A  0C70,80B3,20B0,054C J 54C;14720		MEM.PCB (VA)&, [WBUS] <-- PASSB [R6], LONG ; save register
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  435
;     OPSYS.MIC 	     SVPCTX										      /REV=
;															      OPSYS
				;14721
				;14722	;	SVPCTX, continued.
				;14723	;	Save R7 - R13.
				;14724
				;14725	;	At this point,
				;14726	;		W4	=	pc to save
				;14727	;		W5	=	psl to save
				;14728
				;14729		;---------------------------------------;
				;14730		VA <-- [VA] + 4,			; calculate next PCB address
E 54C  0C70,80BB,20B0,054D J 54D;14731		MEM.PCB (VA)&, [WBUS] <-- PASSB [R7], LONG ; save register
				;14732
				;14733		;---------------------------------------;
				;14734		VA <-- [VA] + 4,			; calculate next PCB address
E 54D  0C70,80C3,20B0,0550 J 550;14735		MEM.PCB (VA)&, [WBUS] <-- PASSB [R8], LONG ; save register
				;14736
				;14737		;---------------------------------------;
				;14738		VA <-- [VA] + 4,			; calculate next PCB address
E 550  0C70,80CB,20B0,0551 J 551;14739		MEM.PCB (VA)&, [WBUS] <-- PASSB [R9], LONG ; save register
				;14740
				;14741		;---------------------------------------;
				;14742		VA <-- [VA] + 4,			; calculate next PCB address
E 551  0C70,80D3,20B0,0552 J 552;14743		MEM.PCB (VA)&, [WBUS] <-- PASSB [R10], LONG ; save register
				;14744
				;14745		;---------------------------------------;
				;14746		VA <-- [VA] + 4,			; calculate next PCB address
E 552  0C70,80DB,20B0,0553 J 553;14747		MEM.PCB (VA)&, [WBUS] <-- PASSB [R11], LONG ; save register
				;14748
				;14749		;---------------------------------------;
				;14750		VA <-- [VA] + 4,			; calculate next PCB address
E 553  0C70,80E3,20B0,0554 J 554;14751		MEM.PCB (VA)&, [WBUS] <-- PASSB [R12], LONG ; save register
				;14752
				;14753		;---------------------------------------;
			    p436;14754		VA <-- [VA] + 4,			; calculate next PCB address
E 554  0C70,80EB,20B0,0555 J 555;14755		MEM.PCB (VA)&, [WBUS] <-- PASSB [R13], LONG ; save register
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  436
;     OPSYS.MIC 	     SVPCTX										      /REV=
;															      OPSYS
				;14756
				;14757	;	SVPCTX, continued.
				;14758	;	Save popped PC, PSL.
				;14759
				;14760	;	At this point,
				;14761	;		W4	=	pc to save
				;14762	;		W5	=	psl to save
				;14763
				;14764		;---------------------------------------;
				;14765		VA <-- [VA] + 4,			; calculate next PCB address
E 555  0C70,802B,20B0,0556 J 556;14766		MEM.PCB (VA)&, [WBUS] <-- PASSB [W4], LONG ; save PC
				;14767
				;14768		;---------------------------------------;
				;14769		VA <-- [VA] + 4,			; calculate next PCB address
E 556  0C70,8033,20B0,0559 J 559;14770		MEM.PCB (VA)&, [WBUS] <-- PASSB [W5], LONG ; save PSL
				;14771
				;14772		;---------------------------------------;
				;14773		VA <-- K10.[IPR.CWB],			; push writes out of the chip
			    p351;14774		MEM.PR (VA)&, [WBUS] <-- PASSA [K0], LONG,
E 559  00F4,6883,2311,0507 J 507;14775		GOTO [RESTART.IBOX]			; restart Ibox and decode
				;14776
				;14777
				;14778	;	SVPCTX subroutines.
				;14779
				;14780	;	Subroutine to write one word to PCB from W1.
				;14781
				;14782	WRITE.W1.PCB.NEXT:
				;14783		;---------------------------------------;
				;14784		VA <-- [VA] + 4,			; calculate next PCB address
				;14785		MEM.PCB (VA)&, [WBUS] <-- PASSB [W1], LONG, ; write value
E 55A  0C70,8013,20B0,0800 R	;14786		RETURN					; return to caller
				;14787
;14788	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  437
;     OPSYS.MIC 	     PROBEx										      /REV=
;															      OPSYS
;14789	.TOC	"	PROBEx"
;14790
;14791	;	These instructions test the read or write accessibility of a given region of virtual address space.
;14792	;
;14793	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;14794	;	--------      ------	---------				----	-----		--------
;14795	;	PROBER		0C	psl.z <-- probe.read(mode,length,base)	3	rra/bwb 	PROBEX..
;14796	;	PROBEW		0D	psl.z <-- probe.write(mode,length,base) 3	rra/bwb 	PROBEX..
;14797	;
;14798	;	Entry conditions:
;14799	;		source queue	=	mode.rb operand (not zero extended)
;14800	;					len.rw operand (not zero extended)
;14801	;					base.ab operand
;14802	;		dest queue	=	none
;14803	;		branch queue	=	none
;14804	;		field queue	=	none
;14805	;		DL		=	BYTE
;14806	;		Ibox state	=	running
;14807	;		Mbox state	=	running
;14808	;
;14809	;	Exit conditions:
;14810	;		The PSL condition codes reflect the result of the probe test.
;14811	;
;14812	;	Condition codes:
;14813	;		N <-- 0
;14814	;		Z <-- 0 if accessible, 1 if not
;14815	;		V <-- 0 		[Integer overflow trap disabled.]
;14816	;		C <-- C
;14817	;
;14818	;	Notes:
;14819	;		1.  PROBEx can take a translation not valid fault.  This occurs if the system PTE
;14820	;		    mapping the process PTE for the address being probed is invalid.
;14821	;		2.  PROBEx can probably be optimized better in the first few microwords.
;14822	;		    The brute force method was used to remove the ALU ZEXTWL function from
;14823	;		    the first microword of the flow.
;14824	;
				;14825	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  438
;     OPSYS.MIC 	     PROBEx										      /REV=
;															      OPSYS
				;14826
				;14827	;	PROBEx operation:
				;14828	;
				;14829	;		if {base .. base+size-1 accessible}
				;14830	;			then psl.z <-- 0 else psl.z <-- 1
				;14831
				;14832	PROBEX..:
				;14833		;********** Hardware dispatch **********;
				;14834		[W1] <-- [S1], LONG,			; get operand mode
E 20C  0001,5E00,0880,0412 J 412;14835		NODST <-- [S1] LSH [30.]		; test mode<1> as shifter sign
				;14836
				;14837		;---------------------------------------;
				;14838		[W0] <-- [S1] AND [K.FFFF], LONG,	; zero extend length
				;14839		CASE [PSL.29.23-22] AT [PROBEX.PM.00],	; case on PSL<prv_mode>
E 412  C400,0070,0480,4E79 B 479;14840			sim cond k s3.[2]
				;14841
				;14842	;= ALIGNLIST 100x	(PROBEX.PM.00,	PROBEX.PM.01,
				;14843	;=			 PROBEX.PM.10,	PROBEX.PM.11)
				;14844
				;14845	PROBEX.PM.00:
				;14846		;---------------------------------------; psl<23:22> = 00:
				;14847		VA <-- B [S1],				; get base address
				;14848		[MMGT.MODE] <-- [W1] LSH [2], LONG,	; probe mode = operand mode
			    p439;14849		GOTO [PROBEX.PROBE],			; go start probes
E 479  0081,4243,D820,0486 J 486;14850			sim addr [ea.3]
				;14851
				;14852	PROBEX.PM.01:
				;14853		;---------------------------------------; psl<23:22> = 01:
				;14854		VA <-- [S1],				; get base address
				;14855		[MMGT.MODE] <-- PASSB 000000[04], LONG, ; assume probe mode = exec (1*4)
			    p439;14856		CASE [SHF.NZ.INT] AT [PROBEX.PROBE],	; case on operand mode
E 47B  E000,A023,D880,4F86 B 486;14857			sim addr [ea.3]
				;14858
				;14859	PROBEX.PM.10:
				;14860		;---------------------------------------; psl<23:22> = 10:
				;14861		VA <-- [S1],				; get base address
				;14862		[MMGT.MODE] <-- PASSB 000000[08], LONG, ; assume probe mode = super (2*4)
			    p439;14863		CASE [SHF.NZ.INT] AT [PROBEX.PROBE],	; case on operand mode
E 47D  E000,A043,D880,4F86 B 486;14864			sim addr [ea.3]
				;14865
				;14866	PROBEX.PM.11:
				;14867		;---------------------------------------; psl<23:22> = 11:
				;14868		VA <-- [S1],				; get base address
				;14869		[MMGT.MODE] <-- PASSB 000000[0C], LONG, ; probe mode = prev mode
			    p439;14870		GOTO [PROBEX.PROBE],			; go start probes
E 47F  0000,A063,D880,0486 J 486;14871			sim addr [ea.3]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  439
;     OPSYS.MIC 	     PROBEx										      /REV=
;															      OPSYS
				;14872
				;14873	;	PROBEx, continued.
				;14874	;	Mode chosen, check for max (op, prv) if required.
				;14875
				;14876	;	At this point,
				;14877	;		W0	=	size
				;14878	;		Q	=	operand mode
				;14879	;		VA	=	base
				;14880
				;14881	;= ALIGNLIST 011x	(PROBEX.PROBE,		PROBEX.OP.MODE)
				;14882
				;14883	PROBEX.OP.MODE:
				;14884		;---------------------------------------; shf.n = b<1> = 1:
E 48E  0001,4202,D820,0486 J 486;14885		[MMGT.MODE] <-- [W1] LSH [2], LONG	; op = 2,3, prv = 1,2, use op
				;14886
				;14887	PROBEX.PROBE:
				;14888		;---------------------------------------; shf.n = b<1> = 0:
				;14889		[W0] <-- [W0] - 1, LONG,		; calc size - 1
E 486  8B00,0000,0410,4C29 B 429;14890		CASE [OPCODE.2-0] AT [PROBER.PROBE]	; case on PROBER vs PROBEW
				;14891
				;14892	;= ALIGNLIST 1x0x	(PROBER.PROBE,	PROBEW.PROBE)
				;14893	;  Opcodes = 0C, 0D --> opcode<2:0> = 10?
				;14894
				;14895	PROBER.PROBE:
				;14896		;---------------------------------------; PROBER:
E 429  005C,0004,0C00,055B J 55B;14897		[W2] <-- PROBE.R.MODE (VA), LEN(DL)	; probe at base address
				;14898
				;14899		;---------------------------------------;
				;14900		VA <-- [VA] + [W0],			; get base + size - 1
				;14901		Q <-- PASSA [VA],			; save base
				;14902		[W3] <-- PROBE.R.MODE (VA), LEN(DL),	; probe at base + size - 1
			    p440;14903		GOTO [PROBEX.TEST],			; go test probes
E 55B  08DE,400D,10B0,0562 J 562;14904			sim addr [probe]
				;14905
				;14906	PROBEW.PROBE:
				;14907		;---------------------------------------; PROBEW:
				;14908		[W2] <-- PROBE.W.MODE (VA), LEN(DL),	; probe at base address
E 42B  007C,0004,0C09,8561 J 561;14909		STATE.2 <-- 1				; flag write operation in case of fault
				;14910
				;14911		;---------------------------------------;
				;14912		VA <-- [VA] + [W0],			; get base + size - 1
				;14913		Q <-- PASSA [VA],			; save base
				;14914		[W3] <-- PROBE.W.MODE (VA), LEN(DL),	; probe at base + size - 1
			    p440;14915		GOTO [PROBEX.TEST],			; go test probes
E 561  08FE,400D,10B0,0562 J 562;14916			sim addr [probe]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  440
;     OPSYS.MIC 	     PROBEx										      /REV=
;															      OPSYS
				;14917
				;14918	;	PROBEx, continued.
				;14919	;	Probes done, case on results.
				;14920
				;14921	;	At this point,
				;14922	;		W2	=	result of first probe
				;14923	;		W3	=	result of second probe
				;14924	;		Q	=	base
				;14925	;		VA	=	base + size - 1
				;14926	;		STATE<2> =	0 if PROBER, 1 if PROBEW
				;14927
				;14928	PROBEX.TEST:
				;14929		;---------------------------------------;
				;14930		ACCESS B [W2],				; get first probe result
E 562  0000,0018,2000,0338 J 338;14931			sim cond k s3.[0]
				;14932
				;14933		;---------------------------------------;
				;14934		ACCESS B [W3],				; get second probe result
				;14935		CASE [B.2-0] AT [PROBEX.1ST.000],	; case on first probe
E 338  6000,0020,2000,43D0 B 3D0;14936			sim cond k s3.[0]
				;14937
				;14938	;= ALIGNLIST 000x	(PROBEX.1ST.000,	PROBEX.1ST.001,
				;14939	;=			 PROBEX.1ST.010,	PROBEX.1ST.011,
				;14940	;=			 PROBEX.1ST.100,	PROBEX.1ST.101,
				;14941	;=			 PROBEX.1ST.110,	PROBEX.1ST.111)
				;14942
				;14943	PROBEX.1ST.000:
				;14944		;---------------------------------------; b<2:0> = 000: (ok)
			    p442;14945		NOP,					; nop
E 3D0  6000,0000,2000,43D1 B 3D1;14946		CASE [B.2-0] AT [PROBEX.2ND.000]	; case on second probe
				;14947
				;14948	PROBEX.1ST.001:
				;14949		;---------------------------------------; b<2:0> = 001: (m = 0)
			    p442;14950		NOP,					; nop
E 3D2  6000,0000,2000,43D1 B 3D1;14951		CASE [B.2-0] AT [PROBEX.2ND.000]	; case on second probe
				;14952
				;14953	PROBEX.1ST.010:
				;14954		;---------------------------------------; b<2:0> = 010: (tnv)
			    p442;14955		NOP,					; nop
E 3D4  6000,0000,2000,43D1 B 3D1;14956		CASE [B.2-0] AT [PROBEX.2ND.000]	; case on second probe
				;14957
				;14958	PROBEX.1ST.011:
				;14959		;---------------------------------------; b<2:0> = 011: (ppte tnv)
			    p402;14960		VA <-- [Q], LONG,			; reset VA to faulting address
E 3D6  0000,0001,20A0,0173 J 173;14961		GOTO [CHMX.PROBEX.MM.FAULT]		; join common exception flow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  441
;     OPSYS.MIC 	     PROBEx										      /REV=
;															      OPSYS
				;14962
				;14963	;	PROBEx, continued.
				;14964	;	First probe results, ACV cases.
				;14965
				;14966	PROBEX.1ST.100:
				;14967		;---------------------------------------; b<2:0> = 100: (acv)
				;14968		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;14969		SET PSL CC.IIIP,			; psl map is iiip
E 3D8  0080,2000,200C,1000 L	;14970		LAST CYCLE				; decode next instruction
				;14971
				;14972	PROBEX.1ST.101:
				;14973		;---------------------------------------; b<2:0> = 101: (lnv)
				;14974		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;14975		SET PSL CC.IIIP,			; psl map is iiip
E 3DA  0080,2000,200C,1000 L	;14976		LAST CYCLE				; decode next instruction
				;14977
				;14978	PROBEX.1ST.110:
				;14979		;---------------------------------------; b<2:0> = 110: (acv+tnv)
				;14980		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;14981		SET PSL CC.IIIP,			; psl map is iiip
E 3DC  0080,2000,200C,1000 L	;14982		LAST CYCLE				; decode next instruction
				;14983
				;14984	PROBEX.1ST.111:
				;14985		;---------------------------------------; b<2:0> = 111: (ppte lnv)
				;14986		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;14987		SET PSL CC.IIIP,			; psl map is iiip
E 3DE  0080,2000,200C,1000 L	;14988		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  442
;     OPSYS.MIC 	     PROBEx										      /REV=
;															      OPSYS
				;14989
				;14990	;	PROBEx, continued.
				;14991	;	Second probe results.
				;14992
				;14993	;	At this point,
				;14994	;		W3	=	probe results
				;14995	;		VA	=	probe address
				;14996	;		STATE<2> =	0 if PROBER, 1 if PROBEW
				;14997
				;14998	;= ALIGNLIST 000x	(PROBEX.2ND.000,	PROBEX.2ND.001,
				;14999	;=			 PROBEX.2ND.010,	PROBEX.2ND.011,
				;15000	;=			 PROBEX.2ND.100,	PROBEX.2ND.101,
				;15001	;=			 PROBEX.2ND.110,	PROBEX.2ND.111)
				;15002
				;15003	PROBEX.2ND.000:
				;15004		;---------------------------------------; b<2:0> = 000: (ok)
				;15005		[WBUS] <-- 000000[01], LONG,		; set psl cc's = 0000
				;15006		SET PSL CC.IIIP,			; psl map is iiip
E 3D1  0080,2008,200C,1000 L	;15007		LAST CYCLE				; decode next instruction
				;15008
				;15009	PROBEX.2ND.001:
				;15010		;---------------------------------------; b<2:0> = 001: (m = 0)
				;15011		[WBUS] <-- 000000[01], LONG,		; set psl cc's = 0000
				;15012		SET PSL CC.IIIP,			; psl map is iiip
E 3D3  0080,2008,200C,1000 L	;15013		LAST CYCLE				; decode next instruction
				;15014
				;15015	PROBEX.2ND.010:
				;15016		;---------------------------------------; b<2:0> = 010: (tnv)
				;15017		[WBUS] <-- 000000[01], LONG,		; set psl cc's = 0000
				;15018		SET PSL CC.IIIP,			; psl map is iiip
E 3D5  0080,2008,200C,1000 L	;15019		LAST CYCLE				; decode next instruction
				;15020
				;15021	PROBEX.2ND.011:
			    p402;15022		;---------------------------------------; b<2:0> = 011: (ppte tnv)
E 3D7  0000,0000,2000,0173 J 173;15023		GOTO [CHMX.PROBEX.MM.FAULT]		; join common exception flow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  443
;     OPSYS.MIC 	     PROBEx										      /REV=
;															      OPSYS
				;15024
				;15025	;	PROBEx, continued.
				;15026	;	Second probe results.
				;15027
				;15028	PROBEX.2ND.100:
				;15029		;---------------------------------------; b<2:0> = 100: (acv)
				;15030		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;15031		SET PSL CC.IIIP,			; psl map is iiip
E 3D9  0080,2000,200C,1000 L	;15032		LAST CYCLE				; decode next instruction
				;15033
				;15034	PROBEX.2ND.101:
				;15035		;---------------------------------------; b<2:0> = 101: (lnv)
				;15036		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;15037		SET PSL CC.IIIP,			; psl map is iiip
E 3DB  0080,2000,200C,1000 L	;15038		LAST CYCLE				; decode next instruction
				;15039
				;15040	PROBEX.2ND.110:
				;15041		;---------------------------------------; b<2:0> = 110: (acv+tnv)
				;15042		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;15043		SET PSL CC.IIIP,			; psl map is iiip
E 3DD  0080,2000,200C,1000 L	;15044		LAST CYCLE				; decode next instruction
				;15045
				;15046	PROBEX.2ND.111:
				;15047		;---------------------------------------; b<2:0> = 111: (ppte lnv)
				;15048		[WBUS] <-- 000000[00], LONG,		; set psl cc's = 0100
				;15049		SET PSL CC.IIIP,			; psl map is iiip
E 3DF  0080,2000,200C,1000 L	;15050		LAST CYCLE				; decode next instruction
				;15051
;15052	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  444
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15053	.TOC	"	MTPR, MFPR"
;15054
;15055	;	These instructions move data to or from internal processor registers.
;15056	;
;15057	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;15058	;	--------      ------	---------				----	-----		--------
;15059	;	MTPR		DA	PR[procreg.rl] <-- src.rl		2	rr/ll		MTPR..
;15060	;	MFPR		DB	dst.wl <-- PR[procreg.rl]		2	rm/ll		MFPR..
;15061	;
;15062	;	Entry conditions (MTPR):
;15063	;		source queue	=	src.rl operand
;15064	;					procreg.rl operand
;15065	;		dest queue	=	none
;15066	;		branch queue	=	none
;15067	;		field queue	=	none
;15068	;		DL		=	LONG
;15069	;		Ibox state	=	stopped
;15070	;		Mbox state	=	running
;15071	;
;15072	;	Entry conditions (MFPR):
;15073	;		source queue	=	procreg.rl operand
;15074	;					dst.ml operand (accessed and discarded)
;15075	;		dest queue	=	dst.ml result
;15076	;		branch queue	=	none
;15077	;		field queue	=	none
;15078	;		DL		=	LONG
;15079	;		Ibox state	=	stopped
;15080	;		Mbox state	=	running
;15081	;
;15082	;	Exit conditions (MTPR):
;15083	;		The source has been stored in the specified processor register.
;15084	;
;15085	;	Exit conditions (MFPR):
;15086	;		The specified processor register data has been stored in the destination memory location or register.
;15087	;
;15088	;	Condition codes (MFPR):
;15089	;		N <-- dst LSS 0
;15090	;		Z <-- dst EQL 0
;15091	;		V <-- 0 		[Integer overflow trap disabled.]
;15092	;		C <-- C
;15093	;
;15094	;	Condition codes:
;15095	;		(MTPR, except TBCHK)			(MTPR TBCHK)
;15096	;		N <-- src LSS 0 			N <-- src LSS 0
;15097	;		Z <-- src EQL 0 			Z <-- src EQL 0
;15098	;		V <-- 0 				V <-- src in TB 	[Integer overflow trap disabled.]
;15099	;		C <-- C 				C <-- C
;15100	;
;15101
;15102	;	Note:	The final specifier for MFPR has been changed from .wl to .ml in the IROM.  This is done
;15103	;		because the Ibox must be fully stopped before the Ebox issues an IPR read to the Ibox.
;15104	;		If the final specifier were a .wl specifier, the Ibox could still be parsing this specifier
;15105	;		when it receives the IPR read.	By making the final specifier .ml instead, the Ebox stalls on
;15106	;		the source queue read until the Ibox has parsed the specifier and stopped.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  445
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15107
;15108	;	The processor registers that are implemented by the NVAX CPU chip, and
;15109	;	those that are required of the system environment, are logically di-
;15110	;	vided into five groups, as follows:
;15111	;
;15112	;	 o Normal--Those IPRs that address individual registers in the NVAX CPU
;15113	;	   chip or system environment.
;15114	;
;15115	;	 o Bcache tag IPRs--The read-write block of IPRs that allow direct access
;15116	;	   to the Bcache tags.
;15117	;
;15118	;	 o Bcache deallocate IPRs--The write-only block of IPRs by which a Bcache
;15119	;	   block may be deallocated.
;15120	;
;15121	;	 o Pcache tag IPRs--The read-write block of IPRs that allow direct access
;15122	;	   to the Pcache tags.
;15123	;
;15124	;	 o Pcache data parity IPRs--The read-write block of IPRs that allow direct
;15125	;	   access to the Pcache data parity bits.
;15126	;
;15127	;	Each group of IPRs is distinguished by a particular pattern of bits
;15128	;	in the IPR address, as shown below.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  446
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15129
;15130	;
;15131	;	Normal IPR Address
;15132	;
;15133	;	 31 30 29 28|27 26 25 24|23 22 21 20|19 18 17 16|15 14 13 12|11 10 09 08|07 06 05 04|03 02 01 00
;15134	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15135	;	|	SBZ	     | 0|		       SBZ			|	IPR Number	|
;15136	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15137	;
;15138	;	Bcache Tag IPR Address
;15139	;
;15140	;	 31 30 29 28|27 26 25 24|23 22 21 20|19 18 17 16|15 14 13 12|11 10 09 08|07 06 05 04|03 02 01 00
;15141	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15142	;	|	SBZ	     | 1| 0| 0| x|		  Bcache Tag Index		 |     SBZ	|
;15143	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15144	;
;15145	;	Bcache Deallocate IPR Address
;15146	;
;15147	;	 31 30 29 28|27 26 25 24|23 22 21 20|19 18 17 16|15 14 13 12|11 10 09 08|07 06 05 04|03 02 01 00
;15148	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15149	;	|	 SBZ	     | 1| 0| 1| x|	    Bcache Tag Deallocate Index 	 |     SBZ	|
;15150	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15151	;
;15152	;	Pcache Tag IPR Address
;15153	;
;15154	;	 31 30 29 28|27 26 25 24|23 22 21 20|19 18 17 16|15 14 13 12|11 10 09 08|07 06 05 04|03 02 01 00
;15155	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15156	;	|	 SBZ	     | 1| 1| 0| 	 SBZ		 |  |  Pcache Tag Index  |	SBZ	|
;15157	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15158	;								   |
;15159	;			      Pcache Set Select (0=left, 1=right) -+
;15160	;
;15161	;	Pcache Data Parity IPR Address
;15162	;
;15163	;	 31 30 29 28|27 26 25 24|23 22 21 20|19 18 17 16|15 14 13 12|11 10 09 08|07 06 05 04|03 02 01 00
;15164	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15165	;	|	 SBZ	     | 1| 1| 1| 	 SBZ		 |  |  Pcache Tag Index  |     |   SBZ	|
;15166	;	+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;15167	;								   |			    |
;15168	;			      Pcache Set Select (0=left, 1=right) -+	    Subblock select +
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  447
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15169
;15170	;
;15171	;	The numeric range for each of the four groups is shown in the following table
;15172	;
;15173	;	IPR Group	    Mnemonic Address Range (hex)	 Contents
;15174	;	------------------  -------- ------------------  -------------------------------
;15175	;	Normal			     00000000..000000FF  256 Individual IPRs (see below)
;15176	;
;15177	;	Bcache Tag	    BCTAG    01000000..011FFFE0  64K Bcache tag IPRs
;15178	;
;15179	;	Bcache Deallocate   BCFLUSH  01400000..015FFFE0  64K Bcache deallocate IPRs
;15180	;
;15181	;	Pcache Tag	    PCTAG    01800000..01801FE0  256 Pcache tag IPRs
;15182	;
;15183	;	Pcache Data Parity  PCDAP    01C00000..01C01FF8  1024 Pcache data parity IPRs
;15184	;
;15185	;	There is no range checking done by the microcde, so all IPR addresses
;15186	;	fall into one of these ranges.	References to IPRs outside the ranges
;15187	;	shown can result in UNDEFINED behavior.
;15188	;
;15189	;	The address ranges shown above are those used by the programmer. When
;15190	;	processing normal IPRs, the microcode shifts the IPR number left by 2
;15191	;	bits for use as an IPR command address. This positions the IPR number
;15192	;	to bits <9:2> and modifies the address range as seen by the hardware
;15193	;	to 0..3FC, with bits <1:0>=00. No shifting is performed for the other
;15194	;	groups of IPR addresses.
;15195	;
;15196	;	Processor registers in all groups except the normal group are
;15197	;	processed entirely by the NVAX CPU chip and will never appear on
;15198	;	the NDAL. This is also true for a number of the IPRs in the normal
;15199	;	group. IPRs in the normal group that are not processed by the NVAX
;15200	;	CPU chip are converted into I/O space references and passed to the
;15201	;	system environment via a read or write command on the NDAL.
;15202	;
;15203	;	Each of the 256 possible IPRs in the normal group are of longword
;15204	;	length, so a 1KB block of I/O space is required to convert each
;15205	;	possible IPR to a unique I/O space longword. This block starts at
;15206	;	address E1000000 (hex). Conversion of an IPR address to an I/O
;15207	;	space address in this block is done by shifting the IPR address
;15208	;	left into bits <9:2>, filling bits <1:0> with zeros, and merging
;15209	;	in the base address of the block. This can be expressed by the
;15210	;	equation
;15211	;
;15212	;		       IO ADDRESS = E1000000 + (IPR NUMBER * 4)
;15213	;
;15214	;	Many of the processor registers listed in the table below are used
;15215	;	internally by the microcode during normal operation of the CPU, and
;15216	;	are not intended to be referenced by software except during test or
;15217	;	diagnosis of the system. These registers are flagged with the notation
;15218	;	"Testability and diagnostic use only; not for software use in normal
;15219	;	operation". References by software to these registers during normal
;15220	;	operation can cause UNDEFINED behavior of the CPU.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  448
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15221
;15222	;	The following table lists all IPRs in the normal group.
;15223	;
;15224	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15225	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15226	;	Kernel Stack Pointer			   KSP	     0	  0   RW   NVAX    1-1
;15227	;	Executive Stack Pointer 		   ESP	     1	  1   RW   NVAX    1-1
;15228	;	Supervisor Stack Pointer		   SSP	     2	  2   RW   NVAX    1-1
;15229	;	User Stack Pointer			   USP	     3	  3   RW   NVAX    1-1
;15230	;	Interrupt Stack Pointer 		   ISP	     4	  4   RW   NVAX    1-1
;15231	;	Reserved					     5	  5		   3	E1000014
;15232	;	Reserved					     6	  6		   3	E1000018
;15233	;	Reserved					     7	  7		   3	E100001C
;15234	;	P0 Base Register			   P0BR      8	  8   RW   NVAX    1-2
;15235	;	P0 Length Register			   P0LR      9	  9   RW   NVAX    1-2
;15236	;	P1 Base Register			   P1BR     10	  A   RW   NVAX    1-2
;15237	;	P1 Length Register			   P1LR     11	  B   RW   NVAX    1-2
;15238	;	System Base Register			   SBR	    12	  C   RW   NVAX    1-2
;15239	;	System Length Register			   SLR	    13	  D   RW   NVAX    1-2
;15240	;	CPU Identification[1]			   CPUID    14	  E   RW   NVAX    2-1
;15241	;	Reserved					    15	  F		   3	E100003C
;15242	;	Process Control Block Base		   PCBB     16	 10   RW   NVAX    1-1
;15243	;	System Control Block Base		   SCBB     17	 11   RW   NVAX    1-1
;15244	;	Interrupt Priority Level[1]		   IPL	    18	 12   RW   NVAX    1-1
;15245	;	AST Level[1]				   ASTLVL   19	 13   RW   NVAX    1-1
;15246	;	Software Interrupt Request Register	   SIRR     20	 14   W    NVAX    1-1
;15247	;	Software Interrupt Summary Register[1]	   SISR     21	 15   RW   NVAX    1-1
;15248	;	Reserved					    22	 16		   3	E1000058
;15249	;	Reserved					    23	 17		   3	E100005C
;15250	;	Interval Counter Control/Status[1,2]	   ICCS     24	 18   RW   NVAX    2-7	E1000060
;15251	;	Next Interval Count			   NICR     25	 19   RW   System  3-7	E1000064
;15252	;	Interval Count				   ICR	    26	 1A   RW   System  3-7	E1000068
;15253	;	Time of Year Register			   TODR     27	 1B   RW   System  2-3	E100006C
;15254	;	Console Storage Receiver Status 	   CSRS     28	 1C   RW   System  2-3	E1000070
;15255	;	Console Storage Receiver Data		   CSRD     29	 1D   R    System  2-3	E1000074
;15256	;	Console Storage Transmitter Status	   CSTS     30	 1E   RW   System  2-3	E1000078
;15257	;	Console Storage Transmitter Data	   CSTD     31	 1F   W    System  2-3	E100007C
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  449
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15258
;15259	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15260	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15261	;	Console Receiver Control/Status 	   RXCS     32	 20   RW   System  2-3	E1000080
;15262	;	Console Receiver Data Buffer		   RXDB     33	 21   R    System  2-3	E1000084
;15263	;	Console Transmitter Control/Status	   TXCS     34	 22   RW   System  2-3	E1000088
;15264	;	Console Transmitter Data Buffer 	   TXDB     35	 23   W    System  2-3	E100008C
;15265	;	Reserved					    36	 24		   3	E1000090
;15266	;	Reserved					    37	 25		   3	E1000094
;15267	;	Machine Check Error Register		   MCESR    38	 26   W    NVAX    2-1
;15268	;	Reserved					    39	 27		   3	E100009C
;15269	;	Reserved					    40	 28		   3	E10000A0
;15270	;	Reserved					    41	 29		   3	E10000A4
;15271	;	Console Saved PC			   SAVPC    42	 2A   R    NVAX    2-1
;15272	;	Console Saved PSL			   SAVPSL   43	 2B   R    NVAX    2-1
;15273	;	Reserved					    44	 2C		   3	E10000B0
;15274	;	Reserved					    45	 2D		   3	E10000B4
;15275	;	Reserved					    46	 2E		   3	E10000B8
;15276	;	Reserved					    47	 2F		   3	E10000BC
;15277	;	Reserved					    48	 30		   3	E10000C0
;15278	;	Reserved					    49	 31		   3	E10000C4
;15279	;	Reserved					    50	 32		   3	E10000C8
;15280	;	Reserved					    51	 33		   3	E10000CC
;15281	;	Reserved					    52	 34		   3	E10000D0
;15282	;	Reserved					    53	 35		   3	E10000D4
;15283	;	Reserved					    54	 36		   3	E10000D8
;15284	;	I/O System Reset Register		   IORESET  55	 37   W    System  2-3	E10000DC
;15285	;	Memory Management Enable[1]		   MAPEN    56	 38   RW   NVAX    1-2
;15286	;	Translation Buffer Invalidate All	   TBIA     57	 39   W    NVAX    1-1
;15287	;	Translation Buffer Invalidate Single	   TBIS     58	 3A   W    NVAX    1-1
;15288	;	Reserved					    59	 3B		   3	E10000EC
;15289	;	Reserved					    60	 3C		   3	E10000F0
;15290	;	Performance Monitor Enable[1]		   PME	    61	 3D   RW   NVAX    2-1
;15291	;	System Identification			   SID	    62	 3E   R    NVAX    2-1
;15292	;	Translation Buffer Check		   TBCHK    63	 3F   W    NVAX    1-1
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  450
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15293
;15294	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15295	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15296	;	IPL 14 Interrupt ACK[3] 		   IAK14    64	 40   R    System  2-3	E1000100
;15297	;	IPL 15 Interrupt ACK[3] 		   IAK15    65	 41   R    System  2-3	E1000104
;15298	;	IPL 16 Interrupt ACK[3] 		   IAK16    66	 42   R    System  2-3	E1000108
;15299	;	IPL 17 Interrupt ACK[3] 		   IAK17    67	 43   R    System  2-3	E100010C
;15300	;	Clear Write Buffer[3]			   CWB	    68	 44   RW   System  2-3	E1000110
;15301	;	Reserved					    69	 45		   3	E1000114
;15302	;	Reserved					    70	 46		   3	E1000118
;15303	;	Reserved					    71	 47		   3	E100011C
;15304	;	Reserved					    72	 48		   3	E1000120
;15305	;	Reserved					    73	 49		   3	E1000124
;15306	;	Reserved					    74	 4A		   3	E1000128
;15307	;	Reserved					    75	 4B		   3	E100012C
;15308	;	Reserved					    76	 4C		   3	E1000130
;15309	;	Reserved					    77	 4D		   3	E1000134
;15310	;	Reserved					    78	 4E		   3	E1000138
;15311	;	Reserved					    79	 4F		   3	E100013C
;15312	;	Reserved					    80	 50		   3	E1000140
;15313	;	Reserved					    81	 51		   3	E1000144
;15314	;	Reserved					    82	 52		   3	E1000148
;15315	;	Reserved					    83	 53		   3	E100014C
;15316	;	Reserved					    84	 54		   3	E1000150
;15317	;	Reserved					    85	 55		   3	E1000154
;15318	;	Reserved					    86	 56		   3	E1000158
;15319	;	Reserved					    87	 57		   3	E100015C
;15320	;	Reserved					    88	 58		   3	E1000160
;15321	;	Reserved					    89	 59		   3	E1000164
;15322	;	Reserved					    90	 5A		   3	E1000168
;15323	;	Reserved					    91	 5B		   3	E100016C
;15324	;	Reserved					    92	 5C		   3	E1000170
;15325	;	Reserved					    93	 5D		   3	E1000174
;15326	;	Reserved					    94	 5E		   3	E1000178
;15327	;	Reserved					    95	 5F		   3	E100017C
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  451
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15328
;15329	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15330	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15331	;	Reserved					    96	 60		   3	E1000180
;15332	;	Reserved					    97	 61		   3	E1000184
;15333	;	Reserved					    98	 62		   3	E1000188
;15334	;	Reserved					    99	 63		   3	E100018C
;15335	;	Reserved for VM 				   100	 64		   3	E1000190
;15336	;	Reserved for VM 				   101	 65		   3	E1000194
;15337	;	Reserved for VM 				   102	 66		   3	E1000198
;15338	;	Reserved					   103	 67		   3	E100019C
;15339	;	Reserved					   104	 68		   3	E10001A0
;15340	;	Reserved					   105	 69		   3	E10001A4
;15341	;	Reserved					   106	 6A		   3	E10001A8
;15342	;	Reserved					   107	 6B		   3	E10001AC
;15343	;	Reserved					   108	 6C		   3	E10001B0
;15344	;	Reserved					   109	 6D		   3	E10001B4
;15345	;	Reserved					   110	 6E		   3	E10001B8
;15346	;	Reserved					   111	 6F		   3	E10001BC
;15347	;	Reserved					   112	 70		   3	E10001C0
;15348	;	Reserved					   113	 71		   3	E10001C4
;15349	;	Reserved					   114	 72		   3	E10001C8
;15350	;	Reserved					   115	 73		   3	E10001CC
;15351	;	Reserved					   116	 74		   3	E10001D0
;15352	;	Reserved					   117	 75		   3	E10001D4
;15353	;	Reserved					   118	 76		   3	E10001D8
;15354	;	Reserved					   119	 77		   3	E10001DC
;15355	;	Reserved for Ebox				   120	 78		   2-6
;15356	;	Reserved for Ebox				   121	 79		   2-6
;15357	;	Interrupt System Status Register[3]	   INTSYS  122	 7A   RW   NVAX    2-1
;15358	;	Performance Monitoring Facility Count	   PMFCNT  123	 7B   RW   NVAX    2-1
;15359	;	Patchable Control Store Control Reg[3]	   PCSCR   124	 7C   RW   NVAX    2-1
;15360	;	Ebox Control Register			   ECR	   125	 7D   RW   NVAX    2-1
;15361	;	Mbox TB Tag Fill[3]			   MTBTAG  126	 7E   W    NVAX    2-1
;15362	;	Mbox TB PTE Fill[3]			   MTBPTE  127	 7F   W    NVAX    2-1
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  452
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15363
;15364	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15365	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15366	;	Reserved for Vectors				   128	 80		   3	E1000200
;15367	;	Reserved for Vectors				   129	 81		   3	E1000204
;15368	;	Reserved for Vectors				   130	 82		   3	E1000208
;15369	;	Reserved for Vectors				   131	 83		   3	E100020C
;15370	;	Reserved for Vectors				   132	 84		   3	E1000210
;15371	;	Reserved for Vectors				   133	 85		   3	E1000214
;15372	;	Reserved for Vectors				   134	 86		   3	E1000230
;15373	;	Reserved for Vectors				   135	 87		   3	E100021C
;15374	;	Reserved for Vectors				   136	 88		   3	E1000220
;15375	;	Reserved for Vectors				   137	 89		   3	E1000224
;15376	;	Reserved for Vectors				   138	 8A		   3	E1000228
;15377	;	Reserved for Vectors				   139	 8B		   3	E100022C
;15378	;	Reserved for Vectors				   140	 8C		   3	E1000230
;15379	;	Reserved for Vectors				   141	 8D		   3	E1000234
;15380	;	Reserved for Vectors				   142	 8E		   3	E1000238
;15381	;	Reserved for Vectors				   143	 8F		   3	E100023C
;15382	;	Vector Processor Status Register	   VPSR    144	 90   RW   Vector  3	E1000240
;15383	;	Vector Arithmetic Exception Register	   VAER    145	 91   R    Vector  3	E1000244
;15384	;	Vector Memory Activity Register 	   VMAC    146	 92   R    Vector  3	E1000248
;15385	;	Vector Trans. Buffer Invalidate All	   VTBIA   147	 93   W    Vector  3	E100024C
;15386	;	Reserved for Vectors				   148	 94		   3	E1000250
;15387	;	Reserved for Vectors				   149	 95		   3	E1000254
;15388	;	Reserved for Vectors				   150	 96		   3	E1000258
;15389	;	Reserved for Vectors				   151	 97		   3	E100025C
;15390	;	Reserved for Vectors				   152	 98		   3	E1000260
;15391	;	Reserved for Vectors				   153	 99		   3	E1000264
;15392	;	Reserved for Vectors				   154	 9A		   3	E1000268
;15393	;	Reserved for Vectors				   155	 9B		   3	E100026C
;15394	;	Reserved for Vectors				   156	 9C		   3	E1000270
;15395	;	Reserved for Vectors				   157	 9D		   3	E1000274
;15396	;	Reserved for Vectors				   158	 9E		   3	E1000278
;15397	;	Reserved for Vectors				   159	 9F		   3	E100027C
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  453
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15398
;15399	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15400	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15401	;	Cbox Control Register			   CCTL    160	 A0   RW   NVAX    2-5
;15402	;	Reserved for Cbox				   161	 A1	   NVAX    2-6
;15403	;	Bcache Data ECC 			   BCDECC  162	 A2   W    NVAX    2-5
;15404	;	Bcache Error Tag Status 		   BCETSTS 163	 A3   RW   NVAX    2-5
;15405	;	Bcache Error Tag Index			   BCETIDX 164	 A4   R    NVAX    2-5
;15406	;	Bcache Error Tag			   BCETAG  165	 A5   R    NVAX    2-5
;15407	;	Bcache Error Data Status		   BCEDSTS 166	 A6   RW   NVAX    2-5
;15408	;	Bcache Error Data Index 		   BCEDIDX 167	 A7   R    NVAX    2-5
;15409	;	Bcache Error ECC			   BCEDECC 168	 A8   R    NVAX    2-5
;15410	;	Reserved for Cbox				   169	 A9	   NVAX    2-6
;15411	;	Reserved for Cbox				   170	 AA	   NVAX    2-6
;15412	;	Fill Error Address			   CEFADR  171	 AB   R    NVAX    2-5
;15413	;	Fill Error Status			   CEFSTS  172	 AC   RW   NVAX    2-5
;15414	;	Reserved for Cbox				   173	 AD	   NVAX    2-6
;15415	;	NDAL Error Status			   NESTS   174	 AE   RW   NVAX    2-5
;15416	;	Reserved for Cbox				   175	 AF	   NVAX    2-6
;15417	;	NDAL Error Output Address		   NEOADR  176	 B0   R    NVAX    2-5
;15418	;	Reserved for Cbox				   177	 B1	   NVAX    2-6
;15419	;	NDAL Error Output Command		   NEOCMD  178	 B2   R    NVAX    2-5
;15420	;	Reserved for Cbox				   179	 B3	   NVAX    2-6
;15421	;	NDAL Error Data High			   NEDATHI 180	 B4   R    NVAX    2-5
;15422	;	Reserved for Cbox				   181	 B5	   NVAX    2-6
;15423	;	NDAL Error Data Low			   NEDATLO 182	 B6   R    NVAX    2-5
;15424	;	Reserved for Cbox				   183	 B7	   NVAX    2-6
;15425	;	NDAL Error Input Command		   NEICMD  184	 B8   R    NVAX    2-5
;15426	;	Reserved for Cbox				   185	 B9	   NVAX    2-6
;15427	;	Reserved for Cbox				   186	 BA	   NVAX    2-6
;15428	;	Reserved for Cbox				   187	 BB	   NVAX    2-6
;15429	;	Reserved for Cbox				   188	 BC	   NVAX    2-6
;15430	;	Reserved for Cbox				   189	 BD	   NVAX    2-6
;15431	;	Reserved for Cbox				   190	 BE	   NVAX    2-6
;15432	;	Reserved for Cbox				   191	 BF	   NVAX    2-6
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  454
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15433
;15434	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15435	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15436	;	Reserved					   192	 C0		   3	E1000300
;15437	;	Reserved					   193	 C1		   3	E1000304
;15438	;	Reserved					   194	 C2		   3	E1000308
;15439	;	Reserved					   195	 C3		   3	E100030C
;15440	;	Reserved					   196	 C4		   3	E1000310
;15441	;	Reserved					   197	 C5		   3	E1000314
;15442	;	Reserved					   198	 C6		   3	E1000318
;15443	;	Reserved					   199	 C7		   3	E100031C
;15444	;	Reserved					   200	 C8		   3	E1000320
;15445	;	Reserved					   201	 C9		   3	E1000324
;15446	;	Reserved					   202	 CA		   3	E1000328
;15447	;	Reserved					   203	 CB		   3	E100032C
;15448	;	Reserved					   204	 CC		   3	E1000330
;15449	;	Reserved					   205	 CD		   3	E1000334
;15450	;	Reserved					   206	 CE		   3	E1000338
;15451	;	Reserved					   207	 CF		   3	E100033C
;15452	;	VIC Memory Address Register		   VMAR    208	 D0   RW   NVAX    2-5
;15453	;	VIC Tag Register			   VTAG    209	 D1   RW   NVAX    2-5
;15454	;	VIC Data Register			   VDATA   210	 D2   RW   NVAX    2-5
;15455	;	Ibox Control and Status Register	   ICSR    211	 D3   RW   NVAX    2-5
;15456	;	Ibox Branch Prediction Control Register[3] BPCR    212	 D4   RW   NVAX    2-5
;15457	;	Reserved for Ibox				   213	 D5	   NVAX    2-6
;15458	;	Ibox Backup PC[3]			   BPC	   214	 D6   R    NVAX    2-5
;15459	;	Ibox Backup PC with RLOG Unwind[3]	   BPCUNW  215	 D7   R    NVAX    2-5
;15460	;	Reserved for Ibox				   216	 D8	   NVAX    2-6
;15461	;	Reserved for Ibox				   217	 D9	   NVAX    2-6
;15462	;	Reserved for Ibox				   218	 DA	   NVAX    2-6
;15463	;	Reserved for Ibox				   219	 DB	   NVAX    2-6
;15464	;	Reserved for Ibox				   220	 DC	   NVAX    2-6
;15465	;	Reserved for Ibox				   221	 DD	   NVAX    2-6
;15466	;	Reserved for Ibox				   222	 DE	   NVAX    2-6
;15467	;	Reserved for Ibox				   223	 DF	   NVAX    2-6
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  455
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15468
;15469	;		Register			 Mnemonic  Dec	Hex  Type   Impl   Cat	I/O Addr
;15470	;	---------------------------------------  --------  ---	---  ----  ------  ---	--------
;15471	;	Mbox P0 Base Register[3]		   MP0BR   224	 E0   RW   NVAX    2-5
;15472	;	Mbox P0 Length Register[3]		   MP0LR   225	 E1   RW   NVAX    2-5
;15473	;	Mbox P1 Base Register[3]		   MP1BR   226	 E2   RW   NVAX    2-5
;15474	;	Mbox P1 Length Register[3]		   MP1LR   227	 E3   RW   NVAX    2-5
;15475	;	Mbox System Base Register[3]		   MSBR    228	 E4   RW   NVAX    2-5
;15476	;	Mbox System Length Register[3]		   MSLR    229	 E5   RW   NVAX    2-5
;15477	;	Mbox Memory Management Enable[3]	   MMAPEN  230	 E6   RW   NVAX    2-5
;15478	;	Mbox Physical Address Mode		   PAMODE  231	 E7   RW   NVAX    2-5
;15479	;	Mbox MME Address			   MMEADR  232	 E8   R    NVAX    2-5
;15480	;	Mbox MME PTE Address			   MMEPTE  233	 E9   R    NVAX    2-5
;15481	;	Mbox MME Status 			   MMESTS  234	 EA   R    NVAX    2-5
;15482	;	Reserved for Mbox				   235	 EB	   NVAX    2-6
;15483	;	Mbox TB Parity Address			   TBADR   236	 EC   R    NVAX    2-5
;15484	;	Mbox TB Parity Status			   TBSTS   237	 ED   RW   NVAX    2-5
;15485	;	Reserved for Mbox				   238	 EE	   NVAX    2-6
;15486	;	Reserved for Mbox				   239	 EF	   NVAX    2-6
;15487	;	Reserved for Mbox				   240	 F0	   NVAX    2-6
;15488	;	Reserved for Mbox				   241	 F1	   NVAX    2-6
;15489	;	Mbox Pcache Parity Address		   PCADR   242	 F2   R    NVAX    2-5
;15490	;	Reserved for Mbox				   243	 F3	   NVAX    2-6
;15491	;	Mbox Pcache Status			   PCSTS   244	 F4   RW   NVAX    2-5
;15492	;	Reserved for Mbox				   245	 F5	   NVAX    2-6
;15493	;	Reserved for Mbox				   246	 F6	   NVAX    2-6
;15494	;	Reserved for Mbox				   247	 F7	   NVAX    2-6
;15495	;	Mbox Pcache Control			   PCCTL   248	 F8   RW   NVAX    2-5
;15496	;	Reserved for Mbox				   249	 F9	   NVAX    2-6
;15497	;	Reserved for Mbox				   250	 FA	   NVAX    2-6
;15498	;	Reserved for Mbox				   251	 FB	   NVAX    2-6
;15499	;	Reserved for Mbox				   252	 FC	   NVAX    2-6
;15500	;	Reserved for Mbox				   253	 FD	   NVAX    2-6
;15501	;	Reserved for Mbox				   254	 FE	   NVAX    2-6
;15502	;	Reserved for Mbox				   255	 FF	   NVAX    2-6
;15503	;	---------------------------------------
;15504	;	[1] Initialized on reset
;15505	;	[2] Subset or full implementation depending on ECR control bit
;15506	;	[3] Testability and diagnostic use only; not for software use in normal operation
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  456
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
;15507
;15508	;
;15509	;	Type:
;15510	;
;15511	;	  R = Read-only register
;15512	;	  RW = Read-write register
;15513	;	  W = Write-only register
;15514	;
;15515	;	Impl(emented):
;15516	;
;15517	;	  NVAX = Implemented in the NVAX CPU chip
;15518	;	  System = Implemented in the system environment
;15519	;	  Vector = Implemented in the optional vector unit or its bus
;15520	;		   interface
;15521	;
;15522	;	Cat(egory), class-subclass, where:
;15523	;
;15524	;	class is one of:
;15525	;
;15526	;	  1 = Implemented as per DEC standard 032
;15527	;	  2 = NVAX-specific implementation which is unique or different from
;15528	;	      the DEC standard 032 implementation
;15529	;	  3 = Not implemented internally; converted to I/O space read or
;15530	;	      write and passed to system environment
;15531	;
;15532	;	subclass is one of:
;15533	;
;15534	;	  1 = Processed as appropriate by Ebox microcode
;15535	;	  2 = Converted to Mbox IPR number and processed via internal IPR
;15536	;	      command
;15537	;	  3 = Processed by internal IPR command, then converted to I/O space
;15538	;	      read or write and passed to system environment
;15539	;	  4 = If virtual machine option is implemented, processed as in 1,
;15540	;	      otherwise as in 3
;15541	;	  5 = Processed by internal IPR command
;15542	;	  6 = May be block decoded; reference causes UNDEFINED behavior
;15543	;	  7 = Full interval timer may be implemented in the system
;15544	;	      environment. Subset ICCS is implemented in NVAX CPU chip
;15545
				;15546	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  457
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15547
				;15548	;	MTPR operation:
				;15549	;
				;15550	;		PR[procreg.rl] <-- src.rl
				;15551
				;15552	MTPR..:
				;15553		;********** Hardware dispatch **********;
				;15554		[W1] <-- [S1], LONG,			; [1] get source data
				;15555		SET PSL CC.IIIP,			; set condition codes, map is iiip
E 300  0002,8048,088C,000D J 00D;15556		Q <-- PASSB [S2]			; get register number
				;15557
				;15558		;---------------------------------------;
				;15559		NODST <-- [Q] ANDNOT 000000[03F], LONG, ; [2] test register number > 63
				;15560		[W0] <-- PASSA [Q],			; save register number
				;15561		SC <-- A [Q],				; load low order 5b of reg into SC
			    p458;15562		CASE [PSL.26-24] AT [MXPR.FROM.KERNEL], ; if not kernel mode, fault
E 00D  A480,61FA,04AA,4DB9 B 0B9;15563			sim cond [s34.ipr]
				;15564
				;15565	;	MFPR operation:
				;15566	;
				;15567	;		dst.wl <-- PR[procreg.rl]
				;15568
				;15569	MFPR..:
				;15570		;********** Hardware dispatch **********;
				;15571		[W0] <-- [S1], LONG,			; [1] get register number
E 302  0000,0048,0480,0013 J 013;15572		ACCESS B [S2]				; check destination, toss queue entry
				;15573
				;15574		;---------------------------------------;
				;15575		NODST <-- [W0] ANDNOT 000000[03F], LONG,; [2] test register number > 63
				;15576		SC <-- A [W0],				; load low order 5b of reg into SC
			    p458;15577		CASE [PSL.26-24] AT [MXPR.FROM.KERNEL], ; if not kernel mode, fault
E 013  A480,21F8,201A,4DB9 B 0B9;15578			sim cond [s34.ipr]
				;15579
				;15580	;= ALIGNLIST 100x	(MXPR.FROM.KERNEL,	MXPR.FROM.EXEC,
				;15581	;=			 MXPR.FROM.SUPER,	MXPR.FROM.USER)
				;15582
				;15583	MXPR.FROM.EXEC:
			    p126;15584		;---------------------------------------; psl<25:24> = 01:
E 0BB  0000,0000,2000,0100 J 100;15585		RESERVED INSTRUCTION FAULT		; [3] reserved instruction fault
				;15586
				;15587	MXPR.FROM.SUPER:
			    p126;15588		;---------------------------------------; psl<25:24> = 10:
E 0BD  0000,0000,2000,0100 J 100;15589		RESERVED INSTRUCTION FAULT		; [3] reserved instruction fault
				;15590
				;15591	MXPR.FROM.USER:
			    p126;15592		;---------------------------------------; psl<25:24> = 11:
E 0BF  0000,0000,2000,0100 J 100;15593		RESERVED INSTRUCTION FAULT		; [3] reserved instruction fault
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  458
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15594
				;15595	;	MxPR, continued.
				;15596	;	In kernel mode.  Break out into opcode flows, do range check
				;15597
				;15598	;	At this point,
				;15599	;		W0	=	register number
				;15600	;		W1	=	data (MTPR)
				;15601	;		alu.z	=	1 if register number <= 63 (from cycle 2)
				;15602
				;15603	MXPR.FROM.KERNEL:
				;15604		;---------------------------------------; psl<25:24> = 00:
				;15605		[W5] <-- [W1] AND 000000[1F], LONG,	; [3] mask data to 5 bits
E 0B9  8400,20F8,1820,4C15 B 015;15606		CASE [OPCODE.2-0] AT [MTPR.CONTINUE]	; break back out into opcode flows
				;15607
				;15608	;= ALIGNLIST x10x	(MTPR.CONTINUE, 	MFPR.CONTINUE)
				;15609	;  Opcodes = DA, DB --> opcode<2:0> = 01?
				;15610
				;15611	MTPR.CONTINUE:
				;15612		;---------------------------------------; opcode<2:0> = 010:
				;15613		[W5] <-- [W5] LSH [16.], LONG,		; [4] shift masked data left 16 bits
			    p463;15614		ACCESS B [W0],				; test IPR number for breakout
E 015  2001,500A,1860,411B B 01B;15615		CASE [ALU.NZV] AT [MTPR.GT.63]		; check for IPR <= 63 from [2]
				;15616
				;15617	;= ALIGNLIST 10xx	(MTPR.GT.63,		MTPR.LE.63)
				;15618	;  ALU.NZVC set by ANDNOT --> V = 0
				;15619
				;15620	MTPR.LE.63:
				;15621		;---------------------------------------; alu.z = 1:
				;15622		Q <-- [K1] LSH (SC), LONG,		; [5] shift 1 by (IPR number MOD 32)
			    p459;15623		ACCESS B [W0],				; test IPR number for breakout
E 01F  8003,4008,2320,4450 B 050;15624		CASE [B.5-3] AT [MTPR.00.07]		; do initial breakout
				;15625
				;15626	MFPR.CONTINUE:
				;15627		;---------------------------------------; opcode<2:0> = 110:
				;15628		[W2] <-- [PSL] LSH [11.], LONG, 	; [4] left-justify IPL
				;15629							; >> PSL read, no write/set in last 2 cycles
			    p463;15630		ACCESS B [W0],				; test IPR number for breakout
E 017  2001,4B0A,0CC0,412A B 02A;15631		CASE [ALU.NZV] AT [MFPR.GT.63]		; check for IPR <= 63 from [2]
				;15632
				;15633	;= ALIGNLIST 10xx	(MFPR.GT.63,		MFPR.LE.63)
				;15634	;  ALU.NZVC set by ANDNOT --> V = 0
				;15635
				;15636	MFPR.LE.63:
				;15637		;---------------------------------------; alu.z = 1:
				;15638		Q <-- [K1] LSH (SC), LONG,		; [5] shift 1 by (IPR number MOD 32)
			    p461;15639		ACCESS B [W0],				; test IPR number for breakout
E 02E  8003,4008,2320,4460 B 060;15640		CASE [B.5-3] AT [MFPR.00.07]		; do initial breakout
				;15641
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  459
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15642
				;15643	;	MTPR, continued.
				;15644	;	Breakout to block complete, continue breakout to individual IPR
				;15645	;
				;15646	;	At this point,
				;15647	;		W0	=	register number
				;15648	;		W1	=	data
				;15649	;		W5	=	masked data<4:0> left-shifted by 16 bits
				;15650	;		Q	=	1 left-shifted by (IPR number MOD 32)
				;15651	;		W0 tested on B-bus from cycle 5.
				;15652
				;15653	MTPR.00.07:
			    p467;15654		;---------------------------------------; b<5:3> = 000:
E 050  6000,0000,2000,4380 B 080;15655		CASE [B.2-0] AT [MTPR.00]		; [6] branch to specific flow
				;15656
				;15657	MTPR.08.15:
				;15658		;---------------------------------------; b<5:3> = 001:
			    p469;15659		Q <-- [W1] LSH [9.], LONG,		; [6] shift data left by 9 bits
E 052  6003,4900,2020,4381 B 081;15660		CASE [B.2-0] AT [MTPR.08]		; branch to specific flow
				;15661
				;15662	MTPR.16.23:
				;15663		;---------------------------------------; b<5:3> = 010:
				;15664		[W2] <-- [PSL] ANDNOT 00[1F]0000, LONG, ; [6] mask out ipl field
			    p471;15665							; >> PSL read, no write/set in last 2 cycles
E 054  6480,30F8,0CC0,4370 B 070;15666		CASE [B.2-0] AT [MTPR.16]		; branch to specific flow
				;15667
				;15668	MTPR.24.31:
				;15669		;---------------------------------------; b<5:3> = 011:
			    p495;15670		[WBUS] <-- [Q] AND [01]000000, LONG,	; [6] test for ICCS,
E 056  0400,3808,20A0,2579 S 579;15671		CALL [MXPR.TEST.VALID]			; return only if valid with
				;15672							;   W3 = ICCS<6> right-justified
				;15673							;   W5 = INT.SYS with bit<0> clear
				;15674							;   ECR tested on A-bus
				;15675
				;15676		;---------------------------------------;
			    p473;15677		[W3] <-- [W3] AND 000000[01], LONG,	; [10] isolate new iccs<6>
E 057  A400,2008,1040,4507 B 007;15678		CASE [A.7-5] AT [MTPR.24.INT]		; case on ECR<ICCS_EXT>
				;15679
				;15680	MTPR.32.39:
				;15681		;---------------------------------------; b<5:3> = 100:
			    p495;15682		[WBUS] <-- [Q] AND 000000[40], LONG,	; [6] test for MCESR
E 058  0400,2200,20A0,2579 S 579;15683		CALL [MXPR.TEST.VALID]			; return only if valid with
				;15684							;   W3 and W5 destroyed
				;15685
				;15686		;---------------------------------------; MCESR:
				;15687		STATE.5-4 <-- 0,			; [10] clear permanent state flags
				;15688		RESTART IBOX,				; restart suspended Ibox
E 059  1001,4000,2004,1000 L	;15689		LAST CYCLE				; exit instruction
				;15690
				;15691	MTPR.40.47:
			    p481;15692		;---------------------------------------; b<5:3> = 101:
E 05A  0001,4202,0C10,00FD J 0FD;15693		UNIMPLEMENTED MTPR REGISTER [W0]	; [6] all registers in this range
				;15694							; are external or read-only
				;15695
				;15696	MTPR.48.55:
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  460
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
			    p481;15697		;---------------------------------------; b<5:3> = 110:
E 05C  0001,4202,0C10,00FD J 0FD;15698		UNIMPLEMENTED MTPR REGISTER [W0]	; [6] all registers in this range
				;15699							; are external
				;15700
				;15701	MTPR.56.63:
				;15702		;---------------------------------------; b<5:3> = 111:
				;15703		[W2] <-- [W1] LSH [9.], LONG,		; [6] shift data left by 9 bits
				;15704		ACCESS B [W1],				; test data on Bbus
			    p474;15705		SYNCHRONIZE MBOX,			; synchronize with TBIA/TBIS next cycle
E 05E  6021,4912,0C20,4390 B 090;15706		CASE [B.2-0] AT [MTPR.56]		; branch to specific flow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  461
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15707
				;15708	;	MFPR, continued.
				;15709	;	Breakout to block complete, continue breakout to individual IPR
				;15710	;
				;15711	;	At this point,
				;15712	;		W0	=	register number
				;15713	;		W1	=	data (MFPR)
				;15714	;		W2	=	PSL left-shifted by 11 bits
				;15715	;		Q	=	1 left-shifted by (IPR number MOD 32)
				;15716	;		W0 tested on B-bus from cycle 5.
				;15717
				;15718	MFPR.00.07:
			    p482;15719		;---------------------------------------; b<5:3> = 000:
E 060  6000,0000,2000,4391 B 091;15720		CASE [B.2-0] AT [MFPR.00]		; [6] branch to specific flow
				;15721
				;15722	MFPR.08.15:
			    p484;15723		;---------------------------------------; b<5:3> = 001:
E 062  6000,0000,2000,43A0 B 0A0;15724		CASE [B.2-0] AT [MFPR.08]		; [6] branch to specific flow
				;15725
				;15726	MFPR.16.23:
				;15727		;---------------------------------------; b<5:3> = 010:
			    p486;15728		[W4] <-- [INT.SYS] AND [K.FFFF], LONG,	; [6] remove int.id bits from int.sys
E 064  6400,0070,1700,43A1 B 0A1;15729		CASE [B.2-0] AT [MFPR.16]		; branch to specific flow
				;15730
				;15731	MFPR.24.31:
				;15732		;---------------------------------------; b<5:3> = 011:
			    p495;15733		[WBUS] <-- [Q] AND [01]000000, LONG,	; [6] test for ICCS,
E 066  0400,3808,20A0,2579 S 579;15734		CALL [MXPR.TEST.VALID]			; return only if valid with
				;15735							;   W3 and W5 destroyed,
				;15736							;   ECR tested on A-bus
				;15737
				;15738		;---------------------------------------;
			    p488;15739		[W2] <-- [INT.SYS] AND 000000[01], LONG, ; [10] isolate iccs<6>
E 067  A400,2008,0F00,4516 B 016;15740		CASE [A.7-5] AT [MFPR.24.INT]		; case on ECR<ICCS_EXT>
				;15741
				;15742	MFPR.32.39:
			    p494;15743		;---------------------------------------; b<5:3> = 100:
E 068  0001,4202,0C10,00FF J 0FF;15744		UNIMPLEMENTED MFPR REGISTER [W0]	; [6] all registers in this range
				;15745							; are external or write-only
				;15746
				;15747	MFPR.40.47:
				;15748		;---------------------------------------; b<5:3> = 101:
			    p495;15749		[WBUS] <-- [Q] AND 0000[0C]00, LONG,	; [6] test for SAVPC, SAVPSL
E 06A  0400,2860,20A0,2579 S 579;15750		CALL [MXPR.TEST.VALID]			; return only if valid with
				;15751							;   W3 and W5 destroyed,
				;15752							;   W0 tested on B-bus
				;15753
			    p489;15754		;---------------------------------------;
E 06B  6000,0000,2000,432D B 02D;15755		CASE [B.2-0] AT [MFPR.42]		; [10] branch to specific flow
				;15756
				;15757	MFPR.48.55:
			    p494;15758		;---------------------------------------; b<5:3> = 110:
E 06C  0001,4202,0C10,00FF J 0FF;15759		UNIMPLEMENTED MFPR REGISTER [W0]	; [6] all registers in this range
				;15760							; are external
				;15761
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  462
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15762	MFPR.56.63:
				;15763		;---------------------------------------; b<5:3> = 111:
				;15764		[WBUS] <-- [PCSCR] AND 0000[PCSCR.PCS.ENB]00, ; [6] test PCS enable bit
			    p490;15765		Q <-- PASSA [PCSCR], LONG,		; save PCSCR in Q
E 06E  6402,6810,23C0,43B0 B 0B0;15766		CASE [B.2-0] AT [MFPR.56]		; branch to specific flow
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  463
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15767
				;15768	;	MxPR continued.
				;15769	;	IPR > 63, test for special cases.
				;15770	;
				;15771	;	At this point,
				;15772	;		W0	=	register number
				;15773	;		W1	=	data (MTPR)
				;15774
				;15775	MTPR.GT.63:
				;15776		;---------------------------------------; alu.z = 0:
				;15777		[W2] <-- [W0] ANDNOT 000000[07], LONG,	; [5] mask out lower 3 bits
E 01B  0480,2038,0C10,0563 J 563;15778		GOTO [MXPR.GT.63]			; recombine flows
				;15779
				;15780	MFPR.GT.63:
				;15781		;---------------------------------------; alu.z = 0:
				;15782		[W2] <-- [W0] ANDNOT 000000[07], LONG,	; [5] mask out lower 3 bits
E 02A  0480,2038,0C10,0563 J 563;15783		GOTO [MXPR.GT.63]			; recombine flows
				;15784
				;15785	MXPR.GT.63:
				;15786		;---------------------------------------;
				;15787		[WBUS] <-- [W2] XOR 000000[IPR.VECTOR.BLOCK], ; [6] test for vector IPR block
E 563  0600,2480,2030,0564 J 564;15788		LONG
				;15789
				;15790		;---------------------------------------;
				;15791		[WBUS] <-- [W2] XOR 000000[IPR.EBOX.BLOCK], ; [7] test for Ebox IPR block
E 564  0600,23C0,2030,0042 J 042;15792		LONG
				;15793
			    p464;15794		;---------------------------------------;
E 042  2000,0000,2000,41E9 B 0E9;15795		CASE [ALU.NZV] AT [MXPR.NOT.144.151]	; [8] case on vector IPR
				;15796
				;15797	;= ALIGNLIST	10xx	(MXPR.NOT.144.151,	MXPR.144.151)
				;15798	;  ALU.NZV set by XOR --> V = 0
				;15799
				;15800	;	Here on vector IPR in the range [144:151]
				;15801
				;15802	MXPR.144.151:
				;15803		;---------------------------------------; alu.z = 1:
			    p480;15804		ACCESS B [W0],				; [9] test register number
E 0ED  8000,0008,2000,4CB5 B 0B5;15805		CASE [OPCODE.2-0] AT [MTPR.144.151]	; branch to opcode-specific flow
				;15806
				;15807	;= ALIGNLIST x10x	(MTPR.144.151,		MFPR.144.151)
				;15808	;  Opcodes = DA, DB --> opcode<2:0> = 01?
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  464
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15809
				;15810	;	MxPR continued.
				;15811	;	IPR > 63, but not in the range [144:151]
				;15812	;
				;15813	;	At this point,
				;15814	;		W0	=	register number
				;15815	;		W1	=	data (MTPR)
				;15816
				;15817	;	Not vector IPR, check for Ebox IPR
				;15818
				;15819	MXPR.NOT.144.151:
				;15820		;---------------------------------------; alu.z = 0:
			    p465;15821		[WBUS] <-- [W0] AND [IPR.CACHE]000000, LONG, ; [9] test for cache IPR
E 0E9  2400,3808,2010,41F8 B 0F8;15822		CASE [ALU.NZV] AT [MXPR.IPR.CACHE.OR.NORMAL] ; case on Ebox IPR
				;15823
				;15824	;= ALIGNLIST	10xx	(MXPR.IPR.CACHE.OR.NORMAL,	MXPR.120.127)
				;15825	;  ALU.NZV set by XOR --> V = 0
				;15826
				;15827	;	Here on Ebox IPR in the range [120:127]
				;15828
				;15829	MXPR.120.127:
				;15830		;---------------------------------------; alu.z = 1:
			    p477;15831		ACCESS B [W0],				; [10] test IPR number
E 0FC  8000,0008,2000,4CE4 B 0E4;15832		CASE [OPCODE.2-0] AT [MTPR.120.127]	; branch to opcode-specific flow
				;15833
				;15834	;= ALIGNLIST x10x	(MTPR.120.127,		MFPR.120.127)
				;15835	;  Opcodes = DA, DB --> opcode<2:0> = 01?
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  465
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15836
				;15837	;	MxPR, continued.
				;15838	;	Normal mode or cache IPR implemented via an IPR command.
				;15839	;
				;15840	;	At this point,
				;15841	;		W0	=	register number
				;15842	;		W1	=	data (MTPR)
				;15843	;		alu.z	=	0 if cache IPR (from previous cycle)
				;15844
				;15845	MXPR.IPR.CACHE.OR.NORMAL:
				;15846		;---------------------------------------; alu.z = 0:
				;15847		[W2] <-- [W0] LSH [2.], LONG,		; compute normal group address
E 0F8  8001,4202,0C10,4CF5 B 0F5;15848		CASE [OPCODE.2-0] AT [MTPR.IPR.CACHE.OR.NORMAL] ; break out opcodes
				;15849
				;15850	;= ALIGNLIST x10x	(MTPR.IPR.CACHE.OR.NORMAL,	MFPR.IPR.CACHE.OR.NORMAL)
				;15851	;  Opcodes = DA, DB --> opcode<2:0> = 01?
				;15852
				;15853	MTPR.IPR.CACHE.OR.NORMAL:
			    p481;15854		;---------------------------------------; opcode<0> = 0:
E 0F5  2000,0000,2000,41F9 B 0F9;15855		CASE [ALU.NZV] AT [MTPR.IPR.CACHE]	; case on cache vs. normal IPR
				;15856
				;15857	;= ALIGNLIST	10xx	(MTPR.IPR.CACHE,	MTPR.IPR.NORMAL)
				;15858	;  ALU.NZV set by AND or PASS --> V = 0
				;15859
				;15860	MFPR.IPR.CACHE.OR.NORMAL:
			    p494;15861		;---------------------------------------; opcode<0> = 0:
E 0F7  2000,0000,2000,41FB B 0FB;15862		CASE [ALU.NZV] AT [MFPR.IPR.CACHE]	; case on cache vs. normal IPR
				;15863
				;15864	;= ALIGNLIST	10xx	(MFPR.IPR.CACHE,	MFPR.IPR.NORMAL)
				;15865	;  ALU.NZV set by AND or PASS --> v = 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  466
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15866
				;15867	;	MxPR, continued.
				;15868	;	Block dispatch constraints.
				;15869
				;15870	;	MTPR block constraints
				;15871
				;15872	;= ALIGNLIST	000x	(MTPR.00.07,	MTPR.08.15,	MTPR.16.23,	MTPR.24.31,
				;15873	;=			 MTPR.32.39,	MTPR.40.47,	MTPR.48.55,	MTPR.56.63)
				;15874
				;15875	;= ALIGNLIST	000x	(MTPR.00,	MTPR.01,	MTPR.02,	MTPR.03,
				;15876	;=			 MTPR.04,	MTPR.05,	MTPR.06,	MTPR.07)
				;15877
				;15878	;= ALIGNLIST	000x	(MTPR.08,	MTPR.09,	MTPR.10,	MTPR.11,
				;15879	;=			 MTPR.12,	MTPR.13,	MTPR.14,	MTPR.15)
				;15880
				;15881	;= ALIGNLIST	000x	(MTPR.16,	MTPR.17,	MTPR.18,	MTPR.19,
				;15882	;=			 MTPR.20,	MTPR.21,	MTPR.22,	MTPR.23)
				;15883
				;15884	;= ALIGNLIST	011x	(MTPR.24.INT,	MTPR.24.EXT)
				;15885
				;15886	;= ALIGNLIST	000x	(MTPR.56,	MTPR.57,	MTPR.58,	MTPR.59,
				;15887	;=			 MTPR.60,	MTPR.61,	MTPR.62,	MTPR.63)
				;15888
				;15889	;	MFPR block constraints
				;15890
				;15891	;= ALIGNLIST	000x	(MFPR.00.07,	MFPR.08.15,	MFPR.16.23,	MFPR.24.31,
				;15892	;=			 MFPR.32.39,	MFPR.40.47,	MFPR.48.55,	MFPR.56.63)
				;15893
				;15894	;= ALIGNLIST	000x	(MFPR.00,	MFPR.01,	MFPR.02,	MFPR.03,
				;15895	;=			 MFPR.04,	MFPR.05,	MFPR.06,	MFPR.07)
				;15896
				;15897	;= ALIGNLIST	000x	(MFPR.08,	MFPR.09,	MFPR.10,	MFPR.11,
				;15898	;=			 MFPR.12,	MFPR.13,	MFPR.14,	MFPR.15)
				;15899
				;15900	;= ALIGNLIST	000x	(MFPR.16,	MFPR.17,	MFPR.18,	MFPR.19,
				;15901	;=			 MFPR.20,	MFPR.21,	MFPR.22,	MFPR.23)
				;15902
				;15903	;= ALIGNLIST	011x	(MFPR.24.INT,	MFPR.24.EXT)
				;15904
				;15905	;= ALIGNLIST	110x	(MFPR.42,	MFPR.43)
				;15906
				;15907	;= ALIGNLIST	000x	(MFPR.56,	MFPR.57,	MFPR.58,	MFPR.59,
				;15908	;=			 MFPR.60,	MFPR.61,	MFPR.62,	MFPR.63)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  467
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15909
				;15910	;	MTPR registers [0:3].
				;15911	;
				;15912	;	At this point,
				;15913	;		W1	=	data
				;15914
				;15915	MTPR.00:
				;15916		;---------------------------------------; ksp:
				;15917		NOP,					; [7] nothing to do
E 080  A000,0000,2000,4D03 B 003;15918		CASE [PSL.26-24] AT [MTPR.KS.ON.KS]	; test for kernel vs interrupt stack
				;15919
				;15920	;= ALIGNLIST 0xxx	(MTPR.KS.ON.KS, MTPR.KS.ON.IS)
				;15921	;  PSL<25:24> = 00 by mode = kernel --> PSL<26:24> = ?00
				;15922
				;15923	MTPR.KS.ON.KS:
				;15924		;---------------------------------------; psl<26> = 0:
				;15925		[SP] <-- [W1], LONG,			; [8] move data to active SP
				;15926		RESTART IBOX,				; restart suspended I-box
E 003  0000,0000,7824,1000 L	;15927		LAST CYCLE				; decode next instruction
				;15928
				;15929	MTPR.KS.ON.IS:
				;15930		;---------------------------------------; psl<26> = 1:
				;15931		[KSP] <-- [W1], LONG,			; [8] move data to inactive SP
				;15932		RESTART IBOX,				; restart suspended I-box
E 00B  0000,0000,8024,1000 L	;15933		LAST CYCLE				; decode next instruction
				;15934
				;15935	MTPR.01:
				;15936		;---------------------------------------; esp:
				;15937		[ESP] <-- [W1], LONG,			; [7] move data to inactive SP
				;15938		RESTART IBOX,				; restart suspended I-box
E 082  0000,0000,8424,1000 L	;15939		LAST CYCLE				; decode next instruction
				;15940
				;15941	MTPR.02:
				;15942		;---------------------------------------; ssp:
				;15943		[SSP] <-- [W1], LONG,			; [7] move data to inactive SP
				;15944		RESTART IBOX,				; restart suspended I-box
E 084  0000,0000,8824,1000 L	;15945		LAST CYCLE				; decode next instruction
				;15946
				;15947	MTPR.03:
				;15948		;---------------------------------------; usp:
				;15949		[USP] <-- [W1], LONG,			; [7] move data to inactive SP
				;15950		RESTART IBOX,				; restart suspended I-box
E 086  0000,0000,8C24,1000 L	;15951		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  468
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15952
				;15953	;	MTPR registers [4:7].
				;15954	;
				;15955	;	At this point,
				;15956	;		W0	=	register number
				;15957	;		W1	=	data
				;15958
				;15959
				;15960	MTPR.04:
				;15961		;---------------------------------------; isp:
				;15962		NOP,					; [7] nothing to do
E 088  A000,0000,2000,4D12 B 012;15963		CASE [PSL.26-24] AT [MTPR.IS.ON.KS]	; test for kernel vs interrupt stack
				;15964
				;15965	;= ALIGNLIST 0xxx	(MTPR.IS.ON.KS, MTPR.IS.ON.IS)
				;15966	;  PSL<25:24> = 00 by mode = kernel --> PSL<26:24> = ?00
				;15967
				;15968	MTPR.IS.ON.KS:
				;15969		;---------------------------------------; psl<26> = 0:
				;15970		[ISP] <-- [W1], LONG,			; [8] move data to inactive SP
				;15971		RESTART IBOX,				; restart suspended I-box
E 012  0000,0000,9024,1000 L	;15972		LAST CYCLE				; decode next instruction
				;15973
				;15974	MTPR.IS.ON.IS:
				;15975		;---------------------------------------; psl<26> = 1:
				;15976		[SP] <-- [W1], LONG,			; [8] move data to active SP
				;15977		RESTART IBOX,				; restart suspended I-box
E 01A  0000,0000,7824,1000 L	;15978		LAST CYCLE				; decode next instruction
				;15979
				;15980	MTPR.05:
			    p481;15981		;---------------------------------------;
E 08A  0001,4202,0C10,00FD J 0FD;15982		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
				;15983
				;15984	MTPR.06:
			    p481;15985		;---------------------------------------;
E 08C  0001,4202,0C10,00FD J 0FD;15986		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
				;15987
				;15988	MTPR.07:
			    p481;15989		;---------------------------------------;
E 08E  0001,4202,0C10,00FD J 0FD;15990		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  469
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;15991
				;15992	;	MTPR registers [8:11].
				;15993	;
				;15994	;	At this point,
				;15995	;		W1	=	data
				;15996	;		Q	=	data left shifted 9 bits
				;15997
				;15998	MTPR.08:
				;15999		;---------------------------------------; p0br:
				;16000		VA <-- K10.[IPR.MP0BR], 		; [7] write register
				;16001		MEM.PR (VA)&, [WBUS] <-- PASSA [W1],	; to M-box
				;16002		LONG,					;
			    p474;16003		GOTO [MTPR.TBIA],			; flush TB and exit
E 081  00F4,7C03,2021,0092 J 092;16004			sim addr [k]
				;16005
				;16006	MTPR.09:
				;16007		;---------------------------------------; p0lr:
				;16008		VA <-- K10.[IPR.MP0LR], 		; [7] write shifted register
				;16009		MEM.PR (VA)&, [WBUS] <-- PASSA [Q],	; to M-box
				;16010		LONG,					;
			    p474;16011		GOTO [MTPR.TBIA],			; flush TB and exit
E 083  00F4,7C23,20A1,0092 J 092;16012			sim addr [k]
				;16013
				;16014	MTPR.10:
				;16015		;---------------------------------------; p1br:
E 085  0A80,3400,0820,0565 J 565;16016		[W1] <-- [W1] - 00[P1BR.BIAS]0000, LONG ; [7] pre-bias base register
				;16017
				;16018		;---------------------------------------;
				;16019		VA <-- K10.[IPR.MP1BR], 		; [8] write register
				;16020		MEM.PR (VA)&, [WBUS] <-- PASSA [W1],	; to M-box
				;16021		LONG,					;
			    p474;16022		GOTO [MTPR.TBIA],			; flush TB and exit
E 565  00F4,7C43,2021,0092 J 092;16023			sim addr [k]
				;16024
				;16025	MTPR.11:
				;16026		;---------------------------------------; p1lr:
				;16027		[W1] <-- [Q] + [P1LR.BIAS.SHIFTED]000000, ; [7] pre-bias P1LR
E 087  0880,3A00,08A0,0566 J 566;16028		LONG
				;16029
				;16030		;---------------------------------------;
				;16031		VA <-- K10.[IPR.MP1LR], 		; [8] load IPR address
				;16032		MEM.PR (VA)&, [WBUS] <-- PASSA [W1],	; to M-box
				;16033		LONG,					;
			    p474;16034		GOTO [MTPR.TBIA],			; flush TB and exit
E 566  00F4,7C63,2021,0092 J 092;16035			sim addr [k]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  470
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16036
				;16037	;	MTPR registers [12:15].
				;16038
				;16039	;	At this point,
				;16040	;		W0	=	register number
				;16041	;		W1	=	data
				;16042	;		Q	=	data left shifted 9
				;16043
				;16044	MTPR.12:
				;16045		;---------------------------------------; sbr:
				;16046		VA <-- K10.[IPR.MSBR],			; [7] write register
				;16047		MEM.PR (VA)&, [WBUS] <-- PASSA [W1],	; to M-box
				;16048		LONG,					;
			    p474;16049		GOTO [MTPR.TBIA],			; flush TB and exit
E 089  00F4,7C83,2021,0092 J 092;16050			sim addr [k]
				;16051
				;16052	MTPR.13:
				;16053		;---------------------------------------; slr:
				;16054		VA <-- K10.[IPR.MSLR],			; [7] load IPR address
				;16055		MEM.PR (VA)&, [WBUS] <-- PASSA [Q],	; to M-box
				;16056		LONG,					;
			    p474;16057		GOTO [MTPR.TBIA],			; flush TB and exit
E 08B  00F4,7CA3,20A1,0092 J 092;16058			sim addr [k]
				;16059
				;16060	MTPR.14:
				;16061		;---------------------------------------; cpuid:
E 08D  0000,0000,0E50,0567 J 567;16062		[W2] <-- [ASTLVL], LONG 		; [7] copy ASTLVL for right shift
				;16063
				;16064		;---------------------------------------;
E 567  0001,881A,0820,0568 J 568;16065		[W1] <-- [W1]!![W2] RSH [8.], LONG	; [8] merge in new cpuid
				;16066
				;16067		;---------------------------------------;
				;16068		[ASTLVL] <-- [W1] LROT [8.], LONG,	; [9] reposition result and store
				;16069		RESTART IBOX,				; restart suspended Ibox
E 568  0001,0812,9424,1000 L	;16070		LAST CYCLE				; decode next instruction
				;16071
				;16072	MTPR.15:
			    p481;16073		;---------------------------------------;
E 08F  0001,4202,0C10,00FD J 0FD;16074		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  471
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16075
				;16076	;	MTPR registers [16:19].
				;16077
				;16078	;	At this point,
				;16079	;		W1	=	data
				;16080	;		W2	=	PSL, with IPL field clear
				;16081	;		W5	=	masked data<4:0> left-shifted by 16 bits
				;16082
				;16083	MTPR.16:
				;16084		;---------------------------------------; pcbb:
				;16085		[PCBB] <-- [W1] ANDNOT 000000[03], LONG, ; [7] store longword aligned PCBB
				;16086		RESTART IBOX,				; restart suspended I-box
E 070  0480,2018,9C24,1000 L	;16087		LAST CYCLE				; decode next instruction
				;16088
				;16089	MTPR.17:
				;16090		;---------------------------------------; scbb:
				;16091		[SCBB] <-- [W1] ANDNOT 000000[03], LONG, ; [7] store longword aligned SCBB
				;16092		RESTART IBOX,				; restart suspended I-box
E 072  0480,2018,9824,1000 L	;16093		LAST CYCLE				; decode next instruction
				;16094
				;16095	MTPR.18:
				;16096		;---------------------------------------; ipl:
				;16097		[PSL] <-- [W2] OR [W5], LONG,		; [7] or new ipl into psl
				;16098							; >> Int sys change, no decode for 4 cycles
			    p417;16099		RESTART IBOX,				; restart suspended I-box
E 074  0500,0030,3034,028C J 28C;16100		GOTO [INTERRUPT.STATE.CHANGE]		; go wait out interrupt change
				;16101
				;16102	MTPR.19:
				;16103		;---------------------------------------; astlvl:
E 076  0001,4302,0E50,0569 J 569;16104		[W2] <-- [ASTLVL] LSH [3], LONG 	; [7] shift out current ASTLVL value
				;16105
				;16106		;---------------------------------------;
				;16107		[ASTLVL] <-- [W1]!![W2] RSH [3], LONG,	; [8] Merge in new ASTLVL value
				;16108		RESTART IBOX,				; restart suspended I-box
E 569  0001,831A,9424,1000 L	;16109		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  472
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16110
				;16111	;	MTPR registers [20:23].
				;16112
				;16113	;	At this point,
				;16114	;		W1	=	data
				;16115
				;16116	MTPR.20:
				;16117		;---------------------------------------; sirr:
E 078  0400,2078,D420,056A J 56A;16118		[SC] <-- [W1] AND 000000[0F]		; [7] load data<3:0> into SC
				;16119
				;16120		;---------------------------------------;
E 56A  0000,0000,2000,0390 J 390;16121		NOP					; [8] wait for SC to set up
				;16122
				;16123		;---------------------------------------;
				;16124		[W3] <-- [K1] LSH (SC), LONG,		; [9] create mask for interrupt
E 390  0001,4002,1320,256D S 56D;16125		CALL [MXPR.CLEAR.W3.BIT.0]		; [10] make sure it won't change iccs<6>
				;16126
				;16127	MTPR.UPDATE.INT.SYS:
				;16128		;---------------------------------------;
				;16129		[INT.SYS] <-- [INT.SYS] OR [W3], LONG,	; [11] set interrupt request flag
				;16130							; >> Int sys change, no decode for 4 cycles
			    p417;16131		RESTART IBOX,				; restart suspended I-box
E 391  0500,0020,C304,028C J 28C;16132		GOTO [INTERRUPT.STATE.CHANGE]		; go wait out state change
				;16133
				;16134	MTPR.21:
				;16135		;---------------------------------------; sisr:
				;16136		[W3] <-- [W1] AND [K.FFFF], LONG,	; [7] mask out any left-half bits
E 07A  0400,0070,1020,256D S 56D;16137		CALL [MXPR.CLEAR.W3.BIT.0]		; [8] make room for iccs<6>
				;16138
				;16139		;---------------------------------------;
				;16140		[W5] <-- [INT.SYS] AND 000000[01],	; [9] save only ICCS<6> from INT.SYS
			    p473;16141		LONG,					;
E 07B  0400,2008,1B00,0007 J 007;16142		GOTO [MTPR.OR.INT.SYS]			; go create new INT.SYS
				;16143
				;16144	MTPR.22:
			    p481;16145		;---------------------------------------;
E 07C  0001,4202,0C10,00FD J 0FD;16146		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
				;16147
				;16148	MTPR.23:
			    p481;16149		;---------------------------------------;
E 07E  0001,4202,0C10,00FD J 0FD;16150		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
				;16151
				;16152	;	Single instruction subroutine to clear W3, bit 0
				;16153
				;16154	MXPR.CLEAR.W3.BIT.0:
				;16155		;---------------------------------------;
				;16156		[W3] <-- [W3] ANDNOT 000000[01], LONG,	; make room for iccs<6>
E 56D  0480,2008,1040,0800 R	;16157		RETURN					; return to caller
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  473
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16158
				;16159	;	MTPR register [24].
				;16160	;	Enter at MTPR.24.INT for internally-implemented subset interval
				;16161	;	timer, MTPR.24.EXT for externally-implemented full interval timer.
				;16162
				;16163	;	At this point,
				;16164	;		W1	=	data
				;16165	;		W3	=	New ICCS<6> in bit 0, other bits clear
				;16166	;		W5	=	INT.SYS with bit 0 clear
				;16167
				;16168	MTPR.24.EXT:
				;16169		;---------------------------------------; a<7> = 1:
				;16170		VA <-- K10.[IPR.ICCS],			; [11] load external ICCS IPR
				;16171		MEM.PR (VA)&, [WBUS] <-- PASSA [W1], LONG, ; and send ICCS off-chip
E 00F  00F4,6303,2021,0007 J 007;16172		GOTO [MTPR.24.INT]			; update internal copy also
				;16173
				;16174	MTPR.OR.INT.SYS:
				;16175	MTPR.24.INT:
				;16176		;---------------------------------------; a<7> = 0:
				;16177		[INT.SYS] <-- [W5] OR [W3], LONG,	; [11,12] or new data to INT.SYS
				;16178							; >> Int sys change, no decode for 4 cycles
			    p417;16179		RESTART IBOX,				; restart suspended I-box
E 007  0500,0020,C064,028C J 28C;16180		GOTO [INTERRUPT.STATE.CHANGE]		; go wait out interrupt state change
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  474
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16181
				;16182	;	MTPR registers [56:58].
				;16183
				;16184	;	At this point,
				;16185	;		W0	=	register number
				;16186	;		W1	=	data
				;16187	;		W2	=	data left shifted 9
				;16188
				;16189	MTPR.56:
				;16190		;---------------------------------------; mapen:
				;16191		VA <-- K10.[IPR.MMAPEN],		; [7] write shifted register
				;16192		MEM.PR (VA)&, [WBUS] <-- PASSA [W2],	; to M-box
E 090  00F4,7CC3,2031,0570 J 570;16193		LONG					;
				;16194
				;16195		;---------------------------------------;
				;16196		VA <-- K10.[IPR.CWB],			; [8] push writes out of the chip
				;16197		MEM.PR (VA)&, [WBUS] <-- PASSA [K0], LONG,
				;16198		GOTO [MTPR.TBIA],			; flush tb, exit instruction
E 570  00F4,6883,2311,0092 J 092;16199			sim addr [k]
				;16200
				;16201	;	Note: MTPR.TBIA is also used as a common exit path for
				;16202	;	IPR writes to the base and length registers.
				;16203
				;16204	;	Note: All paths to MTPR.57 and MTPR.58 (currently only
				;16205	;	from MTPR.08, MTPR.09, MTPR.10, MTPR.11, MTPR.12, MTPR.13,
				;16206	;	MTPR.56, and MTPR.56.63) must have a SYNCHRONIZE MBOX or
				;16207	;	other Mbox request in order to guarantee that the Mbox
				;16208	;	is not in the middle of a TB miss sequence when the
				;16209	;	TBIA/TBIS in injected into the EM latch.  In addition,
				;16210	;	there can be no S3 stall caused by the microinstructions
				;16211	;	at MTPR.57 and MTPR.58.
				;16212
				;16213	MTPR.TBIA:
				;16214	MTPR.57:
				;16215		;---------------------------------------; tbia:
				;16216		TB INVALIDATE ALL,			; [7] kill the translation buffer
			    p351;16217							; >> TBIA, sync with mbox last cycle
E 092  0018,0000,2000,0507 J 507;16218		GOTO [RESTART.IBOX]			; restart Ibox, exit instruction
				;16219
				;16220	MTPR.58:
				;16221		;---------------------------------------; tbis:
				;16222		VA&, [WBUS] <-- [W1], LONG,		; [7] use data as address
				;16223		TB INVALIDATE SINGLE,			; flush the tb entry selected by data
			    p351;16224							; >> TBIS, sync with mbox last cycle
E 094  0010,0001,2020,0507 J 507;16225		GOTO [RESTART.IBOX]			; restart Ibox, exit instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  475
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16226
				;16227	;	MTPR registers [59:61].
				;16228
				;16229	;	At this point,
				;16230	;		W0	=	register number
				;16231	;		W1	=	data
				;16232
				;16233	MTPR.59:
			    p481;16234		;---------------------------------------;
E 096  0001,4202,0C10,00FD J 0FD;16235		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
				;16236
				;16237	MTPR.60:
			    p481;16238		;---------------------------------------;
E 098  0001,4202,0C10,00FD J 0FD;16239		UNIMPLEMENTED MTPR REGISTER [W0]	; [7] unimplemented
				;16240
				;16241	MTPR.61:
				;16242		;---------------------------------------; pme:
E 09A  0001,5F02,0820,0571 J 571;16243		[W1] <-- [W1] LSH [31.], LONG		; [7] shift PME to bit<31>
				;16244
				;16245		;---------------------------------------;
			    p428;16246		ACCESS A [W1],				; [8] test new PME on a<31>
E 571  0000,0000,2020,0515 J 515;16247		GOTO [LDPCTX.MTPR.UPDATE.PME]		; join common code in LDPCTX
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  476
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16248
				;16249	;	MTPR registers [62:63].
				;16250
				;16251	;	At this point,
				;16252	;		W0	=	register number
				;16253	;		W1	=	data
				;16254
				;16255	MTPR.62:
			    p127;16256		;---------------------------------------; sid:
E 09C  0000,0000,2000,003C J 03C;16257		RESERVED OPERAND FAULT			; [7] can't write to SID!!!
				;16258
				;16259	MTPR.63:
				;16260		;---------------------------------------; tbchk:
E 09E  0001,D67A,D800,0516 J 516;16261		[MMGT.MODE] <-- ZEXT [RN.MODE.OPCODE] RSH [22.] ; [7] load curmod into mode reg
				;16262
				;16263		;---------------------------------------;
				;16264		VA <-- [W1],				; [8] probe the address specified,
			    p495;16265		[W0] <-- PROBE.R.MODE.NOFILL (VA),	; but don't do fill
E 516  0058,0001,0420,23F8 S 3F8;16266		CALL [MXPR.ACCESS.B.W0] 		; [9] access status on B port
				;16267
				;16268		;---------------------------------------;
E 517  8000,0000,2000,446C B 56C;16269		CASE [B.5-3] AT [MTPR.63.TBMISS]	; [10] case on TB hit/miss
				;16270
				;16271	;= ALIGNLIST 110x	(MTPR.63.TBMISS,	MTPR.63.TBHIT)
				;16272
				;16273	MTPR.63.TBMISS:
				;16274		;---------------------------------------; b<3> = 0:
				;16275		RESTART IBOX,				; [11] psl cc's correct, restart
E 56C  0000,0000,2004,1000 L	;16276		LAST CYCLE				; Ibox and decode next instn
				;16277
				;16278	MTPR.63.TBHIT:
				;16279		;---------------------------------------; b<3> = 0:
			    p351;16280		SET PSL(V),				; [11] set psl<v> to flag tb hit
E 56E  0080,2008,200E,8507 J 507;16281		GOTO [RESTART.IBOX]			; wait a cycle, restart
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  477
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16282
				;16283	;	MTPR register [120:123].
				;16284	;
				;16285	;	At this point,
				;16286	;		W0	=	register number
				;16287	;		W1	=	data
				;16288	;		W0 selected onto B-bus the previous cycle
				;16289	;
				;16290	;	Note: A SYNCHRONIZE MBOX is done here to guarantee that
				;16291	;	the Mbox is not in a TB miss sequence when the TB TAG/PTE
				;16292	;	fill is done below.  The SYNCHRONIZE MBOX must be in the
				;16293	;	microinstruction immediately preceding the TB TAG/PTE fill
				;16294	;	and there can be no S3 stall in the TB TAG/PTE fill
				;16295	;	microinstruction.
				;16296
				;16297	MTPR.120.127:
				;16298		;---------------------------------------; mtpr:
				;16299		ACCESS A [W1],				; [11] test data for ECR case
				;16300		SYNCHRONIZE MBOX,			; synchronize with TB TAG/PTE FILL below
E 0E4  6020,0000,2020,43D1 B 0D1;16301		CASE [B.2-0] AT [MTPR.120]		; break out registers
				;16302
				;16303	;= ALIGNLIST 000x	(MTPR.120,	MTPR.121,	MTPR.122,	MTPR.123,
				;16304	;=			 MTPR.124,	MTPR.125,	MTPR.126,	MTPR.127)
				;16305
				;16306	MTPR.120:
			    p127;16307		;---------------------------------------; b<2:0> = 000:
E 0D1  0000,0000,2000,003C J 03C;16308		RESERVED OPERAND FAULT			; [12] Unimplemented IPR
				;16309
				;16310	MTPR.121:
			    p127;16311		;---------------------------------------; b<2:0> = 001:
E 0D3  0000,0000,2000,003C J 03C;16312		RESERVED OPERAND FAULT			; [12] Unimplemented IPR
				;16313
				;16314	MTPR.122:
				;16315		;---------------------------------------; b<2:0> = 010 (intsys):
			    p472;16316		[W3] <-- [W1] ANDNOT [K.FFFF], LONG,	; [12] clear right half bits
E 0D5  0480,0070,1020,0391 J 391;16317		GOTO [MTPR.UPDATE.INT.SYS]		; clear any interrupt requests and exit
				;16318
				;16319	MTPR.123:
				;16320		;---------------------------------------; b<2:0> = 011 (pmfcnt):
			    p351;16321		INCREMENT PMF COUNTER,			; [12] increment the counter
E 0D7  0000,0000,2007,8507 J 507;16322		GOTO [RESTART.IBOX]			; restart Ibox and exit instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  478
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16323
				;16324	;	MTPR register [124:127].
				;16325	;
				;16326	;	At this point,
				;16327	;		W0	=	register number
				;16328	;		W1	=	data
				;16329
				;16330	MTPR.124:
				;16331		;---------------------------------------; b<2:0> = 100 (pcscr):
				;16332		[PCSCR] <-- [W1], LONG, 		; [12] store data to register
			    p417;16333		RESTART IBOX,				; restart suspended I-box
E 0D9  0000,0000,F024,028C J 28C;16334		GOTO [INTERRUPT.STATE.CHANGE]		; wait for change, the do next instruction
				;16335
				;16336	MTPR.125:
				;16337		;---------------------------------------; b<2:0> = 101 (ecr):
E 0DB  E000,0000,2000,47E7 B 0E7;16338		CASE [A31.BQA.BNZ1] AT [MTPR.125.POS]	; [12] test new ECR<31>
				;16339
				;16340	;= ALIGNLIST	011x	(MTPR.125.POS,		MTPR.125.NEG)
				;16341
				;16342	MTPR.125.NEG:
				;16343		;---------------------------------------; a<31> = 1:
				;16344		[ECR] <-- [W1], LONG,			; [13] store data to register
			    p163;16345		CLEAR PMF COUNTERS,			; clear the PMF counters
E 0EF  0000,0000,E827,22B7 S 2B7;16346		CALL [WAIT.TWO.CYCLES]			; wait for request to go away
				;16347
				;16348		;---------------------------------------;
				;16349		[INT.SYS] <-- [INT.SYS] OR [ISR.PMF]000000, ; clear interrupt request
				;16350		LONG,					; with different ISR bit
			    p417;16351		RESTART IBOX,				; restart suspended Ibox
E 0E0  0500,3880,C304,028C J 28C;16352		GOTO [INTERRUPT.STATE.CHANGE]		; wait for change to take effect
				;16353
				;16354	MTPR.125.POS:
				;16355		;---------------------------------------; a<31> = 0:
				;16356		[ECR] <-- [W1], LONG,			; [13] store data to register
			    p417;16357		RESTART IBOX,				; restart suspended I-box
E 0E7  0000,0000,E824,028C J 28C;16358		GOTO [INTERRUPT.STATE.CHANGE]		; wait for change, then do next instruction
				;16359
				;16360	;	Note: SYNCHRONIZE MBOX required in the previous cycle
				;16361
				;16362	MTPR.126:
				;16363		;---------------------------------------; b<2:0> = 110 (mtbtag):
				;16364		VA <-- [W1],				; [12] load data into VA
				;16365		[WBUS] <-- 0, LONG,			; data is unused; make it 0
				;16366		TB TAG FILL,				; and do TB tag fill
				;16367							; >> TB TAG FILL, sync mbox last cycle
				;16368		RESTART IBOX,				; restart suspended Ibox
E 0DD  0028,C003,2024,1000 L	;16369		LAST CYCLE				; decode next instruction
				;16370
				;16371	;	Note: SYNCHRONIZE MBOX required in the previous cycle
				;16372
				;16373	MTPR.127:
				;16374		;---------------------------------------; b<2:0> = 111 (mtbpte):
				;16375		VA <-- [W1],				; [13] load data into VA
				;16376		[WBUS] <-- 0, LONG,			; data is unused; make it 0
				;16377		TB PTE FILL,				; and do TB PTE fill
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  479
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16378							; >> TB PTE FILL, sync mbox last cycle
				;16379		RESTART IBOX,				; restart suspended Ibox
E 0DF  002C,C003,2024,1000 L	;16380		LAST CYCLE				; decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  480
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16381
				;16382	;	MTPR registers [144:151]
				;16383	;
				;16384	;	At this point,
				;16385	;		W0	=	register number (MTPR.144.151 entry only)
				;16386	;		W1	=	data (MTPR)
				;16387	;
				;16388	;	These registers must be special-cased if no vector unit is present.
				;16389	;	In that instance, no bus transaction should be issued.
				;16390
				;16391	MTPR.144.151:
				;16392		;---------------------------------------; alu.z = 1:
				;16393		[W2] <-- [W0] LSH [2.], LONG,		; [10] compute IPR address
E 0B5  0001,4202,0C10,5077 B 077;16394		CASE [VECTOR] AT [MTPR.VECTOR.ABSENT]	; case on vector present state
				;16395
				;16396	;= ALIGNLIST	011x	(MTPR.VECTOR.ABSENT,	MTPR.VECTOR.PRESENT)
				;16397
				;16398	MTPR.VECTOR.ABSENT:
				;16399		;---------------------------------------; vector<2> = 0:
				;16400		RESTART IBOX,				; [11] restart suspended Ibox
E 077  0000,0000,2004,1000 L	;16401		LAST CYCLE				; exit instruction
				;16402
				;16403	MTPR.VECTOR.PRESENT:
				;16404		;---------------------------------------; vector<2> = 1:
				;16405		RESTART IBOX,				; [11] restart suspended Ibox
E 07F  0000,0000,2004,1000 L	;16406		LAST CYCLE				; exit instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  481
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16407
				;16408	;	MTPR cache or normal IPRs.
				;16409	;	Enter at MTPR.IPR.CACHE for cache IPRs, MTPR.IPR.NORMAL for
				;16410	;	normal IPRs processed via an IPR write command.
				;16411	;
				;16412	;	At this point,
				;16413	;		W0	=	IPR number (MTPR.IPR.CACHE entry only)
				;16414	;		W1	=	data
				;16415	;		W2	=	IPR number * 4 (MTPR.IPR.NORMAL entry only)
				;16416
				;16417	MTPR.IPR.CACHE:
				;16418		;---------------------------------------; alu.z = 1:
				;16419		[W2] <-- [W0], LONG,			; use unshifted IPR address
E 0F9  0000,0000,0C10,00FD J 0FD;16420		GOTO [MTPR.IPR.NORMAL]			; and join normal flow
				;16421
				;16422	MTPR.IPR.NORMAL:
				;16423		;---------------------------------------; alu.z = 0:
				;16424		VA <-- [W2],				; load appropriate VA
				;16425		MEM.PR (VA)&, [WBUS] <-- PASSB [W1],	; write data
				;16426		LONG,
E 0FD  0074,8013,2030,0572 J 572;16427		GOTO [SYNC.RESTART.IBOX]
				;16428
				;16429	;	The following SYNCHRONIZE MBOX is required to synchronize a possible
				;16430	;	Ibox IPR write or LOAD PC with a possible subsequent Ibox IPR write or
				;16431	;	LOAD PC.  This is required because there is no queue for either command
				;16432	;	in the Ibox, and it must accept the command before receiving the next one.
				;16433	;	A synchronize Mbox does this because of the operation of the
				;16434	;	S5 and S6 segments of the Mbox pipe, relative to delivery of Ibox
				;16435	;	IPR write or LOAD PC data on the MD bus.
				;16436
				;16437	SYNC.RESTART.IBOX:
				;16438		;---------------------------------------;
				;16439		SYNCHRONIZE MBOX,			; synchronize possible Ibox IPR write
				;16440		RESTART IBOX,				; restart suspended I-box
E 572  0020,0000,2004,1000 L	;16441		LAST CYCLE				; decode next instruction
				;16442
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  482
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16443
				;16444	;	MFPR registers [0:3].
				;16445
				;16446	;	At this point,
				;16447	;		DST	=	destination pointer
				;16448
				;16449	MFPR.00:
				;16450		;---------------------------------------; ksp:
				;16451		NOP,					; [7] nothing to do
E 091  A000,0000,2000,4D23 B 023;16452		CASE [PSL.26-24] AT [MFPR.KS.ON.KS]	; case on kernel vs interrupt stack
				;16453
				;16454	;= ALIGNLIST 0xxx	(MFPR.KS.ON.KS, MFPR.KS.ON.IS)
				;16455	;  PSL<25:24> = 00 by mode = kernel --> PSL<26:24> = ?00
				;16456
				;16457	MFPR.KS.ON.KS:
				;16458		;---------------------------------------; psl<26> = 0:
				;16459		[DST] <-- [SP], LONG,			; [8] get active stack pointer
			    p351;16460		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 023  0000,0000,25EC,0507 J 507;16461		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16462
				;16463	MFPR.KS.ON.IS:
				;16464		;---------------------------------------; psl<26> = 1:
				;16465		[DST] <-- [KSP], LONG,			; [8] get inactive stack pointer
			    p351;16466		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 02B  0000,0000,260C,0507 J 507;16467		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16468
				;16469	MFPR.01:
				;16470		;---------------------------------------; esp:
				;16471		[DST] <-- [ESP], LONG,			; [7] get inactive stack pointer
			    p351;16472		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 093  0000,0000,261C,0507 J 507;16473		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16474
				;16475	MFPR.02:
				;16476		;---------------------------------------; ssp:
				;16477		[DST] <-- [SSP], LONG,			; [7] get inactive stack pointer
			    p351;16478		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 095  0000,0000,262C,0507 J 507;16479		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16480
				;16481	MFPR.03:
				;16482		;---------------------------------------; usp:
				;16483		[DST] <-- [USP], LONG,			; [7] get inactive stack pointer
			    p351;16484		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 097  0000,0000,263C,0507 J 507;16485		GOTO [RESTART.IBOX]			; restart Ibox and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  483
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16486
				;16487	;	MFPR registers [4:7].
				;16488
				;16489	;	At this point,
				;16490	;		W0	=	register number
				;16491	;		DST	=	destination pointer
				;16492
				;16493	MFPR.04:
				;16494		;---------------------------------------; is:
				;16495		NOP,					; [7] nothing to do
E 099  A000,0000,2000,4D32 B 032;16496		CASE [PSL.26-24] AT [MFPR.IS.ON.KS]	; case on PSL<is>
				;16497
				;16498	;= ALIGNLIST 0xxx	(MFPR.IS.ON.KS, MFPR.IS.ON.IS)
				;16499	;  PSL<25:24> = 00 by mode = kernel --> PSL<26:24> = ?00
				;16500
				;16501	MFPR.IS.ON.KS:
				;16502		;---------------------------------------; psl<26> = 0:
				;16503		[DST] <-- [ISP], LONG,			; [8] get inactive stack pointer
			    p351;16504		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 032  0000,0000,264C,0507 J 507;16505		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16506
				;16507	MFPR.IS.ON.IS:
				;16508		;---------------------------------------; psl<26> = 1:
				;16509		[DST] <-- [SP], LONG,			; [8] get active stack pointer
			    p351;16510		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 03A  0000,0000,25EC,0507 J 507;16511		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16512
				;16513	MFPR.05:
			    p494;16514		;---------------------------------------;
E 09B  0001,4202,0C10,00FF J 0FF;16515		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
				;16516
				;16517	MFPR.06:
			    p494;16518		;---------------------------------------;
E 09D  0001,4202,0C10,00FF J 0FF;16519		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
				;16520
				;16521	MFPR.07:
			    p494;16522		;---------------------------------------;
E 09F  0001,4202,0C10,00FF J 0FF;16523		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  484
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16524
				;16525	;	MFPR registers [8:11].
				;16526
				;16527	;	At this point,
				;16528	;		DST	=	destination pointer
				;16529
				;16530	MFPR.08:
				;16531		;---------------------------------------; p0br:
				;16532		VA <-- K10.[IPR.MP0BR], 		; [7] read register
				;16533		[W1] <-- MEM.PR (VA), LONG,		; into E-box
			    p494;16534		GOTO [MFPR.DST],			; go store result
E 0A0  00D4,3C01,0801,0577 J 577;16535			sim addr [k]
				;16536
				;16537	MFPR.09:
				;16538		;---------------------------------------; p0lr:
				;16539		VA <-- K10.[IPR.MP0LR], 		; [7] read register
				;16540		[W1] <-- MEM.PR (VA), LONG,		; into E-box
			    p494;16541		GOTO [MFPR.DST.RSH.9],			; right-justify and store result
E 0A2  00D4,3C21,0801,0578 J 578;16542			sim addr [k]
				;16543
				;16544	MFPR.10:
				;16545		;---------------------------------------; p1br:
				;16546		VA <-- K10.[IPR.MP1BR], 		; [7] read register
				;16547		[W1] <-- MEM.PR (VA), LONG,		; into E-box
E 0A4  00D4,3C41,0801,0573 J 573;16548			sim addr [k]
				;16549
				;16550		;---------------------------------------;
			    p494;16551		[W1] <-- [W1] + 00[P1BR.BIAS]0000, LONG, ; [8] unbias base register
E 573  0880,3400,0820,0577 J 577;16552		GOTO [MFPR.DST] 			; go store result
				;16553
				;16554	MFPR.11:
				;16555		;---------------------------------------; p1lr:
				;16556		VA <-- K10.[IPR.MP1LR], 		; [7] read register
				;16557		[W1] <-- MEM.PR (VA), LONG,		; into E-box
E 0A6  00D4,3C61,0801,0574 J 574;16558			sim addr [k]
				;16559
				;16560		;---------------------------------------; p1lr:
				;16561		[W1] <-- [W1] - [P1LR.BIAS.SHIFTED]000000, ; [8] unbias length register
			    p494;16562		LONG,
E 574  0A80,3A00,0820,0578 J 578;16563		GOTO [MFPR.DST.RSH.9]			; right-justify and store result
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  485
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16564
				;16565	;	MFPR registers [12:15].
				;16566
				;16567	;	At this point,
				;16568	;		W0	=	register number
				;16569	;		DST	=	destination pointer
				;16570
				;16571	MFPR.12:
				;16572		;---------------------------------------; sbr:
				;16573		VA <-- K10.[IPR.MSBR],			; [7] read register
				;16574		[W1] <-- MEM.PR (VA), LONG,		; into E-box
			    p494;16575		GOTO [MFPR.DST],			; go store result
E 0A8  00D4,3C81,0801,0577 J 577;16576			sim addr [k]
				;16577
				;16578	MFPR.13:
				;16579		;---------------------------------------; slr:
				;16580		VA <-- K10.[IPR.MSLR],			; [7] read register
				;16581		[W1] <-- MEM.PR (VA), LONG,		; into E-box
			    p494;16582		GOTO [MFPR.DST.RSH.9],			; right-justify and store result
E 0AA  00D4,3CA1,0801,0578 J 578;16583			sim addr [k]
				;16584
				;16585	MFPR.14:
				;16586		;---------------------------------------; cpuid:
				;16587		[DST] <-- [ASTLVL] AND 000000[0FF], LONG, ; [7] mask off and write CPUID
			    p351;16588		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 0AC  0400,27F8,265C,0507 J 507;16589		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16590
				;16591	MFPR.15:
			    p494;16592		;---------------------------------------;
E 0AE  0001,4202,0C10,00FF J 0FF;16593		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  486
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16594
				;16595	;	MFPR registers [16:19].
				;16596
				;16597	;	At this point,
				;16598	;		W2	=	PSL left-shifted by 11 bits
				;16599	;		DST	=	destination pointer
				;16600
				;16601	MFPR.16:
				;16602		;---------------------------------------; pcbb:
				;16603		[DST] <-- [PCBB], LONG, 		; [7] get PCBB
			    p351;16604		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 0A1  0000,0000,267C,0507 J 507;16605		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16606
				;16607	MFPR.17:
				;16608		;---------------------------------------; scbb:
				;16609		[DST] <-- [SCBB], LONG, 		; [7] get SCBB
			    p351;16610		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 0A3  0000,0000,266C,0507 J 507;16611		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16612
				;16613	MFPR.18:
				;16614		;---------------------------------------; ipl:
				;16615		[DST] <-- ZEXT [W2] RSH [27.], LONG,	; [7] right-justify and store ipl
			    p351;16616		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 0A5  0001,DB1A,240C,0507 J 507;16617		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16618
				;16619	MFPR.19:
				;16620		;---------------------------------------; astlvl:
E 0A7  0000,0000,1250,0575 J 575;16621		[W3] <-- [ASTLVL], LONG 		; [7] copy ASTLVL for right shift
				;16622
				;16623		;---------------------------------------;
				;16624		[DST] <-- ZEXT [W3] RSH [29.], LONG,	; [8] shift astlvl to low order bits
			    p351;16625		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 575  0001,DD22,240C,0507 J 507;16626		GOTO [RESTART.IBOX]			; restart Ibox and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  487
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16627
				;16628	;	MFPR registers [20:23].
				;16629
				;16630	;	At this point,
				;16631	;		W0	=	register number
				;16632	;		W4	=	INT.SYS<15:0>, with other bits clear
				;16633	;		DST	=	destination pointer
				;16634
				;16635	MFPR.20:
			    p127;16636		;---------------------------------------; sirr:
E 0A9  0000,0000,2000,003C J 03C;16637		RESERVED OPERAND FAULT			; [7] can't read SIRR!!!
				;16638
				;16639	MFPR.21:
				;16640		;---------------------------------------; sisr:
				;16641		[DST] <-- [W4] ANDNOT 000000[01], LONG, ; [7] clear iccs<6>
			    p351;16642		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 0AB  0480,2008,245C,0507 J 507;16643		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16644
				;16645	MFPR.22:
			    p494;16646		;---------------------------------------;
E 0AD  0001,4202,0C10,00FF J 0FF;16647		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
				;16648
				;16649	MFPR.23:
			    p494;16650		;---------------------------------------;
E 0AF  0001,4202,0C10,00FF J 0FF;16651		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  488
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16652
				;16653	;	MFPR register [24].
				;16654	;	Enter at MFPR.24.INT for internally-implemented subset interval
				;16655	;	timer, MFPR.24.EXT for externally-implemented full interval timer.
				;16656
				;16657	;	At this point,
				;16658	;		W2	=	INT.SYS<0>, other bits clear
				;16659	;		DST	=	destination pointer
				;16660
				;16661	MFPR.24.INT:
				;16662		;---------------------------------------; a<7> = 0:
				;16663		[DST] <-- [W2] LSH [6.], LONG,		; [11] shift iccs<6> into bit 6
			    p351;16664		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 016  0001,4602,243C,0507 J 507;16665		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16666
				;16667	MFPR.24.EXT:
				;16668		;---------------------------------------; a<7> = 0:
				;16669		VA <-- K10.[IPR.ICCS],			; [11] read external ICCS
			    p494;16670		[W1] <-- MEM.PR (VA), LONG,		; into W1
E 01E  00D4,2301,0801,0577 J 577;16671		GOTO [MFPR.DST] 			; do store and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  489
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16672
				;16673	;	MFPR registers [42:43].
				;16674
				;16675	;	At this point,
				;16676	;		DST	=	destination pointer
				;16677
				;16678	MFPR.42:
				;16679		;---------------------------------------; savpc:
				;16680		[DST] <-- [SAVEPC], LONG,		; [11] get saved PC
			    p351;16681		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 02D  0000,0000,268C,0507 J 507;16682		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16683
				;16684	MFPR.43:
				;16685		;---------------------------------------; savpsl:
				;16686		[DST] <-- [SAVEPSL], LONG,		; [11] get saved PSL
			    p351;16687		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 02F  0000,0000,269C,0507 J 507;16688		GOTO [RESTART.IBOX]			; restart Ibox and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  490
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16689
				;16690	;	MFPR registers [56:59].
				;16691
				;16692	;	At this point,
				;16693	;		W0	=	register number
				;16694	;		DST	=	destination pointer
				;16695
				;16696	MFPR.56:
				;16697		;---------------------------------------; mapen:
				;16698		VA <-- K10.[IPR.MMAPEN],		; [7] read register
				;16699		[W1] <-- MEM.PR (VA), LONG,		; into E-box
			    p494;16700		GOTO [MFPR.DST.RSH.9],			; right-justify and store result
E 0B0  00D4,3CC1,0801,0578 J 578;16701			sim addr [k]
				;16702
				;16703	MFPR.57:
			    p127;16704		;---------------------------------------; tbia:
E 0B2  0000,0000,2000,003C J 03C;16705		RESERVED OPERAND FAULT			; [7] can't read TBIA!!!
				;16706
				;16707	MFPR.58:
			    p127;16708		;---------------------------------------; tbis:
E 0B4  0000,0000,2000,003C J 03C;16709		RESERVED OPERAND FAULT			; [7] can't read TBIS!!!
				;16710
				;16711	MFPR.59:
			    p494;16712		;---------------------------------------;
E 0B6  0001,4202,0C10,00FF J 0FF;16713		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  491
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16714
				;16715	;	MFPR registers [60:63].
				;16716
				;16717	;	At this point,
				;16718	;		W0	=	register number
				;16719	;		Q	=	PCSCR value
				;16720	;		DST	=	destination pointer
				;16721
				;16722	MFPR.60:
			    p494;16723		;---------------------------------------;
E 0B8  0001,4202,0C10,00FF J 0FF;16724		UNIMPLEMENTED MFPR REGISTER [W0]	; [7] unimplemented
				;16725
				;16726	MFPR.61:
				;16727		;---------------------------------------; pme:
				;16728		[W2] <-- [ECR] AND 00[ECR.PMF.ENABLE]0000, ; [7] isolate PME bit
E 0BA  0400,3008,0FA0,0576 J 576;16729		LONG
				;16730
				;16731		;---------------------------------------;
				;16732		[DST] <-- ZEXT [W2] RSH [16.], LONG,	; [8] right justify and store
			    p351;16733		SET PSL CC.IIIP,			; set psl cc's
E 576  0001,D01A,240C,0507 J 507;16734		GOTO [RESTART.IBOX]			; go restart Ibox and exit
				;16735
				;16736	MFPR.62:
				;16737		;---------------------------------------; sid:
E 0BC  0080,3898,0C00,0176 J 176;16738		[W2] <-- [NVAX.SID]000000, LONG 	; [7] load up SID type field
				;16739
				;16740		;---------------------------------------;
				;16741		Q <-- ZEXT [Q] RSH [15.], LONG, 	; [8] position patch field
E 176  2003,CF50,2000,41C1 B 1C1;16742		CASE [ALU.NZV] AT [MFPR.62.PCS.ENABLED] ; case on PCS enabled from [6]
				;16743
				;16744	;= ALIGNLIST	x0xx	(MFPR.62.PCS.ENABLED,	MFPR.62.PCS.DISABLED)
				;16745	;  ALU.NZVC set by AND with mask<31> = 0 --> N = V = C = 0
				;16746
				;16747	MFPR.62.PCS.ENABLED:
				;16748		;---------------------------------------; alu.z = 0:
E 1C1  0500,0050,0C30,01C5 J 1C5;16749		[W2] <-- [W2] OR [Q], LONG		; [9] merge PCS rev into
				;16750							;     SID<13:8>
				;16751
				;16752	MFPR.62.PCS.DISABLED:
				;16753		;---------------------------------------; alu.z = 1:
				;16754		[DST] <-- [W2] OR 000000[<MICROCODE.REVISION>], ; [9,10] merge ucode rev and store
				;16755		LONG,
			    p351;16756		SET PSL CC.IIIP,			; set psl cc's, default map is iiip
E 1C5  0500,2018,243C,0507 J 507;16757		GOTO [RESTART.IBOX]			; restart Ibox and exit
				;16758
				;16759	MFPR.63:
			    p127;16760		;---------------------------------------; tbchk:
E 0BE  0000,0000,2000,003C J 03C;16761		RESERVED OPERAND FAULT			; [7] can't read TBCHK!!!
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  492
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16762
				;16763	;	MFPR registers [120:127]
				;16764	;	Only four registers in the range [120:127] are actually implemented,
				;16765	;	but the entire range is block decoded.	Therefore, the unimplemented
				;16766	;	registers are actually mapped into the implemented registers by the
				;16767	;	4-way case below.
				;16768	;
				;16769	;	At this point,
				;16770	;		W0	=	register number
				;16771	;		DST	=	destination pointer
				;16772	;		W0 selected onto B-bus the previous cycle
				;16773
				;16774	MFPR.120.127:
				;16775		;---------------------------------------; mfpr:
E 0E6  6000,0000,2000,43E8 B 0E8;16776		CASE [B.2-0] AT [MFPR.120.124]		; [11] break out registers
				;16777
				;16778	;= ALIGNLIST 100x	(MFPR.120.124,		MFPR.121.125,
				;16779	;=			 MFPR.122.126,		MFPR.123.127)
				;16780
				;16781	MFPR.120.124:
				;16782		;---------------------------------------; b<1:0> = 00:
				;16783		[DST] <-- [PCSCR], LONG,		; [12] must be pcscr, store it
			    p351;16784		SET PSL CC.IIIP,			; set psl cc's
E 0E8  0000,0000,27CC,0507 J 507;16785		GOTO [RESTART.IBOX]			; go restart Ibox and exit
				;16786
				;16787	MFPR.121.125:
				;16788		;---------------------------------------; b<1:0> = 01:
				;16789		[DST] <-- [ECR], LONG,			; [12] must be ecr, store it
			    p351;16790		SET PSL CC.IIIP,			; set psl cc's
E 0EA  0000,0000,27AC,0507 J 507;16791		GOTO [RESTART.IBOX]			; go restart Ibox and exit
				;16792
				;16793	MFPR.122.126:
				;16794		;---------------------------------------; b<1:0> = 10:
				;16795		[DST] <-- [INT.SYS], LONG,		; [12] must be intsys, store it
			    p351;16796		SET PSL CC.IIIP,			; set psl cc's
E 0EC  0000,0000,270C,0507 J 507;16797		GOTO [RESTART.IBOX]			; go restart Ibox and exit
				;16798
				;16799	MFPR.123.127:
				;16800		;---------------------------------------; b<1:0> = 11:
				;16801		[DST] <-- [PERF.COUNT], LONG,		; [12] must be pmfcnt, store it
			    p351;16802		SET PSL CC.IIIP,			; set psl cc's
E 0EE  0000,0000,27BC,0507 J 507;16803		GOTO [RESTART.IBOX]			; go restart Ibox and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  493
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16804
				;16805	;	MFPR registers [144:151]
				;16806	;
				;16807	;	At this point,
				;16808	;		W0	=	register number
				;16809	;
				;16810	;	These registers must be special-cased if no vector unit is present.
				;16811	;	In that instance, no bus transaction should be issued and a zero
				;16812	;	is returned in the destination.
				;16813
				;16814	MFPR.144.151:
				;16815		;---------------------------------------; alu.z = 1:
E 0B7  0000,0000,2000,50F6 B 0F6;16816		CASE [VECTOR] AT [MFPR.VECTOR.ABSENT]	; [10] case on vector present state
				;16817
				;16818	;= ALIGNLIST	011x	(MFPR.VECTOR.ABSENT,	MFPR.VECTOR.PRESENT)
				;16819
				;16820	MFPR.VECTOR.ABSENT:
				;16821		;---------------------------------------; vector<2> = 0:
				;16822		[DST] <-- [K0], LONG,			; [11] write 0 to destination
			    p351;16823		SET PSL CC.IIIP,			; set psl cc's
E 0F6  0000,0000,271C,0507 J 507;16824		GOTO [RESTART.IBOX]			; go restart Ibox and exit
				;16825
				;16826	MFPR.VECTOR.PRESENT:
				;16827		;---------------------------------------; vector<2> = 1:
				;16828		[DST] <-- [K0], LONG,			; [11] write 0 to destination
			    p351;16829		SET PSL CC.IIIP,			; set psl cc's
E 0FE  0000,0000,271C,0507 J 507;16830		GOTO [RESTART.IBOX]			; go restart Ibox and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  494
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16831
				;16832	;	MFPR cache or external IPRs.
				;16833	;	Enter at MFPR.CACHE for cache IPRS, MFPR.IPR.NORMAL for normal IPRs
				;16834	;	processed via an IPR read command.
				;16835	;
				;16836	;	At this point,
				;16837	;		W0	=	IPR number (MFPR.CACHE entry only)
				;16838	;		W2	=	IPR number * 4 (MFPR.IPR.NORMAL entry only)
				;16839
				;16840	MFPR.IPR.CACHE:
				;16841		;---------------------------------------; alu.z = 1:
				;16842		[W2] <-- [W0], LONG,			; use unshifted IPR address
E 0FB  0000,0000,0C10,00FF J 0FF;16843		GOTO [MFPR.IPR.NORMAL]			; and join normal flow
				;16844
				;16845	MFPR.IPR.NORMAL:
				;16846		;---------------------------------------; alu.z = 0:
				;16847		VA <-- [W2],				; load appropriate VA
				;16848		[W1] <-- MEM.PR (VA), LONG,		; read data
E 0FF  0054,0001,0830,0577 J 577;16849		GOTO [MFPR.DST] 			; store result and exit
				;16850
				;16851	MFPR.DST:
				;16852		;---------------------------------------;
				;16853		[DST] <-- [W1], LONG,			; write data to destination
			    p351;16854		SET PSL CC.IIIP,			; set psl cc's
E 577  0000,0000,242C,0507 J 507;16855		GOTO [RESTART.IBOX]			; go restart Ibox and exit
				;16856
				;16857	MFPR.DST.RSH.9:
				;16858		;---------------------------------------;
				;16859		[DST] <-- ZEXT [W1] RSH [9.], LONG,	; right justify result and store
			    p351;16860		SET PSL CC.IIIP,			; set psl cc's
E 578  0001,C912,240C,0507 J 507;16861		GOTO [RESTART.IBOX]			; go restart Ibox and exit
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  495
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16862
				;16863	;	MxPR subroutines.
				;16864	;
				;16865	;	MXPR.TEST.VALID checks for a valid register number based on a
				;16866	;	test performed in the microinstruction that calls this routine.
				;16867	;	If the register number is not valid, this subroutine does not
				;16868	;	return but, rather, jumps directly to MXPR.IPR.CACHE.OR.NORMAL.  If it does
				;16869	;	return, it sets up certain conditions used by the callers.
				;16870	;
				;16871	;	Entry conditions:
				;16872	;		ALU.Z	=	0 if register number is valid (from calling cycle)
				;16873	;		W0	=	register number
				;16874	;		W1	=	data (MTPR)
				;16875	;
				;16876	;	Exit conditions:
				;16877	;		W3	=	data right-shifted 6 bits
				;16878	;		W5	=	INT.SYS with all but bit<0> cleared
				;16879	;		ECR selected onto the A-bus in the return cycle
				;16880	;		W0 selected onto the B-bus in the return cycle
				;16881
				;16882	MXPR.TEST.VALID:
				;16883		;---------------------------------------;
E 579  0001,C612,1000,0347 J 347;16884		[W3] <-- ZEXT [W1] RSH [6.], LONG	; shift iccs<6> into bit 0
				;16885
				;16886		;---------------------------------------;
				;16887		[W5] <-- [INT.SYS] ANDNOT 000000[01], LONG, ; clear old iccs<6>
E 347  2480,2008,1B00,41F8 B 3F8;16888		CASE [ALU.NZV] AT [MXPR.REG.VALID]	 ; case on valid register
				;16889
				;16890	;= ALIGNLIST	10xx	(MXPR.REG.VALID,	MXPR.REG.INVALID)
				;16891	;  ALU.NZVC set by AND	--> V = 0
				;16892
				;16893	MXPR.REG.INVALID:
				;16894		;---------------------------------------; alu.z = 1:
			    p465;16895		[WBUS] <-- [K0], LONG,			; can't be cache IPR (force alu.z=1)
E 3FC  0000,0000,2310,00F8 J 0F8;16896		GOTO [MXPR.IPR.CACHE.OR.NORMAL] 	; join external flow
				;16897
				;16898	MXPR.REG.VALID:
				;16899	MXPR.ACCESS.B.W0:				; used to ACCESS B [W0]
				;16900		;---------------------------------------; alu.z = 0:
				;16901		ACCESS A [ECR], 			; access ECR on A-bus
				;16902		ACCESS B [W0],				; access IPR number on B-bus
E 3F8  0000,0008,23A0,0800 R	;16903		RETURN
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  496
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16904
				;16905	;	Subroutine to conditionally update the performance monitoring
				;16906	;	block in memory with the current hardware counters.
				;16907	;
				;16908	;	Entry conditions:
				;16909	;		ASTLVL<7:0> =	CPUID value for this CPU
				;16910	;		ALU.Z	=	0 if PME=1, 1 if PME=0 (valid in first cycle)
				;16911	;
				;16912	;	Exit conditions:
				;16913	;		Memory block updated if PME=1
				;16914
				;16915	UPDATE.PMF.COUNTERS:
				;16916		;---------------------------------------;
			    p497;16917		[W2] <-- [ASTLVL] AND 000000[0FF], LONG, ; isolate CPUID value
E 177  2400,27F8,0E50,41D1 B 1D1;16918		CASE [ALU.NZV] AT [UPDATE.PMF.COUNTERS.ON] ; case on current PME
				;16919
				;16920	;= ALIGNLIST	x0xx	(UPDATE.PMF.COUNTERS.ON, UPDATE.PMF.COUNTERS.OFF)
				;16921	;  ALU.NZVC set by longword AND with bit other than 31 --> N = V = 0
				;16922
				;16923	UPDATE.PMF.COUNTERS.OFF:
				;16924		;---------------------------------------; alu.z = 1:
E 1D5  0000,0000,2000,0800 R	;16925		RETURN					; no update needed, return
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  497
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16926
				;16927	;	UPDATE.PMF.COUNTERS, continued.
				;16928	;	PME=1, so update is required.
				;16929	;
				;16930	;	At this point,
				;16931	;		W2	=	Right-justified and zero-extended CPUID value
				;16932
				;16933	UPDATE.PMF.COUNTERS.ON:
				;16934		;---------------------------------------; alu.z = 0:
				;16935		VA <-- [SCBB] + 000000[SCB.PMF.BASE],	; Compute PMF base in SCB
E 1D1  08D0,22C1,1A60,057A J 57A;16936		[W5] <-- MEM.SCB (VA), LONG		; read base address of block
				;16937
				;16938		;---------------------------------------;
E 57A  0A80,2018,1860,057B J 57B;16939		[W5] <-- [W5] - 000000[03], LONG	; remove bit encoding
				;16940
				;16941		;---------------------------------------;
				;16942		[W2] <-- [W2] LSH [4],			; QW align CPUID value
E 57B  0001,4432,0C30,0518 J 518;16943		ACCESS B [W5]				; test for SCB<3:0> = 011
				;16944
				;16945		;---------------------------------------;
				;16946		VA <-- [W5] + [W2],			; compute address of block for CPU
E 518  E880,0019,2060,476B B 56B;16947		CASE [A31.BQA.BNZ1] AT [UPDATE.PMF.ERROR] ; case on valid SCB value
				;16948
				;16949
				;16950	;= ALIGNLIST	101x	(UPDATE.PMF.ERROR,	UPDATE.PMF.MEM)
				;16951
				;16952	UPDATE.PMF.ERROR:
			    p135;16953		;---------------------------------------;
E 56B  0080,3038,A400,0038 J 038;16954		MACHINE CHECK [MCHK.PMF.CONFIG] 	; indicate illegal SCB configuration
				;16955
				;16956	;		W1	=	PMCTR1'PMCTR0 hardware counters
				;16957	;		VA	=	physical base address - 4 of memory block
				;16958
				;16959	UPDATE.PMF.MEM:
				;16960		;---------------------------------------;
				;16961		[W2] <-- [PERF.COUNT] AND [K.FFFF], LONG, ; zero extend 16-bit HW counter
				;16962		Q <-- PASSA [PERF.COUNT],		; and save entire value
			    p498;16963		CLEAR PMF COUNTERS,			; clear counters
E 56F  0402,4070,0FB7,251C S 51C;16964		CALL [UPDATE.PMF.QW]			; update QW in memory
				;16965
				;16966		;---------------------------------------;
			    p498;16967		[W2] <-- ZEXT [Q] RSH [16.], LONG,	; right-justify second HW counter
E 560  0001,D052,0C00,051C J 51C;16968		GOTO [UPDATE.PMF.QW]			; update 2nd QW and return
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  498
;     OPSYS.MIC 	     MTPR, MFPR 									      /REV=
;															      OPSYS
				;16969
				;16970	;	Subroutine to add a value to a quadword in physical memory
				;16971	;
				;16972	;	Entry conditions:
				;16973	;		W2	=	zero-extended 16-bit value to add to memory
				;16974	;		VA	=	physical address of quadword
				;16975	;
				;16976	;	Exit conditions:
				;16977	;		Quadword updated
				;16978	;		VA	=	physical address of second LW
				;16979	;		W2, W3 trashed
				;16980
				;16981	UPDATE.PMF.QW:
				;16982		;---------------------------------------;
E 51C  0000,0000,2000,257E S 57E;16983		CALL [UPDATE.PMF.LW]			; update memory with low LW
				;16984							; return with ALU.C set if overflow
				;16985		;---------------------------------------;
				;16986		[W2] <-- [K1], LONG,			; Set up for carry-in
E 51D  4000,0000,0F20,427C B 57C;16987		CASE [ALU.NZC] AT [UPDATE.PMF.LW.RETURN] ; case on overflow from low LW
				;16988
				;16989	;= ALIGNLIST	110x	(UPDATE.PMF.LW.RETURN,	UPDATE.PMF.LW)
				;16990
				;16991	UPDATE.PMF.LW.RETURN:
				;16992		;---------------------------------------; alu.c = 0:
				;16993		VA <-- [VA] + 4, LONG,			; no overflow, advance to second LW
E 57C  0C00,0001,20B0,0800 R	;16994		RETURN					; and return to caller
				;16995
				;16996	;	Subroutine to add a value to a longword in physical memory.
				;16997	;
				;16998	;	Entry conditions:
				;16999	;		VA	=	physical address of LW to update
				;17000	;		W2	=	value to add to memory
				;17001	;
				;17002	;	Exit conditions:
				;17003	;		Memory LW updated
				;17004	;		VA	=	physical address of updated LW
				;17005	;		ALU.C	=	1 if overflow occurred on add (valid in return cycle)
				;17006	;		W3 trashed
				;17007
				;17008	UPDATE.PMF.LW:
				;17009		;---------------------------------------; alu.c = 1:
E 57E  0050,0000,1000,0580 J 580;17010		[W3] <-- MEM.PHYS (VA), LONG		; read LW from memory
				;17011
				;17012		;---------------------------------------;
				;17013		MEM.PHYS (VA)&, 			; write updated result back
				;17014		[WBUS] <-- [W3] + [W2], LONG,		; to memory; test overflow
E 580  08F0,0018,2040,057C J 57C;17015		GOTO [UPDATE.PMF.LW.RETURN]		; advance VA past longword,
				;17016							; delay 1 cycle for overflow test
				;17017
				;17018	;= END OPSYS
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  499
;   CSTRING.MIC 	     CSTRING.MIC -- Character String Instructions					      /REV=
;
				;17019	.TOC	"CSTRING.MIC -- Character String Instructions"
				;17020	.TOC	"Revision 1.0"
				;17021
				;17022	;	Bob Supnik
				;17023
;17024	.nobin
;17025	;****************************************************************************
;17026	;*									    *
;17027	;*  COPYRIGHT (c) 1988, 1989, 1990, 1991, 1992 BY			    *
;17028	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;17029	;*  ALL RIGHTS RESERVED.						    *
;17030	;*									    *
;17031	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;17032	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;17033	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;17034	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;17035	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;17036	;*  TRANSFERRED.							    *
;17037	;*									    *
;17038	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;17039	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;17040	;*  CORPORATION.							    *
;17041	;*									    *
;17042	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;17043	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;17044	;*									    *
;17045	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  500
;   CSTRING.MIC 	     Revision History									      /REV=
;
;17046	.TOC	"	Revision History"
;17047
;17048	; Edit	  Date	 Who	     Description
;17049	; ---- --------- ---	---------------------
;17050	; (1)0 24-Jul-90 GMU	Initial production microcode.
;17051	;
;17052	; Begin version 1.0 here
;17053	;   18 23-Jul-90 GMU	Update with Bob's review comments.
;17054	;   17 26-Jun-90 DGM	Add some global labels for the ARCS Bolt-On restriction checker
;17055	;   16 05-Jun-90 GMU	Update SEQ.COND names to match implementation.
;17056	;   15 30-Apr-90 GMU	Sync with Mbox after LOAD PC.
;17057	;   14 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;17058	;   13 25-Apr-90 GMU	Change MOVC3.COMPLETE constraint to allow all "*" constraints
;17059	;			to be replaced by "1" constraints.
;17060	;   12 26-Mar-90 DGM	Fix STATE.3 bit bugs on exit and unpack bug and update comments
;17061	;   11 22-Mar-90 DGM	Update comments
;17062	;   10 12-Feb-90 DGM	Fix bugs with not clearing STATE.3 in CMPC & SKPC.
;17063	;    9 03-Feb-90 GMU	Fix simultaneous reference restriction problems.
;17064	;    8 18-Jan-90 DGM	Fix bug in MOVC - clearing STATE.3 one cycle too soon
;17065	;    7 15-Jan-90 DGM	Fix bug in SCANC unpack
;17066	;    6	8-Jan-90 DGM	Remove all ALU SEXT and ZEXT functions
;17067	;    5 28-Nov-89 GMU	Don't write to GPRs in SCANC/SPANC before completing
;17068	;			references to all source queue entries; defer setting
;17069	;			state<3> in LOCC/SKPC/SCANC/SPANC such that it doesn't
;17070	;			fall in the trap shadow of operand faults.
;17071	;    4 17-Nov-89 GMU	Convert LOAD NEW PC macro to LOAD PC.
;17072	;    3 07-Nov-89 GMU	Update entry condition comments in STRING.PACK and
;17073	;			fix bug in decoding saved state bits in MOVCx unpack.
;17074	;    2 25-OCT-89 GMU	Cleanup string pack/unpack interface with INTEXC.
;17075	;    1 17-Oct-89 DGM	The first group of many wonderful bug fixes in MOVC
;17076	;			    - correctly update R3 on fill (also init R4 when srclen=0)
;17077	;			    - don't step on W5 fill value in fill loop
;17078	;			Optimize startup of SCANC & fix bug - mask upper bytes of src read
;17079	; (0)0 19-Jan-88 RMS	Trial microcode.
;17080
				;17081	.bin
				;17082	;= BEGIN CSTRING
;17083	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  501
;   CSTRING.MIC 	     Revision History									      /REV=
;															    CSTRING
;17084
;17085	;	This module implements the character string instruction class.
;17086	;	The instructions in this class are:
;17087	;
;17088	;	Opcode	 Instruction							N Z V C 	Exceptions
;17089	;	------	 -----------							------- 	----------
;17090	;
;17091	;	29	 CMPC3 len.rw, src1addr.ab, src2addr.ab 			* * 0 *
;17092	;	2D	 CMPC5 src1len.rw, src1addr.ab, fill.rb,
;17093	;		       src2len.rw, src2addr.ab					* * 0 *
;17094	;
;17095	;	3A	 LOCC char.rb, len.rw, srcaddr.ab				0 * 0 0
;17096	;	3B	 SKPC char.rb, len.rw, srcaddr.ab				0 * 0 0
;17097	;
;17098	;	28	 MOVC3 len.rw, srcaddr.ab, dstaddr.ab				0 1 0 0
;17099	;	2C	 MOVC5 srclen.rw, srcaddr.ab, fill.rb,
;17100	;		       dstlen.rw, dstaddr.ab					* * 0 *
;17101	;
;17102	;	2A	 SCANC len.rw, srcaddr.ab, tbladdr.ab, mask.rb			0 * 0 0
;17103	;	2B	 SPANC len.rw, srcaddr.ab, tbladdr.ab, mask.rb			0 * 0 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  502
;   CSTRING.MIC 	     Revision History									      /REV=
;															    CSTRING
;17104
;17105	;					CAUTION
;17106	;					-------
;17107	;
;17108	;	Ebox microcode for any instruction whose IROM entry contains a .ax or
;17109	;	.vx specifier followed immediately by a .rx, .mx, or .vx specifier may not
;17110	;	reference the source queue entries for this pair of specifiers in the
;17111	;	same microinstruction.	This restriction is necessary to avoid getting
;17112	;	the incorrect operand data for the second specifier of the pair if the
;17113	;	first specifier of the pair is auto-increment, auto-decrement, or auto-increment
;17114	;	deferred, and the second specifier of the pair is register mode using the
;17115	;	same register specified for the first specifier of the pair.  Because the Ibox
;17116	;	must write both the address operand to the MD, and the auto-inc/dec value
;17117	;	to the GPR, the Ebox may read the old value of the GPR if both specifiers
;17118	;	are referenced in the same microword.  In addition, a simultaneous reference
;17119	;	to these specifiers may cause an infinite Ibox RXS stall if the source
;17120	;	queue retire for the second GPR specifier arrives at the Ibox before
;17121	;	the scoreboard is incremented.
;17122	;
;17123	;	This restriction does not apply if, by context, it is known that the
;17124	;	second specifier of the pair is not register mode.
;17125	;
;17126	;	Several of the instructions processed by this module are affected by this
;17127	;	restriction.  The following table lists the restriction for each instruction using
;17128	;	the notation [spec n; spec n+1] to denote a restriction in referencing the
;17129	;	source queue entries for these two specifiers in the same microinstruction.
;17130	;
;17131	;	Entry Point   Opcode   Mnemonic 		   Restriction
;17132	;	-----------   ------   -------- 	----------------------------------
;17133	;	CMPCX.. 	29	 CMPC3		none
;17134	;			2D	 CMPC5		[spec 2; spec 3]
;17135	;
;17136	;	LOCC.SKPC..	3A	 LOCC		none
;17137	;			3B	 SKPC		none
;17138	;
;17139	;	MOVCX.. 	28	 MOVC3		none
;17140	;			2C	 MOVC5		[spec 2; spec 3]
;17141	;
;17142	;	SCANC.SPANC..	2A	 SCANC		[spec 3; spec 4]
;17143	;			2B	 SPANC		[spec 3; spec 4]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  503
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
;17144	.TOC	"	MOVC3, MOVC5"
;17145
;17146	;	These instructions move a string of characters from one area of memory to another.
;17147	;
;17148	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;17149	;	--------      ------	---------				----	-----		--------
;17150	;	MOVC3		28	M[dstaddr...dstaddr+len-1] <--		3	raa/wbb 	MOVCX..
;17151	;					M[srcaddr...srcaddr+len-1]
;17152	;
;17153	;	MOVC5		2C	let len = minu(srclen,dstlen)		5   rarra/wbbwb 	MOVCX..
;17154	;				M[dstaddr...dstaddr+len-1] <--
;17155	;					M[srcaddr...srcaddr+len-1]
;17156	;				if srclen < dstlen,
;17157	;					M[dstaddr+len-1...dstaddr+dstlen-1] <-- fill
;17158	;
;17159	;	Entry conditions (MOVC3):
;17160	;		source queue	=	len.rw operand
;17161	;					srcaddr.ab operand
;17162	;					dstaddr.ab operand
;17163	;		dest queue	=	none
;17164	;		branch queue	=	none
;17165	;		field queue	=	none
;17166	;		DL		=	BYTE
;17167	;		Ibox state	=	stopped
;17168	;		Mbox state	=	running
;17169	;
;17170	;	Entry conditions (MOVC5):
;17171	;		source queue	=	srclen.rw operand
;17172	;					srcaddr.ab operand
;17173	;					fill.rb operand
;17174	;					dstlen.rw operand
;17175	;					dstaddr.ab operand
;17176	;		dest queue	=	none
;17177	;		branch queue	=	none
;17178	;		field queue	=	none
;17179	;		DL		=	BYTE
;17180	;		Ibox state	=	stopped
;17181	;		Mbox state	=	running
;17182	;
;17183	;	Exit conditions:
;17184	;		The PSL condition codes are set.
;17185	;		R0 - R5 have been updated to the SRM specified values.
;17186	;
;17187	;	Condition codes:
;17188	;		(MOVC3) 		(MOVC5)
;17189	;		N <-- 0 		N <-- srclen LSS dstlen
;17190	;		Z <-- 1 		Z <-- srclen EQL dstlen
;17191	;		V <-- 0 		V <-- 0 			[Integer overflow trap disabled.]
;17192	;		C <-- 0 		C <-- srclen LSSU dstlen
;17193	;
;17194	;	Note:	MOVC3/MOVC5 are interruptible instructions.  If a memory management fault or interrupt
;17195	;		occurs in mid instruction, the outstanding state is packed into R0 - R5, FPD is set,
;17196	;		and the exception is processed.  When the instruction is redecoded, the state is unpacked
;17197	;		and the instruction is resumed at the interruption point.
;17198	;		specifier is proven.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  504
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
;17199	;
;17200	;	Note:	All source queue entries that may fault must be referenced before any GPRs are written
;17201	;		to prevent overwriting an operand that may be in R0-R5.  In addition, state<3> must not
;17202	;		be set in the microinstruction that follows the one that contains the last reference to
;17203	;		a source queue entry that may fault.  This prevents state<3> from being set in the trap
;17204	;		shadow of a faulting operand reference.
;17205	;
;17206	;	Note:	When the ALU ZEXT and SEXT functions were removed, no attempt was made to optimize the
;17207	;		flows.	Much work can be done here.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  505
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
;17208
;17209	;	The microcode uses a control block which is kept partially in the general
;17210	;	registers, and partially in the working registers.  In greater detail:
;17211	;
;17212	;	General registers:
;17213	;		R0	=	loop count (at packup only: delta PC, fill character, count)
;17214	;		R1	=	initial srcaddr
;17215	;		R2	=	initial loop count
;17216	;		R3	=	initial dstaddr
;17217	;		R4	=	srclen - dstlen (MOVC5 only)
;17218	;		R5	=	at packup only:   state flags
;17219	;
;17220	;	Working registers:
;17221	;		W0	=	fill character (MOVC5 only)
;17222	;		W1	=	biased srcaddr
;17223	;		W2	=	srcaddr - dstaddr
;17224	;		W3	=	k(dl)
;17225	;
;17226	;	State flags:
;17227	;		<1:0>	=	type of move (00 forward, 01 backward, 10 fill)
;17228	;		<2>	=	destination is longword aligned
;17229	;		<3>	=	set for interruptible instruction
;17230
				;17231	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  506
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17232
				;17233	;	MOVC3, MOVC5 operation:
				;17234	;
				;17235	;		let len = minu(srclen, dstlen)
				;17236	;		if len > 0 then
				;17237	;			{ for i = 0 to len - 1
				;17238	;				{ dst[i] <-- src[i] }}
				;17239	;		if srclen < dstlen
				;17240	;			{ for i = srclen to dstlen - 1
				;17241	;				{ dst[i] <-- fill }}
				;17242	;
				;17243	;	CAUTION: Do not change the order of reference to the
				;17244	;	source queue in the entry point below without
				;17245	;	reading the explanation at the beginning of this module.
				;17246	;
				;17247	;	The following simultaneous reference restriction exists for
				;17248	;	this entry point: [spec 2; spec 3].
				;17249
				;17250	MOVCX..:
				;17251		;********** Hardware dispatch **********;
				;17252		[W1] <-- B [S2], LONG,			; [1] get srcaddr
				;17253		Q <-- [S1] LSH [16.],			; get srclen, left justify
				;17254		DL <-- WORD,				; set dl = word
E 202  8083,5048,0882,CC15 B 215;17255		CASE [OPCODE.2-0] AT [MOVC3]		; case on MOVC3 vs MOVC5
				;17256							; >> no [spec 2; spec 3] reference
				;17257
				;17258	;= ALIGNLIST 0xxx	(MOVC3, MOVC5)
				;17259	;  Opcodes = 28, 2C --> opcode<2:0> = ?00
				;17260
				;17261	MOVC3:
				;17262		;---------------------------------------; opcode<2> = 0 (MOVC3):
				;17263		[R3] <-- [S1], LONG,			; [2] get dstaddr, save in R3
				;17264							; >> GPR write, all SQ references complete
E 215  0003,D050,4C80,0581 J 581;17265		Q <-- ZEXT [Q] RSH [16.]		; right justify, zero extend srclen, test
				;17266
				;17267		;---------------------------------------;
E 581  0A80,0098,0C20,0321 J 321;17268		[W2] <-- [W1] - [R3], LONG		; [3] calc, save srcaddr - dstaddr
				;17269
				;17270		;---------------------------------------;
				;17271		[R1] <-- [W1], LONG,			; [4] save srcaddr in R1
				;17272		STATE.3 <-- 1,				; flag interruptible instruction
				;17273							; >> state<3> change, no SQ ref last cycle
			    p508;17274							; >> state<3> change, sync done on prev MRQ
E 321  F001,8000,4420,4FA2 B 3A2;17275		CASE [SHF.NZ.INT] AT [MOVC3.CONT]	; case on srclen = 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  507
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17276
				;17277	;	MOVCx, continued.
				;17278	;	MOVC5 setup.
				;17279
				;17280	;	At this point,
				;17281	;		Q	=	left-justified srclen
				;17282	;		W1	=	srcaddr
				;17283
				;17284	MOVC5:
				;17285		;---------------------------------------; MOVC5:
				;17286		[W0] <-- [S1], LONG,			; [2] get fill character
E 21D  0003,D050,0480,0582 J 582;17287		Q <-- ZEXT [Q] RSH [16.]		; right justify, zero extend srclen, test
				;17288
				;17289		;---------------------------------------;
E 582  0400,0071,2080,0241 J 241;17290		VA <-- [S1] AND [K.FFFF], LONG		; [3] get dstlen, zero extend, test
				;17291
				;17292		;---------------------------------------;
				;17293		[R3] <-- PASSB [S1], LONG,		; [4] get dstaddr, save in R3
				;17294							; >> GPR write, all SQ references complete
				;17295		VA <-- [VA],				; retest length
E 241  E000,8043,4CB0,4F73 B 273;17296		CASE [SHF.NZ.INT] AT [MOVC5.CONT]	; case on src length = 0
				;17297
				;17298	;= ALIGNLIST x01x	(MOVC5.CONT,	MOVC5.ZERO.SRC)
				;17299	;  SHF.NZ set by zext right shift --> N = 0
				;17300
				;17301	MOVC5.CONT:
				;17302		;---------------------------------------; alu.z = 0:
				;17303		[W3] <-- (-[VA] + [Q]), LEN(DL),	; [5] calc, save zext srclen - dstlen
E 273  0A00,0054,10BC,8505 J 505;17304		SET PSL CC.JIZJ 			; set psl cc's, psl map is jizj
				;17305
				;17306		;---------------------------------------;
				;17307		[R1] <-- [W1], LONG,			; [6] save srcaddr in R1
				;17308		STATE.3 <-- 1,				; flag interruptible instruction
				;17309							; >> state<3> change, no SQ ref last cycle
			    p508;17310							; >> state<3> change, sync done on prev MRQ
E 505  3001,8000,4420,4108 B 508;17311		CASE [ALU.NZV] AT [MOVC5.CONT.1]	; case on dstlen = 0
				;17312
				;17313	;= ALIGNLIST x0xx	(MOVC5.CONT.1,	MOVC5.ZERO.DST)
				;17314	;  ALU.NZVC set by MOVE with bit<31> = 0 --> N = V = 0
				;17315
				;17316	MOVC5.ZERO.DST:
				;17317		;---------------------------------------; shf.z = 1:
				;17318		[R0] <-- [Q], LONG,			; [7] srclen > 0, dstlen = 0,
			    p527;17319							; set R0 = srclen - dstlen = srclen
E 50C  0000,0000,40A0,0336 J 336;17320		GOTO [MOVC.COMPLETE]			; go clean up registers R2, R4, R5
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  508
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17321
				;17322	;	MOVCx, continued.
				;17323	;	MOVC5 setup, continued.  Srclen, dstlen > 0.
				;17324
				;17325	;	At this point,
				;17326	;		R1	=	srcaddr
				;17327	;		R3	=	dstaddr
				;17328	;		W3	=	srclen - dstlen, unsigned and zero extended
				;17329	;		Q	=	srclen
				;17330	;		VA	=	dstlen
				;17331	;		PSL CC's =	set from srclen - dstlen
				;17332
				;17333	MOVC5.CONT.1:
				;17334		;---------------------------------------; shf.z = 0:
				;17335		[W2] <-- [R1] - [R3], LONG,		; [7] calc, save srcaddr - dstaddr
E 508  4A80,0098,0D10,422C B 52C;17336		CASE [ALU.NZC] AT [MOVC5.DST.LONGER]	; case on srclen - dstlen
				;17337
				;17338	;= ALIGNLIST 110x	(MOVC5.DST.LONGER,	MOVC5.SRC.LONGER)
				;17339
				;17340	MOVC5.DST.LONGER:
				;17341		;---------------------------------------; alu.c = 0:
E 52C  0A80,3008,5040,03A2 J 3A2;17342		[R4] <-- [W3] - 00[01]0000, LONG	; [8] Have 0000'xxxx, to make negative,
				;17343							; subtract 0001'0000
				;17344
				;17345	;= ALIGNLIST x01x	(MOVC3.CONT,		MOVC3.COMPLETE)
				;17346	;  SHF.NZ set by ZEXT right shift --> N = 0
				;17347
				;17348	MOVC3.CONT:
				;17349		;---------------------------------------; shf.z = 0:
				;17350		[R0] <-- [Q], LONG,			; [5/9] srclen is move length
			    p510;17351		ACCESS B [R3],				; test dstaddr<1:0>
E 3A2  4000,0098,40A0,429D B 39D;17352		CASE [ALU.NZC] AT [MOVC.BACKWARD]	; case on forward vs backward move
				;17353
				;17354	MOVC5.SRC.LONGER:
				;17355		;---------------------------------------; alu.c = 0:
E 52E  0000,0000,5040,0323 J 323;17356		[R4] <-- [W3], LONG			; [8] fill not needed, save fill cnt
				;17357
				;17358		;---------------------------------------;
				;17359		[R0] <-- [VA], LONG,			; [9] dstlen is move length
			    p510;17360		ACCESS B [R3],				; test dstaddr<1:0>
E 323  4000,0098,40B0,429D B 39D;17361		CASE [ALU.NZC] AT [MOVC.BACKWARD]	; case on forward vs backward move
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  509
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17362
				;17363	;	MOVCx, continued.
				;17364	;	MOVC5 setup, continued.  Srclen = 0.
				;17365
				;17366	;	At this point,
				;17367	;		R3	=	dstaddr
				;17368	;		W0	=	fill character
				;17369	;		W1	=	srcaddr
				;17370	;		Q	=	srclen = 0
				;17371	;		VA	=	dstlen
				;17372
				;17373	MOVC5.ZERO.SRC:
				;17374		;---------------------------------------; alu.z = 1:
				;17375		[W3] <-- (-[VA] + [Q]), LEN(DL),	; [5] calc, save zext srclen - dstlen
E 277  0A00,0054,10BC,8245 J 245;17376		SET PSL CC.JIZJ 			; set psl cc's, psl map is jizj
				;17377
				;17378		;---------------------------------------;
				;17379		[R1] <-- [W1], LONG,			; [6] save srcaddr in R1
				;17380		STATE.3 <-- 1,				; flag interruptible instruction
				;17381							; >> state<3> change, no SQ ref last cycle
				;17382							; >> state<3> change, sync done on prev MRQ
E 245  3001,8000,4420,4161 B 261;17383		CASE [ALU.NZV] AT [MOVC5.ZERO.SRC.CONT] ; case on dstlen = 0
				;17384
				;17385	;= ALIGNLIST x0xx	(MOVC5.ZERO.SRC.CONT,	MOVC5.ZERO.SRC.DST)
				;17386	;  ALU.NZVC set by move with bit<31> = 0 --> N = V = 0
				;17387
				;17388	MOVC5.ZERO.SRC.CONT:
				;17389		;---------------------------------------; shf.z = 1:
				;17390		[R4] <-- 000000[00] - [VA], LONG,	; [7] R4 should have srclen - dstlen =
			    p523;17391							;     0 - dstlen = -dstlen = -VA
E 261  0A00,2000,50B0,0586 J 586;17392		GOTO [MOVC.FILL.1]			; join fill code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  510
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17393
				;17394	;	MOVC, continued.
				;17395	;	Move setup complete, start forward or backward move.
				;17396
				;17397	;	At this point,
				;17398	;		R0	=	initial loop count
				;17399	;		R1	=	initial srcaddr
				;17400	;		R3	=	initial dstaddr
				;17401	;		R4	=	srclen - dstlen (MOVC5 only)
				;17402	;		W0<7:0> =	fill character (MOVC5 only)
				;17403	;		W2	=	srcaddr - dstaddr
				;17404	;		STATE<3:0> =	1000
				;17405
				;17406	;	R3 tested on B port in previous cycle.
				;17407
				;17408	;= ALIGNLIST 110x	(MOVC.BACKWARD, MOVC.FORWARD)
				;17409
				;17410	MOVC.BACKWARD:
				;17411		;---------------------------------------; alu.c = 0:
				;17412		[W4] <-- [R0] + [R3], LONG,		; compute effective dstaddr
E 39D  0880,0098,1508,8583 J 583;17413		STATE.0 <-- 1				; flag backward move
				;17414
				;17415		;---------------------------------------;
E 583  0000,0028,2000,039F J 39F;17416		ACCESS B [W4]				; test dstaddr<1:0>
				;17417
				;17418	MOVC.FORWARD:
				;17419		;---------------------------------------; alu.c = 1:
			    p511;17420		[R2] <-- [R0], LONG,			; copy loop count to R2
E 39F  6000,0000,4900,4398 B 398;17421		CASE [B.2-0] AT [MOVC.ALIGN.DST.00]	; case on dstaddr<1:0>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  511
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17422
				;17423	;	MOVCx, continued.
				;17424	;	Case here to align destination.
				;17425
				;17426	;	This code section is used by move forward, move backward, and fill
				;17427	;	to set up the data length of the upcoming transfer.  Based on the
				;17428	;	present data alignment (W4<1:0>), the data length is set to byte,
				;17429	;	word, or longword, the data alignment flag is updated, and the
				;17430	;	k(dl) register (W3) is updated.  This code is, in effect, an
				;17431	;	inline subroutine, which exits by casing on the STATE flags to
				;17432	;	get back to the proper move loop.
				;17433
				;17434	;	At this point,
				;17435	;		R0	=	loop count
				;17436	;		R1	=	initial srcaddr
				;17437	;		R2	=	initial loop count
				;17438	;		R3	=	initial dstaddr
				;17439	;		R4	=	srclen - dstlen (MOVC5 only)
				;17440	;		W0<7:0> =	fill (MOVC5 only)
				;17441	;		W2	=	srcaddr - dstaddr
				;17442	;		STATE<3:0> =	10<move/fill><forward/backward>
				;17443
				;17444	;= ALIGNLIST 100x	(MOVC.ALIGN.DST.00,	MOVC.ALIGN.DST.01,
				;17445	;=			 MOVC.ALIGN.DST.10,	MOVC.ALIGN.DST.11)
				;17446
				;17447	MOVC.ALIGN.DST.00:
				;17448		;---------------------------------------; b<1:0> = 00:
				;17449		[W1] <-- [R2] - 000000[08.], LONG,	; start bias calculation for longword
			    p512;17450		STATE.2 <-- 1,				; set aligned flag
E 398  0A80,2040,0929,8125 J 125;17451		GOTO [MOVC.ALIGN.DECR.LONG..]		; go decrement loop count
				;17452
				;17453	MOVC.ALIGN.DST.01:
				;17454		;---------------------------------------; b<1:0> = 01:
			    p512;17455		[W1] <-- [R2] - 000000[02.], LONG,	; start bias calculation for byte
E 39A  0A80,2010,0920,0123 J 123;17456		GOTO [MOVC.ALIGN.DECR.BYTE..]		; go decrement loop count
				;17457
				;17458	MOVC.ALIGN.DST.10:
				;17459		;---------------------------------------; b<1:0> = 10:
			    p512;17460		[W1] <-- [R2] - 000000[04.], LONG,	; start bias calculation for word
E 39C  0A80,2020,0920,0124 J 124;17461		GOTO [MOVC.ALIGN.DECR.WORD..]		; go decrement loop count
				;17462
				;17463	MOVC.ALIGN.DST.11:
				;17464		;---------------------------------------; b<1:0> = 11:
			    p512;17465		[W1] <-- [R2] - 000000[02.], LONG,	; start bias calculation for byte
E 39E  0A80,2010,0920,0123 J 123;17466		GOTO [MOVC.ALIGN.DECR.BYTE..]		; go decrement loop count
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  512
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17467
				;17468	;	MOVCx, continued.
				;17469	;	New transfer length chosen, decrement loop count.
				;17470
				;17471	;		R0	=	loop count
				;17472	;		R1	=	initial srcaddr
				;17473	;		R2	=	initial loop count
				;17474	;		R3	=	initial dstaddr
				;17475	;		R4	=	srclen - dstlen (MOVC5 only)
				;17476	;		W0<7:0> =	fill (MOVC5 only)
				;17477	;		W1	=	initial loop count - 2*k(dl)
				;17478	;		W2	=	srcaddr - dstaddr
				;17479	;		STATE<3:0> =	1<not aligned/aligned><move/fill><forward/backward>
				;17480
				;17481	MOVC.ALIGN.DECR.BYTE..:
				;17482		;---------------------------------------;
				;17483		[R0] <-- [R0] - 000000[01.], LONG,	; decrement loop count by k(dl)
				;17484		Q <-- PASSB 000000[01.],		; save k(dl)
			    p513;17485		DL <-- BYTE,				; set dl = byte
E 123  4A82,A008,4102,4A99 B 199;17486		CASE [STATE.2-0] AT [MOVC.BIAS.FORWARD] ; case on forward vs backward vs fill
				;17487
				;17488	MOVC.ALIGN.DECR.WORD..:
				;17489		;---------------------------------------;
				;17490		[R0] <-- [R0] - 000000[02.], LONG,	; decrement loop count by k(dl)
				;17491		Q <-- PASSB 000000[02.],		; save k(dl)
			    p513;17492		DL <-- WORD,				; set dl = word
E 124  4A82,A010,4102,CA99 B 199;17493		CASE [STATE.2-0] AT [MOVC.BIAS.FORWARD] ; case on forward vs backward vs fill
				;17494
				;17495	MOVC.ALIGN.DECR.LONG..:
				;17496		;---------------------------------------;
				;17497		[R0] <-- [R0] - 000000[04.], LONG,	; decrement loop count by k(dl)
				;17498		Q <-- PASSB 000000[04.],		; save k(dl)
			    p513;17499		DL <-- LONG,				; set dl = long
E 125  4A82,A020,4103,4A99 B 199;17500		CASE [STATE.2-0] AT [MOVC.BIAS.FORWARD] ; case on forward vs backward vs fill
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  513
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17501
				;17502	;	MOVCx, continued.
				;17503	;	Bias source address as required.
				;17504
				;17505	;		R0	=	loop count - k(dl)
				;17506	;		R1	=	initial srcaddr
				;17507	;		R2	=	initial loop count
				;17508	;		R3	=	initial dstaddr
				;17509	;		R4	=	srclen - dstlen (MOVC5 only)
				;17510	;		W0<7:0> =	fill (MOVC5 only)
				;17511	;		W1	=	initial loop count - 2*k(dl)
				;17512	;		W2	=	srcaddr - dstaddr
				;17513	;		Q	=	k(dl)
				;17514	;		STATE<3:0> =	1<not aligned/aligned><move/fill><forward/backward>
				;17515
				;17516	;= ALIGNLIST 100x	(MOVC.BIAS.FORWARD,	MOVC.BIAS.BACKWARD,
				;17517	;=			 MOVC.BIAS.FILL,	MOVC.BIAS.UNK)
				;17518
				;17519	MOVC.BIAS.FORWARD:
				;17520		;---------------------------------------; state<1:0> = 00:
E 199  0880,0010,0910,0121 J 121;17521		[W1] <-- [R1] + [W1], LONG		; set b.src = srcaddr + init cnt - 2*k(dl)
				;17522
				;17523		;---------------------------------------;
			    p514;17524		[W3] <-- B [Q], LONG,			; save k(dl), test on B port
E 121  2080,0050,1000,41C3 B 1C3;17525		CASE [ALU.NZV] AT [MOVC.FORWARD.LOOP]	; case on whether data item will fit
				;17526
				;17527	MOVC.BIAS.BACKWARD:
				;17528		;---------------------------------------; state<1:0> = 01:
E 19B  0880,0050,0910,011B J 11B;17529		[W1] <-- [R1] + [Q], LONG		; set b.src = srcaddr + k(dl)
				;17530
				;17531		;---------------------------------------;
			    p519;17532		[W3] <-- B [Q], LONG,			; save k(dl), test on B port
E 11B  2080,0050,1000,41C2 B 1C2;17533		CASE [ALU.NZV] AT [MOVC.BACKWARD.LOOP]	; case on whether data item will fit
				;17534
				;17535	MOVC.BIAS.FILL:
				;17536		;---------------------------------------; state<1:0> = 10:
E 19D  0880,0050,0930,0117 J 117;17537		[W1] <-- [R3] + [Q], LONG		; set b.dst = dstaddr + k(dl)
				;17538
				;17539		;---------------------------------------;
			    p524;17540		[W3] <-- B [Q], LONG,			; save k(dl), test on B port
E 117  2080,0050,1000,41A3 B 1A3;17541		CASE [ALU.NZV] AT [MOVC.FILL.LOOP]	; case on whether data item will fit
				;17542
				;17543	MOVC.BIAS.UNK:
			    p135;17544		;---------------------------------------; state<1:0> = 11:
E 19F  0080,3020,A400,0038 J 038;17545		MACHINE CHECK [MCHK.MOVC.STATUS]	; unknown status, die
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  514
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17546
				;17547	;	MOVCx, continued.
				;17548	;	Move forward: main loop.
				;17549	;	Move the next data item from srcaddr to dstaddr.
				;17550
				;17551	;	At this point,
				;17552	;		R0	=	loop count - k(dl)
				;17553	;		R1	=	initial srcaddr
				;17554	;		R2	=	initial loop count
				;17555	;		R3	=	initial dstaddr
				;17556	;		R4	=	srclen - dstlen (MOVC5 only)
				;17557	;		W0<7:0> =	fill (MOVC5 only)
				;17558	;		W1	=	biased srcaddr = srcaddr + init cnt - 2*k(dl)
				;17559	;		W2	=	srcaddr - dstaddr
				;17560	;		W3	=	k(dl)
				;17561	;		STATE<3:0> =	1<aligned>00
				;17562
				;17563	;= ALIGNLIST 001x	(MOVC.FORWARD.LOOP,		MOVC.FORWARD.COMPLETE,
				;17564	;=			 MOVC.FORWARD.DL.TOO.BIG,			)
				;17565
				;17566	MOVC.FORWARD.LOOP:
				;17567		;---------------------------------------; alu.nz or shf.nz = 00:
				;17568		[R0] <-- [R0] - [W3], LONG,		; decr loop count for NEXT iteration
E 1C3  EA80,0020,4100,4FCD B 1CD;17569		CASE [SHF.NZ.INT] AT [MOVC.FORWARD.NO.INTERRUPTS] ; case on interrupt pending
				;17570
				;17571	;= ALIGNLIST 110x	(MOVC.FORWARD.NO.INTERRUPTS,	MOVC.FORWARD.INTERRUPT)
				;17572
				;17573	MOVC.FORWARD.INTERRUPT:
			    p143;17574		;---------------------------------------; int = 1:
E 1CF  0000,0000,2000,0040 J 040;17575		INTERRUPT FAULT 			; enter interrupt fault processor
				;17576
				;17577	MOVC.FORWARD.NO.INTERRUPTS:
				;17578		;---------------------------------------; int = 0:
				;17579		VA <-- [W1] - [R0],			; read next data item at
				;17580		[W5] <-- MEM (VA), LEN(DL),		; srcaddr + init cnt - loop cnt, in effect
E 1CD  0AC2,8085,1820,011E J 11E;17581		Q <-- PASSB [R0]			; pass R0 thru shifter to test cc's
				;17582							; loop cnt 2*kdl low, b.src biased by 2*kdl
				;17583
				;17584		;---------------------------------------;
				;17585		WCHK (VA)&, VA <-- [VA] - [W2], 	; write next data item at
			    p515;17586		LEN(DL),				; srcaddr - (srcaddr - dstaddr) = dstaddr
E 11E  4AE0,001D,20B0,4AA6 B 1A6;17587		CASE [STATE.2-0] AT [MOVC.FORWARD.NOT.ALIGNED]	; case on dstaddr aligned
				;17588
				;17589	;= ALIGNLIST 0**x	(MOVC.FORWARD.NOT.ALIGNED,	MOVC.FORWARD.ALIGNED)
				;17590	;  STATE<1:0> = 00 --> STATE<2:0> = ?00
				;17591
				;17592	MOVC.FORWARD.ALIGNED:
				;17593		;---------------------------------------; state<2> = 1:
				;17594		MEM (VA)&, [WBUS] <-- [W5], LEN(DL),	; write data to destination
				;17595		ACCESS B [W3],				; test k(dl) on B port
E 1AE  E064,0024,2060,4FC3 B 1C3;17596		CASE [SHF.NZ.INT] AT [MOVC.FORWARD.LOOP] ; case on whether next iteration will work
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  515
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17597
				;17598	;	MOVCx, continued.
				;17599	;	Move forward: destination not aligned.
				;17600
				;17601	;	At this point,
				;17602	;		R0	=	loop count - 2*k(dl)
				;17603	;		R1	=	initial srcaddr
				;17604	;		R2	=	initial loop count
				;17605	;		R3	=	initial dstaddr
				;17606	;		R4	=	srclen - dstlen (MOVC5 only)
				;17607	;		W0<7:0> =	fill (MOVC5 only)
				;17608	;		W1	=	biased srcaddr = srcaddr + init cnt - 2*k(dl)
				;17609	;		W2	=	srcaddr - dstaddr
				;17610	;		W3	=	k(dl)
				;17611	;		W5	=	current data item
				;17612	;		VA	=	effective dstaddr
				;17613	;		STATE<3:0> =	1000
				;17614
				;17615	MOVC.FORWARD.NOT.ALIGNED:
				;17616		;---------------------------------------; state<2> = 0:
E 1A6  0880,0020,14B0,0146 J 146;17617		[W4] <-- [VA] + [W3], LONG		; get updated dstaddr
				;17618
				;17619	MOVC.BACKWARD.NOT.ALIGNED:
				;17620		;---------------------------------------; state<2> = 0:
				;17621		MEM (VA)&, [WBUS] <-- [W5], LEN(DL),	; write data to destination
E 146  0064,002C,2060,0330 J 330;17622		ACCESS B [W4]				; test dstaddr<1:0>
				;17623
				;17624	MOVC.COMMON.NOT.ALIGNED:
				;17625		;---------------------------------------;
			    p511;17626		[R0] <-- [R0] + [W3], LONG,		; restore decremented count
E 330  6880,0020,4100,4398 B 398;17627		CASE [B.2-0] AT [MOVC.ALIGN.DST.00]	; case into alignment routine
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  516
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17628
				;17629	;	MOVCx, continued.
				;17630	;	Move forward: data length too big.
				;17631	;	Cut down the current data length and retry the move.
				;17632
				;17633	;	At this point,
				;17634	;		R0	=	loop count - k(dl)
				;17635	;		R1	=	initial srcaddr
				;17636	;		R2	=	initial loop count
				;17637	;		R3	=	initial dstaddr
				;17638	;		R4	=	srclen - dstlen (MOVC5 only)
				;17639	;		W0<7:0> =	fill (MOVC5 only)
				;17640	;		W1	=	biased srcaddr = srcaddr + init cnt - 2*k(dl)
				;17641	;		W2	=	srcaddr - dstaddr
				;17642	;		W3	=	k(dl)
				;17643	;		STATE<3:0> =	1<aligned>00
				;17644
				;17645	;	k(dl) was just tested on the B port.
				;17646
				;17647	MOVC.FORWARD.DL.TOO.BIG:
				;17648		;---------------------------------------; alu.nz or shf.nz = 10:
				;17649		[W1] <-- [R2] - [W3], LONG,		; calculate init loop cnt - 2*k(dl)
				;17650							; new k(dl) will be half, hence W3 = 2*
				;17651		Q <-- ZEXT [W3] RSH [1],		; halve k(dl)
				;17652		STATE.2 <-- 1,				; force "aligned" from now on
E 1CB  6A83,C120,0929,C3D9 B 1D9;17653		CASE [B.2-0] AT [MOVC.DL.LONG..]	; case on k(dl)<1:0>
				;17654
				;17655	;= ALIGNLIST 100x	(MOVC.DL.LONG..,	MOVC.DL.BYTE..,
				;17656	;=			 MOVC.DL.WORD..,			)
				;17657
				;17658	MOVC.DL.BYTE..:
				;17659		;---------------------------------------; k(dl)<1:0> = 01:
			    p527;17660		[R0] <-- [R4], LONG,			; FPD with zero length count,
E 1DB  0000,0000,4140,0336 J 336;17661		GOTO [MOVC.COMPLETE]			; terminate instruction NOW
				;17662
				;17663	MOVC.DL.WORD..:
				;17664		;---------------------------------------; k(dl)<1:0> = 10:
				;17665		[R0] <-- [R0] + [Q], LONG,		; add back half the data length
			    p513;17666		DL <-- BYTE,				; set dl = byte
E 1DD  4880,0050,4102,4A99 B 199;17667		CASE [STATE.2-0] AT [MOVC.BIAS.FORWARD] ; case on forward vs backward vs fill
				;17668
				;17669	MOVC.DL.LONG..:
				;17670		;---------------------------------------; k(dl)<1:0> = (1)00:
				;17671		[R0] <-- [R0] + [Q], LONG,		; add back half the data length
			    p513;17672		DL <-- WORD,				; set dl = word
E 1D9  4880,0050,4102,CA99 B 199;17673		CASE [STATE.2-0] AT [MOVC.BIAS.FORWARD] ; case on forward vs backward vs fill
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  517
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17674
				;17675	;	MOVCx, continued.
				;17676	;	Move forward: move completed.
				;17677	;	Read last data item.
				;17678
				;17679	;	At this point,
				;17680	;		R0	=	loop count = 0
				;17681	;		R1	=	initial srcaddr
				;17682	;		R2	=	initial loop count
				;17683	;		R3	=	initial dstaddr
				;17684	;		R4	=	srclen - dstlen (MOVC5 only)
				;17685	;		W0<7:0> =	fill (MOVC5 only)
				;17686	;		W1	=	biased srcaddr = srcaddr + init cnt - 2*k(dl)
				;17687	;		W2	=	srcaddr - dstaddr
				;17688	;		W3	=	k(dl)
				;17689	;		STATE<3:0> =	1<aligned>00
				;17690
				;17691	MOVC.FORWARD.COMPLETE:
				;17692		;---------------------------------------; alu.nz or shf.nz = 01:
E 1C7  0A80,0020,4100,0584 J 584;17693		[R0] <-- [R0] - [W3], LONG		; decr loop count
				;17694
				;17695		;---------------------------------------;
			    p518;17696		VA <-- [W1] - [R0],			; read next data item at
E 584  0AC0,0085,1820,0392 J 392;17697		[W5] <-- MEM (VA), LEN(DL)		; srcaddr + init cnt - loop cnt, in effect
				;17698							; loop cnt 2*kdl low, b.src biased by 2*kdl
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  518
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17699
				;17700	;	MOVCx, continued.
				;17701	;	Forward or backward move completed.
				;17702	;	Write last data item, fix up registers, go fill.
				;17703
				;17704	;	At this point,
				;17705	;		R0	=	loop count - k(dl)
				;17706	;		R1	=	initial srcaddr
				;17707	;		R2	=	initial loop count
				;17708	;		R3	=	initial dstaddr
				;17709	;		R4	=	srclen - dstlen (MOVC5 only)
				;17710	;		W0<7:0> =	fill (MOVC5 only)
				;17711	;		W2	=	srcaddr - dstaddr
				;17712	;		W3	=	k(dl)
				;17713	;		W5	=	last data item
				;17714	;		STATE<3:0> =	1<aligned>0<forward/backward>
				;17715
				;17716	MOVC.MOVE.COMPLETE:
				;17717		;---------------------------------------;
				;17718		WCHK (VA)&, VA <-- [VA] - [W2], 	; write next data item at
			    p527;17719		LEN(DL),				; srcaddr - (srcaddr - dstaddr) = dstaddr
E 392  0AE0,001D,20B0,258B S 58B;17720		CALL [WRITE.VA.W5]			; write last data item to memory
				;17721
				;17722		;---------------------------------------;
E 393  0880,0090,4510,0331 J 331;17723		[R1] <-- [R1] + [R2], LONG		; calc srcaddr + init loop count
				;17724							; >> sync with read last cycle
				;17725							; >> no state<3> change this cycle
				;17726
				;17727		;---------------------------------------;
				;17728		[R3] <-- [R3] + [R2], LONG,		; calc dstaddr + init loop count
				;17729		STATE.3-0 <-- 0,			; clear state flags
				;17730							; >> state<3> change, no SQ ref last cycle
				;17731							; >> state<3> change, sync done on prev MRQ
E 331  8880,0090,4D38,4CA6 B 3A6;17732		CASE [OPCODE.2-0] AT [MOVC3.COMPLETE]	; get out fast if MOVC3, else fill
				;17733
				;17734	;= ALIGNLIST 0xxx	(MOVC3.COMPLETE,	MOVC.FILL..)
				;17735	;  Opcodes = 28, 2C --> opcode<2:0> = ?00
				;17736	;  NOTE: Check overlapping MOVC3.COMPLETE constraint above before changing this ALIGNLIST.
				;17737
				;17738	MOVC3.COMPLETE:
				;17739		;---------------------------------------; opcode<2> = 0 (MOVC3) or shf.z = 1:
				;17740		[R0] <-- 000000[00], LONG,		; clear R0 (R1, R3 are correct)
			    p527;17741		SET PSL CC.IIII,			; set psl cc's
E 3A6  0080,2000,400D,0336 J 336;17742		GOTO [MOVC.COMPLETE]			; go finish register cleanup
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  519
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17743
				;17744	;	MOVCx, continued.
				;17745	;	Move backward: main loop.
				;17746	;	Move the next data item from srcaddr to dstaddr.
				;17747
				;17748	;	At this point,
				;17749	;		R0	=	loop count - k(dl)
				;17750	;		R1	=	initial srcaddr
				;17751	;		R2	=	initial loop count
				;17752	;		R3	=	initial dstaddr
				;17753	;		R4	=	srclen - dstlen (MOVC5 only)
				;17754	;		W0<7:0> =	fill (MOVC5 only)
				;17755	;		W1	=	biased srcaddr = srcaddr + k(dl)
				;17756	;		W2	=	srcaddr - dstaddr
				;17757	;		W3	=	k(dl)
				;17758	;		STATE<3:0> =	1<aligned>01
				;17759
				;17760	;= ALIGNLIST 001x	(MOVC.BACKWARD.LOOP,		MOVC.BACKWARD.COMPLETE,
				;17761	;=			 MOVC.BACKWARD.DL.TOO.BIG,			)
				;17762
				;17763	MOVC.BACKWARD.LOOP:
				;17764		;---------------------------------------; alu.nz or shf.nz = 00:
				;17765		[R0] <-- [R0] - [W3], LONG,		; decr loop count for NEXT iteration
E 1C2  EA80,0020,4100,4FAD B 1AD;17766		CASE [SHF.NZ.INT] AT [MOVC.BACKWARD.NO.INTERRUPTS] ; case on interrupt pending
				;17767
				;17768	;= ALIGNLIST 110x	(MOVC.BACKWARD.NO.INTERRUPTS,	MOVC.BACKWARD.INTERRUPT)
				;17769
				;17770	MOVC.BACKWARD.INTERRUPT:
			    p143;17771		;---------------------------------------; int = 1:
E 1AF  0000,0000,2000,0040 J 040;17772		INTERRUPT FAULT 			; enter interrupt fault processor
				;17773
				;17774	MOVC.BACKWARD.NO.INTERRUPTS:
				;17775		;---------------------------------------; int = 0:
				;17776		VA <-- [W1] + [R0],			; read next data item at
				;17777		[W5] <-- MEM (VA), LEN(DL),		; srcaddr + loop cnt - kdl, in effect
E 1AD  08C2,8085,1820,0119 J 119;17778		Q <-- PASSB [R0]			; pass R0 thru shifter to test cc's
				;17779							; loop cnt 2*kdl low, b.src biased by kdl
				;17780
				;17781		;---------------------------------------;
				;17782		WCHK (VA)&, VA&, [W4] <-- [VA] - [W2],	; write next data item at
			    p515;17783		LEN(DL),				; srcaddr - (srcaddr - dstaddr) = dstaddr
E 119  4AE0,001D,14B0,4A46 B 146;17784		CASE [STATE.2-0] AT [MOVC.BACKWARD.NOT.ALIGNED] ; case on dstaddr aligned
				;17785
				;17786	;= ALIGNLIST 0*1x	(MOVC.BACKWARD.NOT.ALIGNED,	MOVC.BACKWARD.ALIGNED)
				;17787	;  STATE<1> = 0 --> STATE<2:0> = ?01
				;17788
				;17789	MOVC.BACKWARD.ALIGNED:
				;17790		;---------------------------------------; state<2> = 1:
				;17791		MEM (VA)&, [WBUS] <-- [W5], LEN(DL),	; write data to destination
				;17792		ACCESS B [W3],				; test k(dl) on B port
E 14E  E064,0024,2060,4FC2 B 1C2;17793		CASE [SHF.NZ.INT] AT [MOVC.BACKWARD.LOOP] ; case on whether next iteration will work
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  520
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17794
				;17795	;	MOVCx, continued.
				;17796	;	Move backward: destination not aligned.
				;17797
				;17798	;	At this point,
				;17799	;		R0	=	loop count - 2*k(dl)
				;17800	;		R1	=	initial srcaddr
				;17801	;		R2	=	initial loop count
				;17802	;		R3	=	initial dstaddr
				;17803	;		R4	=	srclen - dstlen (MOVC5 only)
				;17804	;		W0<7:0> =	fill (MOVC5 only)
				;17805	;		W1	=	biased srcaddr = srcaddr + k(dl)
				;17806	;		W2	=	srcaddr - dstaddr
				;17807	;		W3	=	k(dl)
				;17808	;		W4<7:0> =	low byte of effective dstaddr
				;17809	;		W5	=	current data item
				;17810	;		STATE<3:0> =	1<aligned>01
				;17811
				;17812	;MOVC.BACKWARD.NOT.ALIGNED:			; see MOVC.FORWARD.NOT.ALIGNED
				;17813
				;17814	;	At MOVC.BACKWARD.NOT.ALIGNED, the current data item is written out,
				;17815	;	and the erroneous decrement of R0 is undone.  The destination address
				;17816	;	is then checked to select a new move length.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  521
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17817
				;17818	;	MOVCx, continued.
				;17819	;	Move backward: data length too big.
				;17820	;	Cut down the current data length and retry the move.
				;17821
				;17822	;	At this point,
				;17823	;		R0	=	loop count - k(dl)
				;17824	;		R1	=	initial srcaddr
				;17825	;		R2	=	initial loop count
				;17826	;		R3	=	initial dstaddr
				;17827	;		R4	=	srclen - dstlen (MOVC5 only)
				;17828	;		W0<7:0> =	fill (MOVC5 only)
				;17829	;		W1	=	biased srcaddr = srcaddr + k(dl)
				;17830	;		W2	=	srcaddr - dstaddr
				;17831	;		W3	=	k(dl)
				;17832	;		STATE<3:0> =	1<aligned>01
				;17833
				;17834	;	W3 was just tested on the B port.
				;17835
				;17836	MOVC.BACKWARD.DL.TOO.BIG:
				;17837		;---------------------------------------; shf.nz = 10:
				;17838		[W1] <-- [R2] - [W3], LONG,		; calculate init loop cnt - 2*k(dl)
				;17839							; new k(dl) will be half, hence W3 = 2*
				;17840		Q <-- ZEXT [W3] RSH [1],		; halve k(dl)
			    p516;17841		STATE.2 <-- 1,				; force "aligned" from now on
E 1CA  6A83,C120,0929,C3D9 B 1D9;17842		CASE [B.2-0] AT [MOVC.DL.LONG..]	; case on k(dl)<1:0>
				;17843
				;17844	;	At MOVC.DL.BYTE../WORD../LONG.., the erroneous decrement of R0 is undone
				;17845	;	while simultaneously choosing a new data length that is half the
				;17846	;	current data length.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  522
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17847
				;17848	;	MOVCx, continued.
				;17849	;	Move backward: move completed.
				;17850	;	Read last data item.
				;17851
				;17852	;	At this point,
				;17853	;		R0	=	loop count = 0
				;17854	;		R1	=	initial srcaddr
				;17855	;		R2	=	initial loop count
				;17856	;		R3	=	initial dstaddr
				;17857	;		R4	=	srclen - dstlen (MOVC5 only)
				;17858	;		W0<7:0> =	fill (MOVC5 only)
				;17859	;		W1	=	biased srcaddr = srcaddr + k(dl)
				;17860	;		W2	=	srcaddr - dstaddr
				;17861	;		W3	=	k(dl)
				;17862	;		STATE<3:0> =	1<aligned>01
				;17863
				;17864	MOVC.BACKWARD.COMPLETE:
				;17865		;---------------------------------------; alu.nz or shf.nz = 01:
E 1C6  0A80,0020,4100,0585 J 585;17866		[R0] <-- [R0] - [W3], LONG		; decr loop count
				;17867
				;17868		;---------------------------------------;
				;17869		VA <-- [W1] + [R0],			; read next data item at
				;17870		[W5] <-- MEM (VA), LEN(DL),		; srcaddr + loop cnt - kdl, in effect
			    p518;17871							; loop cnt 2*kdl low, b.src biased by kdl
E 585  08C0,0085,1820,0392 J 392;17872		GOTO [MOVC.MOVE.COMPLETE]		; go write last data item, fix up registers
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  523
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17873
				;17874	;	MOVCx, continued.
				;17875	;	MOVC5 main move completed, test for fill.
				;17876
				;17877	;	At this point,
				;17878	;		R1	=	final srcaddr
				;17879	;		R3	=	current dstaddr
				;17880	;		R4	=	srclen - dstlen
				;17881	;		W0<7:0> =	fill character
				;17882	;		STATE<3:0> =	1000
				;17883
				;17884	MOVC.FILL..:
				;17885		;---------------------------------------; opcode<2> = 1 (MOVC5):
E 3AE  1001,8000,2000,0586 J 586;17886		STATE.3 <-- 1				; set state<3> again
				;17887							; >> state<3> change, no SQ ref last cycle
				;17888							; >> state<3> change, sync done on prev MRQ
				;17889
				;17890	MOVC.FILL.1:
				;17891		;---------------------------------------;
				;17892		[R0] <-- -[R4], LONG,			; negate fill count
E 586  0D03,58A0,4010,0587 J 587;17893		Q <-- [W0] LSH [24.]			; start replication of fill character
				;17894
				;17895		;---------------------------------------;
				;17896		[W5] <-- [W0]!![Q] RSH [24.], LONG,	; W5<15:0> contains word of fill
E 587  0001,9852,1819,031B J 31B;17897		STATE.1 <-- 1				; flag fill
				;17898
				;17899		;---------------------------------------;
				;17900		ACCESS B [R3],				; test dstaddr<1:0>
				;17901		Q <-- [W5] LSH [16.], LONG,		; Q<31:16> contains word of fill
E 31B  2003,5098,2060,4132 B 332;17902		CASE [ALU.NZV] AT [MOVC.FILL.SETUP]	; case on any fill to do
				;17903
				;17904	;= ALIGNLIST 001x	(MOVC.FILL.SETUP,	MOVC.COMPLETE,
				;17905	;=			 MOVC.NO.FILL,			)
				;17906
				;17907	MOVC.FILL.SETUP:
				;17908		;---------------------------------------; alu.nz = 00:
			    p511;17909		[W5] <-- [W5]!![Q] RSH [16.], LONG,	; W5 contains longword of fill
E 332  6001,9052,1860,4398 B 398;17910		CASE [B.2-0] AT [MOVC.ALIGN.DST.00]	; case on dstaddr<1:0>
				;17911
				;17912	MOVC.NO.FILL:
				;17913		;---------------------------------------; alu.nz = 10:
			    p527;17914		[R0] <-- [R4], LONG,			; set R0 from srclen - dstlen
E 33A  0000,0000,4140,0336 J 336;17915		GOTO [MOVC.COMPLETE]			; go finish instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  524
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17916
				;17917	;	MOVCx, continued.
				;17918	;	Move fill: main loop.
				;17919	;	Move the fill data to dstaddr.
				;17920
				;17921	;	At this point,
				;17922	;		R0	=	loop count - k(dl)
				;17923	;		R1	=	final srcaddr
				;17924	;		R3	=	final dstaddr after move
				;17925	;		R4	=	srclen - dstlen
				;17926	;		W0<7:0> =	fill character
				;17927	;		W1	=	biased dstaddr = dstaddr + k(dl)
				;17928	;		W3	=	k(dl)
				;17929	;		W5	=	fill longword
				;17930	;		STATE<3:0> =	1<aligned>10
				;17931
				;17932	;= ALIGNLIST 00*x	(MOVC.FILL.LOOP,	MOVC.FILL.COMPLETE,
				;17933	;=			 MOVC.FILL.DL.TOO.BIG,			)
				;17934	;  ALU.NZVC set by subtract of words in longword --> V = 0
				;17935
				;17936	MOVC.FILL.LOOP:
				;17937		;---------------------------------------; alu.nz = 00:
				;17938		[R0] <-- [R0] - [W3], LONG,		; decr loop count for NEXT iteration
E 1A3  EA80,0020,4100,4F8D B 18D;17939		CASE [SHF.NZ.INT] AT [MOVC.FILL.NO.INTERRUPTS] ; case on interrupt pending
				;17940
				;17941	;= ALIGNLIST 110x	(MOVC.FILL.NO.INTERRUPTS,	MOVC.FILL.INTERRUPT)
				;17942
				;17943	MOVC.FILL.INTERRUPT:
			    p143;17944		;---------------------------------------; int = 1:
E 18F  0000,0000,2000,0040 J 040;17945		INTERRUPT FAULT 			; enter interrupt fault processor
				;17946
				;17947	MOVC.FILL.NO.INTERRUPTS:
				;17948		;---------------------------------------; int = 0:
				;17949		WCHK (VA)&, VA&, [W4] <-- [W1] + [R0],	; write next data item at
				;17950		LEN(DL),				; dstaddr + loop cnt - kdl, in effect
			    p525;17951							; loop cnt 2*kdl low, b.dst biased by kdl
E 18D  48E0,0085,1420,4A26 B 126;17952		CASE [STATE.2-0] AT [MOVC.FILL.NOT.ALIGNED]	; case on dstaddr aligned
				;17953
				;17954	;= ALIGNLIST 01*x	(MOVC.FILL.NOT.ALIGNED, MOVC.FILL.ALIGNED)
				;17955	;  STATE<0> = 0 --> STATE<2:0> = ?10
				;17956
				;17957	MOVC.FILL.ALIGNED:
				;17958		;---------------------------------------; state<2> = 1:
				;17959		MEM (VA)&, [WBUS] <-- [W5], LEN(DL),	; write data to destination
				;17960		ACCESS B [W3],				; test k(dl) on B port
E 12E  2064,0024,2060,41A3 B 1A3;17961		CASE [ALU.NZV] AT [MOVC.FILL.LOOP]	; case on whether next iteration will work
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  525
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17962
				;17963	;	MOVCx, continued.
				;17964	;	Move fill: destination not aligned.
				;17965
				;17966	;	At this point,
				;17967	;		R0	=	loop count - 2*k(dl)
				;17968	;		R1	=	final srcaddr
				;17969	;		R3	=	final dstaddr after move
				;17970	;		R4	=	srclen - dstlen
				;17971	;		W0<7:0> =	fill character
				;17972	;		W1	=	biased dstaddr = dstaddr + k(dl)
				;17973	;		W3	=	k(dl)
				;17974	;		W4<7:0> =	low byte of effective destination address
				;17975	;		W5	=	fill longword
				;17976	;		VA	=	updated dstaddr
				;17977	;		STATE<3:0> =	1010
				;17978
				;17979	MOVC.FILL.NOT.ALIGNED:
				;17980		;---------------------------------------; state<2> = 0:
				;17981		MEM (VA)&, [WBUS] <-- [W5], LEN(DL),	; write data to destination
			    p515;17982		ACCESS B [W4],				; test dstaddr<1:0>
E 126  0064,002C,2060,0330 J 330;17983		GOTO [MOVC.COMMON.NOT.ALIGNED]		; join common code
				;17984
				;17985	;	At MOVC.COMMON.NOT.ALIGNED, the current data item is written out,
				;17986	;	and the erroneous decrement of R0 is undone.  The destination address
				;17987	;	is then checked to select a new move length.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  526
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;17988
				;17989	;	MOVCx, continued.
				;17990	;	Move fill: data length too big.
				;17991	;	Cut down the current data length and retry the move.
				;17992
				;17993	;	At this point,
				;17994	;		R0	=	loop count - k(dl)
				;17995	;		R1	=	final srcaddr
				;17996	;		R3	=	final dstaddr after move
				;17997	;		R4	=	srclen - dstlen
				;17998	;		W0<7:0> =	fill character
				;17999	;		W1	=	biased dstaddr = dstaddr + k(dl)
				;18000	;		W3	=	k(dl)
				;18001	;		W5	=	fill longword
				;18002	;		STATE<3:0> =	1<aligned>10
				;18003
				;18004	;	W3 was just tested on the B port.
				;18005
				;18006	MOVC.FILL.DL.TOO.BIG:
				;18007		;---------------------------------------; alu.nz = 10:
				;18008		[W1] <-- [R2] - [W3], LONG,		; calculate init loop cnt - 2*k(dl)
				;18009							; new k(dl) will be half, hence W3 = 2*
				;18010		Q <-- ZEXT [W3] RSH [1],		; halve k(dl)
			    p516;18011		STATE.2 <-- 1,				; force "aligned" from now on
E 1AB  6A83,C120,0929,C3D9 B 1D9;18012		CASE [B.2-0] AT [MOVC.DL.LONG..]	; case on k(dl)<1:0>
				;18013
				;18014	;	At MOVC.DL.BYTE../WORD../LONG.., the erroneous decrement of R0 is undone
				;18015	;	while simultaneously choosing a new data length that is half the
				;18016	;	current data length.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  527
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
				;18017
				;18018	;	MOVCx, continued.
				;18019	;	Move fill: move completed.
				;18020	;	Write last data item, fix registers.
				;18021
				;18022	;	At this point,
				;18023	;		R0	=	loop count = 0
				;18024	;		R1	=	final srcaddr
				;18025	;		R3	=	final dstaddr after move
				;18026	;		R4	=	srclen - dstlen
				;18027	;		W0<7:0> =	fill character
				;18028	;		W1	=	biased dstaddr = dstaddr + init cnt - 2*k(dl)
				;18029	;		W3	=	k(dl)
				;18030	;		W5	=	fill longword
				;18031	;		STATE<3:0> =	1<aligned>10
				;18032
				;18033	MOVC.FILL.COMPLETE:
				;18034		;---------------------------------------; alu.nz = 01:
E 1A7  0A80,0020,4100,0394 J 394;18035		[R0] <-- [R0] - [W3], LONG		; decr loop count
				;18036
				;18037		;---------------------------------------;
				;18038		WCHK (VA)&, VA <-- [W1] + [R0], 	; write next data item at
				;18039		LEN(DL),				; dstaddr + loop cnt - kdl, in effect
				;18040							; loop cnt 2*kdl low, b.dst biased by 2*kdl
E 394  08E0,0085,2020,258B S 58B;18041		CALL [WRITE.VA.W5]			; write last data item to memory
				;18042
				;18043		;---------------------------------------;
E 395  0A80,00A0,4D30,0265 J 265;18044		[R3] <-- [R3] - [R4], LONG		; update R3 to equal dstlen
				;18045
				;18046	MOVC5.ZERO.SRC.DST:
				;18047		;---------------------------------------; shf.z = 1:
E 265  0080,2000,4000,0336 J 336;18048		[R0] <-- 000000[00], LONG		; clear R0
				;18049
				;18050	MOVC.COMPLETE:
				;18051		;---------------------------------------; alu.nz = 01:
E 336  0080,2000,5000,0588 J 588;18052		[R4] <-- 000000[00], LONG		; clear R4
				;18053
				;18054		;---------------------------------------;
				;18055		[R5] <-- 000000[00], LONG,		; clear R5
E 588  0080,2000,5408,0589 J 589;18056		STATE.3-0 <-- 0 			; clear state flags
				;18057							; >> state<3> change, no SQ ref last cycle
				;18058							; >> state<3> change, sync done on prev MRQ
				;18059
				;18060		;---------------------------------------;
				;18061		[R2] <-- 000000[00], LONG,		; clear R2
				;18062		RESTART IBOX,				; restart suspended I-box
E 589  0080,2000,4804,1000 L	;18063		LAST CYCLE				; decode next instruction
				;18064
				;18065	;	One line subroutine to write W5 to memory, len(dl).
				;18066
				;18067	WRITE.VA.W5:
				;18068		;---------------------------------------;
				;18069		MEM (VA)&, [WBUS] <-- [W5], LEN(DL),	; write data item to memory
E 58B  0064,0004,2060,0800 R	;18070		RETURN					; return to caller
				;18071
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  528
;   CSTRING.MIC 	     MOVC3, MOVC5									      /REV=
;															    CSTRING
;18072	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  529
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
;18073	.TOC	"	CMPC3, CMPC5"
;18074
;18075	;	These instructions compare two strings of characters.
;18076	;
;18077	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;18078	;	--------      ------	---------				----	-----			--------
;18079	;	CMPC3		29	M[src1addr...src1addr+len-1] :		3	raa/wbb 		CMPCX..
;18080	;					M[src2addr...src2addr+len-1]
;18081	;
;18082	;	CMPC5		2D	let len = minu(src1len, src2len)	5	rarra/wbbwb		CMPCX..
;18083	;				M[src1addr...src1addr+len-1] :
;18084	;					M[src2addr...src2addr+len-1]
;18085	;				if src1len < src2len,
;18086	;					fill : M[src2addr+len-1...src2addr+src2len-1]
;18087	;				if src1len > src2len,
;18088	;					M[src1addr+len-1...src1addr+src2len-1] : fill
;18089	;
;18090	;	Entry conditions (CMPC3):
;18091	;		source queue	=	len.rw operand
;18092	;					src1addr.ab operand
;18093	;					src2addr.ab operand
;18094	;		dest queue	=	none
;18095	;		branch queue	=	none
;18096	;		field queue	=	none
;18097	;		DL		=	BYTE
;18098	;		Ibox state	=	stopped
;18099	;		Mbox state	=	running
;18100	;
;18101	;	Entry conditions (CMPC5):
;18102	;		source queue	=	src1len.rw operand
;18103	;					src1addr.ab operand
;18104	;					fill.rb operand
;18105	;					src2len.rw operand
;18106	;					src2addr.ab operand
;18107	;		dest queue	=	none
;18108	;		branch queue	=	none
;18109	;		field queue	=	none
;18110	;		DL		=	BYTE
;18111	;		Ibox state	=	stopped
;18112	;		Mbox state	=	running
;18113	;
;18114	;	Exit conditions:
;18115	;		The PSL condition codes are set.
;18116	;		R0 - R3 have been updated to the SRM specified values.
;18117	;
;18118	;	Condition codes reflect last byte compared:
;18119	;		N <-- src1byte LSS src2byte
;18120	;		Z <-- src1byte EQL src2byte
;18121	;		V <-- 0 			[Integer overflow trap disabled.]
;18122	;		C <-- src1byte LSSU src2byte
;18123	;
;18124	;	Note:	CMPC3/CMPC5 are interruptible instructions.  If a memory management fault or interrupt
;18125	;		occurs in mid instruction, the outstanding state is packed into R0 - R3, FPD is set,
;18126	;		and the exception is processed.  When the instruction is redecoded, the state is unpacked
;18127	;		and the instruction is resumed at the interruption point.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  530
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
;18128	;
;18129	;	Note:	All source queue entries that may fault must be referenced before any GPRs are written
;18130	;		to prevent overwriting an operand that may be in R0-R5.  In addition, state<3> must not
;18131	;		be set in the microinstruction that follows the one that contains the last reference to
;18132	;		a source queue entry that may fault.  This prevents state<3> from being set in the trap
;18133	;		shadow of a faulting operand reference.
;18134	;
;18135	;	Note:	CMPC3/CMPC5 are currently coded for minimum microcode size.  This is probably slower than
;18136	;		a macrocode loop.  Better implementations should be investigated.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  531
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
;18137
;18138	;	The microcode uses a control block which is kept partially in the general registers,
;18139	;	and partially in the working registers.  In greater detail:
;18140	;
;18141	;	General registers:
;18142	;		R0	=	src1 count (at packup only: delta PC, fill character, count)
;18143	;		R1	=	src1addr
;18144	;		R2	=	src2 count
;18145	;		R3	=	src2addr
;18146	;
;18147	;	Working registers:
;18148	;		W0	=	fill character
;18149
				;18150	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  532
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
				;18151
				;18152	;	CMPC3, CMPC5 operat5ion:
				;18153	;
				;18154	;		let len = minu(src1len, src2len)
				;18155	;		if len > 0 then
				;18156	;			{for i = 0 to len - 1
				;18157	;				{if src1[i] ne src2[i] then exit}}
				;18158	;		if src1len < src2len then
				;18159	;			{for i = src1len to src2len - 1
				;18160	;				{if fill ne src2[i] then exit}}
				;18161	;		if src1len > src2len then
				;18162	;			{for i = src2len to src1len - 1
				;18163	;				{if src1[i] ne fill then exit}}
				;18164	;
				;18165	;	CAUTION: Do not change the order of reference to the
				;18166	;	source queue in the entry point below without
				;18167	;	reading the explanation at the beginning of this module.
				;18168	;
				;18169	;	The following simultaneous reference restriction exists for
				;18170	;	this entry point: [spec 2; spec 3].
				;18171
				;18172	CMPCX..:
				;18173		;********** Hardware dispatch **********;
				;18174		VA <-- [S1],				; [1] get src1len = src2len
				;18175		[W1] <-- PASSB [S2], LONG,		; get src1addr
E 204  8000,804B,0880,4C06 B 206;18176		CASE [OPCODE.2-0] AT [CMPC3]		; case on CMPC3 vs CMPC5
				;18177							; >> no [spec 2; spec 3] reference
				;18178
				;18179	;= ALIGNLIST 0x1x	(CMPC3, 	CMPC5)
				;18180	;  Opcodes = 29, 2D --> opcode<2:0> = ?01
				;18181
				;18182	CMPC3:
				;18183		;---------------------------------------; opcode<2> = 0 (CMPC3):
E 206  0002,8040,2000,058C J 58C;18184		Q <-- PASSB [S1], LONG			; [2] get src2addr
				;18185
				;18186		;---------------------------------------;
				;18187		[R2] <-- [VA] AND [K.FFFF], LONG,	; [3] zero extend and test src2len
				;18188							; >> GPR write, all SQ references complete
			    p533;18189		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 58C  0400,0070,48BD,0592 J 592;18190		GOTO [CMPCX.CONTINUE]			; join common code
				;18191
				;18192	CMPC5:
				;18193		;---------------------------------------; opcode<2> = 1 (CMPC5):
				;18194		[W0] <-- [S1], LONG,			; [2] get fill character
E 20E  0002,8048,0480,0590 J 590;18195		Q <-- PASSB [S2]			; get src2len
				;18196
				;18197		;---------------------------------------;
				;18198		[R2] <-- [Q], LONG,			; [3] get src2len
				;18199							; >> GPR write, all SQ references complete
E 590  0002,8040,48A0,0591 J 591;18200		Q <-- PASSB [S1]			; get src2addr
				;18201
				;18202		;---------------------------------------;
				;18203		[R2] <-- [R2] AND [K.FFFF], LONG,	; [4] zero extend and test src2len
			    p533;18204		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 591  0400,0070,492D,0592 J 592;18205		GOTO [CMPCX.CONTINUE]			; join common code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  533
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
				;18206
				;18207	;	CMPCx, continued.
				;18208	;	Determine initial entry into compare loops.
				;18209
				;18210	;	At this point,
				;18211	;		R2	=	src2len
				;18212	;		W0	=	fill character
				;18213	;		W1	=	src1addr
				;18214	;		Q	=	src2addr
				;18215	;		VA	=	src1len
				;18216
				;18217	CMPCX.CONTINUE:
				;18218		;---------------------------------------;
E 592  0400,0070,40B0,0225 J 225;18219		[R0] <-- [VA] AND [K.FFFF], LONG	; [4/5] zero extend and test src1len
				;18220
				;18221		;---------------------------------------;
				;18222		[R3] <-- [Q], LONG,			; [5/6] copy src2addr to R3
E 225  2000,0000,4CA0,4120 B 220;18223		CASE [ALU.NZV] AT [CMPCX.SRC2.NEQ.ZERO] ; case on src2len = 0
				;18224
				;18225	;= ALIGNLIST x0xx	(CMPCX.SRC2.NEQ.ZERO,	CMPCX.SRC2.EQL.ZERO)
				;18226	;  ALU.NZVC set by AND with bit<31> = 0 --> N = V = C = 0
				;18227
				;18228	CMPCX.SRC2.NEQ.ZERO:
				;18229		;---------------------------------------; alu.z = 0 --> src2 NEQ 0:
				;18230		[R1] <-- [W1], LONG,			; [6/7] copy src1addr to R1
				;18231		STATE.3 <-- 1,				; flag interruptable instruction
				;18232							; >> state<3> change, no SQ ref last cycle
				;18233							; >> state<3> change, sync done on prev MRQ
			    p534;18234		DL <-- BYTE,				; set dl = byte for reads
E 220  3001,8000,4422,41B8 B 2B8;18235		CASE [ALU.NZV] AT [CMPCX.SRC1.SRC2.LOOP] ; case on src1len = 0
				;18236
				;18237	CMPCX.SRC2.EQL.ZERO:
				;18238		;---------------------------------------; alu.z = 1 --> src1 EQL 0:
				;18239		[R1] <-- [W1], LONG,			; [6/7] copy src1addr to R1
				;18240		STATE.3 <-- 1,				; flag interruptable instruction
				;18241							; >> state<3> change, no SQ ref last cycle
				;18242							; >> state<3> change, sync done on prev MRQ
			    p536;18243		DL <-- BYTE,				; set dl = byte for reads
E 224  3001,8000,4422,41B9 B 2B9;18244		CASE [ALU.NZV] AT [CMPCX.SRC1.FILL.LOOP] ; case on src1len = 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  534
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
				;18245
				;18246	;	CMPCX, continued.
				;18247	;	Compare src1 to src2.
				;18248
				;18249	;	At this point,
				;18250	;		R0	=	src1len
				;18251	;		R1	=	src1addr
				;18252	;		R2	=	src2len
				;18253	;		R3	=	src2addr
				;18254	;		W0	=	fill character
				;18255	;		STATE<3> =	1
				;18256
				;18257	;= ALIGNLIST 10xx	(CMPCX.SRC1.SRC2.LOOP,	CMPCX.SRC1.DONE)
				;18258	;  ALU.NZVC set by AND or subtract of word in longword --> V = 0
				;18259
				;18260	CMPCX.SRC1.SRC2.LOOP:
				;18261		;---------------------------------------; alu.z = 0:
				;18262		VA <-- [R1],				; [L1] next byte from src1
				;18263		[W1] <-- MEM (VA), LEN(DL),		; read byte
E 2B8  E040,0005,0910,4F9D B 29D;18264		CASE [SHF.NZ.INT] AT [CMPCX.SRC1.SRC2.NO.INTERRUPT] ; case on int pending
				;18265
				;18266	;= ALIGNLIST 110x	(CMPCX.SRC1.SRC2.NO.INTERRUPT, CMPCX.SRC1.SRC2.INTERRUPT)
				;18267
				;18268	CMPCX.SRC1.SRC2.INTERRUPT:
				;18269		;---------------------------------------; int = 1:
			    p143;18270		ACCESS A [W1],				; [L2] wait for read to complete
E 29F  0000,0000,2020,0040 J 040;18271		INTERRUPT FAULT 			; enter interrupt fault flows
				;18272
				;18273	CMPCX.SRC1.SRC2.NO.INTERRUPT:
				;18274		;---------------------------------------; int = 0:
				;18275		VA <-- [R3],				; [L2] next byte from src2
E 29D  0040,0005,1130,0593 J 593;18276		[W3] <-- MEM (VA), LEN(DL)		; read byte
				;18277
				;18278		;---------------------------------------;
				;18279		[WBUS] <-- [W1] - [W3], LEN(DL),	; [L3] compare src1 char with src2 char
				;18280		SET PSL CC.JIZJ,			; set psl cc's, psl map is jizj
E 593  0A80,0024,202C,8594 J 594;18281			sim cond [s4.char.match]
				;18282
				;18283		;---------------------------------------;
E 594  0B00,0000,4920,0223 J 223;18284		[R2] <-- [R2] - 1, LONG 		; [L4] decrement src2len
				;18285
				;18286		;---------------------------------------;
			    p535;18287		[R0] <-- [R0] - 1, LONG,		; [L5] decrement src1len
E 223  2B00,0000,4100,419A B 29A;18288		CASE [ALU.NZV] AT [CMPCX.SRC1.SRC2.NEQ] ; case on compare from [L4]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  535
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
				;18289
				;18290	;	CMPCX, continued.
				;18291	;	Compare src1 to src2, decrement counts, increment addresses.
				;18292
				;18293	;	At this point,
				;18294	;		R0	=	decremented src1len
				;18295	;		R1	=	src1addr
				;18296	;		R2	=	decremented src2len
				;18297	;		R3	=	src2addr
				;18298	;		W0	=	fill character
				;18299	;		ALU.Z	=	set from decremented value of R2 (cycle L5)
				;18300	;		ALU.Z	=	set from decremented value of R0 (cycle L6)
				;18301	;		STATE<3> =	1
				;18302
				;18303	;= ALIGNLIST 101x	(CMPCX.SRC1.SRC2.NEQ,	CMPCX.SRC1.SRC2.EQL)
				;18304
				;18305	CMPCX.SRC1.SRC2.NEQ:
				;18306		;---------------------------------------; alu.z = 0:
			    p536;18307		[R2] <-- [R2] + 1, LONG,		; [L6] difference found, correct src2len
E 29A  0800,0000,4920,028B J 28B;18308		GOTO [CMPCX.CORRECT.R0] 		; correct src1len and exit
				;18309
				;18310	CMPCX.SRC1.SRC2.EQL:
				;18311		;---------------------------------------; alu.z = 1:
				;18312		[R1] <-- [R1] + 1, LONG,		; [L6] increment src1addr
E 29E  2800,0000,4510,4198 B 298;18313		CASE [ALU.NZV] AT [CMPCX.SRC1.SRC2.CONTINUE] ; case on src2len = 0
				;18314
				;18315	;= ALIGNLIST 10xx	(CMPCX.SRC1.SRC2.CONTINUE, CMPCX.SRC2.DONE)
				;18316	;  ALU.NZVC set by subtract of words in longword --> V = 0
				;18317
				;18318	CMPCX.SRC1.SRC2.CONTINUE:
				;18319		;---------------------------------------; alu.z = 0:
			    p534;18320		[R3] <-- [R3] + 1, LONG,		; [L7] increment src2addr
E 298  2800,0000,4D30,41B8 B 2B8;18321		CASE [ALU.NZV] AT [CMPCX.SRC1.SRC2.LOOP] ; case on src1len = 0
				;18322
				;18323	CMPCX.SRC2.DONE:
				;18324		;---------------------------------------; wbus.z = 1:
			    p536;18325		[R3] <-- [R3] + 1, LONG,		; [L7] increment src2addr
E 29C  2800,0000,4D30,41B9 B 2B9;18326		CASE [ALU.NZV] AT [CMPCX.SRC1.FILL.LOOP] ; case on src1len = 0
				;18327
				;18328	;	Here when src1len = 0.	Src2len is known to be non-zero, join
				;18329	;	fill.src2 loop.
				;18330
				;18331	CMPCX.SRC1.DONE:
				;18332		;---------------------------------------; alu.z = 1:
				;18333		VA <-- [R3],				; [L1] next byte from src2
			    p538;18334		[W1] <-- MEM (VA), LEN(DL),		; read byte
E 2BC  E040,0005,0930,4FAC B 2AC;18335		CASE [SHF.NZ.INT] AT [CMPCX.FILL.SRC2.NO.INTERRUPT] ; case on int pending
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  536
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
				;18336
				;18337	;	CMPCX, continued.
				;18338	;	Compare src1 to fill.
				;18339
				;18340	;	At this point,
				;18341	;		R0	=	src1len
				;18342	;		R1	=	src1addr
				;18343	;		R2	=	src2len
				;18344	;		R3	=	src2addr
				;18345	;		W0	=	fill character
				;18346	;		STATE<3> =	1
				;18347
				;18348	;= ALIGNLIST 10xx	(CMPCX.SRC1.FILL.LOOP,	CMPCX.SRC1.FILL.EXIT)
				;18349	;  ALU.NZVC set by AND or subtract of word in longword --> V = 0
				;18350
				;18351	CMPCX.SRC1.FILL.LOOP:
				;18352		;---------------------------------------; alu.z = 0:
				;18353		VA <-- [R1],				; [L1] next byte from src1
				;18354		[W1] <-- MEM (VA), LEN(DL),		; read byte
E 2B9  E040,0005,0910,4FAD B 2AD;18355		CASE [SHF.NZ.INT] AT [CMPCX.SRC1.FILL.NO.INTERRUPT] ; case on int pending
				;18356
				;18357	;= ALIGNLIST 110x	(CMPCX.SRC1.FILL.NO.INTERRUPT, CMPCX.SRC1.FILL.INTERRUPT)
				;18358
				;18359	CMPCX.SRC1.FILL.INTERRUPT:
				;18360		;---------------------------------------; int = 1:
			    p143;18361		ACCESS A [W1],				; [L2] wait for read to complete
E 2AF  0000,0000,2020,0040 J 040;18362		INTERRUPT FAULT 			; enter interrupt fault processor
				;18363
				;18364	CMPCX.SRC1.FILL.NO.INTERRUPT:
				;18365		;---------------------------------------; int = 0:
				;18366		[WBUS] <-- [W1] - [W0], LEN(DL),	; [L2] compare src1 char to fill
				;18367		SET PSL CC.JIZJ,			; set psl cc's, psl map is jizj
E 2AD  0A80,000C,202C,8595 J 595;18368			sim cond [s4.char.match]
				;18369
				;18370		;---------------------------------------;
E 595  0B00,0000,4100,0222 J 222;18371		[R0] <-- [R0] - 1, LONG 		; [L3] decrement src1len, test for 0
				;18372
				;18373		;---------------------------------------;
				;18374		NOP,					; [L4] nothing to do...
E 222  2000,0000,2000,418B B 28B;18375		CASE [ALU.NZV] AT [CMPCX.SRC1.FILL.NEQ] ; case on compare from [L3]
				;18376
				;18377	;= ALIGNLIST 101x	(CMPCX.SRC1.FILL.NEQ,	CMPCX.SRC1.FILL.EQL)
				;18378
				;18379	CMPCX.CORRECT.R0:
				;18380	CMPCX.SRC1.FILL.NEQ:
				;18381		;---------------------------------------; alu.z = 0:
				;18382		[R0] <-- [R0] + 1, LONG,		; [L5] difference found, correct src1len
				;18383		STATE.3-0 <-- 0,			; clear state flags
				;18384							; >> state<3> change, no SQ ref last cycle
			    p351;18385							; >> state<3> change, sync done on prev MRQ
E 28B  0800,0000,4108,0507 J 507;18386		GOTO [RESTART.IBOX]			; restart I-box and decode next instruction
				;18387
				;18388	CMPCX.SRC1.FILL.EQL:
				;18389		;---------------------------------------; alu.z = 1:
				;18390		[R1] <-- [R1] + 1, LONG,		; [L5] increment src1addr
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  537
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;			    p536											    CSTRING
E 28F  2800,0000,4510,41B9 B 2B9;18391		CASE [ALU.NZV] AT [CMPCX.SRC1.FILL.LOOP] ; case on loop count = 0 from [L4]
				;18392
				;18393	CMPCX.SRC1.FILL.EXIT:				; PSL cc's are correct
				;18394	CLR.STATE.3.RESTART.IBOX:
				;18395		;---------------------------------------; alu.z = 1:
				;18396		STATE.3-0 <-- 0,			; clear state 3 before exiting
				;18397							; >> state<3> change, no SQ ref last cycle
			    p351;18398							; >> state<3> change, sync done on prev MRQ
E 2BD  0000,0000,2008,0507 J 507;18399		GOTO [RESTART.IBOX]			; restart I-box and decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  538
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
				;18400
				;18401	;	CMPCX, continued.
				;18402	;	Compare fill to src2.
				;18403
				;18404	;	At this point,
				;18405	;		R0	=	src1len
				;18406	;		R1	=	src1addr
				;18407	;		R2	=	src2len
				;18408	;		R3	=	src2addr
				;18409	;		W0	=	fill character
				;18410	;		STATE<3> =	1
				;18411
				;18412	;= ALIGNLIST 10xx	(CMPCX.FILL.SRC2.LOOP,	CMPCX.FILL.SRC2.EXIT)
				;18413	;  ALU.NZVC set by AND or subtract of word in longword --> V = 0
				;18414
				;18415	CMPCX.FILL.SRC2.LOOP:
				;18416		;---------------------------------------; alu.z = 0:
				;18417		VA <-- [R3],				; [L1] next byte of src2
				;18418		[W1] <-- MEM (VA), LEN(DL),		; read byte
E 2BA  E040,0005,0930,4FAC B 2AC;18419		CASE [SHF.NZ.INT] AT [CMPCX.FILL.SRC2.NO.INTERRUPT] ; case on int pending
				;18420
				;18421	;= ALIGNLIST 110x	(CMPCX.FILL.SRC2.NO.INTERRUPT, CMPCX.FILL.SRC2.INTERRUPT)
				;18422
				;18423	CMPCX.FILL.SRC2.INTERRUPT:
				;18424		;---------------------------------------; int = 1:
			    p143;18425		ACCESS A [W1],				; [L2] wait for read to complete
E 2AE  0000,0000,2020,0040 J 040;18426		INTERRUPT FAULT 			; enter interrupt fault processor
				;18427
				;18428	CMPCX.FILL.SRC2.NO.INTERRUPT:
				;18429		;---------------------------------------; int = 0:
				;18430		[WBUS] <-- [W0] - [W1], LEN(DL),	; [L2] compare fill to src2 char
				;18431		SET PSL CC.JIZJ,			; set psl cc's, psl map is jizj
E 2AC  0A80,0014,201C,8596 J 596;18432			sim cond [s4.char.match]
				;18433
				;18434		;---------------------------------------;
E 596  0B00,0000,4920,0221 J 221;18435		[R2] <-- [R2] - 1, LONG 		; [L3] decrement src2len, test for 0
				;18436
				;18437		;---------------------------------------;
				;18438		NOP,					; [L4] nothing to do...
E 221  2000,0000,2000,417B B 27B;18439		CASE [ALU.NZV] AT [CMPCX.FILL.SRC2.NEQ] ; case on result of compare
				;18440
				;18441	;= ALIGNLIST 101x	(CMPCX.FILL.SRC2.NEQ,	CMPCX.FILL.SRC2.EQL)
				;18442
				;18443	CMPCX.FILL.SRC2.NEQ:
				;18444		;---------------------------------------; alu.z = 0:
				;18445		[R2] <-- [R2] + 1, LONG,		; [L5] match found, correct src2len
				;18446		STATE.3-0 <-- 0,			; clear state flags
				;18447							; >> state<3> change, no SQ ref last cycle
			    p351;18448							; >> state<3> change, sync done on prev MRQ
E 27B  0800,0000,4928,0507 J 507;18449		GOTO [RESTART.IBOX]			; restart I-box and decode next instruction
				;18450
				;18451	CMPCX.FILL.SRC2.EQL:
				;18452		;---------------------------------------; alu.z = 1:
				;18453		[R3] <-- [R3] + 1, LONG,		; [L5] increment src2addr
E 27F  2800,0000,4D30,41BA B 2BA;18454		CASE [ALU.NZV] AT [CMPCX.FILL.SRC2.LOOP] ; case on loop count = 0 from [L4]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  539
;   CSTRING.MIC 	     CMPC3, CMPC5									      /REV=
;															    CSTRING
				;18455
				;18456	CMPCX.FILL.SRC2.EXIT:
				;18457		;---------------------------------------; alu.z = 1:
				;18458		STATE.3-0 <-- 0,			; clear state 3 before exiting
				;18459							; >> state<3> change, no SQ ref last cycle
			    p351;18460							; >> state<3> change, sync done on prev MRQ
E 2BE  0000,0000,2008,0507 J 507;18461		GOTO [RESTART.IBOX]			; restart I-box and decode next instruction
				;18462
;18463	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  540
;   CSTRING.MIC 	     SCANC, SPANC									      /REV=
;															    CSTRING
;18464	.TOC	"	SCANC, SPANC"
;18465
;18466	;	These instructions test a string of characters against a table.
;18467	;
;18468	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;18469	;	--------      ------	---------				----	-----			--------
;18470	;	SCANC		2A	see below				4	raar/wbbb		SCANC.SPANC..
;18471	;
;18472	;	SPANC		2B	see below				4	raar/wbbb		SCANC.SPANC..
;18473	;
;18474	;	Operation:
;18475	;		if len > 0 then
;18476	;			{for i = 0 to len - 1
;18477	;				{char = table[src[i]]
;18478	;				if char and mask eq/neq 0 then exit}}
;18479	;
;18480	;	Entry conditions:
;18481	;		source queue	=	len.rw operand
;18482	;					addr.ab operand
;18483	;					tbladdr.ab operand
;18484	;					mask.rb operand
;18485	;		dest queue	=	none
;18486	;		branch queue	=	none
;18487	;		field queue	=	none
;18488	;		DL		=	BYTE
;18489	;		Ibox state	=	stopped
;18490	;		Mbox state	=	running
;18491	;
;18492	;	Exit conditions:
;18493	;		The PSL condition codes are set.
;18494	;		R0 - R3 have been updated to the SRM specified values.
;18495	;
;18496	;	Condition codes:
;18497	;		N <-- 0
;18498	;		Z <-- R0 EQL 0
;18499	;		V <-- 0 			[Integer overflow trap disabled.]
;18500	;		C <-- 0
;18501	;
;18502	;	Note:	SCANC/SPANC are interruptible instructions.  If a memory management fault or interrupt
;18503	;		occurs in mid instruction, the outstanding state is packed into R0 - R3, FPD is set,
;18504	;		and the exception is processed.  When the instruction is redecoded, the state is unpacked
;18505	;		and the instruction is resumed at the interruption point.
;18506	;
;18507	;	Note:	All source queue entries that may fault must be referenced before any GPRs are written
;18508	;		to prevent overwriting an operand that may be in R0-R5.  In addition, state<3> must not
;18509	;		be set in the microinstruction that follows the one that contains the last reference to
;18510	;		a source queue entry that may fault.  This prevents state<3> from being set in the trap
;18511	;		shadow of a faulting operand reference.
;18512	;
;18513	;	Note:	SCANC/SPANC are currently coded for minimum microcode size.  This is probably slower than
;18514	;		a macrocode loop.  Better implementations should be investigated.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  541
;   CSTRING.MIC 	     SCANC, SPANC									      /REV=
;															    CSTRING
;18515
;18516	;	The microcode uses a control block which is kept partially in the general registers,
;18517	;	and partially in the working registers.  In greater detail:
;18518	;
;18519	;	General registers:
;18520	;		R0	=	source count (at packup only: delta PC, mask, count)
;18521	;		R1	=	srcaddr
;18522	;		R2	=	0
;18523	;		R3	=	table address
;18524	;
;18525	;	Working registers:
;18526	;		W0	=	mask
;18527
				;18528	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  542
;   CSTRING.MIC 	     SCANC, SPANC									      /REV=
;															    CSTRING
				;18529
				;18530	;	SCANC, SPANC operation:
				;18531	;
				;18532	;		if len > 0 then
				;18533	;			{for i = 0 to len - 1
				;18534	;				{char = table[src[i]]
				;18535	;				if char and mask eq/neq 0 then exit}}
				;18536	;
				;18537	;	CAUTION: Do not change the order of reference to the
				;18538	;	source queue in the entry point below without
				;18539	;	reading the explanation at the beginning of this module.
				;18540	;
				;18541	;	The following simultaneous reference restriction exists for
				;18542	;	this entry point: [spec 3; spec 4].
				;18543
				;18544	SCANC.SPANC..:
				;18545		;********** Hardware dispatch **********;
				;18546		VA <-- [S1] AND [K.FFFF], LONG, 	; [1] zero extend string length
E 1A2  0400,0071,208D,0597 J 597;18547		SET PSL CC.IIII 			; set psl cc's for zero length path
				;18548
				;18549		;---------------------------------------;
				;18550		[W1] <-- [S1], LONG,			; [2] get string address in W1
E 597  0002,8048,0880,0599 J 599;18551		Q <-- PASSB [S2]			; and table address in Q
				;18552							; >> no [spec 3; spec 4] reference
				;18553
				;18554		;---------------------------------------;
				;18555		[R3] <-- [Q], LONG,			; [3] move table address to R3
E 599  0002,8040,4CA0,059C J 59C;18556		Q <-- PASSB [S1]			; get match character
				;18557							; >> GPR write, all SQ references complete
				;18558
				;18559		;---------------------------------------;
				;18560		[R1] <-- PASSB [W1], LONG,		; [4] move string address to R1
E 59C  0000,8012,44B0,059D J 59D;18561		NODST <-- [VA]				; retest length
				;18562
				;18563		;---------------------------------------;
E 59D  0000,0000,04A0,032B J 32B;18564		[W0] <-- [Q], LONG			; [5] move match character to W0
				;18565
				;18566	SCANC.SPANC.RESTART:
				;18567		;---------------------------------------;
				;18568		[R0] <-- [VA], LONG,			; [6] save length in R0
			    p543;18569		DL <-- BYTE,				; set dl = byte
E 32B  2000,0000,40B2,4149 B 349;18570		CASE [ALU.NZV] AT [SCANC.SPANC.LOOP]	; case on string length = 0
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  543
;   CSTRING.MIC 	     SCANC, SPANC									      /REV=
;															    CSTRING
				;18571
				;18572	;	SCANC/SPANC, continued.
				;18573	;	Main loop: read character, test for interrupts, compute table
				;18574	;	address, read table.
				;18575
				;18576	;	At this point:
				;18577	;		R0	=	loop count
				;18578	;		R1	=	source address
				;18579	;		R3	=	table address
				;18580	;		W0	=	mask
				;18581	;		STATE<3> =	1
				;18582
				;18583	;= ALIGNLIST 10xx	(SCANC.SPANC.LOOP,	SCANC.SPANC.EXIT)
				;18584	;  ALU.NZVC set by pass or subtract of word in longword --> V = 0
				;18585
				;18586	SCANC.SPANC.LOOP:
				;18587		;---------------------------------------; alu.z = 0:
				;18588		VA <-- [R1],				; [L1] get string address
				;18589		[W1] <-- MEM (VA), LEN(DL),		; read next byte from string
				;18590		STATE.3 <-- 1,				; flag interruptable instruction
				;18591							; >> state<3> change, no SQ ref last cycle
				;18592							; >> state<3> change, sync done on prev MRQ
E 349  F041,8005,0910,4F3C B 33C;18593		CASE [SHF.NZ.INT] AT [SCANC.SPANC.NO.INTERRUPTS] ; case on interrupt pending
				;18594
				;18595	;= ALIGNLIST 110x	(SCANC.SPANC.NO.INTERRUPTS, SCANC.SPANC.INTERRUPT)
				;18596
				;18597	SCANC.SPANC.INTERRUPT:
				;18598		;---------------------------------------; int = 1:
			    p143;18599		ACCESS A [W1],				; [L2] wait for read to complete
E 33E  0000,0000,2020,0040 J 040;18600		INTERRUPT FAULT 			; enter interrupt fault processor
				;18601
				;18602	SCANC.SPANC.NO.INTERRUPTS:
				;18603		;---------------------------------------; int = 0:
E 33C  0400,27F8,0820,05A0 J 5A0;18604		[W1] <-- [W1] AND 000000[0FF], LONG	; [L2] mask off upper bytes
				;18605
				;18606		;---------------------------------------;
				;18607		VA <-- [R3] + [W1],			; [L3] index table with character
E 5A0  08C0,0015,1130,05A1 J 5A1;18608		[W3] <-- MEM (VA), LEN(DL)		; read table entry
				;18609
				;18610		;---------------------------------------;
				;18611		[WBUS] <-- [W3] AND [W0], LEN(DL),	; [L4] mask table entry for compare
E 5A1  0400,000C,2040,0308 J 308;18612			sim cond [s4.char.match]
				;18613
				;18614		;---------------------------------------;
				;18615		[R0] <-- [R0] - 1, LONG,		; [L5] decrement loop count
			    p544;18616		SET PSL CC.IIIJ,			; set psl cc's for loop exhausted path
E 308  8B00,0000,410D,CC25 B 325;18617		CASE [OPCODE.2-0] AT [SCANC.COMPARE]	; case on SCANC vs. SPANC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  544
;   CSTRING.MIC 	     SCANC, SPANC									      /REV=
;															    CSTRING
				;18618
				;18619	;	SCANC/SPANC, continued.
				;18620	;	SCANC: case on table entry AND mask EQL 0.
				;18621
				;18622	;	At this point:
				;18623	;		R0	=	decremented loop count
				;18624	;		R1	=	source address
				;18625	;		R2	=	0
				;18626	;		R3	=	table address
				;18627	;		W0	=	mask
				;18628	;		ALU.Z	=	1 if table entry AND mask EQL 0
				;18629	;		STATE<3> =	1
				;18630
				;18631	;= ALIGNLIST x10x	(SCANC.COMPARE, 	SPANC.COMPARE)
				;18632	;  Opcodes = 2A, 2B --> opcode<2:0> = 01?
				;18633
				;18634	SCANC.COMPARE:
				;18635		;---------------------------------------; opcode<0> = 0 (SCANC):
				;18636		[R2] <-- 000000[00], LONG,		; [L6] clear R2 while waiting
E 325  2080,2000,4800,4148 B 348;18637		CASE [ALU.NZV] AT [SCANC.NEQ]		; case on entry AND mask EQL 0
				;18638
				;18639	;= ALIGNLIST 10xx	(SCANC.NEQ,	SCANC.EQL)
				;18640	;  ALU.NZVC set by AND --> V = C = 0
				;18641
				;18642	SCANC.NEQ:
				;18643		;---------------------------------------; alu.z = 0:
				;18644		[R0] <-- [R0] + 1, LONG,		; [L7] correct loop count
			    p537;18645		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 348  0800,0000,410D,02BD J 2BD;18646		GOTO [CLR.STATE.3.RESTART.IBOX] 	; clear state <3>, restart I-box, and
				;18647							; decode next instruction
				;18648
				;18649	SCANC.EQL:
				;18650		;---------------------------------------; alu.z = 1:
			    p543;18651		[R1] <-- [R1] + 1, LONG,		; [L7] increment source address
E 34C  2800,0000,4510,4149 B 349;18652		CASE [ALU.NZV] AT [SCANC.SPANC.LOOP]	; test loop count = 0
				;18653
				;18654	SCANC.SPANC.EXIT:				; psl cc's are correct
				;18655		;---------------------------------------; alu.z = 1:
				;18656		[R2] <-- 000000[00], LONG,		; clear R2
				;18657		STATE.3-0 <-- 0,			; clear state 3 before exiting
				;18658							; >> state<3> change, no SQ ref last cycle
			    p351;18659							; >> state<3> change, sync done on prev MRQ
E 34D  0080,2000,4808,0507 J 507;18660		GOTO [RESTART.IBOX]			; restart I-box and decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  545
;   CSTRING.MIC 	     SCANC, SPANC									      /REV=
;															    CSTRING
				;18661
				;18662	;	SCANC/SPANC, continued.
				;18663	;	SPANC: case on table entry AND mask NEQ 0.
				;18664
				;18665	;	At this point:
				;18666	;		R0	=	decremented loop count
				;18667	;		R1	=	source address
				;18668	;		R2	=	0
				;18669	;		R3	=	table address
				;18670	;		W0	=	mask
				;18671	;		ALU.Z	=	1 if table entry AND mask EQL 0
				;18672	;		STATE<3> =	1
				;18673
				;18674	SPANC.COMPARE:
				;18675		;---------------------------------------; opcode<0> = 1 (SPANC):
				;18676		[R2] <-- 000000[00], LONG,		; [L6] clear R2 while waiting
E 327  2080,2000,4800,414A B 34A;18677		CASE [ALU.NZV] AT [SPANC.NEQ]		; case on entry AND mask NEQ 0
				;18678
				;18679	;= ALIGNLIST 10xx	(SPANC.NEQ,	SPANC.EQL)
				;18680	;  ALU.NZVC set by AND --> V = C = 0
				;18681
				;18682	SPANC.EQL:
				;18683		;---------------------------------------; alu.z = 1:
				;18684		[R0] <-- [R0] + 1, LONG,		; [L7] correct loop count
			    p537;18685		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 34E  0800,0000,410D,02BD J 2BD;18686		GOTO [CLR.STATE.3.RESTART.IBOX] 	; clear state <3>, restart I-box, and
				;18687							; decode next instruction
				;18688
				;18689	SPANC.NEQ:
				;18690		;---------------------------------------; alu.z = 0:
			    p543;18691		[R1] <-- [R1] + 1, LONG,		; [L7] increment source address
E 34A  2800,0000,4510,4149 B 349;18692		CASE [ALU.NZV] AT [SCANC.SPANC.LOOP]	; test loop count = 0
				;18693
;18694	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  546
;   CSTRING.MIC 	     LOCC, SKPC 									      /REV=
;															    CSTRING
;18695	.TOC	"	LOCC, SKPC"
;18696
;18697	;	These instructions test a string of characters against a character.
;18698	;
;18699	;	Mnemonic      Opcode	Operation				Spec	AT/DL			Dispatch
;18700	;	--------      ------	---------				----	-----			--------
;18701	;	LOCC		3A	search M[srcaddr...srcaddr+len-1]	3	rra/bwb 		LOCC.SKPC..
;18702	;					until char found
;18703	;
;18704	;	SKPC		3B	search M[srcaddr...srcaddr+len-1]	3	rra/bwb 		LOCC.SKPC..
;18705	;
;18706	;	Entry conditions:
;18707	;		source queue	=	char.rb operand
;18708	;					len.rw operand
;18709	;					addr.ab operand
;18710	;		dest queue	=	none
;18711	;		branch queue	=	none
;18712	;		field queue	=	none
;18713	;		DL		=	BYTE
;18714	;		Ibox state	=	stopped
;18715	;		Mbox state	=	running
;18716	;
;18717	;	Exit conditions:
;18718	;		The PSL condition codes are set.
;18719	;		R0 - R1 have been updated to the SRM specified values.
;18720	;
;18721	;	Condition codes:
;18722	;		N <-- 0
;18723	;		Z <-- R0 EQL 0
;18724	;		V <-- 0 			[Integer overflow trap disabled.]
;18725	;		C <-- 0
;18726	;
;18727	;	Note:	LOCC/SKPC are interruptible instructions.  If a memory management fault or interrupt
;18728	;		occurs in mid instruction, the outstanding state is packed into R0 - R1, FPD is set,
;18729	;		and the exception is processed.  When the instruction is redecoded, the state is unpacked
;18730	;		and the instruction is resumed at the interruption point.
;18731	;
;18732	;	Note:	All source queue entries that may fault must be referenced before any GPRs are written
;18733	;		to prevent overwriting an operand that may be in R0-R5.  In addition, state<3> must not
;18734	;		be set in the microinstruction that follows the one that contains the last reference to
;18735	;		a source queue entry that may fault.  This prevents state<3> from being set in the trap
;18736	;		shadow of a faulting operand reference.
;18737	;
;18738	;	Note:	LOCC/SKPC are currently coded for minimum microcode size.  This is probably slower than
;18739	;		a macrocode loop.  Better implementations should be investigated.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  547
;   CSTRING.MIC 	     LOCC, SKPC 									      /REV=
;															    CSTRING
;18740
;18741	;	The microcode uses a control block which is kept partially in the general registers,
;18742	;	and partially in the working registers.  In greater detail:
;18743	;
;18744	;	General registers:
;18745	;		R0	=	source count (at packup only: delta PC, match character, count)
;18746	;		R1	=	srcaddr
;18747	;
;18748	;	Working registers:
;18749	;		W0	=	match character
;18750
				;18751	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  548
;   CSTRING.MIC 	     LOCC, SKPC 									      /REV=
;															    CSTRING
				;18752
				;18753	;	LOCC, SKPC operation:
				;18754	;
				;18755	;		if len > 0 then
				;18756	;			{for i = 0 to len - 1
				;18757	;				if src[i] eq/neq char then exit}}
				;18758	;
				;18759	;	There are no simultaneous reference restrictions for this
				;18760	;	entry point.
				;18761
				;18762	LOCC.SKPC..:
				;18763		;********** Hardware dispatch **********;
E 1A0  0000,8042,0400,05A2 J 5A2;18764		[W0] <-- PASSB [S1], LONG		; [1] get fill character
				;18765
				;18766		;---------------------------------------;
				;18767		VA <-- [S1] AND [K.FFFF], LONG, 	; [2] zero extend and test length
E 5A2  0400,0071,208D,05A3 J 5A3;18768		SET PSL CC.IIII 			; set psl cc's for zero length path
				;18769
				;18770		;---------------------------------------;
E 5A3  0000,0000,4480,032F J 32F;18771		[R1] <-- [S1], LONG			; [3] save source address in R1
				;18772							; >> GPR write, all SQ references complete
				;18773
				;18774	LOCC.SKPC.RESTART:
				;18775		;---------------------------------------;
				;18776		[R0] <-- [VA], LONG,			; [4] save source length in R0
			    p549;18777		DL <-- BYTE,				; set dl = byte
E 32F  2000,0000,40B2,414B B 34B;18778		CASE [ALU.NZV] AT [LOCC.SKPC.LOOP]	; case on length = 0 from [2]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  549
;   CSTRING.MIC 	     LOCC, SKPC 									      /REV=
;															    CSTRING
				;18779
				;18780	;	LOCC/SKPC, continued.
				;18781	;	Main loop: read character, test for interrupts,
				;18782	;	compare with match character, decrement loop count.
				;18783
				;18784	;	At this point:
				;18785	;		R0	=	loop count
				;18786	;		R1	=	source address
				;18787	;		W0	=	match character
				;18788	;		STATE<3> =	1
				;18789
				;18790	;= ALIGNLIST 10xx	(LOCC.SKPC.LOOP,	LOCC.SKPC.EXIT)
				;18791	;  ALU.NZVC set by pass or subtract of words in longword --> V = 0
				;18792
				;18793	LOCC.SKPC.LOOP:
				;18794		;---------------------------------------; alu.z = 0:
				;18795		VA <-- [R1],				; [L1] get next byte address
				;18796		[W1] <-- MEM (VA), LEN(DL),		; read next byte from string
				;18797		STATE.3 <-- 1,				; flag interruptible instruction
				;18798							; >> state<3> change, no SQ ref last cycle
				;18799							; >> state<3> change, sync done on prev MRQ
E 34B  F041,8005,0910,4F3D B 33D;18800		CASE [SHF.NZ.INT] AT [LOCC.SKPC.NO.INTERRUPTS] ; case on interrupt pending
				;18801
				;18802	;= ALIGNLIST 110x	(LOCC.SKPC.NO.INTERRUPTS, LOCC.SKPC.INTERRUPT)
				;18803
				;18804	LOCC.SKPC.INTERRUPT:
				;18805		;---------------------------------------; int = 1:
			    p143;18806		ACCESS A [W1],				; [L2] wait for read to complete
E 33F  0000,0000,2020,0040 J 040;18807		INTERRUPT FAULT 			; enter interrupt fault processor
				;18808
				;18809	LOCC.SKPC.NO.INTERRUPTS:
				;18810		;---------------------------------------; int = 0:
				;18811		[WBUS] <-- [W0] XOR [W1], LEN(DL),	; [L2] compare with match character
E 33D  0600,0014,2010,0306 J 306;18812			sim cond [s4.char.match]
				;18813
				;18814		;---------------------------------------;
				;18815		[R0] <-- [R0] - 1, LONG,		; [L3] decrement loop count
			    p550;18816		SET PSL CC.IIIJ,			; set psl cc's for loop exhausted path
E 306  8B00,0000,410D,CC15 B 315;18817		CASE [OPCODE.2-0] AT [LOCC.COMPARE]	; case on LOCC vs. SKPC
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  550
;   CSTRING.MIC 	     LOCC, SKPC 									      /REV=
;															    CSTRING
				;18818
				;18819	;	LOCC/SKPC, continued.
				;18820	;	LOCC: case on source character EQL match character.
				;18821
				;18822	;	At this point:
				;18823	;		R0	=	decremented loop count
				;18824	;		R1	=	source address
				;18825	;		W0	=	match character
				;18826	;		ALU.Z	=	1 if source character EQL match character
				;18827	;		STATE<3> =	1
				;18828
				;18829	;= ALIGNLIST x10x	(LOCC.COMPARE,		SKPC.COMPARE)
				;18830	;  Opcodes = 3A, 3B --> opcode<2:0> = 01?
				;18831
				;18832	LOCC.COMPARE:
				;18833		;---------------------------------------; opcode<0> = 0 (LOCC):
				;18834		NOP,					; [L4] nothing to do...
E 315  2000,0000,2000,4129 B 329;18835		CASE [ALU.NZV] AT [LOCC.NEQ]		; case on result of compare from [L3]
				;18836
				;18837	;= ALIGNLIST 10xx	(LOCC.NEQ,	LOCC.EQL)
				;18838	;  ALU.NZVC set by XOR --> V = C = 0
				;18839
				;18840	LOCC.EQL:
				;18841		;---------------------------------------; alu.z = 1:
				;18842		[R0] <-- [R0] + 1, LONG,		; [L5] correct loop count
			    p537;18843		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 32D  0800,0000,410D,02BD J 2BD;18844		GOTO [CLR.STATE.3.RESTART.IBOX] 	; clear state <3>, restart I-box, and
				;18845							; decode next instruction
				;18846
				;18847	LOCC.NEQ:
				;18848		;---------------------------------------; alu.z = 0:
			    p549;18849		[R1] <-- [R1] + 1, LONG,		; [L5] increment source address
E 329  2800,0000,4510,414B B 34B;18850		CASE [ALU.NZV] AT [LOCC.SKPC.LOOP]	; case on loop count = 0
				;18851
				;18852	LOCC.SKPC.EXIT: 				; psl cc's are correct
				;18853		;---------------------------------------; alu.z = 1:
				;18854		STATE.3-0 <-- 0,			; clear state 3 before exiting
				;18855							; >> state<3> change, no SQ ref last cycle
			    p351;18856							; >> state<3> change, sync done on prev MRQ
E 34F  0000,0000,2008,0507 J 507;18857		GOTO [RESTART.IBOX]			; restart I-box and decode next instruction
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  551
;   CSTRING.MIC 	     LOCC, SKPC 									      /REV=
;															    CSTRING
				;18858
				;18859	;	LOCC/SKPC, continued.
				;18860	;	SKPC: case on source character NEQ match character.
				;18861
				;18862	;	At this point:
				;18863	;		R0	=	decremented loop count
				;18864	;		R1	=	source address
				;18865	;		W0	=	match character
				;18866	;		ALU.Z	=	1 if source character EQL match character
				;18867	;		STATE<3> =	1
				;18868
				;18869	SKPC.COMPARE:
				;18870		;---------------------------------------; opcode<0> = 1 (SKPC):
				;18871		NOP,					; [L4] nothing to do...
E 317  2000,0000,2000,4158 B 358;18872		CASE [ALU.NZV] AT [SKPC.NEQ]		; case on result of compare
				;18873
				;18874	;= ALIGNLIST 10xx	(SKPC.NEQ,	SKPC.EQL)
				;18875	;  ALU.NZVC set by XOR --> V = C = 0
				;18876
				;18877	SKPC.NEQ:
				;18878		;---------------------------------------; alu.z = 0:
				;18879		[R0] <-- [R0] + 1, LONG,		; [L5] correct loop count
			    p537;18880		SET PSL CC.IIII,			; set psl cc's, psl map is iiii
E 358  0800,0000,410D,02BD J 2BD;18881		GOTO [CLR.STATE.3.RESTART.IBOX] 	; clear state <3>, restart I-box, and
				;18882							; decode next instruction
				;18883
				;18884	SKPC.EQL:
				;18885		;---------------------------------------; alu.z = 1:
			    p549;18886		[R1] <-- [R1] + 1, LONG,		; [L5] increment source address
E 35C  2800,0000,4510,414B B 34B;18887		CASE [ALU.NZV] AT [LOCC.SKPC.LOOP]	; test loop count = 0
				;18888
;18889	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  552
;   CSTRING.MIC 	     String Packup Routine								      /REV=
;															    CSTRING
;18890	.TOC	"	String Packup Routine"
;18891
;18892	;	This routine is invoked by the exception processor microcode
;18893	;	if an interrupt or exception occurs during one of the eight
;18894	;	string instructions.  It packs up the current instruction
;18895	;	state into the general registers, sets FPD, and returns to the
;18896	;	exception processor.
;18897
;18898	;	On entry, Q contains the left-justified fill, mask, match character,
;18899	;	W2 contains the current PC.
;18900	;	For each instruction, state needed to restart the instruction is
;18901	;	collected and packed into the general registers as indicated:
;18902
;18903	;	MOVCx:
;18904	;		Entry						Exit
;18905	;		R0	=	loop count - 2*[kdl]		R0	=	delta PC, fill character, loop count
;18906	;		R1	=	initial srcaddr 		R1	=	initial srcaddr
;18907	;		R2	=	initial loop count		R2	=	initial loop count
;18908	;		R3	=	initial dstaddr 		R3	=	initial dstaddr
;18909	;		R4	=	srclen - dstlen 		R4	=	srclen - dstlen
;18910	;		Q<31:24> =	fill character			R5	=	state flags
;18911	;		W3	=	k(dl)				W0	=	old PC
;18912	;		STATE<1:0> =	type of move			STATE<3:0> =	0
;18913	;		W2	=	current PC
;18914
;18915	;	CMPCx:
;18916	;		Entry						Exit
;18917	;		R0	=	src1 count			R0	=	delta PC, fill character, src1 count
;18918	;		R1	=	src1addr			R1	=	src1addr
;18919	;		R2	=	src2 count			R2	=	src2count
;18920	;		R3	=	src2addr			R3	=	src2addr
;18921	;		Q<31:24> =	fill character			W0	=	old PC
;18922	;		W2	=	current PC			STATE<3:0> =	0
;18923
;18924	;	LOCC/SKPC:
;18925	;		Entry						Exit
;18926	;		R0	=	source count			R0	=	delta PC, match character, source count
;18927	;		R1	=	srcaddr 			R1	=	srcaddr
;18928	;		Q<31:24> =	match character 		W0	=	old PC
;18929	;		W2	=	current PC			STATE<3:0> =	0
;18930
;18931	;	SCANC/SPANC:
;18932	;		Entry						Exit
;18933	;		R0	=	source count			R0	=	delta PC, mask, source count
;18934	;		R1	=	srcaddr 			R1	=	srcaddr
;18935	;		R3	=	table address			R3	=	table address
;18936	;		Q<31:24> =	mask				W0	=	old PC
;18937	;		W2	=	current PC			STATE<3:0> =	0
;18938
				;18939	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  553
;   CSTRING.MIC 	     String Packup Routine								      /REV=
;															    CSTRING
				;18940
				;18941	;	String packup, continued.
				;18942
				;18943	;	Note: A RESET CPU was done last cycle.	No memory request may
				;18944	;	be made in the first two instructions of this routine.	Working
				;18945	;	registers may be written because the previous CPU aborted all
				;18946	;	outstanding reads.
				;18947
				;18948	;	At this point, the general registers contain all required state,
				;18949	;	except as noted:
				;18950	;		R0	=	loop count {- 2*[kdl] if MOVCx}
				;18951	;		W1 = SAVEPC =	opcode PC
				;18952	;		W2	=	next PC
				;18953	;		W3	=	k(dl) if MOVCx
				;18954	;		Q<31:24> =	fill character, mask, or match character
				;18955	;		STATE<1:0> =	type of move {if MOVCx}
				;18956
				;18957	STRING.PACK:
				;18958		;---------------------------------------; opcode<6> = 0 --> string:
E 5A4  0500,3840,30C0,05A5 J 5A5;18959		[PSL] <-- [PSL] OR [08]000000, LONG	; set PSL<fpd>
				;18960							; >> PSL change, no decode for 3 cycles
				;18961							; >> RESET CPU: no MRQ this cycle
				;18962
				;18963		;---------------------------------------;
E 5A5  0A80,0010,0C30,0509 J 509;18964		[W2] <-- [W2] - [W1], LONG		; calculate delta PC
				;18965							; >> RESET CPU: no MRQ this cycle
				;18966
				;18967		;---------------------------------------;
				;18968		Q <-- [W2]!![Q] RSH [8.], LONG, 	; combine delta PC, char/mask
			    p554;18969		RESTART MBOX,				; restart mbox
E 509  8003,8850,2034,CC29 B 529;18970		CASE [OPCODE.2-0] AT [MOVC.PACK]	; case on opcode
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  554
;   CSTRING.MIC 	     String Packup Routine								      /REV=
;															    CSTRING
				;18971
				;18972	;	String packup, continued
				;18973	;	MOVCx-specific packup routine.	Adjust the loop count and
				;18974	;	save the state flags.
				;18975	;
				;18976	;	At this point,
				;18977	;		R0	=	loop count - 2*[kdl]
				;18978	;		W0	=	old PC
				;18979	;		W3	=	k(dl)
				;18980	;		Q	=	delta PC, char/mask in <31:16>
				;18981	;		STATE<1:0> =	type of move
				;18982
				;18983	;= ALIGNLIST 100x	(MOVC.PACK,		CMPC.PACK,
				;18984	;=			 SCANC.LOCC.PACK,	SPANC.SKPC.PACK)
				;18985
				;18986	MOVC.PACK:
				;18987		;---------------------------------------; opcode<1:0> = 00 (MOVCx):
E 529  0880,0020,4100,050D J 50D;18988		[R0] <-- [R0] + [W3], LONG		; restore loop count
				;18989
				;18990		;---------------------------------------;
				;18991		[R0] <-- [R0] + [W3], LONG,		; restore loop count
				;18992		STATE.3-0 <-- 0,			; clear state<3> to avoid potential
				;18993							; machine check loop below
				;18994							; >> state<3> change, no SQ ref last cycle
				;18995							; >> state<3> change, sync done on prev MRQ
E 50D  4880,0020,4108,4A38 B 538;18996		CASE [STATE.2-0] AT [MOVC.PACK.00]	; fill in flags via case
				;18997
				;18998	;= ALIGNLIST 100x	(MOVC.PACK.00,	MOVC.PACK.01,
				;18999	;=			 MOVC.PACK.10,	MOVC.PACK.UNKNOWN)
				;19000
				;19001	MOVC.PACK.00:
				;19002		;---------------------------------------; state<1:0> = 00:
			    p555;19003		[R5] <-- 000000[00], LONG,		; save state<1:0>
E 538  0080,2000,5400,052B J 52B;19004		GOTO [MOVC.PACK.EXIT]			; exit thru common exit
				;19005
				;19006	MOVC.PACK.01:
				;19007		;---------------------------------------; state<1:0> = 01:
			    p555;19008		[R5] <-- 000000[01], LONG,		; save state<1:0>
E 53A  0080,2008,5400,052B J 52B;19009		GOTO [MOVC.PACK.EXIT]			; exit thru common exit
				;19010
				;19011	MOVC.PACK.10:
				;19012		;---------------------------------------; state<1:0> = 10:
			    p555;19013		[R5] <-- 000000[02], LONG,		; save state<1:0>
E 53C  0080,2010,5400,052B J 52B;19014		GOTO [MOVC.PACK.EXIT]			; exit thru common exit
				;19015
				;19016	MOVC.PACK.UNKNOWN:
			    p135;19017		;---------------------------------------; state<1:0> = 11:
E 53E  0080,3020,A400,0038 J 038;19018		MACHINE CHECK [MCHK.MOVC.STATUS]	; impossible state, die
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  555
;   CSTRING.MIC 	     String Packup Routine								      /REV=
;															    CSTRING
				;19019
				;19020	;	String packup, continued
				;19021	;	CMPCx, LOCC, SKPC, SCANC, SPANC-specific packup routines.
				;19022	;	Combine delta PC, char/mask, and loop count.
				;19023	;
				;19024	;	At this point,
				;19025	;		R0	=	loop count
				;19026	;		W0	=	old PC
				;19027	;		Q	=	delta PC, char/mask in <31:16>
				;19028
				;19029	MOVC.PACK.EXIT:
				;19030	CMPC.PACK:
				;19031		;---------------------------------------; opcode<1:0> = 01 (CMPCx):
				;19032		[R0] <-- [R0] OR [Q], LONG,		; merge delta PC, char, count
				;19033		STATE.3-0 <-- 0,			; clear state
				;19034							; >> state<3> change, no SQ ref last cycle
				;19035							; >> state<3> change, sync done on prev MRQ
E 52B  0500,0050,4108,0800 R	;19036		RETURN					; return to caller
				;19037
				;19038	SCANC.LOCC.PACK:
				;19039		;---------------------------------------; opcode<1:0> = 10 (SCANC/LOCC):
				;19040		[R0] <-- [R0] OR [Q], LONG,		; merge delta PC, char, count
				;19041		STATE.3-0 <-- 0,			; clear state
				;19042							; >> state<3> change, no SQ ref last cycle
				;19043							; >> state<3> change, sync done on prev MRQ
E 52D  0500,0050,4108,0800 R	;19044		RETURN					; return to caller
				;19045
				;19046	SPANC.SKPC.PACK:
				;19047		;---------------------------------------; opcode<1:0> = 11 (SPANC/SKPC):
				;19048		[R0] <-- [R0] OR [Q], LONG,		; merge delta PC, char, count
				;19049		STATE.3-0 <-- 0,			; clear state
				;19050							; >> state<3> change, no SQ ref last cycle
				;19051							; >> state<3> change, sync done on prev MRQ
E 52F  0500,0050,4108,0800 R	;19052		RETURN					; return to caller
;19053	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  556
;   CSTRING.MIC 	     String Unpack Routine								      /REV=
;															    CSTRING
;19054	.TOC	"	String Unpack Routine"
;19055
;19056	;	This routine is invoked by the FPD processor microcode
;19057	;	to restart a string instruction following an interrupt or exception.
;19058	;	It unpacks the current instruction state from the general
;19059	;	registers, clears FPD, and restarts the instruction.
;19060
;19061	;	For each instruction, state needed to restart the instruction is
;19062	;	extracted from the general registers and restored as indicated:
;19063
;19064	;	MOVCx:
;19065	;		Entry							Exit
;19066	;		R0	=	delta PC, fill character, loop count	R0	=	loop count
;19067	;		R1	=	initial srcaddr 			R1	=	initial srcaddr
;19068	;		R2	=	initial loop count			R2	=	initial loop count
;19069	;		R3	=	initial dstaddr 			R3	=	initial dstaddr
;19070	;		R4	=	srclen - dstlen 			R4	=	srclen - dstlen
;19071	;		R5	=	state flags				W0<7:0> =	fill character
;19072	;		SAVEPC	=	opcode PC				W2	=	srcaddr - dstaddr
;19073	;									STATE<1:0> =	type of move
;19074	;									STATE<3:2> =	10
;19075
;19076	;	CMPCx:
;19077	;		Entry							Exit
;19078	;		R0	=	delta PC, fill character, src1 count	R0	=	src1 count
;19079	;		R1	=	src1addr				R1	=	src1addr
;19080	;		R2	=	src2 count				R2	=	src2 count
;19081	;		R3	=	src2addr				R3	=	src2addr
;19082	;		SAVEPC	=	opcode PC				W0<7:0> =	fill character
;19083
;19084	;	LOCC/SKPC:
;19085	;		Entry							Exit
;19086	;		R0	=	delta PC, match character, source count R0	=	source count
;19087	;		R1	=	srcaddr 				R1	=	srcaddr
;19088	;		W5	=	R0 rsh 24
;19089	;		SAVEPC	=	opcode PC				W0<7:0> =	match character
;19090
;19091	;	SCANC/SPANC:
;19092	;		Entry							Exit
;19093	;		R0	=	delta PC, mask, source count		R0	=	source count
;19094	;		R1	=	srcaddr 				R1	=	srcaddr
;19095	;		R3	=	table address				R3	=	table address
;19096	;		W5	=	R0 rsh 24
;19097	;		SAVEPC	=	opcode PC				W0<7:0> =	match character
;19098
				;19099	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  557
;   CSTRING.MIC 	     String Unpack Routine								      /REV=
;															    CSTRING
				;19100
				;19101	;	String unpack, continued.
				;19102
				;19103	;	At this point,
				;19104	;		W1	=	opcode<7:0>, junk in remaining bits
				;19105	;		W5	=	R0 rsh 24 (if SCANC, SPANC, LOCC, SKPC)
				;19106
				;19107	;	The general registers contain instruction-specific data, with the
				;19108	;	following exceptions:
				;19109	;		R0	=	<delta PC><char/mask><loop count>
				;19110	;		R5	=	state flags {if MOVCx}
				;19111
				;19112	;	Prefetch is disabled for both entry points.
				;19113
				;19114	MOVC.CMPC.FPD:
				;19115		;---------------------------------------; alu.z = 1:
E 165  0001,D882,1800,00E5 J 0E5;19116		[W5] <-- ZEXT [R0] RSH [24.], LONG	; isolate delta PC
				;19117
				;19118	SCANC.LOCC.FPD:
				;19119		;---------------------------------------; alu.z = 1:
				;19120		[PSL] <-- [PSL] ANDNOT [08]000000,	; clear PSL<fpd>
				;19121		LONG,					; >> PSL change, no decode for 3 cycles
E 0E5  1481,B840,30C0,05A6 J 5A6;19122		STATE.3 <-- 1				; flag interruptible instruction
				;19123							; >> state<3> change, no SQ ref last cycle
				;19124							; >> state<3> change, sync done on prev MRQ
				;19125
				;19126		;---------------------------------------;
				;19127		VA <-- K10.[IPR.BPC], LONG,		; load BPC IPR address for string
E 5A6  00D4,3AC1,1401,0530 J 530;19128		[W4] <-- MEM.PR (VA)			; read BPC
				;19129
				;19130		;---------------------------------------;
				;19131		[WBUS] <-- [W4] + [W5], LONG,		; add opcode PC to delta PC
				;19132							; >> sync with Ibox IPR read
				;19133		LOAD PC,				; load new PC, restart PREFETCHING
				;19134							; >> LOAD PC: queues must be empty
			    p559;19135							; >> LOAD PC: sync required before exit
E 530  88A4,0030,2050,4CEB B 5EB;19136		CASE [OPCODE.2-0] AT [MOVC.CMPC.UNPACK] ; case on opcode<1> = MOVC/CMPC vs others
				;19137
				;19138	;= ALIGNLIST 101x	(MOVC.CMPC.UNPACK,	SCANC.LOCC.UNPACK)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  558
;   CSTRING.MIC 	     String Unpack Routine								      /REV=
;															    CSTRING
				;19139
				;19140	;	SCANC/SPANC/LOCC/SKPC unpack.
				;19141	;	Complete unpack and return to interrupted instruction.
				;19142
				;19143	;	At this point,
				;19144	;		R0	=	<delta PC><char/mask><loop count>
				;19145	;		R1	=	srcaddr
				;19146	;		R3	=	table address (SCANC/SPANC only)
				;19147	;		W1	=	opcode<7:0>, junk in remaining bits
				;19148	;		STATE<3> =	1
				;19149
				;19150	SCANC.LOCC.UNPACK:
				;19151		;---------------------------------------; opcode<1> = 1 (SCANC/SPANC/LOCC/SKPC):
E 5EF  0400,0071,2100,05A7 J 5A7;19152		VA <-- [R0] AND [K.FFFF], LONG		; zero extend loop count
				;19153
				;19154		;---------------------------------------;
				;19155		[WBUS] <-- [VA], LONG,			; retest loop count
E 5A7  0000,0010,20B0,030A J 30A;19156		ACCESS B [W1]				; test opcode<4>
				;19157
				;19158		;---------------------------------------;
				;19159		[W0] <-- ZEXT [R0] RSH [16.], LONG,	; right justify char/mask
			    p542;19160		SYNCHRONIZE MBOX,			; >> sync with LOAD PC
E 30A  8021,D082,0400,442B B 32B;19161		CASE [B.5-3] AT [SCANC.SPANC.RESTART]	; case on SCANC/SPANC vs LOCC/SKPC
				;19162							; destination cases on srclen = 0
				;19163
				;19164	;= ALIGNLIST 101x	(SCANC.SPANC.RESTART,	LOCC.SKPC.RESTART)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  559
;   CSTRING.MIC 	     String Unpack Routine								      /REV=
;															    CSTRING
				;19165
				;19166	;	MOVCx/CMPCx unpack.
				;19167	;	Complete unpack and return to interrupted instruction.
				;19168
				;19169	;	At this point,
				;19170	;		R0	=	<delta PC><char/mask><loop count>
				;19171	;		R1	=	srcaddr
				;19172	;		R2	=	loop count
				;19173	;		R3	=	dstaddr
				;19174	;		R4	=	srclen - dstlen (MOVC5 only)
				;19175	;		R5	=	flags (MOVCx only)
				;19176	;		STATE<3> =	1
				;19177
				;19178	MOVC.CMPC.UNPACK:
				;19179		;---------------------------------------; opcode<1> = 0 (MOVCx, CMPCx):
E 5EB  0001,D082,0400,05A9 J 5A9;19180		[W0] <-- ZEXT [R0] RSH [16.], LONG	; right justify char/mask
				;19181
				;19182		;---------------------------------------;
E 5A9  0400,0070,4100,05AB J 5AB;19183		[R0] <-- [R0] AND [K.FFFF], LONG	; zero extend R0 count
				;19184
				;19185		;---------------------------------------;
E 5AB  0400,0070,4920,0217 J 217;19186		[R2] <-- [R2] AND [K.FFFF], LONG	; zero extend and test R2 count
				;19187
				;19188		;---------------------------------------;
				;19189		[WBUS] <-- [R0], LONG,			; test R0 count
				;19190		ACCESS B [R5],				; test flags for MOVCx
E 217  8000,00A8,2100,4C88 B 288;19191		CASE [OPCODE.2-0] AT [MOVC.UNPACK..]	; case on MOVC vs CMPC
				;19192
				;19193	;= ALIGNLIST 1x0x	(MOVC.UNPACK.., 	CMPC.UNPACK)
				;19194	;  Opcodes = 28, 29, 2C, 2D --> opcode<2:0> = ?0?
				;19195
				;19196	CMPC.UNPACK:
				;19197		;---------------------------------------; opcode<0> = 1 (CMPCx):
				;19198		[W1] <-- [R1], LONG,			; copy srcaddr to W1 for reentry
			    p533;19199		SYNCHRONIZE MBOX,			; >> sync with LOAD PC
E 28A  2020,0000,0910,4120 B 220;19200		CASE [ALU.NZV] AT [CMPCX.SRC2.NEQ.ZERO] ; case on src2len = 0
				;19201							; destination then cases on src1len
				;19202
				;19203	MOVC.UNPACK..:
				;19204		;---------------------------------------; opcode<0> = 0 (MOVCx):
				;19205		[W4] <-- [R2] - [R0], LONG,		; calculate initial - current loop count
			    p560;19206		SYNCHRONIZE MBOX,			; >> sync with LOAD PC
E 288  6AA0,0080,1520,4369 B 269;19207		CASE [B.2-0] AT [MOVC.FPD.FORWARD]	; case on b<1:0> = STATE<1:0>
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  560
;   CSTRING.MIC 	     String Unpack Routine								      /REV=
;															    CSTRING
				;19208
				;19209	;	MOVCx unpack, continued.
				;19210	;	Restore state and restart move forward operation.
				;19211
				;19212	;	At this point,
				;19213	;		R0	=	loop count, zero extended
				;19214	;		R1	=	initial srcaddr
				;19215	;		R2	=	initial loop count, zero extended
				;19216	;		R3	=	initial dstaddr
				;19217	;		R4	=	srclen - dstlen (MOVC5 only)
				;19218	;		W0<7:0> =	fill character (MOVC5 only)
				;19219	;		W4	=	initial loop count - current loop count
				;19220	;		STATE<3:0> =	1000
				;19221
				;19222	;= ALIGNLIST 100x	(MOVC.FPD.FORWARD,	MOVC.FPD.BACKWARD,
				;19223	;=			 MOVC.FPD.FILL, 	MOVC.FPD.ERROR)
				;19224
				;19225	MOVC.FPD.FORWARD:
				;19226		;---------------------------------------; b<1:0> = 00:
E 269  0880,0028,1530,05AC J 5AC;19227		[W4] <-- [R3] + [W4], LONG		; calculate next dstaddr for alignment
				;19228
				;19229	MOVC.FPD.CONT:
				;19230		;---------------------------------------;
E 5AC  0000,0028,2000,0333 J 333;19231		ACCESS B [W4]				; test dstaddr<1:0>
				;19232
				;19233		;---------------------------------------;
			    p511;19234		[W2] <-- [R1] - [R3], LONG,		; calculate srcaddr - dstaddr
E 333  6A80,0098,0D10,4398 B 398;19235		CASE [B.2-0] AT [MOVC.ALIGN.DST.00]	; case into alignment loop
				;19236
				;19237	MOVC.FPD.BACKWARD:
				;19238		;---------------------------------------; b<1:0> = 01:
				;19239		[W4] <-- [R3] + [W0], LONG,		; calculate next dstaddr for alignment
				;19240		STATE.0 <-- 1,				; flag backward move
E 26B  0880,0008,1538,85AC J 5AC;19241		GOTO [MOVC.FPD.CONT]			; join common code
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  561
;   CSTRING.MIC 	     String Unpack Routine								      /REV=
;															    CSTRING
				;19242
				;19243	;	MOVCx unpack, continued.
				;19244	;	Restore state and restart move backward operation.
				;19245
				;19246	;	At this point,
				;19247	;		R0	=	loop count, zero extended
				;19248	;		R1	=	initial srcaddr
				;19249	;		R2	=	initial loop count, zero extended
				;19250	;		R3	=	initial dstaddr
				;19251	;		R4	=	srclen - dstlen
				;19252	;		W0<7:0> =	fill character (MOVC5 only)
				;19253	;		W4	=	initial loop count - current loop count
				;19254	;		STATE<3:0> =	1000
				;19255
				;19256	MOVC.FPD.FILL:
				;19257		;---------------------------------------; b<1:0> = 10:
E 26D  0880,0028,1530,05B0 J 5B0;19258		[W4] <-- [R3] + [W4], LONG		; calculate next dstaddr for alignment
				;19259
				;19260		;---------------------------------------;
E 5B0  0003,5800,2010,05B1 J 5B1;19261		Q <-- [W0] LSH [24.], LONG		; start replication of fill character
				;19262
				;19263		;---------------------------------------;
				;19264		[W5] <-- [W0]!![Q] RSH [24.], LONG,	; W5<15:0> contains word of fill
E 5B1  0001,9852,1819,05B2 J 5B2;19265		STATE.1 <-- 1				; flag fill
				;19266
				;19267		;---------------------------------------;
				;19268		ACCESS B [W4],				; test dstaddr<1:0>
			    p523;19269		Q <-- [W5] LSH [16.], LONG,		; Q<31:16> contains word of fill
E 5B2  0003,5028,2060,0332 J 332;19270		GOTO [MOVC.FILL.SETUP]			; enter fill flows
				;19271
				;19272	MOVC.FPD.ERROR:
			    p127;19273		;---------------------------------------; b<1:0> = 11:
E 26F  0000,0000,2000,003C J 03C;19274		RESERVED OPERAND FAULT			; impossible state, fault
				;19275
				;19276	;= END CSTRING
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  562
;    FPOINT.MIC 	     FPOINT.MIC -- Floating Point Instructions						      /REV=
;
				;19277	.TOC	"FPOINT.MIC -- Floating Point Instructions"
				;19278	.TOC	"Revision 1.0"
				;19279
				;19280	;	Bob Supnik
				;19281
;19282	.nobin
;19283	;****************************************************************************
;19284	;*									    *
;19285	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;19286	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;19287	;*  ALL RIGHTS RESERVED.						    *
;19288	;*									    *
;19289	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;19290	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;19291	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;19292	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;19293	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;19294	;*  TRANSFERRED.							    *
;19295	;*									    *
;19296	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;19297	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;19298	;*  CORPORATION.							    *
;19299	;*									    *
;19300	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;19301	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;19302	;*									    *
;19303	;****************************************************************************
;19304
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  563
;    FPOINT.MIC 	     Revision History									      /REV=
;
;19305	.TOC	"	Revision History"
;19306
;19307	; Edit	  Date	  Who	     Description
;19308	; ---- ---------  ---	---------------------
;19309	; (1)0 24-Jul-90 GMU	Initial production microcode.
;19310	;
;19311	; Begin version 1.0 here
;19312	;    7	29-Mar-90 DGM	Update header page comments
;19313	;    6	22-Mar-90 DGM	Update comments
;19314	;    5	12-Sep-89 DGM	Fix LAST CYCLE NO RETIRE for all floating point
;19315	;    4	25-Aug-89 GMU	Convert all LONG macros to LEN(DL) so fdest check sees
;19316	;			the correct data length.
;19317	;    3	07-Dec-88 DB	Add FBOX.4.SL.ND..
;19318	;    2	06-Dec-88 DB	Bug fix to FBOX DEST CHECK.
;19319	;    1	22-Nov-88 DB	Separate entry points for flow which store results.
;19320	; (0)0	 7-Oct-87 RMS	Trial microcode.
;19321
				;19322	.bin
				;19323	;= BEGIN FPOINT
;19324	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  564
;    FPOINT.MIC 	     Revision History									      /REV=
;															     FPOINT
;19325
;19326	;	This module implements the floating point instruction class.  As these instructions
;19327	;	are entirely executed by the F-box, the responsibility of the microcode is simply
;19328	;	to transfer the instruction operands to the F-box on the FA and FB buses.
;19329	;
;19330	;	The instructions in this class are:
;19331	;
;19332	;	Opcode	 Instruction							N Z V C 	Exceptions
;19333	;	------	 -----------							------- 	----------
;19334	;
;19335	;	60	 ADDD2 add.rd, sum.md						* * 0 0 	rsv, fov, fuv
;19336	;	40	 ADDF2 add.rf, sum.mf						* * 0 0 	rsv, fov, fuv
;19337	;	40FD	 ADDG2 add.rg, sum.mg						* * 0 0 	rsv, fov, fuv
;19338	;
;19339	;	61	 ADDD3 add1.rd, add2.rd, sum.wd 				* * 0 0 	rsv, fov, fuv
;19340	;	41	 ADDF3 add1.rf, add2.rf, sum.wf 				* * 0 0 	rsv, fov, fuv
;19341	;	41FD	 ADDG3 add1.rg, add2.rg, sum.wg 				* * 0 0 	rsv, fov, fuv
;19342	;
;19343	;	71	 CMPD src1.rd, src2.rd						* * 0 0 	rsv
;19344	;	51	 CMPF src1.rf, src2.rf						* * 0 0 	rsv
;19345	;	51FD	 CMPG src1.rg, src2.rg						* * 0 0 	rsv
;19346	;
;19347	;	6C	 CVTBD src.rb, dst.wd						* * 0 0
;19348	;	4C	 CVTBF src.rb, dst.wf						* * 0 0
;19349	;	4CFD	 CVTBG src.rb, dst.wg						* * 0 0
;19350	;	68	 CVTDB src.rd, dst.wb						* * * 0 	rsv, iov
;19351	;	76	 CVTDF src.rd, dst.wf						* * 0 0 	rsv, fov
;19352	;	6A	 CVTDL src.rd, dst.wl						* * * 0 	rsv, iov
;19353	;	69	 CVTDW src.rd, dst.ww						* * * 0 	rsv, iov
;19354	;	48	 CVTFB src.rf, dst.wb						* * * 0 	rsv, iov
;19355	;	56	 CVTFD src.rf, dst.wd						* * 0 0 	rsv
;19356	;	99FD	 CVTFG src.rf, dst.wg						* * 0 0 	rsv
;19357	;	4A	 CVTFL src.rf, dst.wl						* * * 0 	rsv, iov
;19358	;	49	 CVTFW src.rf, dst.ww						* * * 0 	rsv, iov
;19359	;	48FD	 CVTGB src.rg, dst.wb						* * * 0 	rsv, iov
;19360	;	33FD	 CVTGF src.rg, dst.wf						* * 0 0 	rsv, fov, fuv
;19361	;	4AFD	 CVTGL src.rg, dst.wl						* * * 0 	rsv, iov
;19362	;	49FD	 CVTGW src.rg, dst.ww						* * * 0 	rsv, iov
;19363	;	6E	 CVTLD src.rl, dst.wd						* * 0 0
;19364	;	4E	 CVTLF src.rl, dst.wf						* * 0 0
;19365	;	4EFD	 CVTLG src.rl, dst.wg						* * 0 0
;19366	;	6D	 CVTWD src.rw, dst.wd						* * 0 0
;19367	;	4D	 CVTWF src.rw, dst.wf						* * 0 0
;19368	;	4DFD	 CVTWG src.rw, dst.wg						* * 0 0
;19369	;
;19370	;	6B	 CVTRDL src.rd, dst.wl						* * * 0 	rsv, iov
;19371	;	4B	 CVTRFL src.rf, dst.wl						* * * 0 	rsv, iov
;19372	;	4BFD	 CVTRGL src.rg, dst.wl						* * * 0 	rsv, iov
;19373	;
;19374	;	66	 DIVD2 divr.rd, quo.md						* * 0 0 	rsv, fov, fuv, fdvz
;19375	;	46	 DIVF2 divr.rf, quo.mf						* * 0 0 	rsv, fov, fuv, fdvz
;19376	;	46FD	 DIVG2 divr.rg, quo.mg						* * 0 0 	rsv, fov, fuv, fdvz
;19377	;
;19378	;	67	 DIVD3 divr.rd, divd.rd, quo.wd 				* * 0 0 	rsv, fov, fuv, fdvz
;19379	;	47	 DIVF3 divr.rf, divd.rf, quo.wf 				* * 0 0 	rsv, fov, fuv, fdvz
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  565
;    FPOINT.MIC 	     Revision History									      /REV=
;															     FPOINT
;19380	;	47FD	 DIVG3 divr.rg, divd.rg, quo.wg 				* * 0 0 	rsv, fov, fuv, fdvz
;19381	;
;19382	;	72	 MNEGD src.rd, dst.wd						* * 0 0 	rsv
;19383	;	52	 MNEGF src.rf, dst.wf						* * 0 0 	rsv
;19384	;	52FD	 MNEGG src.rg, dst.wg						* * 0 0 	rsv
;19385	;
;19386	;	70	 MOVD src.rd, dst.wd						* * 0 - 	rsv
;19387	;	50	 MOVF src.rf, dst.wf						* * 0 - 	rsv
;19388	;	50FD	 MOVG src.rg, dst.wg						* * 0 - 	rsv
;19389	;
;19390	;	64	 MULD2 mulr.rd, prod.md 					* * 0 0 	rsv, fov, fuv
;19391	;	44	 MULF2 mulr.rf, prod.mf 					* * 0 0 	rsv, fov, fuv
;19392	;	44FD	 MULG2 mulr.rg, prod.mg 					* * 0 0 	rsv, fov, fuv
;19393	;
;19394	;	65	 MULD3 mulr.rd, muld.rd, prod.wd				* * 0 0 	rsv, fov, fuv
;19395	;	45	 MULF3 mulr.rf, muld.rf, prod.wf				* * 0 0 	rsv, fov, fuv
;19396	;	45FD	 MULG3 mulr.rg, muld.rg, prod.wg				* * 0 0 	rsv, fov, fuv
;19397	;
;19398	;	62	 SUBD2 sub.rd, dif.md						* * 0 0 	rsv, fov, fuv
;19399	;	42	 SUBF2 sub.rf, dif.mf						* * 0 0 	rsv, fov, fuv
;19400	;	42FD	 SUBG2 sub.rg, dif.mg						* * 0 0 	rsv, fov, fuv
;19401	;
;19402	;	63	 SUBD3 sub.rd, min.rd, dif.wd					* * 0 0 	rsv, fov, fuv
;19403	;	43	 SUBF3 sub.rf, min.rf, dif.wf					* * 0 0 	rsv, fov, fuv
;19404	;	43FD	 SUBG3 sub.rg, min.rg, dif.wg					* * 0 0 	rsv, fov, fuv
;19405	;
;19406	;	73	 TSTD src.rd							* * 0 0 	rsv
;19407	;	53	 TSTF src.rf							* * 0 0 	rsv
;19408	;	53FD	 TSTG src.rg							* * 0 0 	rsv
;19409
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  566
;    FPOINT.MIC 	     Floating Point Instructions With Single Bus Operand Transfer			      /REV=
;															     FPOINT
;19410	.TOC	"	Floating Point Instructions With Single Bus Operand Transfer"
;19411	.TOC	"		MOVF, MNEGF, CVTFi, CVTiF"
;19412	.TOC	"		CVTiD, CVTFD, CVTiG, CVTFG"
;19413
;19414
;19415	;	These instructions perform the specified function, then store a byte, word, longword, f_floating,
;19416	;	d_floating or g_floating result to memory or register.
;19417	;
;19418	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19419	;	--------      ------	---------				----	-----		--------
;19420	;	MOVF		50	dst.wf <-- src.rf			 2	rw/ff		FBOX.1.SL..
;19421	;
;19422	;	MNEGF		52	dst.wl <-- -src.rf			 2	rw/ff		FBOX.1.SL..
;19423	;
;19424	;	CVTFB		48	dst.wb <-- src.rf			 2	rw/fb		FBOX.1.SL..
;19425	;	CVTFW		49	dst.ww <-- src.rf			 2	rw/fw		FBOX.1.SL..
;19426	;	CVTFL		4A	dst.wl <-- src.rf			 2	rw/fl		FBOX.1.SL..
;19427	;	CVTRFL		4B	dst.wl <-- src.rf			 2	rw/fl		FBOX.1.SL..
;19428	;
;19429	;	CVTBF		4C	dst.wf <-- src.rb			 2	rw/bf		FBOX.1.SL..
;19430	;	CVTWF		4D	dst.wf <-- src.rw			 2	rw/wf		FBOX.1.SL..
;19431	;	CVTLF		4E	dst.wf <-- src.rl			 2	rw/lf		FBOX.1.SL..
;19432	;
;19433	;	CVTBD		6C	dst.wd <-- src.rb			 2	rw/bd		FBOX.1.SL..
;19434	;	CVTWD		6D	dst.wd <-- src.rw			 2	rw/wd		FBOX.1.SL..
;19435	;	CVTLD		6E	dst.wd <-- src.rl			 2	rw/ld		FBOX.1.SL..
;19436	;	CVTFD		56	dst.wd <-- src.rf			 2	rw/fd		FBOX.1.SL..
;19437	;
;19438	;	CVTBG		4CFD	dst.wg <-- src.rb			 2	rw/bg		FBOX.1.SL..
;19439	;	CVTWG		4DFD	dst.wg <-- src.rw			 2	rw/wg		FBOX.1.SL..
;19440	;	CVTLG		4EFD	dst.wg <-- src.rl			 2	rw/lg		FBOX.1.SL..
;19441	;	CVTFG		99FD	dst.wg <-- src.rf			 2	rw/fg		FBOX.1.SL..
;19442	;
;19443	;
;19444	;	Entry conditions:
;19445	;		source queue	=	src.rx operand
;19446	;		dest queue	=	dst.wx result
;19447	;		branch queue	=	none
;19448	;		field queue	=	none
;19449	;		DL		=	data length of dst.wx
;19450	;		Ibox state	=	running
;19451	;		Mbox state	=	running
;19452	;
;19453	;	Exit conditions:
;19454	;		The PSL condition codes are set.
;19455	;		The specified function has been performed and the result has been stored in the destination memory
;19456	;			location or register.
;19457	;
;19458	;	Condition codes:
;19459	;		(MNEGF, CVTFi, CVTiF)			(MOVF, CVTiD, CVTFD, CVTiG, CVTFG)
;19460	;		N <-- dst LSS 0 			N <-- dst LSS 0
;19461	;		Z <-- dst EQL 0 			Z <-- dst EQL 0
;19462	;		V <-- integer overflow			V <-- 0 		[Integer overflow trap enabled.]
;19463	;		C <-- 0 				C <-- 0
				;19464	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  567
;    FPOINT.MIC 	     CVTiD, CVTFD, CVTiG, CVTFG 							      /REV=
;															     FPOINT
				;19465
				;19466	FBOX.1.SL..:
				;19467		;********** Hardware Dispatch **********;
				;19468		FBOX OPERAND A[S1],			; send operand to F-box
				;19469		FBOX DEST CHECK, LEN(DL),		; Update F-box scoreboard
E 1A8  1002,4304,0080,1000 L	;19470		LAST CYCLE NO RETIRE			; decode next instruction
				;19471
;19472	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  568
;    FPOINT.MIC 	     Floating Point Instructions With Single Bus Operand Transfer, No Destination Write       /REV=
;															     FPOINT
;19473	.TOC	"	Floating Point Instructions With Single Bus Operand Transfer, No Destination Write"
;19474	.TOC	"		TSTF"
;19475
;19476	;	This instruction compares a floating point operand against zero.
;19477	;
;19478	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19479	;	--------      ------	---------				----	-----		--------
;19480	;	TSTF		53	src.rf - 0				 1	r/f		FBOX.1.SL.ND..
;19481	;
;19482	;	Entry conditions:
;19483	;		source queue	=	src.rf operand
;19484	;		dest queue	=	none
;19485	;		branch queue	=	none
;19486	;		field queue	=	none
;19487	;		DL		=	LONG
;19488	;		Ibox state	=	running
;19489	;		Mbox state	=	running
;19490	;
;19491	;	Exit conditions:
;19492	;		The PSL condition codes are set.
;19493	;
;19494	;	Condition codes:
;19495	;		N <-- dst LSS 0
;19496	;		Z <-- dst EQL 0
;19497	;		V <-- 0 		[Integer overflow trap disabled.]
;19498	;		C <-- 0
;19499
				;19500	.bin
				;19501
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  569
;    FPOINT.MIC 	     TSTF										      /REV=
;															     FPOINT
				;19502
				;19503	FBOX.1.SL.ND..:
				;19504		;********** Hardware Dispatch **********;
				;19505		FBOX OPERAND A[S1], LEN(DL),		; send operand to F-box
E 1B0  1002,4104,0080,1000 L	;19506		LAST CYCLE NO RETIRE			; decode next instruction
				;19507
;19508	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  570
;    FPOINT.MIC 	     Floating Point Instructions With Double Bus Operand Transfer			      /REV=
;															     FPOINT
;19509	.TOC	"	Floating Point Instructions With Double Bus Operand Transfer"
;19510	.TOC	"		MOVD, MOVG, MNEGD, MNEGG"
;19511	.TOC	"		CVTDi, CVTDF, CVTGi, CVTGF"
;19512	.TOC	"		ADDFx, SUBFx, MULFx, DIVFx"
;19513
;19514	;	These instructions perform the specified function, then store a byte, word, longword, f_floating,
;19515	;	d_floating or g_floating result to memory or register.
;19516	;
;19517	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19518	;	--------      ------	---------				----	-----		--------
;19519	;	MOVD		70	dst.wd <-- src.rd			 2	rw/dd		FBOX.2.SL..
;19520	;	MOVG		50FD	dst.wg <-- src.rg			 2	rw/gg		FBOX.2.SL..
;19521	;	MNEGD		72	dst.wd <-- -src.rd			 2	rw/dd		FBOX.2.SL..
;19522	;	MNEGG		52FD	dst.wg <-- -src.rg			 2	rw/gg		FBOX.2.SL..
;19523	;
;19524	;	CVTDB		68	dst.wb <-- src.rd			 2	rw/db		FBOX.2.SL..
;19525	;	CVTDW		69	dst.ww <-- src.rd			 2	rw/dw		FBOX.2.SL..
;19526	;	CVTDL		6A	dst.wl <-- src.rd			 2	rw/dl		FBOX.2.SL..
;19527	;	CVTRDL		6B	dst.wl <-- src.rd			 2	rw/dl		FBOX.2.SL..
;19528	;	CVTDF		76	dst.wf <-- src.rd			 2	rw/df		FBOX.2.SL..
;19529	;
;19530	;	CVTGB		48FD	dst.wb <-- src.rg			 2	rw/gb		FBOX.2.SL..
;19531	;	CVTGW		49FD	dst.ww <-- src.rg			 2	rw/gw		FBOX.2.SL..
;19532	;	CVTGL		4AFD	dst.wl <-- src.rg			 2	rw/gl		FBOX.2.SL..
;19533	;	CVTRGL		4BFD	dst.wl <-- src.rg			 2	rw/gl		FBOX.2.SL..
;19534	;	CVTGF		33FD	dst.wf <-- src.rg			 2	rw/gf		FBOX.2.SL..
;19535	;
;19536	;	ADDF2		40	dst.mf <-- src.rf + dst.mf		 2	rm/ff		FBOX.2.SL..
;19537	;	ADDF3		41	dst.wf <-- src1.rf + src2.rf		 3	rrw/fff 	FBOX.2.SL..
;19538	;	SUBF2		42	dst.mf <-- dst.mf - src.rf		 2	rm/ff		FBOX.2.SL..
;19539	;	SUBF3		43	dst.wf <-- src2.rf - src1.rf		 3	rrw/fff 	FBOX.2.SL..
;19540	;	MULF2		44	dst.mf <-- src.rf * dst.mf		 2	rm/ff		FBOX.2.SL..
;19541	;	MULF3		45	dst.wf <-- src1.rf * src2.rf		 3	rrw/fff 	FBOX.2.SL..
;19542	;	DIVF2		46	dst.mf <-- dst.mf / src.rf		 2	rm/ff		FBOX.2.SL..
;19543	;	DIVF3		47	dst.wf <-- src2.rf / src1.rf		 3	rrw/fff 	FBOX.2.SL..
;19544	;
;19545	;	Entry conditions:  (MOVD, MOVG, MNEGD, MNEGG, CVTDi, CVTDF, CVTGi, CVTGF)
;19546	;		source queue	=	src.rx operand
;19547	;		dest queue	=	dst.wx result
;19548	;		branch queue	=	none
;19549	;		field queue	=	none
;19550	;		DL		=	data length of destination
;19551	;		Ibox state	=	running
;19552	;		Mbox state	=	running
;19553	;
;19554	;	Entry conditions:  (ADDFx, SUBFx, MULFx, DIVFx)
;19555	;					(2 operand)		(3 operand)
;19556	;		source queue	=	src.rf operand		src1.rf operand
;19557	;					dst.mf operand		src2.rf operand
;19558	;		dest queue	=	dst.mf result		dst.wf result
;19559	;		branch queue	=	none
;19560	;		field queue	=	none
;19561	;		DL		=	LONG
;19562	;		Ibox state	=	running
;19563	;		Mbox state	=	running
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  571
;    FPOINT.MIC 	     ADDFx, SUBFx, MULFx, DIVFx 							      /REV=
;															     FPOINT
;19564	;
;19565	;	Exit conditions:
;19566	;		The PSL condition codes are set.
;19567	;		The specified function has been performed and the result has been stored in the destination memory
;19568	;			location or register.
;19569	;
;19570	;	Condition codes:
;19571	;		(MOVD, MOVG, MNEGD, MNEGG)		(CVTDi, CVTDF, CVTGi, CVTGF, ADDFx, SUBFx, MULFx, DIVFx)
;19572	;		N <-- dst LSS 0 			N <-- dst LSS 0
;19573	;		Z <-- dst EQL 0 			Z <-- dst EQL 0
;19574	;		V <-- 0 				V <-- integer overflow		[Integer overflow trap enabled.]
;19575	;		C <-- 0 				C <-- 0
;19576
				;19577	.bin
				;19578
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  572
;    FPOINT.MIC 	     ADDFx, SUBFx, MULFx, DIVFx 							      /REV=
;															     FPOINT
				;19579
				;19580	FBOX.2.SL..:
				;19581		;********** Hardware Dispatch **********;
				;19582		FBOX OPERAND A[S1] B[S2],		; send operands to F-box
				;19583		FBOX DEST CHECK, LEN(DL),		; Update F-box scoreboard
E 1AA  1002,434C,0080,1000 L	;19584		LAST CYCLE NO RETIRE			; decode next instruction
				;19585
;19586	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  573
;    FPOINT.MIC 	     Floating Point Instructions With Double Bus Operand Transfer, No Destination Write       /REV=
;															     FPOINT
;19587	.TOC	"	Floating Point Instructions With Double Bus Operand Transfer, No Destination Write"
;19588	.TOC	"		CMPF, TSTD, TSTG"
;19589
;19590	;	These instructions compare a floating point operand against zero (TSTf) or another operand (CMPf).
;19591	;
;19592	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19593	;	--------      ------	---------				----	-----		--------
;19594	;	CMPF		51	src1.rf - src2.rf			 2	rr/ff		FBOX.2.SL.ND..
;19595	;
;19596	;	TSTD		73	src.rd - 0				 1	r/d		FBOX.2.SL.ND..
;19597	;	TSTG		53FD	src.rg - 0				 1	r/g		FBOX.2.SL.ND..
;19598	;
;19599	;	Entry conditions:		(CMPF)			(TSTD, TSTG)
;19600	;		source queue	=	src1.rf operand 	src.rx operand
;19601	;					src2.rf opernad
;19602	;		dest queue	=	none
;19603	;		branch queue	=	none
;19604	;		field queue	=	none
;19605	;		DL		=	data length of last operand
;19606	;		Ibox state	=	running
;19607	;		Mbox state	=	running
;19608	;
;19609	;	Exit conditions:
;19610	;		The PSL condition codes are set.
;19611	;
;19612	;	Condition codes:
;19613	;		N <-- dst LSS 0
;19614	;		Z <-- dst EQL 0
;19615	;		V <-- 0 		[Integer overflow trap disabled.]
;19616	;		C <-- 0
;19617
				;19618	.bin
				;19619
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  574
;    FPOINT.MIC 	     CMPF, TSTD, TSTG									      /REV=
;															     FPOINT
				;19620
				;19621	FBOX.2.SL.ND..:
				;19622		;********** Hardware Dispatch **********;
				;19623		FBOX OPERAND A[S1] B[S2], LEN(DL),	; send operands to F-box
E 1B2  1002,414C,0080,1000 L	;19624		LAST CYCLE NO RETIRE			; decode next instruction
				;19625
;19626	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  575
;    FPOINT.MIC 	     Floating Point Instructions With Quadruple Bus Operand Transfer			      /REV=
;															     FPOINT
;19627	.TOC	"	Floating Point Instructions With Quadruple Bus Operand Transfer"
;19628	.TOC	"		ADDDx, SUBDx, MULDx, DIVDx, ADDGx, SUBGx, MULGx, DIVGx, CMPD, CMPG"
;19629
;19630	;	These instructions perform the specified function, then store a d_floating or g_floating result
;19631	;	to memory or registers.
;19632	;
;19633	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19634	;	--------      ------	---------				----	-----		--------
;19635	;	ADDD2		60	dst.md <-- src.rd + dst.md		 2	rm/dd		FBOX.4.SL..
;19636	;	ADDD3		61	dst.wd <-- src1.rd + src2.rd		 3	rrw/ddd 	FBOX.4.SL..
;19637	;	SUBD2		62	dst.md <-- dst.md - src.rd		 2	rm/dd		FBOX.4.SL..
;19638	;	SUBD3		63	dst.wd <-- src2.rd - src1.rd		 3	rrw/ddd 	FBOX.4.SL..
;19639	;	MULD2		64	dst.md <-- src.rd * dst.md		 2	rm/dd		FBOX.4.SL..
;19640	;	MULD3		65	dst.wd <-- src1.rd * src2.rd		 3	rrw/ddd 	FBOX.4.SL..
;19641	;	DIVD2		66	dst.md <-- dst.md / src.rd		 2	rm/dd		FBOX.4.SL..
;19642	;	DIVD3		67	dst.wd <-- src2.rd / src1.rd		 3	rrw/ddd 	FBOX.4.SL..
;19643	;
;19644	;	ADDG2		40FD	dst.mg <-- src.rg + dst.mg		 2	rm/gg		FBOX.4.SL..
;19645	;	ADDG3		41FD	dst.wg <-- src1.rg + src2.rg		 3	rrw/ggg 	FBOX.4.SL..
;19646	;	SUBG2		42FD	dst.mg <-- dst.mg - src.rg		 2	rm/gg		FBOX.4.SL..
;19647	;	SUBG3		43FD	dst.wg <-- src2.rg - src1.rg		 3	rrw/ggg 	FBOX.4.SL..
;19648	;	MULG2		44FD	dst.mg <-- src.rg * dst.mg		 2	rm/gg		FBOX.4.SL..
;19649	;	MULG3		45FD	dst.wg <-- src1.rg * src2.rg		 3	rrw/ggg 	FBOX.4.SL..
;19650	;	DIVG2		46FD	dst.mg <-- dst.mg / src.rg		 2	rm/gg		FBOX.4.SL..
;19651	;	DIVG3		47FD	dst.wg <-- src2.rg / src1.rg		 3	rrw/ggg 	FBOX.4.SL..
;19652	;
;19653	;	Entry conditions:		(2 operand)		(3 operand)
;19654	;		source queue	=	src.rx operand		src1.rx operand
;19655	;					dst.mx operand		src2.rx operand
;19656	;		dest queue	=	dst.mx result		dst.wx result
;19657	;		branch queue	=	none
;19658	;		field queue	=	none
;19659	;		DL		=	QUAD
;19660	;		Ibox state	=	running
;19661	;		Mbox state	=	running
;19662	;
;19663	;	Exit conditions:
;19664	;		The PSL condition codes are set.
;19665	;		The specified function has been performed and the result has been stored in the destination memory
;19666	;			location or register.
;19667	;
;19668	;	Condition codes:
;19669	;		N <-- dst LSS 0
;19670	;		Z <-- dst EQL 0
;19671	;		V <-- 0 		[Integer overflow trap disabled.]
;19672	;		C <-- 0
;19673	;
;19674
				;19675	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  576
;    FPOINT.MIC 	     ADDDx, SUBDx, MULDx, DIVDx, ADDGx, SUBGx, MULGx, DIVGx, CMPD, CMPG 		      /REV=
;															     FPOINT
				;19676
				;19677	FBOX.4.SL..:
				;19678		;********** Hardware Dispatch **********;
			    p572;19679		FBOX OPERAND A[S1] B[S2], LEN(DL),	; send operands to F-box
E 1AC  1002,404C,0080,01AA J 1AA;19680		GOTO [FBOX.2.SL..]			; send the 2nd pair
;19681	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  577
;    FPOINT.MIC 	     Floating Point Instructions With Quadruple Bus Operand Transfer -- No destination	      /REV=
;															     FPOINT
;19682	.TOC	"	Floating Point Instructions With Quadruple Bus Operand Transfer -- No destination"
;19683	.TOC	"		CMPD, CMPG"
;19684
;19685	;	These instructions compare a floating point operand against another operand (CMPf).
;19686	;
;19687	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19688	;	--------      ------	---------				----	-----		--------
;19689	;	CMPD		71	src1.rd - src2.rd			 2	rr/dd		FBOX.4.SL..
;19690	;	CMPG		51FD	src1.rg - src2.rg			 2	rr/gg		FBOX.4.SL..
;19691	;
;19692	;	Entry conditions:
;19693	;		source queue	=	src1.rx operand
;19694	;					src2.rx operand
;19695	;		dest queue	=	none
;19696	;		branch queue	=	none
;19697	;		field queue	=	none
;19698	;		DL		=	QUAD
;19699	;		Ibox state	=	running
;19700	;		Mbox state	=	running
;19701	;
;19702	;	Exit conditions:
;19703	;		The PSL condition codes are set.
;19704	;
;19705	;	Condition codes:
;19706	;		N <-- dst LSS 0
;19707	;		Z <-- dst EQL 0
;19708	;		V <-- 0 		[Integer overflow trap disabled.]
;19709	;		C <-- 0
;19710
				;19711	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  578
;    FPOINT.MIC 	     CMPD, CMPG 									      /REV=
;															     FPOINT
				;19712
				;19713	FBOX.4.SL.ND..:
				;19714		;********** Hardware Dispatch **********;
			    p574;19715		FBOX OPERAND A[S1] B[S2], LEN(DL),	; send operands to F-box
E 1B4  1002,404C,0080,01B2 J 1B2;19716		GOTO [FBOX.2.SL.ND..]			; send the 2nd pair
				;19717
				;19718
				;19719	;= END FPOINT
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  579
;    VECTOR.MIC 	     VECTOR.MIC -- VAX Vector Instructions						      /REV=
;
				;19720	.TOC	"VECTOR.MIC -- VAX Vector Instructions"
				;19721	.TOC	"Revision 1.0"
				;19722
				;19723	;	Mike Uhler
				;19724
;19725	.nobin
;19726	;****************************************************************************
;19727	;*									    *
;19728	;*  COPYRIGHT (c) 1988, 1989, 1990, 1991, 1992 BY			    *
;19729	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;19730	;*  ALL RIGHTS RESERVED.						    *
;19731	;*									    *
;19732	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;19733	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;19734	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;19735	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;19736	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;19737	;*  TRANSFERRED.							    *
;19738	;*									    *
;19739	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;19740	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;19741	;*  CORPORATION.							    *
;19742	;*									    *
;19743	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;19744	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;19745	;*									    *
;19746	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  580
;    VECTOR.MIC 	     Revision History									      /REV=
;
;19747	.TOC	"	Revision History"
;19748
;19749	; Edit	  Date	 Who	     Description
;19750	; ---- --------- ---	---------------------
;19751	; (1)0 01-Aug-90 GMU	Initial production microcode.
;19752	;
;19753	; Begin version 1.0 here
;19754	;    4 31-JUL-90 GMU	Add stubbed entry points for the NVAX+ vector
;19755	;			instruction breakout.
;19756	;    3 22-Mar-90 DGM	Update comments
;19757	;    2 03-Feb-90 GMU	Note simultaneous reference restrictions.
;19758	;    1 02-Jan-90 GMU	Add RESERVED INSTRUCTION FAULT macros at all entry points.
;19759	; (0)0 10-May-88 GMU	Trial microcode.
;19760
				;19761	.bin
				;19762	;= BEGIN VECTOR
;19763	.nobin
;19764
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  581
;    VECTOR.MIC 	     Revision History									      /REV=
;															     VECTOR
;19765
;19766	;	This module implements the VAX vector instruction class.
;19767	;	The instructions in this class are:
;19768	;
;19769	;	Opcode	 Instruction							N Z V C 	Exceptions
;19770	;	------	 -----------							------- 	----------
;19771	;
;19772	;	31FD	 MFVP regnum.rw, dst.wl 					- - - - 	vec
;19773	;	A9FD	 MTVP regnum.rw, src.rl 					- - - - 	vec
;19774	;	A8FD	 VSYNC regnum.rw						- - - - 	vec
;19775	;
;19776	;	34FD	 VLDL cntrl.rw, base.ab, stride.rl				- - - - 	vec
;19777	;	36FD	 VLDQ cntrl.rw, base.ab, stride.rl				- - - - 	vec
;19778	;	9CFD	 VSTL cntrl.rw, base.ab, stride.rl				- - - - 	vec
;19779	;	9EFD	 VSTQ cntrl.rw, base.ab, stride.rl				- - - - 	vec
;19780	;
;19781	;	35FD	 VGATHL cntrl.rw, base.ab					- - - - 	vec
;19782	;	37FD	 VGATHQ cntrl.rw, base.ab					- - - - 	vec
;19783	;	9DFD	 VSCATL cntrl.rw, base.ab					- - - - 	vec
;19784	;	9FFD	 VSCATQ cntrl.rw, base.ab					- - - - 	vec
;19785	;
;19786	;	EDFD	 IOTA	cntrl.rw, scal.rl					- - - - 	vec
;19787	;	85FD	 VSADDF cntrl.rw, scal.rl					- - - - 	vec
;19788	;	81FD	 VSADDL cntrl.rw, scal.rl					- - - - 	vec
;19789	;	CDFD	 VSBICL cntrl.rw, scal.rl					- - - - 	vec
;19790	;	C9FD	 VSBISL cntrl.rw, scal.rl					- - - - 	vec
;19791	;	C5FD	 VSCMPF cntrl.rw, scal.rl					- - - - 	vec
;19792	;	C1FD	 VSCMPL cntrl.rw, scal.rl					- - - - 	vec
;19793	;	ADFD	 VSDIVF cntrl.rw, scal.rl					- - - - 	vec
;19794	;	A5FD	 VSMULF cntrl.rw, scal.rl					- - - - 	vec
;19795	;	A1FD	 VSMULL cntrl.rw, scal.rl					- - - - 	vec
;19796	;	E5FD	 VSSLLL cntrl.rw, scal.rl					- - - - 	vec
;19797	;	E1FD	 VSSRLL cntrl.rw, scal.rl					- - - - 	vec
;19798	;	89FD	 VSSUBL cntrl.rw, scal.rl					- - - - 	vec
;19799	;	E9FD	 VSXORL cntrl.rw, scal.rl					- - - - 	vec
;19800	;	8DFD	 VSSUBF cntrl.rw, scal.rl					- - - - 	vec
;19801	;
;19802	;	87FD	 VSADDD cntrl.rw, scal.rq					- - - - 	vec
;19803	;	83FD	 VSADDG cntrl.rw, scal.rq					- - - - 	vec
;19804	;	C7FD	 VSCMPD cntrl.rw, scal.rq					- - - - 	vec
;19805	;	C3FD	 VSCMPG cntrl.rw, scal.rq					- - - - 	vec
;19806	;	AFFD	 VSDIVD cntrl.rw, scal.rq					- - - - 	vec
;19807	;	ABFD	 VSDIVG cntrl.rw, scal.rq					- - - - 	vec
;19808	;	EFFD	 VSMERGE cntrl.rw, scal.rq					- - - - 	vec
;19809	;	A7FD	 VSMULD cntrl.rw, scal.rq					- - - - 	vec
;19810	;	A3FD	 VSMULG cntrl.rw, scal.rq					- - - - 	vec
;19811	;	8FFD	 VSSUBD cntrl.rw, scal.rq					- - - - 	vec
;19812	;	8BFD	 VSSUBG cntrl.rw, scal.rq					- - - - 	vec
;19813	;
;19814	;	86FD	 VVADDD cntrl.rw						- - - - 	vec
;19815	;	84FD	 VVADDF cntrl.rw						- - - - 	vec
;19816	;	82FD	 VVADDG cntrl.rw						- - - - 	vec
;19817	;	80FD	 VVADDL cntrl.rw						- - - - 	vec
;19818	;	CCFD	 VVBICL cntrl.rw						- - - - 	vec
;19819	;	C8FD	 VVBISL cntrl.rw						- - - - 	vec
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  582
;    VECTOR.MIC 	     Revision History									      /REV=
;															     VECTOR
;19820	;	C4FD	 VVCMPF cntrl.rw						- - - - 	vec
;19821	;	C6FD	 VVCMPD cntrl.rw						- - - - 	vec
;19822	;	C2FD	 VVCMPG cntrl.rw						- - - - 	vec
;19823	;	C0FD	 VVCMPL cntrl.rw						- - - - 	vec
;19824	;	ECFD	 VVCVT cntrl.rw 						- - - - 	vec
;19825	;	ACFD	 VVDIVF cntrl.rw						- - - - 	vec
;19826	;	AEFD	 VVDIVD cntrl.rw						- - - - 	vec
;19827	;	AAFD	 VVDIVG cntrl.rw						- - - - 	vec
;19828	;	EEFD	 VVMERGE cntrl.rw						- - - - 	vec
;19829	;	A4FD	 VVMULF cntrl.rw						- - - - 	vec
;19830	;	A6FD	 VVMULD cntrl.rw						- - - - 	vec
;19831	;	A2FD	 VVMULG cntrl.rw						- - - - 	vec
;19832	;	A0FD	 VVMULL cntrl.rw						- - - - 	vec
;19833	;	E4FD	 VVSLLL cntrl.rw						- - - - 	vec
;19834	;	E0FD	 VVSRLL cntrl.rw						- - - - 	vec
;19835	;	8CFD	 VVSUBF cntrl.rw						- - - - 	vec
;19836	;	8EFD	 VVSUBD cntrl.rw						- - - - 	vec
;19837	;	8AFD	 VVSUBG cntrl.rw						- - - - 	vec
;19838	;	88FD	 VVSUBL cntrl.rw						- - - - 	vec
;19839	;	E8FD	 VVXORL cntrl.rw						- - - - 	vec
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  583
;    VECTOR.MIC 	     Revision History									      /REV=
;															     VECTOR
;19840
;19841	;					CAUTION
;19842	;					-------
;19843	;
;19844	;	Ebox microcode for any instruction whose IROM entry contains a .ax or
;19845	;	.vx specifier followed immediately by a .rx, .mx, or .vx specifier may not
;19846	;	reference the source queue entries for this pair of specifiers in the
;19847	;	same microinstruction.	This restriction is necessary to avoid getting
;19848	;	the incorrect operand data for the second specifier of the pair if the
;19849	;	first specifier of the pair is auto-increment, auto-decrement, or auto-increment
;19850	;	deferred, and the second specifier of the pair is register mode using the
;19851	;	same register specified for the first specifier of the pair.  Because the Ibox
;19852	;	must write both the address operand to the MD, and the auto-inc/dec value
;19853	;	to the GPR, the Ebox may read the old value of the GPR if both specifiers
;19854	;	are referenced in the same microword.  In addition, a simultaneous reference
;19855	;	to these specifiers may cause an infinite Ibox RXS stall if the source
;19856	;	queue retire for the second GPR specifier arrives at the Ibox before
;19857	;	the scoreboard is incremented.
;19858	;
;19859	;	This restriction does not apply if, by context, it is known that the
;19860	;	second specifier of the pair is not register mode.
;19861	;
;19862	;	Several of the instructions processed by this module are affected by this
;19863	;	restriction.  The following table lists the restriction for each instruction using
;19864	;	the notation [spec n; spec n+1] to denote a restriction in referencing the
;19865	;	source queue entries for these two specifiers in the same microinstruction.
;19866	;
;19867	;	Entry Point   Opcode   Mnemonic 		   Restriction
;19868	;	-----------   ------   -------- 	----------------------------------
;19869	;	VLDX..	       34FD	VLDL		[spec 2; spec 3]
;19870	;		       36FD	VLDQ		[spec 2; spec 3]
;19871	;	VSTX..	       9CFD	VSTL		[spec 2; spec 3]
;19872	;		       9EFD	VSTQ		[spec 2; spec 3]
;19873	;	Others					none
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  584
;    VECTOR.MIC 	     Revision History									      /REV=
;															     VECTOR
;19874
;19875	;	Overview Of Vector Instruction Execution
;19876	;	-------- -- ------ ----------- ---------
;19877
;19878	;	VAX vector instructions are executed with the cooperation of the scalar CPU and the
;19879	;	vector pipelines.  The scalar CPU is responsible for parsing the vector instruction
;19880	;	specifiers, processing certain vector instructions, notably the memory reference
;19881	;	instructions, and passing control information to the vector pipelines.
;19882	;
;19883	;	There are two bits of state on the microtest bus (VECTOR decode) which control
;19884	;	the operation of vector instructions.  The first bit indicates that the vector unit is
;19885	;	present (i.e., physically there), the second indicates that the vector unit is enabled
;19886	;	(i.e., not disabled due to an exception or error).  The vector-unit-present bit is
;19887	;	cleared by the hardware on powerup, and set by the console if the vector unit is present.
;19888	;	The vector-unit-enabled bit is driven to the appropriate state by the vector controller.
;19889	;
;19890	;	Vector instruction specifier parsing is done in the same manner as for all instructions,
;19891	;	with the operands pointed to by the source list.  There are 14 entry points to the
;19892	;	vector instruction execution flows, which process the instruction as appropriate.
;19893	;	Checks for vector unit not present and vector unit disable are done by microcode
;19894	;	in the execution flow with the appropriate case on the VECTOR decode on the microtest
;19895	;	bus.
;19896	;
;19897	;	The current version of the chip does not support vector instruction issue.  As
;19898	;	a result, all vector instruction entry points cause a reserved instruction fault.
;19899
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  585
;    VECTOR.MIC 	     Vector Load Instructions								      /REV=
;															     VECTOR
;19900	.TOC	"	Vector Load Instructions"
;19901
;19902
;19903	;	These instruction load a vector register from memory.
;19904	;
;19905	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19906	;	--------      ------	---------				----	-----		--------
;19907	;	VLDL		34FD	load longword vector into register	 3	rar/wbl 	VLDX..
;19908	;	VLDQ		36FD	load quadword vector into register	 3	rar/wbl 	VLDX..
;19909	;
;19910	;	Entry conditions:
;19911	;		source queue	=	control.rw operand
;19912	;					base.ab operand
;19913	;					stride.rl operand
;19914	;		dest queue	=	none
;19915	;		branch queue	=	none
;19916	;		field queue	=	none
;19917	;		DL		=	LONG (VLDL) or QUAD (VLDQ)
;19918	;		Ibox state	=	running
;19919	;		Mbox state	=	running
;19920	;
;19921	;	Exit conditions:
;19922	;		Vector operation complete.
;19923	;
;19924	;	Condition codes:
;19925	;		N <-- N
;19926	;		Z <-- N
;19927	;		V <-- V 			[Integer overflow trap cannot occur.]
;19928	;		C <-- C
;19929	;
;19930	;	Size/performance tradeoffs:
;19931	;		1. The Mbox is running for this instruction even though the Ebox
;19932	;		   will make explicit memory reference instructions.  This is allowed
;19933	;		   (and even encouraged) by the vector architecture because there is
;19934	;		   no implicit synchronization between scalar and vector memory
;19935	;		   references in the absense of MSYNC.	Allowing the Mbox to continue
;19936	;		   enables it to fetch scalar operands in parallel with vector
;19937	;		   memory reference instructions.  Note that there is a small verification
;19938	;		   risk in that these are the only instructions which allow the
;19939	;		   Mbox to proceed in the presence of explicit Ebox memory references.
;19940
				;19941	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  586
;    VECTOR.MIC 	     Vector Load Instructions								      /REV=
;															     VECTOR
				;19942
				;19943	;	CAUTION: Do not change the order of reference to the
				;19944	;	source queue in the entry point below without
				;19945	;	reading the explanation at the beginning of this module.
				;19946	;
				;19947	;	The following simultaneous reference restriction exists for
				;19948	;	this entry point: [spec 2; spec 3].
				;19949
				;19950	VLDX..:
			    p126;19951		;********** Hardware Dispatch **********;
E 1C0  0000,0000,2000,0100 J 100;19952		RESERVED INSTRUCTION FAULT
				;19953
;19954	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  587
;    VECTOR.MIC 	     Vector Store Instructions								      /REV=
;															     VECTOR
;19955	.TOC	"	Vector Store Instructions"
;19956
;19957
;19958	;	These instruction store a vector vegister to memory.
;19959	;
;19960	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;19961	;	--------      ------	---------				----	-----		--------
;19962	;	VSTL		9CFD	store longword vector from register	 3	rar/wbl 	VSTX..
;19963	;	VSTQ		9EFD	store quadword vector from register	 3	rar/wbl 	VSTX..
;19964	;
;19965	;	Entry conditions:
;19966	;		source queue	=	control.rw operand
;19967	;					base.ab operand
;19968	;					stride.rl operand
;19969	;		dest queue	=	none
;19970	;		branch queue	=	none
;19971	;		field queue	=	none
;19972	;		DL		=	LONG (VSTL) or QUAD (VSTQ)
;19973	;		Ibox state	=	running
;19974	;		Mbox state	=	running
;19975	;
;19976	;	Exit conditions:
;19977	;		Vector operation complete.
;19978	;
;19979	;	Condition codes:
;19980	;		N <-- N
;19981	;		Z <-- N
;19982	;		V <-- V 			[Integer overflow trap cannot occur.]
;19983	;		C <-- C
;19984	;
;19985	;	Size/performance tradeoffs:
;19986	;		1. The Mbox is running for this instruction even though the Ebox
;19987	;		   will make explicit memory reference instructions.  This is allowed
;19988	;		   (and even encouraged) by the vector architecture because there is
;19989	;		   no implicit synchronization between scalar and vector memory
;19990	;		   references in the absense of MSYNC.	Allowing the Mbox to continue
;19991	;		   enables it to fetch scalar operands in parallel with vector
;19992	;		   memory reference instructions.  Note that there is a small verification
;19993	;		   risk in that these are the only instructions which allow the
;19994	;		   Mbox to proceed in the presence of explicit Ebox memory references.
;19995
				;19996	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  588
;    VECTOR.MIC 	     Vector Store Instructions								      /REV=
;															     VECTOR
				;19997
				;19998	;	CAUTION: Do not change the order of reference to the
				;19999	;	source queue in the entry point below without
				;20000	;	reading the explanation at the beginning of this module.
				;20001	;
				;20002	;	The following simultaneous reference restriction exists for
				;20003	;	this entry point: [spec 2; spec 3].
				;20004
				;20005	VSTX..:
			    p126;20006		;********** Hardware Dispatch **********;
E 1C4  0000,0000,2000,0100 J 100;20007		RESERVED INSTRUCTION FAULT
				;20008
;20009	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  589
;    VECTOR.MIC 	     Vector Gather Instructions 							      /REV=
;															     VECTOR
;20010	.TOC	"	Vector Gather Instructions"
;20011
;20012
;20013	;	These instructions gather a vector register from memory.
;20014	;
;20015	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20016	;	--------      ------	---------				----	-----		--------
;20017	;	VGATHL		35FD	gather longword vector into register	 2	ra/wb		VGATHX..
;20018	;	VGATHQ		37FD	gather quadword vector into register	 2	ra/wb		VGATHX..
;20019	;
;20020	;	Entry conditions:
;20021	;		source queue	=	control.rw operand
;20022	;					base.ab operand
;20023	;		dest queue	=	none
;20024	;		branch queue	=	none
;20025	;		field queue	=	none
;20026	;		DL		=	LONG (VGATHL) or QUAD (VGATHQ)
;20027	;		Ibox state	=	running
;20028	;		Mbox state	=	running
;20029	;
;20030	;	Exit conditions:
;20031	;		Vector operation completed.
;20032	;
;20033	;	Condition codes:
;20034	;		N <-- N
;20035	;		Z <-- N
;20036	;		V <-- V 			[Integer overflow trap cannot occur.]
;20037	;		C <-- C
;20038	;
;20039	;	Size/performance tradeoffs:
;20040	;		1. The Mbox is running for this instruction even though the Ebox
;20041	;		   will make explicit memory reference instructions.  This is allowed
;20042	;		   (and even encouraged) by the vector architecture because there is
;20043	;		   no implicit synchronization between scalar and vector memory
;20044	;		   references in the absense of MSYNC.	Allowing the Mbox to continue
;20045	;		   enables it to fetch scalar operands in parallel with vector
;20046	;		   memory reference instructions.  Note that there is a small verification
;20047	;		   risk in that these are the only instructions which allow the
;20048	;		   Mbox to proceed in the presence of explicit Ebox memory references.
;20049
				;20050	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  590
;    VECTOR.MIC 	     Vector Gather Instructions 							      /REV=
;															     VECTOR
				;20051
				;20052	VGATHX..:
			    p126;20053		;********** Hardware Dispatch **********;
E 1C8  0000,0000,2000,0100 J 100;20054		RESERVED INSTRUCTION FAULT
				;20055
;20056	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  591
;    VECTOR.MIC 	     Vector Scatter Instructions							      /REV=
;															     VECTOR
;20057	.TOC	"	Vector Scatter Instructions"
;20058
;20059
;20060	;	These instructions scatter a vector register to memory.
;20061	;
;20062	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20063	;	--------      ------	---------				----	-----		--------
;20064	;	VSCATL		9DFD	scatter longword vector into register	 2	ra/wb		VSCATX..
;20065	;	VSCATQ		9FFD	scatter quadword vector into register	 2	ra/wb		VSCATX..
;20066	;
;20067	;	Entry conditions:
;20068	;		source queue	=	control.rw operand
;20069	;					base.ab operand
;20070	;		dest queue	=	none
;20071	;		branch queue	=	none
;20072	;		field queue	=	none
;20073	;		DL		=	LONG (VSCATL) or QUAD (VSCATQ)
;20074	;		Ibox state	=	running
;20075	;		Mbox state	=	running
;20076	;
;20077	;	Exit conditions:
;20078	;		Vector operation completed.
;20079	;
;20080	;	Condition codes:
;20081	;		N <-- N
;20082	;		Z <-- N
;20083	;		V <-- V 			[Integer overflow trap cannot occur.]
;20084	;		C <-- C
;20085	;
;20086	;	Size/performance tradeoffs:
;20087	;		1. The Mbox is running for this instruction even though the Ebox
;20088	;		   will make explicit memory reference instructions.  This is allowed
;20089	;		   (and even encouraged) by the vector architecture because there is
;20090	;		   no implicit synchronization between scalar and vector memory
;20091	;		   references in the absense of MSYNC.	Allowing the Mbox to continue
;20092	;		   enables it to fetch scalar operands in parallel with vector
;20093	;		   memory reference instructions.  Note that there is a small verification
;20094	;		   risk in that these are the only instructions which allow the
;20095	;		   Mbox to proceed in the presence of explicit Ebox memory references.
;20096
				;20097	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  592
;    VECTOR.MIC 	     Vector Scatter Instructions							      /REV=
;															     VECTOR
				;20098
				;20099	VSCATX..:
			    p126;20100		;********** Hardware Dispatch **********;
E 1CC  0000,0000,2000,0100 J 100;20101		RESERVED INSTRUCTION FAULT
				;20102
;20103	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  593
;    VECTOR.MIC 	     MFVP										      /REV=
;															     VECTOR
;20104	.TOC	"	MFVP"
;20105
;20106
;20107	;	This instruction reads a vector register and stores it to GPR or memory.
;20108	;
;20109	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20110	;	--------      ------	---------				----	-----		--------
;20111	;	MFVP		31FD	dst.wl <-- vector register		 2	rw/wl		MFVP..
;20112	;
;20113	;	Entry conditions:
;20114	;		source queue	=	regnum.rw operand
;20115	;		dest queue	=	dst.wl operand
;20116	;		branch queue	=	none
;20117	;		field queue	=	none
;20118	;		DL		=	LONG
;20119	;		Ibox state	=	running
;20120	;		Mbox state	=	stopped
;20121	;
;20122	;	Exit conditions:
;20123	;		Vector register stored in the specified memory location or GPR.
;20124	;
;20125	;	Condition codes:
;20126	;		N <-- N
;20127	;		Z <-- N
;20128	;		V <-- V 			[Integer overflow trap cannot occur.]
;20129	;		C <-- C
;20130	;
;20131	;	Size/performance tradeoffs:
;20132	;		None.
;20133	;
;20134	;	Notes:
;20135	;		1. The Mbox must be stopped for this instruction because one of the
;20136	;		   operations performed by MFVP is MSYNC, which synchronizes scalar
;20137	;		   and vector memory references.
;20138
				;20139	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  594
;    VECTOR.MIC 	     MFVP										      /REV=
;															     VECTOR
				;20140
				;20141
				;20142	MFVP..:
			    p126;20143		;********** Hardware Dispatch **********;
E 1D0  0000,0000,2000,0100 J 100;20144		RESERVED INSTRUCTION FAULT
				;20145
;20146	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  595
;    VECTOR.MIC 	     MTVP										      /REV=
;															     VECTOR
;20147	.TOC	"	MTVP"
;20148
;20149	;	This instruction writes a vector register.
;20150	;
;20151	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20152	;	--------      ------	---------				----	-----		--------
;20153	;	MTVP		A9FD	vector register <-- src.rl		 2	rr/wl		MTVP..
;20154	;
;20155	;	Entry conditions:
;20156	;		source queue	=	regnum.rw operand
;20157	;		dest queue	=	dst.wl operand
;20158	;		branch queue	=	none
;20159	;		field queue	=	none
;20160	;		DL		=	LONG
;20161	;		Ibox state	=	running
;20162	;		Mbox state	=	running
;20163	;
;20164	;	Exit conditions:
;20165	;		The specified vector register is written.
;20166	;
;20167	;	Condition codes:
;20168	;		N <-- N
;20169	;		Z <-- N
;20170	;		V <-- V 			[Integer overflow trap cannot occur.]
;20171	;		C <-- C
;20172	;
;20173	;	Size/performance tradeoffs:
;20174	;		None.
;20175
				;20176	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  596
;    VECTOR.MIC 	     MTVP										      /REV=
;															     VECTOR
				;20177
				;20178
				;20179	MTVP..:
			    p126;20180		;********** Hardware Dispatch **********;
E 1D4  0000,0000,2000,0100 J 100;20181		RESERVED INSTRUCTION FAULT
				;20182
;20183	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  597
;    VECTOR.MIC 	     VSYNC										      /REV=
;															     VECTOR
;20184	.TOC	"	VSYNC"
;20185
;20186
;20187	;	This instruction performs memory synchronization between the
;20188	;	vector unit and itself.
;20189	;
;20190	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20191	;	--------      ------	---------				----	-----		--------
;20192	;	VSYNC		A8FD	synchronize vector memory access	 1	 r/w		VSYNC..
;20193	;
;20194	;	Entry conditions:
;20195	;		source queue	=	regnum.rw operand
;20196	;		dest queue	=	none
;20197	;		branch queue	=	none
;20198	;		field queue	=	none
;20199	;		DL		=	WORD
;20200	;		Ibox state	=	running
;20201	;		Mbox state	=	running
;20202	;
;20203	;	Exit conditions:
;20204	;		Operation completed.
;20205	;
;20206	;	Condition codes:
;20207	;		N <-- N
;20208	;		Z <-- N
;20209	;		V <-- V 			[Integer overflow trap cannot occur.]
;20210	;		C <-- C
;20211	;
;20212	;	Size/performance tradeoffs:
;20213	;		None.
;20214
				;20215	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  598
;    VECTOR.MIC 	     VSYNC										      /REV=
;															     VECTOR
				;20216
				;20217	VSYNC..:
			    p126;20218		;********** Hardware Dispatch **********;
E 1D8  0000,0000,2000,0100 J 100;20219		RESERVED INSTRUCTION FAULT
				;20220
;20221	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  599
;    VECTOR.MIC 	     Vector - Vector Operate Instructions						      /REV=
;															     VECTOR
;20222	.TOC	"	Vector - Vector Operate Instructions"
;20223
;20224
;20225	;	These instructions perform an operation with two vectors.
;20226	;
;20227	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20228	;	--------      ------	---------				----	-----		--------
;20229	;	VVADDL		80FD	vector - vector longword add		 1	 r/w		VVOPX..
;20230	;	VVADDG		82FD	vector - vector G-floating add		 1	 r/w		VVOPX..
;20231	;	VVADDF		84FD	vector - vector F-floating add		 1	 r/w		VVOPX..
;20232	;	VVADDD		86FD	vector - vector D-floating add		 1	 r/w		VVOPX..
;20233	;	VVSUBL		88FD	vector - vector longword subtract	 1	 r/w		VVOPX..
;20234	;	VVSUBG		8AFD	vector - vector G-floating subtract	 1	 r/w		VVOPX..
;20235	;	VVSUBF		8CFD	vector - vector F-floating subtract	 1	 r/w		VVOPX..
;20236	;	VVSUBD		8EFD	vector - vector D-floating subtract	 1	 r/w		VVOPX..
;20237	;
;20238	;	VVMULL		A0FD	vector - vector longword multiply	 1	 r/w		VVOPX..
;20239	;	VVMULG		A2FD	vector - vector G-floating multiply	 1	 r/w		VVOPX..
;20240	;	VVMULF		A4FD	vector - vector F-floating multiply	 1	 r/w		VVOPX..
;20241	;	VVMULD		A6FD	vector - vector D-floating multiply	 1	 r/w		VVOPX..
;20242	;	VVDIVG		AAFD	vector - vector G-floating divide	 1	 r/w		VVOPX..
;20243	;	VVDIVF		ACFD	vector - vector F-floating divide	 1	 r/w		VVOPX..
;20244	;	VVDIVD		AEFD	vector - vector D-floating divide	 1	 r/w		VVOPX..
;20245	;
;20246	;	VVBISL		C8FD	vector - vector longword bit set	 1	 r/w		VVOPX..
;20247	;	VVBICL		CCFD	vector - vector longword bit clear	 1	 r/w		VVOPX..
;20248	;
;20249	;	VVSRLL		E0FD	vector - vector longword shift right	 1	 r/w		VVOPX..
;20250	;	VVSLLL		E4FD	vector - vector longword shift left	 1	 r/w		VVOPX..
;20251	;	VVXORL		E8FD	vector - vector longword exclusive OR	 1	 r/w		VVOPX..
;20252	;	VVCVT		ECFD	vector convert				 1	 r/w		VVOPX..
;20253	;	VVMERGE 	EEFD	vector - vector merge			 1	 r/w		VVOPX..
;20254
;20255	;
;20256	;	Entry conditions:
;20257	;		source queue	=	control.rw operand
;20258	;		dest queue	=	none
;20259	;		branch queue	=	none
;20260	;		field queue	=	none
;20261	;		DL		=	WORD
;20262	;		Ibox state	=	running
;20263	;		Mbox state	=	running
;20264	;
;20265	;	Exit conditions:
;20266	;		Vector operation started.
;20267	;
;20268	;	Condition codes:
;20269	;		N <-- N
;20270	;		Z <-- N
;20271	;		V <-- V 			[Integer overflow trap cannot occur.]
;20272	;		C <-- C
;20273	;
;20274	;	Size/performance tradeoffs:
;20275	;		None.
;20276
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  600
;    VECTOR.MIC 	     Vector - Vector Operate Instructions						      /REV=
;															     VECTOR
				;20277	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  601
;    VECTOR.MIC 	     Vector - Vector Operate Instructions						      /REV=
;															     VECTOR
				;20278
				;20279	VVOPX..:
			    p126;20280		;********** Hardware Dispatch **********;
E 1E0  0000,0000,2000,0100 J 100;20281		RESERVED INSTRUCTION FAULT
				;20282
;20283	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  602
;    VECTOR.MIC 	     Longword Vector - Scalar Operate Instructions					      /REV=
;															     VECTOR
;20284	.TOC	"	Longword Vector - Scalar Operate Instructions"
;20285
;20286
;20287	;	These instructions perform a longword-length operation with a scalar and a vector.
;20288	;
;20289	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20290	;	--------      ------	---------				----	-----		--------
;20291	;	VSADDL		81FD	vector - scalar longword add		 2	rr/wl		VSOPL..
;20292	;	VSADDF		85FD	vector - scalar F-floating add		 2	rr/wl		VSOPL..
;20293	;	VSSUBL		89FD	vector - scalar longword subtract	 2	rr/wl		VSOPL..
;20294	;	VSSUBF		8DFD	vector - scalar F-floating subtract	 2	rr/wl		VSOPL..
;20295	;	VSMULL		A1FD	vector - scalar longword multiply	 2	rr/wl		VSOPL..
;20296	;	VSMULF		A5FD	vector - scalar F-floating multiply	 2	rr/wl		VSOPL..
;20297	;	VSDIVF		ADFD	vector - scalar F-floating divide	 2	rr/wl		VSOPL..
;20298	;	VSBISL		C9FD	vector - scalar longword bit set	 2	rr/wl		VSOPL..
;20299	;	VSBICL		CDFD	vector - scalar longword bit clear	 2	rr/wl		VSOPL..
;20300	;	VSSRLL		E1FD	vector - scalar longword shift right	 2	rr/wl		VSOPL..
;20301	;	VSSLLL		E5FD	vector - scalar longword shift left	 2	rr/wl		VSOPL..
;20302	;	VSXORL		E9FD	vector - scalar longword exclusive or	 2	rr/wl		VSOPL..
;20303	;
;20304	;	Entry conditions:
;20305	;		source queue	=	control.rw operand
;20306	;					scalar.rl operand
;20307	;		dest queue	=	none
;20308	;		branch queue	=	none
;20309	;		field queue	=	none
;20310	;		DL		=	LONG
;20311	;		Ibox state	=	running
;20312	;		Mbox state	=	running
;20313	;
;20314	;	Exit conditions:
;20315	;		Vector operation started.
;20316	;
;20317	;	Condition codes:
;20318	;		N <-- N
;20319	;		Z <-- N
;20320	;		V <-- V 			[Integer overflow trap cannot occur.]
;20321	;		C <-- C
;20322	;
;20323	;	Size/performance tradeoffs:
;20324	;		None.
;20325
				;20326	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  603
;    VECTOR.MIC 	     Longword Vector - Scalar Operate Instructions					      /REV=
;															     VECTOR
				;20327
				;20328	VSOPL..:
			    p126;20329		;********** Hardware Dispatch **********;
E 1E8  0000,0000,2000,0100 J 100;20330		RESERVED INSTRUCTION FAULT
				;20331
;20332	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  604
;    VECTOR.MIC 	     Quadword Vector - Scalar Operate Instructions					      /REV=
;															     VECTOR
;20333	.TOC	"	Quadword Vector - Scalar Operate Instructions"
;20334
;20335
;20336	;	These instructions perform a quadword-length operation with a scalar and a vector.
;20337	;
;20338	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20339	;	--------      ------	---------				----	-----		--------
;20340	;	VSADDG		83FD	vector - scalar G-floating add		 2	rr/wq		VSOPQ..
;20341	;	VSADDD		87FD	vector - scalar D-floating add		 2	rr/wq		VSOPQ..
;20342	;	VSSUBG		8BFD	vector - scalar G-floating subtract	 2	rr/wq		VSOPQ..
;20343	;	VSSUBD		8FFD	vector - scalar D-floating subtract	 2	rr/wq		VSOPQ..
;20344	;	VSMULG		A3FD	vector - scalar G-floating multiply	 2	rr/wq		VSOPQ..
;20345	;	VSMULD		A7FD	vector - scalar D-floating multiply	 2	rr/wq		VSOPQ..
;20346	;	VSDIVG		ABFD	vector - scalar G-floating divide	 2	rr/wq		VSOPQ..
;20347	;	VSDIVD		AFFD	vector - scalar D-floating divide	 2	rr/wq		VSOPQ..
;20348	;	VSMERGE 	EFFD	vector - scalar merge			 2	rr/wq		VSOPQ..
;20349	;
;20350	;	Entry conditions:
;20351	;		source queue	=	control.rw operand
;20352	;					scalar.rq operand
;20353	;		dest queue	=	none
;20354	;		branch queue	=	none
;20355	;		field queue	=	none
;20356	;		DL		=	QUAD
;20357	;		Ibox state	=	running
;20358	;		Mbox state	=	running
;20359	;
;20360	;	Exit conditions:
;20361	;		Vector operation started.
;20362	;
;20363	;	Condition codes:
;20364	;		N <-- N
;20365	;		Z <-- N
;20366	;		V <-- V 			[Integer overflow trap cannot occur.]
;20367	;		C <-- C
;20368	;
;20369	;	Size/performance tradeoffs:
;20370	;		None.
;20371
				;20372	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  605
;    VECTOR.MIC 	     Quadword Vector - Scalar Operate Instructions					      /REV=
;															     VECTOR
				;20373
				;20374	VSOPQ..:
			    p126;20375		;********** Hardware Dispatch **********;
E 1F0  0000,0000,2000,0100 J 100;20376		RESERVED INSTRUCTION FAULT
				;20377
;20378	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  606
;    VECTOR.MIC 	     Vector - Vector Compare Instructions						      /REV=
;															     VECTOR
;20379	.TOC	"	Vector - Vector Compare Instructions"
;20380
;20381
;20382	;	These instructions compare two vectors.
;20383	;
;20384	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20385	;	--------      ------	---------				----	-----		--------
;20386	;	VVCMPL		C0FD	vector - vector longword compare	 1	 r/w		VVCMPX..
;20387	;	VVCMPG		C2FD	vector - vector G-floating compare	 1	 r/w		VVCMPX..
;20388	;	VVCMPF		C4FD	vector - vector F-floating compare	 1	 r/w		VVCMPX..
;20389	;	VVCMPD		C6FD	vector - vector D-floating compare	 1	 r/w		VVCMPX..
;20390	;
;20391	;	Entry conditions:
;20392	;		source queue	=	control.rw operand
;20393	;		dest queue	=	none
;20394	;		branch queue	=	none
;20395	;		field queue	=	none
;20396	;		DL		=	WORD
;20397	;		Ibox state	=	running
;20398	;		Mbox state	=	running
;20399	;
;20400	;	Exit conditions:
;20401	;		Vector operation completed.
;20402	;
;20403	;	Condition codes:
;20404	;		N <-- N
;20405	;		Z <-- N
;20406	;		V <-- V 			[Integer overflow trap cannot occur.]
;20407	;		C <-- C
;20408	;
;20409	;	Size/performance tradeoffs:
;20410	;		None.
;20411
				;20412	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  607
;    VECTOR.MIC 	     Vector - Vector Compare Instructions						      /REV=
;															     VECTOR
				;20413
				;20414	VVCMPX..:
			    p126;20415		;********** Hardware Dispatch **********;
E 1E4  0000,0000,2000,0100 J 100;20416		RESERVED INSTRUCTION FAULT
				;20417
;20418	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  608
;    VECTOR.MIC 	     Longword Vector - Scalar Compare Instructions					      /REV=
;															     VECTOR
;20419	.TOC	"	Longword Vector - Scalar Compare Instructions"
;20420
;20421
;20422	;	These instructions compare a longword-length scalar and a vector.
;20423	;
;20424	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20425	;	--------      ------	---------				----	-----		--------
;20426	;	VSCMPL		C1FD	vector - scalar longword compare	 2	rr/wl		VSCMPL..
;20427	;	VSCMPF		C5FD	vector - scalar F-floating compare	 2	rr/wl		VSCMPL..
;20428	;
;20429	;	Entry conditions:
;20430	;		source queue	=	control.rw operand
;20431	;					scalar.rl operand
;20432	;		dest queue	=	none
;20433	;		branch queue	=	none
;20434	;		field queue	=	none
;20435	;		DL		=	LONG
;20436	;		Ibox state	=	running
;20437	;		Mbox state	=	running
;20438	;
;20439	;	Exit conditions:
;20440	;		Vector operation completed.
;20441	;
;20442	;	Condition codes:
;20443	;		N <-- N
;20444	;		Z <-- N
;20445	;		V <-- V 			[Integer overflow trap cannot occur.]
;20446	;		C <-- C
;20447	;
;20448	;	Size/performance tradeoffs:
;20449	;		None.
;20450
				;20451	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  609
;    VECTOR.MIC 	     Longword Vector - Scalar Compare Instructions					      /REV=
;															     VECTOR
				;20452
				;20453	VSCMPL..:
			    p126;20454		;********** Hardware Dispatch **********;
E 1EC  0000,0000,2000,0100 J 100;20455		RESERVED INSTRUCTION FAULT
				;20456
;20457	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  610
;    VECTOR.MIC 	     Quadword Vector - Scalar Compare Instructions					      /REV=
;															     VECTOR
;20458	.TOC	"	Quadword Vector - Scalar Compare Instructions"
;20459
;20460
;20461	;	These instructions compare a quadword-length scalar and a vector.
;20462	;
;20463	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20464	;	--------      ------	---------				----	-----		--------
;20465	;	VSCMPG		C3FD	vector - scalar G-floating compare	 2	rr/wq		VSCMPQ..
;20466	;	VSCMPD		C7FD	vector - scalar D-floating compare	 2	rr/wq		VSCMPQ..
;20467	;
;20468	;	Entry conditions:
;20469	;		source queue	=	control.rw operand
;20470	;					scalar.rq operand
;20471	;		dest queue	=	none
;20472	;		branch queue	=	none
;20473	;		field queue	=	none
;20474	;		DL		=	QUAD
;20475	;		Ibox state	=	running
;20476	;		Mbox state	=	running
;20477	;
;20478	;	Exit conditions:
;20479	;		Vector operation completed.
;20480	;
;20481	;	Condition codes:
;20482	;		N <-- N
;20483	;		Z <-- N
;20484	;		V <-- V 			[Integer overflow trap cannot occur.]
;20485	;		C <-- C
;20486	;
;20487	;	Size/performance tradeoffs:
;20488	;		None.
;20489
				;20490	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  611
;    VECTOR.MIC 	     Quadword Vector - Scalar Compare Instructions					      /REV=
;															     VECTOR
				;20491
				;20492	VSCMPQ..:
			    p126;20493		;********** Hardware Dispatch **********;
E 1F4  0000,0000,2000,0100 J 100;20494		RESERVED INSTRUCTION FAULT
				;20495
;20496	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  612
;    VECTOR.MIC 	     IOTA										      /REV=
;															     VECTOR
;20497	.TOC	"	IOTA"
;20498
;20499
;20500	;	This instruction generates a compressed IOTA vector.
;20501	;
;20502	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20503	;	--------      ------	---------				----	-----		--------
;20504	;	IOTA		EDFD	generate compressed iota vector 	 2	rr/wl		IOTA..
;20505	;
;20506	;	Entry conditions:
;20507	;		source queue	=	control.rw operand
;20508	;					scalar.rl operand
;20509	;		dest queue	=	none
;20510	;		branch queue	=	none
;20511	;		field queue	=	none
;20512	;		DL		=	LONG
;20513	;		Ibox state	=	running
;20514	;		Mbox state	=	running
;20515	;
;20516	;	Exit conditions:
;20517	;		Vector operation completed.
;20518	;
;20519	;	Condition codes:
;20520	;		N <-- N
;20521	;		Z <-- N
;20522	;		V <-- V 			[Integer overflow trap cannot occur.]
;20523	;		C <-- C
;20524	;
;20525	;	Size/performance tradeoffs:
;20526	;		None.
;20527
				;20528	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  613
;    VECTOR.MIC 	     IOTA										      /REV=
;															     VECTOR
				;20529
				;20530	IOTA..:
			    p126;20531		;********** Hardware Dispatch **********;
E 1DC  0000,0000,2000,0100 J 100;20532		RESERVED INSTRUCTION FAULT
				;20533
				;20534	;= END VECTOR
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  614
;   EMULATE.MIC 	     EMULATE.MIC -- Emulation Support							      /REV=
;
				;20535	.TOC	"EMULATE.MIC -- Emulation Support"
				;20536	.TOC	"Revision 1.1"
				;20537
				;20538	;	Bob Supnik, Mike Uhler
				;20539
;20540	.nobin
;20541	;****************************************************************************
;20542	;*									    *
;20543	;*  COPYRIGHT (c) 1987, 1988, 1989, 1990, 1991, 1992 BY 		    *
;20544	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;20545	;*  ALL RIGHTS RESERVED.						    *
;20546	;*									    *
;20547	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;20548	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;20549	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;20550	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;20551	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;20552	;*  TRANSFERRED.							    *
;20553	;*									    *
;20554	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;20555	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;20556	;*  CORPORATION.							    *
;20557	;*									    *
;20558	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;20559	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;20560	;*									    *
;20561	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  615
;   EMULATE.MIC 	     Revision History									      /REV=
;
;20562	.TOC	"	Revision History"
;20563
;20564	; Edit	  Date	 Who	     Description
;20565	; ---- --------- ---	---------------------
;20566	;    1 28-Jan-91 GMU	Symptom: Ibox CSU deadlock can occur if the field
;20567	;				 queue is referenced before all source queue
;20568	;				 entries corresponding to earlier specifiers
;20569	;				 are referenced.
;20570	;			Cure:	 Modify the CVTPL.. entry point to remove
;20571	;				 the first two source queue entries before
;20572	;				 casing on the field queue.  To avoid changing
;20573	;				 the IROM also, the original field queue
;20574	;				 entry point constraints remain in ALIGN.MIC,
;20575	;				 but are no longer used.
;20576	; (1)0 22-Jul-90 GMU	Initial production microcode.
;20577	;
;20578	; Begin version 1.0 here
;20579	;   13 21-Jul-90 GMU	Update with Bob's review comments.
;20580	;   12 30-Apr-90 GMU	Sync with Mbox after LOAD PC.
;20581	;   11 26-Apr-90 GMU	Convert '*' fill constraints to 'x' constraints.
;20582	;   10 26-Mar-90 DGM	Remove redundant clearing of STATE.3-0 and optimize
;20583	;			three specifier flow
;20584	;    9 02-Feb-90 GMU	Modify EMULATE.4.. entry flow to avoid referencing
;20585	;			.ax and .rx specifiers in the same microinstruction.
;20586	;    8 16-Jan-90 DGM	Change field queue alignment
;20587	;    7 17-Nov-89 GMU	Convert LOAD NEW PC macro to LOAD PC.
;20588	;    6 07-Nov-89 GMU	Complete RESET CPU interface.
;20589	;    5 03-Nov-89 GMU	Move of edit 4.
;20590	;    4 29-Sep-89 GMU	Fix FPD restart of emulated instructions.
;20591	;    3 24-Sep-89 GMU	Fix non-CVTPL instructions broken by edit 2.
;20592	;    2 17-Aug-89 GMU	Add field queue for CVTPL entry point.
;20593	;    1 12-Sep-88 GMU	Add sim emulate macros.
;20594	; (0)0 09-Sep-87 RMS	Trial microcode.
;20595
				;20596	.bin
				;20597	;= BEGIN EMULATE
;20598	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  616
;   EMULATE.MIC 	     Revision History									      /REV=
;															    EMULATE
;20599
;20600	;	This module provides emulation support for the emulated string and decimal instruction class.
;20601	;	The instructions in this class are:
;20602	;
;20603	;	Opcode	Instruction							N Z V C 	Exceptions
;20604	;	------	-----------							------- 	----------
;20605	;
;20606	;	20	ADDP4  addlen.rw, addaddr.ab, sumlen.rw, sumaddr.ab		* * * 0 	rsv, dov
;20607	;	21	ADDP6  add1len.rw, add1addr.ab, add2len.rw, add2addr.ab,	* * * 0 	rsv, dov
;20608	;		       sumlen.rw, sumaddr.ab
;20609	;
;20610	;	F8	ASHP   cnt.rb, srclen.rw, srcaddr.ab, round.rb, 		* * * 0 	rsv, dov
;20611	;		       dstlen.rw, dstaddr.ab
;20612	;
;20613	;	35	CMPP3  len.rw, src1addr.ab, src2addr.ab 			* * 0 0
;20614	;	37	CMPP4  src1len.rw, src1addr.ab, src2len.rw, src2addr.ab 	* * 0 0
;20615	;
;20616	;	0B	CRC    tbl.ab, inicrc.rl, strlen.rw, stream.ab			* * 0 0
;20617	;
;20618	;	F9	CVTLP  src.rl, dstlen.rw, dstaddr.ab				* * * 0 	rsv, dov
;20619	;	36	CVTPL  srclen.rw, srcaddr.ab, dst.wl				* * * 0 	rsv, iov
;20620	;	08	CVTPS  srclen.rw, srcaddr.ab, dstlen.rw, dstaddr.ab		* * * 0 	rsv, dov
;20621	;	24	CVTPT  srclen.rw, srcaddr.ab, tbladdr.ab,			* * * 0 	rsv, dov
;20622	;		       dstlen.rw, dstaddr.ab
;20623	;	09	CVTSP  srclen.rw, srcaddr.ab, dstlen.rw, dstaddr.ab		* * * 0 	rsv, dov
;20624	;	26	CVTTP  srclen.rw, srcaddr.ab, tbladdr.ab,			* * * 0 	rsv, dov
;20625	;		       dstlen.rw, dstaddr.ab
;20626	;
;20627	;	27	DIVP   divrlen.rw, divraddr.ab, divdlen.rw, divdaddr.ab,	* * * 0 	rsv, dov, ddvz
;20628	;		       quolen.rw, quoaddr.ab
;20629	;
;20630	;	38	EDITPC srclen.rw, srcaddr.ab, pattern.ab, dstaddr.ab		* * * * 	rsv, dov
;20631	;
;20632	;	39	MATCHC objlen.rw, objaddr.ab, srclen.rw, srcaddr.ab		0 * 0 0
;20633	;
;20634	;	34	MOVP   len.rw, srcaddr.ab, dstaddr.ab				* * 0 0
;20635	;
;20636	;	2E	MOVTC  srclen.rw, srcaddr.ab, fill.rb, tbladdr.ab,		* * 0 *
;20637	;		       dstlen.rw, dstaddr.ab
;20638	;	2F	MOVTUC srclen.rw, srcaddr.ab, esc.rb, tbladdr.ab,		* * * *
;20639	;		       dstlen.rw, dstaddr.ab
;20640	;
;20641	;	25	MULP   mulrlen.rw, mulraddr.ab, muldlen.rw, muldaddr.ab,	* * * 0 	rsv, dov
;20642	;		       prodlen.rw, prodaddr.ab
;20643	;
;20644	;	22	SUBP4  sublen.rw, subaddr.ab, diflen.rw, difaddr.ab		* * * 0 	rsv, dov
;20645	;	23	SUBP6  sublen.rw, subaddr.ab, minlen.rw, minaddr.ab,		* * * 0 	rsv, dov
;20646	;		       diflen.rw, difaddr.ab
;20647	;
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  617
;   EMULATE.MIC 	     Revision History									      /REV=
;															    EMULATE
;20648
;20649	;					CAUTION
;20650	;					-------
;20651	;
;20652	;	Ebox microcode for any instruction whose IROM entry contains a .ax or
;20653	;	.vx specifier followed immediately by a .rx, .mx, or .vx specifier may not
;20654	;	reference the source queue entries for this pair of specifiers in the
;20655	;	same microinstruction.	This restriction is necessary to avoid getting
;20656	;	the incorrect operand data for the second specifier of the pair if the
;20657	;	first specifier of the pair is auto-increment, auto-decrement, or auto-increment
;20658	;	deferred, and the second specifier of the pair is register mode using the
;20659	;	same register specified for the first specifier of the pair.  Because the Ibox
;20660	;	must write both the address operand to the MD, and the auto-inc/dec value
;20661	;	to the GPR, the Ebox may read the old value of the GPR if both specifiers
;20662	;	are referenced in the same microword.  In addition, a simultaneous reference
;20663	;	to these specifiers may cause an infinite Ibox RXS stall if the source
;20664	;	queue retire for the second GPR specifier arrives at the Ibox before
;20665	;	the scoreboard is incremented.
;20666	;
;20667	;	This restriction does not apply if, by context, it is known that the
;20668	;	second specifier of the pair is not register mode.
;20669	;
;20670	;	A number of instructions processed by this module are affected by this
;20671	;	restriction.  The following table lists the restriction for each instruction using
;20672	;	the notation [spec n; spec n+1] to denote a restriction in referencing the
;20673	;	source queue entries for these two specifiers in the same microinstruction.
;20674	;
;20675	;	Entry Point   Opcode   Mnemonic 		   Restriction
;20676	;	-----------   ------   -------- 	----------------------------------
;20677	;	EMULATE.3.CVTPL.M..
;20678	;			34	MOVP		none
;20679	;			35	CMPP3		none
;20680	;			F9	CVTLP		none
;20681	;
;20682	;	EMULATE.4..	08	CVTPS		[spec 2; spec 3]
;20683	;			09	CVTSP		[spec 2; spec 3]
;20684	;			0B	CRC		[spec 1; spec 2]
;20685	;			20	ADDP4		[spec 2; spec 3]
;20686	;			22	SUBP4		[spec 2; spec 3]
;20687	;			37	CMPP4		[spec 2; spec 3]
;20688	;			38	EDITPC		none
;20689	;			39	MATCHC		[spec 2; spec 3]
;20690	;
;20691	;	EMULATE.5..	24	CVTPT		[spec 3; spec 4]
;20692	;			26	CVTTP		[spec 3; spec 4]
;20693	;
;20694	;	EMULATE.6..	21	ADDP6		[spec 2; spec 3], [spec 4; spec 5]
;20695	;			23	SUBP6		[spec 2; spec 3], [spec 4; spec 5]
;20696	;			25	MULP		[spec 2; spec 3], [spec 4; spec 5]
;20697	;			27	DIVP		[spec 2; spec 3], [spec 4; spec 5]
;20698	;			2E	MOVTC		[spec 2; spec 3], [spec 4; spec 5]
;20699	;			2F	MOVTUC		[spec 2; spec 3], [spec 4; spec 5]
;20700	;			F8	ASHP		[spec 3; spec 4]
;20701	;
;20702	;	CVTPL.. 	36	CVTPL		[spec 2; spec 3]
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  618
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
;20703	.TOC	"	Normal Emulation (FPD Clear)"
;20704
;20705	;	These instructions invoke an emulated instruction exception.
;20706	;
;20707	;	Mnemonic      Opcode	Operation				Spec	AT/DL		Dispatch
;20708	;	--------      ------	---------				----	-----		--------
;20709	;	MOVP		34	push operands, emulate exception	3	raa/wbb 	EMULATE.3.CVTPL.M..
;20710	;	CMPP3		35	push operands, emulate exception	3	raa/wbb 	EMULATE.3.CVTPL.M..
;20711	;	CVTLP		F9	push operands, emulate exception	3	rra/lwb 	EMULATE.3.CVTPL.M..
;20712	;
;20713	;	CVTPL		36	push operands, emulate exception	3	rav/wbl 	CVTPL..
;20714	;
;20715	;	CVTPS		08	push operands, emulate exception	4	rara/wbwb	EMULATE.4..
;20716	;	CVTSP		09	push operands, emulate exception	4	rara/wbwb	EMULATE.4..
;20717	;	CRC		0B	push operands, emulate exception	4	arra/blwb	EMULATE.4..
;20718	;	ADDP4		20	push operands, emulate exception	4	rara/wbwb	EMULATE.4..
;20719	;	SUBP4		22	push operands, emulate exception	4	rara/wbwb	EMULATE.4..
;20720	;	CMPP4		37	push operands, emulate exception	4	rara/wbwb	EMULATE.4..
;20721	;	EDITPC		38	push operands, emulate exception	4	raaa/wbbb	EMULATE.4..
;20722	;	MATCHC		39	push operands, emulate exception	4	rara/wbwb	EMULATE.4..
;20723	;
;20724	;	CVTPT		24	push operands, emulate exception	5	raara/wbbwb	EMULATE.5..
;20725	;	CVTTP		26	push operands, emulate exception	5	raara/wbbwb	EMULATE.5..
;20726	;
;20727	;	ADDP6		21	push operands, emulate exception	6	rarara/wbwbwb	EMULATE.6..
;20728	;	SUBP6		23	push operands, emulate exception	6	rarara/wbwbwb	EMULATE.6..
;20729	;	MULP		25	push operands, emulate exception	6	rarara/wbwbwb	EMULATE.6..
;20730	;	DIVP		27	push operands, emulate exception	6	rarara/wbwbwb	EMULATE.6..
;20731	;	MOVTC		2E	push operands, emulate exception	6	rarara/wbbbwb	EMULATE.6..
;20732	;	MOVTUC		2F	push operands, emulate exception	6	rarara/wbbbwb	EMULATE.6..
;20733	;	ASHP		F8	push operands, emulate exception	6	rrarra/bwbbwb	EMULATE.6..
;20734	;
;20735	;	Entry conditions:
;20736	;		source queue	=	3 to 6 operands, depending on instruction
;20737	;					(implicit specifier) current PC
;20738	;		dest queue	=	none
;20739	;		branch queue	=	none
;20740	;		field queue	=	none
;20741	;		DL		=	LONG for CVTPL, BYTE for all others
;20742	;		Ibox state	=	stopped
;20743	;		Mbox state	=	running
;20744	;
;20745	;	Exit conditions:
;20746	;		The emulation stack frame is built.
;20747	;		The PC and PSL are set up for an emulation trap.
;20748	;
;20749	;	Condition codes:
;20750	;		N <-- 0
;20751	;		Z <-- 0
;20752	;		V <-- 0
;20753	;		C <-- 0
;20754	;
;20755	;	Notes:
;20756	;		1.  Memory management:	The source list is emptied (except for the implicit current
;20757	;		    PC specifier, which cannot fault) before E-box I/O is started.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  619
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
;20758	;		2.  Memory management:	The initial probes guarantee the accessibility of the stack.
;20759	;		3.  Memory management:	The last write is to a known accessible location and thus
;20760	;		    guarantees that all memory management errors are made visible prior to instruction
;20761	;		    completion.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  620
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
;20762
;20763	;	If FPD is clear, the emulation process consists of three steps:
;20764	;
;20765	;	1)  Parse the operand specifiers.
;20766	;	2)  Build the specifier stack frame.
;20767	;	3)  Take a same mode exception to the normal emulation exception handler.
;20768	;
;20769	;	In greater detail:
;20770	;
;20771	;	1)  Parse the operand specifiers.  The operand specifiers are parsed and
;20772	;	    addressed indirectly through the source queue.
;20773	;
;20774	;	2)  Build the specifier stack frame.  The specifier stack frame is 12
;20775	;	    longwords, as follows:
;20776	;
;20777	;	 3
;20778	;	 1							       0
;20779	;	+---------------------------------------------------------------+
;20780	;	|			    opcode				|	: SP - 48
;20781	;	+---------------------------------------------------------------+
;20782	;	|			    old PC				|	: SP - 44
;20783	;	+---------------------------------------------------------------+
;20784	;	|			  argument #1				|	: SP - 40
;20785	;	+---------------------------------------------------------------+
;20786	;	|			  argument #2				|	: SP - 36
;20787	;	+---------------------------------------------------------------+
;20788	;	|			  argument #3				|	: SP - 32
;20789	;	+---------------------------------------------------------------+
;20790	;	|			  argument #4				|	: SP - 28
;20791	;	+---------------------------------------------------------------+
;20792	;	|			  argument #5				|	: SP - 24
;20793	;	+---------------------------------------------------------------+
;20794	;	|			  argument #6				|	: SP - 20
;20795	;	+---------------------------------------------------------------+
;20796	;	|			  argument #7				|	: SP - 16
;20797	;	+---------------------------------------------------------------+
;20798	;	|			  argument #8				|	: SP - 12
;20799	;	+---------------------------------------------------------------+
;20800	;	|			    new PC				|	: SP - 8
;20801	;	+---------------------------------------------------------------+
;20802	;	|			   saved PSL				|	: SP - 4
;20803	;	+---------------------------------------------------------------+
;20804	;
;20805	;	3)  Take a same mode exception through the emulated instruction vector.
;20806	;	    This involves clearing PSL<tp,fpd,dv,fu,iv,t,cc> and vectoring through
;20807	;	    the specified location in the SCB.
;20808	;
;20809
				;20810	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  621
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;20811
				;20812	;	CAUTION: Do not change the order of reference to the
				;20813	;	source queue in any of the entry points below without
				;20814	;	reading the explanation at the beginning of this module.
				;20815
				;20816	;	Four operand instructions.
				;20817	;	The following simultaneous reference restrictions exist for this entry
				;20818	;	point: [spec 1; spec 2], [spec 2; spec 3].
				;20819
				;20820	EMULATE.4..:
				;20821		;********** Hardware dispatch **********;
				;20822		[W0] <-- [S1], LONG,			; get first operand
E 1B8  0000,0000,0488,8396 J 396;20823		STATE.0 <-- 1				; flag number of operands
				;20824							; >> no [spec 1; spec 2] reference
				;20825
				;20826		;---------------------------------------;
			    p622;20827		Q <-- PASSA [S1], LONG, 		; get second operand
E 396  0002,4000,2080,25B3 S 5B3;20828		CALL [EMULATE.FETCH.3]			; get third operand
				;20829							; >> no [spec 2; spec 3] reference
				;20830
				;20831	EMULATE.456:
				;20832		;---------------------------------------;
			    p626;20833		[W4] <-- [S1], LONG,			; get next operand
E 397  0000,0000,1480,0279 J 279;20834		GOTO [EMULATE.NORMAL]			; start emulation exception
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  622
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;20835
				;20836	;	Five operand instructions.
				;20837	;	The following simultaneous reference restriction exists for this entry
				;20838	;	point: [spec 3; spec 4].
				;20839
				;20840	EMULATE.5..:
				;20841		;********** Hardware dispatch **********;
				;20842		[W0] <-- [S1], LONG,			; get first operand
				;20843		Q <-- PASSB [S2],			; get second operand
E 1BA  0002,8048,0480,25B3 S 5B3;20844		CALL [EMULATE.FETCH.3]			; get third operand
				;20845							; >> no [spec 3; spec 4] reference
				;20846
				;20847	EMULATE.56:
				;20848		;---------------------------------------;
				;20849		[W3] <-- [S1], LONG,			; get next operand
			    p621;20850		STATE.1 <-- 1,				; flag number of operands
E 1BB  0000,0000,1089,0397 J 397;20851		GOTO [EMULATE.456]			; fetch remaining operands
				;20852
				;20853	;	Six operand instructions.
				;20854	;	The following simultaneous reference restrictions exist for this entry
				;20855	;	point: [spec 2; spec 3], [spec 3; spec 4, [spec 4; spec 5].
				;20856
				;20857	EMULATE.6..:
				;20858		;********** Hardware dispatch **********;
				;20859		[W0] <-- [S1], LONG,			; get first operand
				;20860		Q <-- PASSB [S2],			; get second operand
E 1BC  0002,8048,0480,25B3 S 5B3;20861		CALL [EMULATE.FETCH.3]			; get third operand
				;20862							; >> no [spec 2; spec 3] reference
				;20863							; >> no [spec 3; spec 4] reference
				;20864		;---------------------------------------;
				;20865		[W2] <-- [S1], LONG,			; get fourth operand
				;20866		STATE.0 <-- 1,				; flag number of operands
E 1BD  0000,0000,0C88,81BB J 1BB;20867		GOTO [EMULATE.56]			; fetch remaining operands
				;20868							; >> no [spec 4; spec 5] reference
				;20869	;	Subroutine to fetch specifier to W1.
				;20870
				;20871	EMULATE.FETCH.3:
				;20872		;---------------------------------------;
				;20873		[W1] <-- [S1], LONG,			; fetch third specifier to W1
E 5B3  0000,0000,0880,0800 R	;20874		RETURN					; return to caller
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  623
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;20875
				;20876	;	CAUTION: Do not change the order of reference to the
				;20877	;	source queue in any of the entry points below without
				;20878	;	reading the explanation at the beginning of this module.
				;20879	;
				;20880	;	Note: In pass 1 microcode, the entry point for the normal 3-specifier
				;20881	;	emulated instructions is the same as the memory case target for
				;20882	;	CVTPL (this was done in ALIGN.MIC).  In pass 2 microcode the field
				;20883	;	queue case is moved into the CVTPL instruction itself and so the CVTPL
				;20884	;	memory case is not shared with the other 3-specifier emulated
				;20885	;	instructions.  To avoid having to change the IROM, the original
				;20886	;	field queue constraint was not removed from ALIGN.MIC.
				;20887	;
				;20888	;	CVTPL instruction.
				;20889	;	The following simultaneous reference restriction exists for this entry
				;20890	;	point: [spec 2; spec 3].
				;20891
				;20892	CVTPL..:
				;20893		;********** Hardware dispatch **********; obsolete fq.vr constraint in ALIGN.MIC
				;20894		[W0] <-- [S1], LONG,			; get first operand
E 27E  0002,8048,0480,05FE J 5FE;20895		Q <-- PASSB [S2]			; get second operand
				;20896							; >> no [spec 2; spec 3] reference
				;20897
				;20898	;= ALIGNLIST 100x	(CVTPL.MEM,		CVTPL.RMODE,
				;20899	;=					,	CVTPL.INVALID)
				;20900
				;20901	CVTPL.INVALID:
				;20902		;---------------------------------------; fq.vr = 11 (invalid)
E 5FE  4000,0000,2000,52F8 B 5F8;20903		CASE [FQ.VR] AT [CVTPL.MEM]		; wait for field queue to
				;20904							; indicate register or memory
				;20905
				;20906	CVTPL.MEM:
				;20907		;---------------------------------------; fq.vr = 00 (valid, memory)
			    p626;20908		[W1] <-- [S1], LONG,			; fetch third specifier to W1
E 5F8  0000,0000,0880,0279 J 279;20909		GOTO [EMULATE.NORMAL]			; join normal emulation flows
				;20910
				;20911	;	CVTPL register destination.
				;20912
				;20913	CVTPL.RMODE:
				;20914		;---------------------------------------; fq.vr = 01 (valid, register)
				;20915		ACCESS A [S1],				; discard third operand
E 5FA  0001,DC7A,0880,027A J 27A;20916		[W1] <-- ZEXT [RN.MODE.OPCODE] RSH [28.], LONG	; right justify register number
				;20917
				;20918	CVTPL.R:					; dummy label for ALIGN.MIC
				;20919		;---------------------------------------; obsolete fq.vr constraint in ALIGN.MIC
			    p626;20920		[W1] <-- NOT [W1], LONG,		; one's complement register number
E 27A  0D80,0010,0800,0279 J 279;20921		GOTO [EMULATE.NORMAL]			; join normal emulation flows
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  624
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;20922
				;20923	;	Three-operand instructions other than CVTPL.
				;20924	;	Despite the name of the entry point, CVTPL no longer flows through
				;20925	;	this microword.  See the explanation at the CVTPL.. entry point.
				;20926	;	There are no simultaneous reference restrictions for this entry point.
				;20927
				;20928	EMULATE.3.CVTPL.M..:
				;20929		;********** Hardware dispatch **********;  obsolete fq.vr constraint in ALIGN.MIC
				;20930		[W0] <-- [S1], LONG,			; get first operand
			    p622;20931		Q <-- PASSB [S2],			; get second operand
E 278  0002,8048,0480,25B3 S 5B3;20932		CALL [EMULATE.FETCH.3]			; get third operand
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  625
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;20933
;20934	.nobin
;20935
;20936	;	The specifiers have been parsed and are stored in the working registers.
;20937	;	This routine builds the emulator stack frame and executes the emulator exception process.
;20938	;
;20939	;	Depending on the number of operands, he specifiers are stored in the working registers as follows:
;20940	;
;20941	;			3 spec		4 spec		5 spec		6 spec
;20942	;			------		------		------		------
;20943	;	operand #1	W0		W0		W0		W0
;20944	;	operand #2	Q		Q		Q		Q
;20945	;	operand #3	W1		W1		W1		W1
;20946	;	operand #4	na		W4		W3		W2
;20947	;	operand #5	na		na		W4		W3
;20948	;	operand #6	na		na		na		W4
;20949	;	STATE<1:0>	00		01		10		11
;20950	;
;20951	;	The detailed steps are as follows:
;20952	;
;20953	;	1)  Probe the stack for writeability.
;20954	;	2)  Write out the arguments and stack top.
;20955	;	3)  Write out the stack base (PSL, PC).
;20956	;	4)  Fetch the SCB exception vector.
;20957	;	5)  Update PSL, PC and exit.
;20958	;
				;20959	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  626
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;20960
				;20961	;	Normal emulation exception.
				;20962	;	Operands parsed.  Validate stack, push PC, PSL, first three operands.
				;20963
				;20964	;	At this point,
				;20965	;		W0, Q, W1..W4 = specifiers 1..6
				;20966	;		STATE<1:0> =	number of specifiers - 3
				;20967
				;20968	EMULATE.NORMAL:
				;20969		;---------------------------------------;
				;20970		VA <-- K10.[IPR.BPC],			; read backup PC
				;20971		[W5] <-- MEM.PR (VA), LONG,		; into E-box
				;20972			sim addr [k],
E 279  00D4,3AC1,1801,05B4 J 5B4;20973			sim emulate
				;20974
				;20975		;---------------------------------------;
				;20976		WCHK (VA)&, VA <-- [SP] - 4, LONG,	; write check SP - 4
				;20977		[SAVEPSL] <-- ZEXT [RN.MODE.OPCODE] RSH [16.], ; save opcode for later
E 5B4  0CE1,D07B,A5E0,05B5 J 5B5;20978			sim addr [sp]
				;20979
				;20980		;---------------------------------------;
				;20981		VA <-- [SP] - 000000[48.], LONG,	; calc last entry on stack
E 5B5  0A80,2181,21E0,05B6 J 5B6;20982			sim addr [sp] - k
				;20983
				;20984		;---------------------------------------;
				;20985		MEM (VA)&, [WBUS] <-- [SAVEPSL] AND 000000[0FF], ; mask opcode to byte
E 5B6  0464,27F8,2290,05B9 J 5B9;20986		LONG					; write to stack
				;20987
				;20988		;---------------------------------------;
				;20989		VA <-- [VA] + 4,			; calc next stack address
E 5B9  0C64,8033,20B0,05BB J 5BB;20990		MEM (VA)&, [WBUS] <-- PASSB [W5], LONG	; write old PC to stack
				;20991							; >> sync with Ibox IPR read
				;20992
				;20993		;---------------------------------------;
				;20994		VA <-- [VA] + 4,			; calc next stack address
E 5BB  0C64,800B,20B0,05BC J 5BC;20995		MEM (VA)&, [WBUS] <-- PASSB [W0], LONG	; write first operand to stack
				;20996
				;20997		;---------------------------------------;
				;20998		VA <-- [VA] + 4,			; calc next stack address
E 5BC  0C64,8053,20B0,0510 J 510;20999		MEM (VA)&, [WBUS] <-- PASSB [Q], LONG	; write second operand to stack
				;21000
				;21001		;---------------------------------------;
				;21002		VA <-- [VA] + 4,			; calc next stack address
			    p628;21003		MEM (VA)&, [WBUS] <-- PASSB [W1], LONG, ; write third operand to stack
E 510  4C64,8013,20B0,4A39 B 539;21004		CASE [STATE.2-0] AT [EMULATE.WRITE.00]	; case on number of specifiers remaining
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  627
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;21005
				;21006	;	Normal emulation, continued.
				;21007	;	Write last three specifiers to stack, if needed.
				;21008
				;21009	;	At this point,
				;21010	;		W2, W3, W4 =	remaining specifiers
				;21011	;		VA	=	running stack pointer
				;21012
				;21013	;= ALIGNLIST *00x	(EMULATE.WRITE.00,	EMULATE.WRITE.01,
				;21014	;=			 EMULATE.WRITE.10,	EMULATE.WRITE.11)
				;21015	;  STATE<2> = 0 --> STATE<2:0> = 0??
				;21016
				;21017	EMULATE.WRITE.11:
				;21018		;---------------------------------------; state<1:0> = 11:
				;21019		VA <-- [VA] + 4,			; calc next stack address
E 53F  0C64,801B,20B0,053D J 53D;21020		MEM (VA)&, [WBUS] <-- PASSB [W2], LONG	; write next operand to stack
				;21021
				;21022	EMULATE.WRITE.10:
				;21023		;---------------------------------------; state<1:0> = 10:
				;21024		VA <-- [VA] + 4,			; calc next stack address
E 53D  0C64,8023,20B0,053B J 53B;21025		MEM (VA)&, [WBUS] <-- PASSB [W3], LONG	; write next operand to stack
				;21026
				;21027	EMULATE.WRITE.01:
				;21028		;---------------------------------------; state<1:0> = 01:
			    p628;21029		VA <-- [VA] + 4,			; calc next stack address
E 53B  0C64,802B,20B0,0539 J 539;21030		MEM (VA)&, [WBUS] <-- PASSB [W4], LONG	; write sixth operand to stack
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  628
;   EMULATE.MIC 	     Normal Emulation (FPD Clear)							      /REV=
;															    EMULATE
				;21031
				;21032	;	Normal emulation, continued.
				;21033	;	Stack checked, specifiers written.
				;21034	;	Write PC, PSL, read vector, take exception.
				;21035
				;21036	EMULATE.WRITE.00:
				;21037		;---------------------------------------; state<1:0> = 00:
				;21038		VA <-- [SCBB] + 000000[SCB.EMULATE],	; calc address of SCB vector
				;21039		[W1] <-- MEM.SCB (VA), LONG,		; start read of SCB vector
E 539  08D0,2641,0A60,05BD J 5BD;21040			sim addr [scb]
				;21041
				;21042		;---------------------------------------;
				;21043		[W2] <-- [PSL] ANDNOT 000000[0FF],	; clear PSL<dv,fu,iv,t,cc>
				;21044		LONG,					;
E 5BD  0482,67F8,0CC0,05C0 J 5C0;21045		Q <-- PASSA [PSL]			; save PSL
				;21046
				;21047		;---------------------------------------;
				;21048		VA <-- [SP] - 4,			; get SP - 4
				;21049		MEM (VA)&, [WBUS] <-- PASSB [Q], LONG,	; write PSL to stack
E 5C0  0CE4,8053,21E0,03E0 J 3E0;21050			sim addr [sp] - k
				;21051		;---------------------------------------;
				;21052		VA <-- [VA] - 4,			; get SP - 8
				;21053		MEM (VA)&, [WBUS] <-- PASSB [S1], LONG, ; write current PC to stack
E 3E0  0CE4,8043,20B0,25C1 S 5C1;21054		CALL [EMULATE.UPDATE.PC.PSL]		; update PC, PSL
				;21055
				;21056		;---------------------------------------;
			    p481;21057		[SP] <-- [SP] - 000000[48.], LONG,	; update SP
E 3E1  0A80,2180,79E0,0572 J 572;21058		GOTO [SYNC.RESTART.IBOX]		; sync with load PC, restart Ibox
				;21059
				;21060	;	Subroutine to update PC and PSL for emulation.
				;21061
				;21062	EMULATE.UPDATE.PC.PSL:
				;21063		;---------------------------------------;
E 5C1  0480,3A40,3030,05C2 J 5C2;21064		[PSL] <-- [W2] ANDNOT [48]000000, LONG	; clear PSL<tp,fpd>
				;21065							; >> PSL change, no decode for 3 cycles
				;21066
				;21067	WRITE.PC.W1.ALIGNED:
				;21068		;---------------------------------------;
				;21069		[WBUS] <-- [W1] ANDNOT 000000[03], LONG, ; force new PC to be longword aligned
				;21070		LOAD PC,				; load new PC
				;21071							; >> LOAD PC: sync required before exit
E 5C2  04A4,2018,2020,0800 R	;21072		RETURN					; return to caller
				;21073
;21074	.nobin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  629
;   EMULATE.MIC 	     Special Emulation (FPD Set)							      /REV=
;															    EMULATE
;21075	.TOC	"	Special Emulation (FPD Set)"
;21076
;21077	;	These instructions invoke a restarted emulated instruction execption.
;21078	;
;21079	;	If FPD is set, all instruction except MOVC3, MOVC5, CMPC3, CMP5,
;21080	;	LOCC, SKPC, SCANC, SPANC (and a few others) are dispatched to this flow.
;21081	;
;21082	;	Entry conditions:
;21083	;		Reached from FPD flows.
;21084	;		source list	=	\unpredictable\
;21085	;		DL		=	\unpredictable\
;21086	;		W0		=	PSL with bits <7:0> clear
;21087	;		Q		=	PSL
;21088	;		I Box is suspended.
;21089	;
;21090	;	Exit conditions:
;21091	;		The restart emulation stack frame is built.
;21092	;		The PC and PSL are set up for a restarted emulation trap.
;21093	;
;21094	;	Condition codes:
;21095	;
;21096	;		N <-- 0
;21097	;		Z <-- 0
;21098	;		V <-- 0
;21099	;		C <-- 0
;21100	;
;21101	;	Notes:
;21102	;		1.  Memory management:	The initial probe and first write guarantee the accessibility
;21103	;		    of the stack.
;21104	;		2.  Memory management:	The last write is to a known accessible location and thus
;21105	;		    guarantees that all memory management errors are made visible prior to instruction
;21106	;		    completion.
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  630
;   EMULATE.MIC 	     Special Emulation (FPD Set)							      /REV=
;															    EMULATE
;21107
;21108	;	If FPD is set, the emulation process consists of two steps:
;21109	;
;21110	;	1)  Build the exception stack frame.
;21111	;	2)  Take a same mode exception to the special emulation exception handler.
;21112	;
;21113	;	In greater detail:
;21114	;
;21115	;	1)  Build the exception stack frame.  The exception stack frame is 2
;21116	;	    longwords, as follows:
;21117	;
;21118	;	 3
;21119	;	 1							       0
;21120	;	+---------------------------------------------------------------+
;21121	;	|			    old PC				|	: SP - 8
;21122	;	+---------------------------------------------------------------+
;21123	;	|			   saved PSL				|	: SP - 4
;21124	;	+---------------------------------------------------------------+
;21125	;
;21126	;	2)  Take a same mode exception through the FPD emulated instruction vector.
;21127	;	    This involves clearing PSL<tp,fpd,dv,fu,iv,t,cc> and vectoring through the
;21128	;	    specified location in the SCB.
;21129	;
				;21130	.bin
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  631
;   EMULATE.MIC 	     Special Emulation (FPD Set)							      /REV=
;															    EMULATE
				;21131
				;21132	;	Special emulation processor.
				;21133	;	Reached from FPD processor.  Build exception stack frame, process exception.
				;21134
				;21135	;	At this point,
				;21136	;		W2	=	PSL with <7:0> clear
				;21137	;		Q	=	original PSL
				;21138
				;21139	EMULATE.FPD:
				;21140		;---------------------------------------;
				;21141		[W3] <-- [Q],				; move original PSL to W3
				;21142		Q <-- 0,				; no PSL bits to clear
			    p159;21143		RESET CPU,				; abort current operations
E 0F0  0002,C000,10A6,22D7 S 2D7;21144		CALL [IE.CLEANUP.CPU]			; cleanup CPU state,
				;21145							; PSL<TP> unchanged, SAVEPC = BPC
				;21146
				;21147		;---------------------------------------;
				;21148		VA <-- [SCBB] + 000000[SCB.EMULFPD],	; calculate SCB vector address
				;21149		[W1] <-- MEM.SCB (VA), LONG,		; start read of SCB vector
E 0F1  08D0,2661,0A60,05C3 J 5C3;21150			sim addr [scb]
				;21151
				;21152		;---------------------------------------;
E 5C3  0000,0000,0680,05C4 J 5C4;21153		[W0] <-- [SAVEPC], LONG 		; move old PC to W0 for later use
				;21154
				;21155		;---------------------------------------;
				;21156		WCHK (VA)&, VA <-- [SP] - 000000[08.],	; calc, write check SP - 8
				;21157		LONG,					;
E 5C4  0AE0,2041,21E0,05C5 J 5C5;21158			sim addr [sp] - k
				;21159
				;21160		;---------------------------------------;
				;21161		VA <-- [VA] + 4,			; calc SP - 4
E 5C5  0C64,8023,20B0,03E2 J 3E2;21162		MEM (VA)&, [WBUS] <-- PASSB [W3], LONG	; write PSL
				;21163
				;21164		;---------------------------------------;
				;21165		VA <-- [VA] - 4,			; get SP - 8
			    p628;21166		MEM (VA)&, [WBUS] <-- PASSB [W0], LONG, ; write old PC
E 3E2  0CE4,800B,20B0,25C1 S 5C1;21167		CALL [EMULATE.UPDATE.PC.PSL]		; update PC, PSL
				;21168
				;21169		;---------------------------------------;
			    p144;21170		[SP] <-- [SP] - 000000[08.], LONG,	; update SP
E 3E3  0A80,2040,79E0,0271 J 271;21171		GOTO [SYNC.RESTART.IBOX.NO.RETIRE]	; sync with load PC, restart Ibox
				;21172
				;21173	;= END EMULATE
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  632
;   EBMCODE.MIC 	     EBMCODE.MIC -- Behavioral Model Support						      /REV=
;
				;21174	.TOC	"EBMCODE.MIC -- Behavioral Model Support"
				;21175	.TOC	"Revision 1.2"
				;21176
				;21177	;	Shawn Persels
				;21178
;21179	.nobin
;21180	;****************************************************************************
;21181	;*									    *
;21182	;*  COPYRIGHT (c) 1988, 1989, 1990, 1991, 1992 BY			    *
;21183	;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;21184	;*  ALL RIGHTS RESERVED.						    *
;21185	;*									    *
;21186	;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;21187	;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;21188	;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY  OTHER   *
;21189	;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;21190	;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;21191	;*  TRANSFERRED.							    *
;21192	;*									    *
;21193	;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;21194	;*  AND  SHOULD  NOT  BE  CONSTRUED AS	A COMMITMENT BY DIGITAL EQUIPMENT   *
;21195	;*  CORPORATION.							    *
;21196	;*									    *
;21197	;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;21198	;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;21199	;*									    *
;21200	;****************************************************************************
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  633
;   EBMCODE.MIC 	     Revision History									      /REV=
;
;21201	.TOC	"	Revision History"
;21202
;21203
;21204	; Edit	  Date	 Who	     Description
;21205	; ---- --------- ---	---------------------
;21206	;    3 02-Oct-90 DB	Reorder AXE.DONE for chango
;21207	;			Take out change #2
;21208	;    2 11-Sep-90 DB	Change axe.microcode to clear int.sys for chango axe
;21209	;    1 21-Aug-90 DB	Change axe.done for ported model
;21210	; (1)0 24-Jul-90 GMU	Initial production microcode.
;21211	;
;21212	; Begin version 1.0 here
;21213	;    6 30-Jan-90 GMU	Fix duplicate allocation to 7FE.
;21214	;    5 23-Jan-90 DB	Reorder Mbox commands in axe startup code.
;21215	;    4 18-Jan-90 DB	Add RESET CPU to axe startup code.
;21216	;    3 30-Oct-89 DB	Add NOPs to axe windup ucode.
;21217	;    2 12-Oct-89 DB	Axe microcode.
;21218	; (0)1 16-Aug-88 SDP	Trial microcode.
				;21219	.bin
				;21220
				;21221	;= BEGIN BMCODE
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  634
;   EBMCODE.MIC 	     Revision History									      /REV=
;															     BMCODE
				;21222
				;21223
				;21224	;= AT 7FE
				;21225	IDLE..: 					; used by the performance model.
				;21226	SIM.HALT.NOT.POWERUP:
				;21227		;---------------------------------------; 7FE:
				;21228		NOP NODEST,				; No destination
E 7FE  0000,0000,0000,07FE J 7FE;21229		GOTO [SIM.HALT.NOT.POWERUP]		; loop until model is stopped
				;21230
				;21231	;= AT 7F0
				;21232	AXE.MICROCODE:					; This is the axe startup microcode.
				;21233		;---------------------------------------; 7F0:
E 7F0  0000,0000,2000,07FC J 7FC;21234		NOP
				;21235
				;21236	;= AT 7FC
				;21237		;---------------------------------------; 7FC:
E 7FC  0000,0000,2006,07FD J 7FD;21238		RESET CPU				;
				;21239
				;21240	;= AT 7FD
				;21241		;---------------------------------------; 7FD:
E 7FD  0000,0000,2000,07FF J 7FF;21242		NOP
				;21243
				;21244	;= AT 7FF
				;21245		;---------------------------------------; 7FF:
E 7FF  0000,0000,3290,07F1 J 7F1;21246		[PSL] <-- [SAVEPSL], LONG		; Load the PSL
				;21247
				;21248	;= AT 7F1
				;21249		;---------------------------------------; 7F1:
E 7F1  0018,0000,2000,07F2 J 7F2;21250		TB INVALIDATE ALL			; Clear the TB
				;21251
				;21252	;= AT 7F2
				;21253		;---------------------------------------; 7F2:
				;21254		RESTART MBOX,				; Reset Mbox state
				;21255		FLUSH PA QUEUE, 			;
E 7F2  1020,0400,2004,87F3 J 7F3;21256		SYNCHRONIZE MBOX			;
				;21257
				;21258	;= AT 7F3
				;21259		;---------------------------------------; 7F3:
				;21260		[WBUS] <-- [SAVEPC], LONG,		; Load the PC
E 7F3  0024,0000,2280,07F4 J 7F4;21261		LOAD PC
				;21262
				;21263	;= AT 7F4
				;21264		;---------------------------------------; 7F4:
E 7F4  0020,0000,2000,07F5 J 7F5;21265		SYNCHRONIZE MBOX			; Wait for LOAD PC to be seen
				;21266
				;21267	;= AT 7F5
				;21268		;---------------------------------------; 7F5:
				;21269		RESTART IBOX,				; Restart the Ibox & do the AXE case.
E 7F5  1000,0100,2004,1000 L	;21270		LAST CYCLE NO RETIRE
				;21271
				;21272	;= AT 7F6
				;21273	AXE.DONE:					; This is the AXE completion microcode
			    p635;21274		;---------------------------------------; 7F6:
E 7F6  0080,2810,1000,07F7 J 7F7;21275		[W3] <-- 0000[02]00			;
				;21276
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  635
;   EBMCODE.MIC 	     Revision History									      /REV=
;															     BMCODE
				;21277
				;21278	;= AT 7F7
				;21279		;---------------------------------------; 7F7:
				;21280		VA <-- [W3] + 000000[80],		; Address of cctl register
E 7F7  08D4,2401,0440,07F9 J 7F9;21281		[W0] <-- MEM.PR (VA), LONG		; Do the IPR read
				;21282
				;21283	;= AT 7F9
				;21284		;---------------------------------------; 7F9:
E 7F9  0000,0000,0810,07FA J 7FA;21285		[W1] <-- [W0]				; Stall until done, now we know that the
				;21286							; writebuffer is empty.
				;21287
				;21288	;= AT 7FA
				;21289		;---------------------------------------; 7FA:
E 7FA  0000,0000,2000,07FB J 7FB;21290		NOP
				;21291
				;21292	;= AT 7FB
				;21293		;---------------------------------------; 7FB:
E 7FB  0000,0000,2000,07F8 J 7F8;21294		NOP
				;21295
				;21296	;= AT 7F8
				;21297	AXE.LOOP:
				;21298		;---------------------------------------; 7F8:
E 7F8  0000,0000,2000,07F8 J 7F8;21299		GOTO [AXE.LOOP] 			;
				;21300
				;21301	;= END BMCODE
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  636
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	ACBB..			8215 #
	ACBI.GEQ		8224	8235	8246	8256 #
	ACBI.LSS		8265 #
	ACBL..			8237 #
	ACBW..			8226 #
	ADAWI.. 		6031 #
	ADAWI.COMPLETE		6044	6072 #
	ADAWI.M 		6033	6046 #
	ADAWI.NOT.WORD.ALIGNED	6059 #
	ADAWI.R 		6036 #
	ADAWI.WORD.ALIGNED	6055	6063 #
	ADDIN.. 		5731 #
	ADWC			5803	5818 #
	ADWC.C0 		5825 #
	ADWC.C1 		5820	5831 #
	ADWC.SBWC..		5792 #
	AOBLXX..		8152 #
	ASHL..			6299 #
	ASHL.LEFT.0.31		6307	6314 #
	ASHL.LEFT.32.63 	6332 #
	ASHL.LEFT.64.95 	6338 #
	ASHL.LEFT.96.127	6344 #
	ASHL.LEFT.ZERO		6336	6342	6348	6350 #
	ASHL.RIGHT.128.97	6364 #
	ASHL.RIGHT.32.1 	6382 #
	ASHL.RIGHT.64.33	6376 #
	ASHL.RIGHT.96.65	6370 #
	ASHP.CVTLP.FPD		3365 #
	ASHQ..			6425 #
	ASHQ.LEFT.0.31		6434	6442 #
	ASHQ.LEFT.32.63 	6475 #
	ASHQ.LEFT.32.63.NEG	6497 #
	ASHQ.LEFT.32.63.POS	6487	6491 #	6526
	ASHQ.LEFT.64.127	6515	6521	6523 #
	ASHQ.LEFT.64.95 	6511 #
	ASHQ.LEFT.96.127	6517 #
	ASHQ.RIGHT.128.97	6537 #
	ASHQ.RIGHT.32.1 	6569 #
	ASHQ.RIGHT.32.1.NEG	6585 #
	ASHQ.RIGHT.32.1.POS	6574	6578 #
	ASHQ.RIGHT.64.33	6549 #
	ASHQ.RIGHT.96.65	6543 #
	ASHQ.RIGHT.EXIT 	6541	6547	6555 #
	ASHX.RESHIFT		6451	6462 #	6483
	AXE.DONE		21273 #
	AXE.LOOP		21297 # 21299
	AXE.MICROCODE		21232 #
	BBCCI.M.READ		8567 #
	BBSSI.M.READ		8517 #
	BBX..			8354 #

	BBX.GET.SRC.RESTART.MBOX	8363	8386 #	8406	8442

	BBX.M			8356	8466 #

;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  637
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	BBX.MAKE.MASK.WAIT.BDISP	8502	8552	8599	8610 #

	BBX.R			8359 #
	BBX.R.RSRV		8367	8372 #
	BBX.R.TEST		8376 #	8478	8512	8529	8562	8579
	BBX.RDLK.MAKE.MASK	8521	8571	8596 #
	BBXC..			8433 #
	BBXC.M			8435	8537 #
	BBXC.M.READ		8544	8548 #
	BBXC.R			8438 #
	BBXC.R.RSRV		8446	8451 #
	BBXC.R.TEST		8455 #
	BBXS..			8397 #
	BBXS.M			8399	8487 #
	BBXS.M.READ		8494	8498 #
	BBXS.R			8402 #
	BBXS.R.RSRV		8410	8415 #
	BBXS.R.TEST		8419 #
	BICPSW			11224 #
	BICXN.. 		5766 #
	BISPSW			11209	11216 #
	BISXN.. 		5754 #
	BITX..			5641 #
	BIXPSW..		11206 #
	BIXPSW.RSRV		11234 #
	BLBX..			8654 #
	BPT..			10858 #
	BRX..			7824 #
	BSBX..			7885 #
	BXX..			7817 #
	CALLG			10058	10064 #
	CALLG.MASK.000		10067	10090 #
	CALLG.MASK.001		10098 #
	CALLG.MASK.010		10103 #
	CALLG.MASK.011		10112 #
	CALLG.MASK.100		10117 #
	CALLG.MASK.101		10126 #
	CALLG.MASK.110		10131 #
	CALLG.MASK.111		10140 #
	CALLG.WRITE.COND	10095	10109	10123	10137	10223 #
	CALLS			10070 #
	CALLS.MASK.000		10073	10159 #
	CALLS.MASK.001		10167 #
	CALLS.MASK.010		10172 #
	CALLS.MASK.011		10181 #
	CALLS.MASK.100		10186 #
	CALLS.MASK.101		10195 #
	CALLS.MASK.110		10200 #
	CALLS.MASK.111		10209 #
	CALLS.WRITE.COND	10164	10178	10192	10206	10230 #
	CALLX.. 		10038 #
	CALLX.0_6.0		10257	10271 # 10275	10281	10287	10293	10299	10305	10311
	CALLX.0_6.1		10277 #
	CALLX.0_6.2		10283 #
	CALLX.0_6.3		10289 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  638
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	CALLX.0_6.4		10295 #
	CALLX.0_6.5		10301 #
	CALLX.0_6.6		10307 #
	CALLX.0_6.NEXT		10313 #
	CALLX.7_13.10		10349 #
	CALLX.7_13.11		10355 #
	CALLX.7_13.12		10361 #
	CALLX.7_13.7		10317	10331 # 10335	10341	10347	10353	10359
	CALLX.7_13.8		10337 #
	CALLX.7_13.9		10343 #
	CALLX.7_13.G		10387 #
	CALLX.7_13.S		10373 #
	CALLX.PSW.000		10385	10393	10408	10414	10420	10422 #
	CALLX.PSW.001		10404 #
	CALLX.PSW.010		10410 #
	CALLX.PSW.100		10416 #
	CALLX.WRITE.MASK	10227	10234	10237 #
	CASEX.. 		7994 #
	CASEX.IN.RANGE.1	8011	8031 #
	CASEX.IN.RANGE.2	8039 #
	CASEX.IN.RANGE.COMMON	8036	8046 #
	CASEX.OUT.RANGE 	8023 #
	CHM.1ST.PROBE		13281	13329	13336	13343	13350	13367	13374	13381	13388	13405	13412
				13419	13426	13437 #
	CHM.1ST.PROBE.FAIL	13465	13517 #
	CHM.1ST.PROBE.OK	13468 #
	CHM.2ND.PROBE.FAIL	13473	13529 #
	CHM.2ND.PROBE.OK	13486 #
	CHM.FROM.101		13303 #
	CHM.FROM.110		13307 #
	CHM.FROM.111		13311 #
	CHM.FROM.EXEC		13284 #
	CHM.FROM.INT		13299 #
	CHM.FROM.KERNEL 	13239	13246	13253	13260	13274 #
	CHM.FROM.SUPER		13289 #
	CHM.FROM.USER		13294 #
	CHME..			13242 #
	CHME.FROM.EXEC		13332 #
	CHME.FROM.SUPER 	13370 #
	CHME.FROM.USER		13408 #
	CHMK..			13235 #
	CHMK.FROM.EXEC		13287	13325 #
	CHMK.FROM.SUPER 	13292	13363 #
	CHMK.FROM.USER		13297	13401 #
	CHMS..			13249 #
	CHMS.FROM.EXEC		13339 #
	CHMS.FROM.SUPER 	13377 #
	CHMS.FROM.USER		13415 #
	CHMU..			13256 #
	CHMU.FROM.EXEC		13346 #
	CHMU.FROM.SUPER 	13384 #
	CHMU.FROM.USER		13422 #
	CHMX.PROBEX.MM.FAULT	13535	13547 # 14961	15023
	CLR.STATE.3.RESTART.IBOX	18394 # 18646	18686	18844	18881

;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  639
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	CLRQ..			5578 #
	CLRX..			5571 #
	CMPC.PACK		19030 #
	CMPC.UNPACK		19196 #
	CMPC3			18176	18182 #
	CMPC5			18192 #
	CMPCX.. 		18172 #
	CMPCX.CONTINUE		18190	18205	18217 #
	CMPCX.CORRECT.R0	18308	18379 #
	CMPCX.FILL.SRC2.EQL	18451 #
	CMPCX.FILL.SRC2.EXIT	18456 #
	CMPCX.FILL.SRC2.INTERRUPT	18423 #
	CMPCX.FILL.SRC2.LOOP		18415 # 18454
	CMPCX.FILL.SRC2.NEQ		18439	18443 #
	CMPCX.FILL.SRC2.NO.INTERRUPT	18335	18419	18428 #
	CMPCX.SRC1.DONE 		18331 #
	CMPCX.SRC1.FILL.EQL		18388 #
	CMPCX.SRC1.FILL.EXIT		18393 #
	CMPCX.SRC1.FILL.INTERRUPT	18359 #
	CMPCX.SRC1.FILL.LOOP		18244	18326	18351 # 18391
	CMPCX.SRC1.FILL.NEQ		18375	18380 #
	CMPCX.SRC1.FILL.NO.INTERRUPT	18355	18364 #
	CMPCX.SRC1.SRC2.CONTINUE	18313	18318 #
	CMPCX.SRC1.SRC2.EQL		18310 #
	CMPCX.SRC1.SRC2.INTERRUPT	18268 #
	CMPCX.SRC1.SRC2.LOOP		18235	18260 # 18321
	CMPCX.SRC1.SRC2.NEQ		18288	18305 #
	CMPCX.SRC1.SRC2.NO.INTERRUPT	18264	18273 #
	CMPCX.SRC2.DONE 		18323 #
	CMPCX.SRC2.EQL.ZERO		18237 #
	CMPCX.SRC2.NEQ.ZERO		18223	18228 # 19200
	CMPI..				5630 #
	CMPV				7039 #
	CMPXV.0 			7008 #
	CMPXV.COMPARE			7007 #	7042	7047
	CMPZV				7044 #
	CONSOLE.BURN.IN 		2561	2585 #
	CONSOLE.DATA.0.STROBE.0 	2603	2611 #	2615	2621	2676
	CONSOLE.DATA.0.STROBE.1 	2623 #
	CONSOLE.DATA.1.STROBE.0 	2617 #
	CONSOLE.DATA.1.STROBE.1 	2628 #
	CONSOLE.DATA.MERGE		2626	2631	2633 #
	CONSOLE.GET.NEXT.BIT		2637	2652 #
	CONSOLE.LOAD.PC 		2503	2509	2515	2521	2527	2534	2541	2548	2557 #
	CONSOLE.LOAD.PC.CONT		2570 #
	CONSOLE.PSL.000 		2484	2499 #
	CONSOLE.PSL.001 		2505 #
	CONSOLE.PSL.010 		2511 #
	CONSOLE.PSL.011 		2517 #
	CONSOLE.PSL.100 		2523 #
	CONSOLE.PSL.101 		2529 #
	CONSOLE.PSL.110 		2536 #
	CONSOLE.PSL.111 		2543 #
	CONSOLE.STROBE.0		2654	2669	2673 #	2680
	CONSOLE.STROBE.1		2678 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  640
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	CONSOLE.WRITE.CONT	2662	2667 #
	CONSOLE.WRITE.LW	2656 #
	CVTBI.. 		6116 #
	CVTLB			6180	6184 #
	CVTLW.. 		6198 #
	CVTPL.. 		20892 #
	CVTPL.INVALID		20901 #
	CVTPL.MEM		20903	20906 #
	CVTPL.R 		20918 #
	CVTPL.RMODE		20913 #
	CVTWB			6191 #
	CVTWL.. 		6125 #
	CVTXB.. 		6174 #
	CVTXI.COMMON		6188	6195	6208	6211 #
	DECX..			5528 #
	DIVBN.. 		9158 #
	DIVIDE.1.STEP		9855	9857 #
	DIVIDE.15.STEPS 	9219	9840	9842 #
	DIVIDE.3.STEPS		9850	9852 #
	DIVIDE.31.STEPS 	9540	9837 #
	DIVIDE.7.STEPS		9226	9233	9845	9847 #
	DIVIDE.BY.ZERO		9341 #
	DIVLN.. 		9202 #
	DIVWN.. 		9180 #
	EDIV..			9411 #
	EDIV.DEST.CONTINUED	9672	9716	9721	9726	9731	9736	9741	9746	9751	9768	9773
				9778	9783	9788	9793	9798	9805 #
	EDIV.DIVD.NEG		9464 #
	EDIV.DIVD.NEG.NZ	9468	9472 #
	EDIV.DIVD.NEG.Z 	9477 #
	EDIV.DIVD.POS		9444	9449	9475	9480	9495 #
	EDIV.DIVR.NEG		9440 #
	EDIV.DIVR.POS		9424	9446 #
	EDIV.DIVR.ZERO		9430 #
	EDIV.DONE		9808	9814 #
	EDIV.MEM.DEST		9656	9659 #
	EDIV.NEG.NO.OVERFLOW	9638 #
	EDIV.NEG.OVERFLOW	9587	9592	9626 #
	EDIV.NEG.ZERO		9632 #
	EDIV.NO.OVERFLOW	9506	9537 #
	EDIV.OVERFLOW		9516 #	9621	9630
	EDIV.POS.NO.OVERFLOW	9582	9597	9611 #
	EDIV.POS.OVERFLOW	9617 #
	EDIV.REM.NEG		9549	9570 #
	EDIV.REM.POS		9565 #
	EDIV.RMODE.DEST 	9674 #
	EDIV.RMODE.HIGH 	9696 #
	EDIV.RMODE.LOW		9686	9691 #
	EDIV.RMODE.R0		9694	9713 #
	EDIV.RMODE.R1		9718 #
	EDIV.RMODE.R10		9775 #
	EDIV.RMODE.R11		9780 #
	EDIV.RMODE.R12		9785 #
	EDIV.RMODE.R13		9790 #
	EDIV.RMODE.R14		9795 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  641
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	EDIV.RMODE.R15		9800 #
	EDIV.RMODE.R2		9723 #
	EDIV.RMODE.R3		9728 #
	EDIV.RMODE.R4		9733 #
	EDIV.RMODE.R5		9738 #
	EDIV.RMODE.R6		9743 #
	EDIV.RMODE.R7		9748 #
	EDIV.RMODE.R8		9699	9765 #
	EDIV.RMODE.R9		9770 #
	EDIV.STATE.00		9568	9573	9579 #
	EDIV.STATE.01		9584 #
	EDIV.STATE.10		9589 #
	EDIV.STATE.11		9594 #
	EDIV.WRITE.RESULT	9438	9526	9615	9636	9642	9654 #
	EMUL..			9003 #
	EMULATE.3.CVTPL.M..	20928 #
	EMULATE.4..		20820 #
	EMULATE.456		20831 # 20851
	EMULATE.5..		20840 #
	EMULATE.56		20847 # 20867
	EMULATE.6..		20857 #
	EMULATE.FETCH.3 	20828	20844	20861	20871 # 20932
	EMULATE.FPD		3327	3370	21139 #
	EMULATE.NORMAL		20834	20909	20921	20968 #
	EMULATE.UPDATE.PC.PSL	21054	21062 # 21167
	EMULATE.WRITE.00	21004	21036 #
	EMULATE.WRITE.01	21027 #
	EMULATE.WRITE.10	21022 #
	EMULATE.WRITE.11	21017 #
	EXTV			7062 #
	EXTXV.0 		7014 #
	EXTZV			7068 #
	FBOX.1.SL..		19466 #
	FBOX.1.SL.ND..		19503 #
	FBOX.2.SL..		19580 # 19680
	FBOX.2.SL.ND..		19621 # 19716
	FBOX.4.SL..		19677 #
	FBOX.4.SL.ND..		19713 #
	FF.0_6.0		7135	7148 #	7238
	FF.0_6.1		7153 #
	FF.0_6.2		7158 #
	FF.0_6.3		7163 #
	FF.0_6.4		7168 #
	FF.0_6.5		7173 #
	FF.0_6.6		7178 #
	FF.0_6.NEXT		7183 #
	FF.7_13.10		7214 #
	FF.7_13.11		7219 #
	FF.7_13.12		7224 #
	FF.7_13.13		7229 #
	FF.7_13.7		7186	7199 #
	FF.7_13.8		7204 #
	FF.7_13.9		7209 #
	FF.7_13.NEXT		7234 #
	FF.NOT.ZERO		7107	7126 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  642
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	FF.ZERO 		7121 #
	FFC			7089 #
	FFS			7093 #
	FFX.0			6997 #
	FFX.0.EXIT		7001 #	7124
	FIELD.. 		6794 #
	FIELD.DATA.CASE 	6848	6965	6979 #	6984
	FIELD.INVALID		6802 #
	FIELD.M 		6931 #
	FIELD.M.1		6960 #
	FIELD.M.2		6942	6969 #
	FIELD.M.SIZE.NOT.ZERO	6895	6900 #
	FIELD.M.SIZE.OK 	6909 #
	FIELD.M.SIZE.TOO.BIG	6873 #	6905
	FIELD.M.SIZE.ZERO	6877 #
	FIELD.MEM		6805	6888 #
	FIELD.R 		6927 #
	FIELD.R.POS.OK		6844 #
	FIELD.R.POS.TOO.BIG	6839	6865 #
	FIELD.R.SIZE.NOT.ZERO	6822	6827 #
	FIELD.R.SIZE.OK 	6835 #
	FIELD.R.SIZE.TOO.BIG	6831	6861 #
	FIELD.R.SIZE.ZERO	6855 #
	FIELD.RMODE		6813 #
	FIELD.ZERO.CASE 	6859	6882	7132 #
	FPD.CVTDH		3332 #
	FPD.EMULATE.TEST	3304	3318 #
	FPD.TEST		3293	3298 #
	FPD.TEST.1		3356	3361 #
	HALT..			10930 #
	HALT.00 		10933	10937 #
	HALT.01 		10946 #
	HALT.10 		10950 #
	HALT.11 		10954 #
	IDIV.16.STEPS		9195	9223 #
	IDIV.8.STEPS		9173	9230 #
	IDIV.SETUP		9167	9189	9210	9321 #
	IDIV.SETUP.DIVR.NEG	9347 #
	IDIV.SETUP.DIVR.POS	9324	9330	9352 #
	IDIV.SETUP.DIVR.ZERO	9336 #
	IDIV.SETUP.NEG		9326 #
	IDIV.STATE.00		9244	9250 #
	IDIV.STATE.01		9256 #
	IDIV.STATE.10		9261 #
	IDIV.STATE.11		9275 #
	IDIV.STATE.11.NO.OVERFLOW	9259	9264	9283	9287 #
	IDIV.STATE.11.OVERFLOW		9293 #

	IDLE..			21225 #
	IE.ARITH.COMMON 	3799	3816	3833	3866	3871	3876	3884 #
	IE.ASYNC.HW.ERROR..	4136 #
	IE.BRANCH..		3139 #
	IE.CLEANUP.CPU		3475	4016	4240	4518	5096 #	10862	10883	13552	21144
	IE.CLEANUP.CPU.NO.PACKUP	2449	3792	3809	3826	3845	3958	3978	3996	4033	4503
					5088 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  643
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	IE.CLEANUP.CPU.NORMAL	5106	5116 #	5190
	IE.CLEANUP.CPU.PACKUP	5155 #
	IE.CLEANUP.CPU.QUEUE	5176 #
	IE.CLEANUP.CPU.STRING	5166	5207 #
	IE.CLEAR.HWRE.INT	4746	4753	4775 #
	IE.CLEAR.SWRE.INT	4593	4599	4601 #
	IE.CONSOLE.HALT..	2428	2445 #	3728	3735	4264	4271	4278	4939	4943	4947	10944
				13301	13305	13309	13313	14001	14006	14011
	IE.CONSOLE.HALT.NO.CLEANUP..	2454 #	3719	4771	4998	5006
	IE.DEVICE.INT			4620 #
	IE.DIVIDE.ERROR..		3822 #	9345
	IE.ENABLE.PMF.RESTART		4550 #	4725
	IE.EXC.PRVMODE.00		4865	4873	4878	4883	4888 #
	IE.EXC.PRVMODE.01		4870 #
	IE.EXC.PRVMODE.10		4875 #
	IE.EXC.PRVMODE.11		4880 #
	IE.EXCEPTION			3676	3895	4056	4080	4302	4861 #
	IE.FAULT.COMMON 		3860	3966	3986	4004	4024	4041	4050 #	10869	10890
	IE.FLT.DIVIDE.ZERO		3863 #
	IE.FLT.FAULT..			3841 #
	IE.FLT.OVERFLOW 		3868 #
	IE.FLT.RSVD.OPERAND		3851	3856 #
	IE.FLT.UNDERFLOW		3873 #
	IE.FPD..			3251 #
	IE.FPD.00..3F			3261	3287 #
	IE.FPD.40..7F			3391 #
	IE.FPD.80..BF			3395 #
	IE.FPD.C0..FF			3350 #
	IE.HARDWIRE.INT 		4682 #
	IE.INT..			4499 #
	IE.INT.COMMON			4609	4655	4707	4740	4779	4787 #
	IE.INT.CONT			4510	4525	4533 #
	IE.INT.CONTINUE 		4542	4571 #
	IE.INT.FAULT..			4514 #	17575	17772	17945	18271	18362	18426	18600	18807
	IE.INT.IPL18			4685	4690 #
	IE.INT.IPL19			4694 #
	IE.INT.IPL1A			4698 #
	IE.INT.IPL1B			4717 #
	IE.INT.IPL1C			4728 #
	IE.INT.IPL1D			4742 #
	IE.INT.IPL1E			4749 #
	IE.INT.IPL1F			4765 #
	IE.INT.NORMAL			4634	4649	4651 #
	IE.INT.OVERFLOW..		3788 #
	IE.INT.QBUS			4646 #
	IE.INTERRUPT			4793	4887 #
	IE.INTEXC.IS			4974 #
	IE.INTEXC.IS.EXC		4988 #
	IE.INTEXC.IS.INT		4977	4982 #
	IE.INTEXC.IS.LOAD		4986	4992	5034 #
	IE.INTEXC.IS.NOLOAD		5038 #
	IE.INTEXC.KS			4915	4920	4925	4930	4935	4965 #
	IE.INTEXC.KS.LOAD		4969	5021 #
	IE.INTEXC.KS.NOLOAD		5025 #
	IE.INTEXC.RES			5004 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  644
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	IE.INTEXC.SWAP.101	4937 #
	IE.INTEXC.SWAP.110	4941 #
	IE.INTEXC.SWAP.111	4945 #
	IE.INTEXC.SWAP.ES	4917 #
	IE.INTEXC.SWAP.IS	4932 #
	IE.INTEXC.SWAP.KS	4892	4912 #
	IE.INTEXC.SWAP.SS	4922 #
	IE.INTEXC.SWAP.US	4927 #
	IE.INTEXC.WCS		4996 #
	IE.INTEXC.WRITE.OLDPC	5029	5042	5045 #
	IE.ISNV 		3717 #
	IE.KSNV 		3713	4074 #
	IE.LOAD.PC		3901	4795 #
	IE.MACHCHK.DOUBLE.ERROR 4262 #
	IE.MACHCHK.KSNV 	4276 #
	IE.MACHCHK.MCHK 	4269 #
	IE.MACHCHK.NEW		4251	4290 #
	IE.MACHINE.CHECK..	3688	3692	3696	4142	4149	4218 #	4692	4696	10363	16954	17545
				19018
	IE.MEMMGT..		3459 #
	IE.MEMMGT.ACV.TNV	3645	3650	3655	3657 #
	IE.MEMMGT.DOUBLE.ERROR	3733 #
	IE.MEMMGT.M0.PX 	3598	3612 #
	IE.MEMMGT.M0.S0 	3624 #
	IE.MEMMGT.MACH.CHK	3726 #
	IE.MEMMGT.NEW		3493	3502 #
	IE.MEMMGT.PROBE.101	3686 #
	IE.MEMMGT.PROBE.110	3690 #
	IE.MEMMGT.PROBE.111	3694 #
	IE.MEMMGT.PROBE.ACV	3652 #
	IE.MEMMGT.PROBE.M0	3594 #
	IE.MEMMGT.PROBE.OK	3555	3573 #	3620	3632
	IE.MEMMGT.PROBE.PPTE.TNV	3647 #
	IE.MEMMGT.PROBE.TNV		3642 #
	IE.MEMMGT.R			3505	3532 #	13565
	IE.MEMMGT.SNV			3708 #
	IE.MEMMGT.TEST.PROBE		3535	3540	3542 #
	IE.MEMMGT.W			3537 #
	IE.NO.INTERRUPT 		4555 #
	IE.PASSIVE.RELEASE.10		4658 #
	IE.PASSIVE.RELEASE.11		4666 #
	IE.POWERUP..			2390 #
	IE.PUSH.W5.EXIT 		3681	3897 #
	IE.RSVD.ADDRESS..		3992 #
	IE.RSVD.OPCODE.TRAP..		3974 #
	IE.RSVD.OPERAND..		4012 #	6061	6863	6868	6875	7355	7359	7363	7376	8374
					8417	8453	9802	10100	10114	10128	10142	10169	10183	10197	10211
					10499	12505	12797	12862	12907	12953	13714	13752	13764	13814	13882
					13900	13907	13911	13915	13946	14150	14154	14158	14162	14173	14178
					14183	16257	16308	16312	16637	16705	16709	16761	19274
	IE.STALL..			3106 #
	IE.SUBSCRIPT.ERROR..		3805 #	11162
	IE.SWRE.INT			4575	4589 #
	IE.SWRE.INT.1			4595 #
	IE.SYNC.HW.ERROR..		4147 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  645
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	IE.TRACE.TRAP.. 	4029 #
	IE.UPDATE.SP		4062	4087	4800	4809 #
	INCX..			5517 #
	INDEX.. 		11045 #
	INDEX.DEST		11143	11150 #
	INDEX.ERROR		11157 #
	INDEX.HIGH.LIMIT.00	11066	11081	11095 #
	INDEX.HIGH.LIMIT.01	11071	11100 #
	INDEX.HIGH.LIMIT.10	11076	11106 #
	INDEX.HIGH.LIMIT.11	11112 #
	INDEX.LOW.LIMIT.00	11058	11063 #
	INDEX.LOW.LIMIT.01	11068 #
	INDEX.LOW.LIMIT.10	11073 #
	INDEX.LOW.LIMIT.11	11078 #
	INDEX.MULTIPLY		11098	11104	11110	11115	11135 #
	INDEX.SIZE.EQL.1	11128 #
	INSQHI.CONT		12229	12395 #
	INSQI.BUSY		12235	12239 #
	INSQTI.C.NOT.QA 	12477	12503 #
	INSQTI.C.QA		12509 #
	INSQTI.CONT		12447 #
	INSQTI.EMPTY		12457 #
	INSQTI.EMPTY.CONT	12400 # 12460
	INSQTI.NOT.EMPTY	12451	12463 #
	INSQUE..		11910 #
	INSQXI..		12150 #
	INSV..			7292 #
	INSV.INVALID		7305 #
	INSV.M			7521 #
	INSV.M.1		7561 #
	INSV.M.2		7536	7594 #
	INSV.M.SIZE.NOT.ZERO	7487	7492 #
	INSV.M.SIZE.OK		7500 #
	INSV.M.SIZE.TOO.BIG	7374 #	7496
	INSV.M.SIZE.ZERO	7368 #
	INSV.MEM		7308	7480 #
	INSV.R			7462 #
	INSV.R.1		7401 #
	INSV.R.1.POS.OK 	7414 #
	INSV.R.1.POS.TOO.BIG	7357 #	7409
	INSV.R.2		7342	7443 #
	INSV.R.2.POS.OK 	7458 #
	INSV.R.2.POS.TOO.BIG	7361 #	7453
	INSV.R.SIZE.NOT.ZERO	7326	7331 #
	INSV.R.SIZE.OK		7338 #
	INSV.R.SIZE.TOO.BIG	7334	7353 #
	INSV.R.SIZE.ZERO	7347 #
	INSV.RMODE		7318 #
	INT.MULT.1.STEP 	9103	9106 #
	INT.MULT.15.STEPS	8897	8908	9086	9088 #
	INT.MULT.3.STEPS	9097	9100 #
	INT.MULT.31.STEPS	9048	9058	9083 #	11139
	INT.MULT.7.STEPS	8850	8861	9091	9094 #
	INT.MULT.LONG.NEG	9055 #
	INT.MULT.LONG.POS	8950	9010	9045 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  646
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	INTERRUPT.STATE.CHANGE	11222	11230	14112	14118 # 16100	16132	16180	16334	16352	16358

	IOTA..			20530 #
	IQ.ACQUIRE.LOCK 	12167 # 12706	12718
	IQ.D.NOT.QA		12173	12284 #
	IQ.D.QA 		12178 #
	IQ.EQUAL		12300 #
	IQ.EXIT 		12422	12528	12553	12561	12584 #
	IQ.H.NOT.QA		12186	12292 #
	IQ.H.QA 		12190 #
	IQ.NOT.EQUAL		12194	12199 #
	IQ.SET.000		12206	12225 #
	IQ.SET.001		12231 #
	IQ.SET.010		12317 #
	IQ.SET.011		12326 #
	IQ.SET.100		12335 #
	IQ.SET.101		12344 #
	IQ.SET.110		12353 #
	IQ.SET.111		12362 #
	JMP..			7830 #
	JSB..			7897 #
	LAST.CYCLE		10723	10991 #
	LDPCTX..		14236 #
	LDPCTX.FROM.EXEC	14244 #
	LDPCTX.FROM.KERNEL	14239	14263 #
	LDPCTX.FROM.SUPER	14248 #
	LDPCTX.FROM.USER	14252 #
	LDPCTX.INT.STK		14458 #
	LDPCTX.KERNEL.STK	14438	14466 #
	LDPCTX.MTPR.PME.0	14490	14494 #
	LDPCTX.MTPR.PME.1	14504 #
	LDPCTX.MTPR.UPDATE.PME	14487 # 16247
	LDPCTX.READ.3.LONGWORDS 14267	14382	14516 #
	LOCC.COMPARE		18817	18832 #
	LOCC.EQL		18840 #
	LOCC.NEQ		18835	18847 #
	LOCC.SKPC..		18762 #
	LOCC.SKPC.EXIT		18852 #
	LOCC.SKPC.INTERRUPT	18804 #
	LOCC.SKPC.LOOP		18778	18793 # 18850	18887
	LOCC.SKPC.NO.INTERRUPTS 18800	18809 #
	LOCC.SKPC.RESTART	18774 #
	MCOMX.. 		5969 #
	MFPR..			15569 #
	MFPR.00 		15720	16449 #
	MFPR.00.07		15640	15718 #
	MFPR.01 		16469 #
	MFPR.02 		16475 #
	MFPR.03 		16481 #
	MFPR.04 		16493 #
	MFPR.05 		16513 #
	MFPR.06 		16517 #
	MFPR.07 		16521 #
	MFPR.08 		15724	16530 #
	MFPR.08.15		15722 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  647
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	MFPR.09 		16537 #
	MFPR.10 		16544 #
	MFPR.11 		16554 #
	MFPR.12 		16571 #
	MFPR.120.124		16776	16781 #
	MFPR.120.127		16774 #
	MFPR.121.125		16787 #
	MFPR.122.126		16793 #
	MFPR.123.127		16799 #
	MFPR.13 		16578 #
	MFPR.14 		16585 #
	MFPR.144.151		16814 #
	MFPR.15 		16591 #
	MFPR.16 		15729	16601 #
	MFPR.16.23		15726 #
	MFPR.17 		16607 #
	MFPR.18 		16613 #
	MFPR.19 		16619 #
	MFPR.20 		16635 #
	MFPR.21 		16639 #
	MFPR.22 		16645 #
	MFPR.23 		16649 #
	MFPR.24.31		15731 #
	MFPR.24.EXT		16667 #
	MFPR.24.INT		15740	16661 #
	MFPR.32.39		15742 #
	MFPR.40.47		15747 #
	MFPR.42 		15755	16678 #
	MFPR.43 		16684 #
	MFPR.48.55		15757 #
	MFPR.56 		15766	16696 #
	MFPR.56.63		15762 #
	MFPR.57 		16703 #
	MFPR.58 		16707 #
	MFPR.59 		16711 #
	MFPR.60 		16722 #
	MFPR.61 		16726 #
	MFPR.62 		16736 #
	MFPR.62.PCS.DISABLED	16752 #
	MFPR.62.PCS.ENABLED	16742	16747 #
	MFPR.63 		16759 #
	MFPR.CONTINUE		15626 #
	MFPR.DST		16534	16552	16575	16671	16849	16851 #
	MFPR.DST.RSH.9		16541	16563	16582	16700	16857 #
	MFPR.GT.63		15631	15780 #
	MFPR.IPR.CACHE		15862	16840 #
	MFPR.IPR.CACHE.OR.NORMAL	15860 #
	MFPR.IPR.NORMAL 		15744	15759	16515	16519	16523	16593	16647	16651	16713	16724
					16843	16845 #
	MFPR.IS.ON.IS			16507 #
	MFPR.IS.ON.KS			16496	16501 #
	MFPR.KS.ON.IS			16463 #
	MFPR.KS.ON.KS			16452	16457 #
	MFPR.LE.63			15636 #
	MFPR.VECTOR.ABSENT		16816	16820 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  648
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	MFPR.VECTOR.PRESENT	16826 #
	MFVP..			20142 #
	MNEGX.. 		5980 #
	MOVC.ALIGN.DECR.BYTE..	17456	17466	17481 #
	MOVC.ALIGN.DECR.LONG..	17451	17495 #
	MOVC.ALIGN.DECR.WORD..	17461	17488 #
	MOVC.ALIGN.DST.00	17421	17447 # 17627	17910	19235
	MOVC.ALIGN.DST.01	17453 #
	MOVC.ALIGN.DST.10	17458 #
	MOVC.ALIGN.DST.11	17463 #
	MOVC.BACKWARD		17352	17361	17410 #
	MOVC.BACKWARD.ALIGNED	17789 #
	MOVC.BACKWARD.COMPLETE	17864 #
	MOVC.BACKWARD.DL.TOO.BIG	17836 #
	MOVC.BACKWARD.INTERRUPT 	17770 #
	MOVC.BACKWARD.LOOP		17533	17763 # 17793
	MOVC.BACKWARD.NO.INTERRUPTS	17766	17774 #
	MOVC.BACKWARD.NOT.ALIGNED	17619 # 17784
	MOVC.BIAS.BACKWARD		17527 #
	MOVC.BIAS.FILL			17535 #
	MOVC.BIAS.FORWARD		17486	17493	17500	17519 # 17667	17673
	MOVC.BIAS.UNK			17543 #
	MOVC.CMPC.FPD			19114 #
	MOVC.CMPC.UNPACK		19136	19178 #
	MOVC.COMMON.NOT.ALIGNED 	17624 # 17983
	MOVC.COMPLETE			17320	17661	17742	17915	18050 #
	MOVC.DL.BYTE..			17658 #
	MOVC.DL.LONG..			17653	17669 # 17842	18012
	MOVC.DL.WORD..			17663 #
	MOVC.FILL..			17884 #
	MOVC.FILL.1			17392	17890 #
	MOVC.FILL.ALIGNED		17957 #
	MOVC.FILL.COMPLETE		18033 #
	MOVC.FILL.DL.TOO.BIG		18006 #
	MOVC.FILL.INTERRUPT		17943 #
	MOVC.FILL.LOOP			17541	17936 # 17961
	MOVC.FILL.NO.INTERRUPTS 	17939	17947 #
	MOVC.FILL.NOT.ALIGNED		17952	17979 #
	MOVC.FILL.SETUP 		17902	17907 # 19270
	MOVC.FORWARD			17418 #
	MOVC.FORWARD.ALIGNED		17592 #
	MOVC.FORWARD.COMPLETE		17691 #
	MOVC.FORWARD.DL.TOO.BIG 	17647 #
	MOVC.FORWARD.INTERRUPT		17573 #
	MOVC.FORWARD.LOOP		17525	17566 # 17596
	MOVC.FORWARD.NO.INTERRUPTS	17569	17577 #
	MOVC.FORWARD.NOT.ALIGNED	17587	17615 #
	MOVC.FPD.BACKWARD		19237 #
	MOVC.FPD.CONT			19229 # 19241
	MOVC.FPD.ERROR			19272 #
	MOVC.FPD.FILL			19256 #
	MOVC.FPD.FORWARD		19207	19225 #
	MOVC.MOVE.COMPLETE		17716 # 17872
	MOVC.NO.FILL			17912 #
	MOVC.PACK			18970	18986 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  649
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	MOVC.PACK.00		18996	19001 #
	MOVC.PACK.01		19006 #
	MOVC.PACK.10		19011 #
	MOVC.PACK.EXIT		19004	19009	19014	19029 #
	MOVC.PACK.UNKNOWN	19016 #
	MOVC.UNPACK..		19191	19203 #
	MOVC3			17255	17261 #
	MOVC3.COMPLETE		17732	17738 #
	MOVC3.CONT		17275	17348 #
	MOVC5			17284 #
	MOVC5.CONT		17296	17301 #
	MOVC5.CONT.1		17311	17333 #
	MOVC5.DST.LONGER	17336	17340 #
	MOVC5.SRC.LONGER	17354 #
	MOVC5.ZERO.DST		17316 #
	MOVC5.ZERO.SRC		17373 #
	MOVC5.ZERO.SRC.CONT	17383	17388 #
	MOVC5.ZERO.SRC.DST	18046 #
	MOVCX.. 		17250 #
	MOVPSL..		11273 #
	MOVQ..			5936 #
	MOVX..			5930 #
	MOVZBX..		5952 #
	MOVZWL..		5959 #
	MTPR..			15552 #
	MTPR.00 		15655	15915 #
	MTPR.00.07		15624	15653 #
	MTPR.01 		15935 #
	MTPR.02 		15941 #
	MTPR.03 		15947 #
	MTPR.04 		15960 #
	MTPR.05 		15980 #
	MTPR.06 		15984 #
	MTPR.07 		15988 #
	MTPR.08 		15660	15998 #
	MTPR.08.15		15657 #
	MTPR.09 		16006 #
	MTPR.10 		16014 #
	MTPR.11 		16025 #
	MTPR.12 		16044 #
	MTPR.120		16301	16306 #
	MTPR.120.127		15832	16297 #
	MTPR.121		16310 #
	MTPR.122		16314 #
	MTPR.123		16319 #
	MTPR.124		16330 #
	MTPR.125		16336 #
	MTPR.125.NEG		16342 #
	MTPR.125.POS		16338	16354 #
	MTPR.126		16362 #
	MTPR.127		16373 #
	MTPR.13 		16052 #
	MTPR.14 		16060 #
	MTPR.144.151		15805	16391 #
	MTPR.15 		16072 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  650
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	MTPR.16 		15666	16083 #
	MTPR.16.23		15662 #
	MTPR.17 		16089 #
	MTPR.18 		16095 #
	MTPR.19 		16102 #
	MTPR.20 		16116 #
	MTPR.21 		16134 #
	MTPR.22 		16144 #
	MTPR.23 		16148 #
	MTPR.24.31		15668 #
	MTPR.24.EXT		16168 #
	MTPR.24.INT		15678	16172	16175 #
	MTPR.32.39		15680 #
	MTPR.40.47		15691 #
	MTPR.48.55		15696 #
	MTPR.56 		15706	16189 #
	MTPR.56.63		15701 #
	MTPR.57 		16214 #
	MTPR.58 		16220 #
	MTPR.59 		16233 #
	MTPR.60 		16237 #
	MTPR.61 		16241 #
	MTPR.62 		16255 #
	MTPR.63 		16259 #
	MTPR.63.TBHIT		16278 #
	MTPR.63.TBMISS		16269	16273 #
	MTPR.CONTINUE		15606	15611 #
	MTPR.GT.63		15615	15775 #
	MTPR.IPR.CACHE		15855	16417 #
	MTPR.IPR.CACHE.OR.NORMAL	15848	15853 #
	MTPR.IPR.NORMAL 		15693	15698	15982	15986	15990	16074	16146	16150	16235	16239
					16420	16422 #
	MTPR.IS.ON.IS			15974 #
	MTPR.IS.ON.KS			15963	15968 #
	MTPR.KS.ON.IS			15929 #
	MTPR.KS.ON.KS			15918	15923 #
	MTPR.LE.63			15620 #
	MTPR.OR.INT.SYS 		16142	16174 #
	MTPR.TBIA			16003	16011	16022	16034	16049	16057	16198	16213 #
	MTPR.UPDATE.INT.SYS		16127 # 16317
	MTPR.VECTOR.ABSENT		16394	16398 #
	MTPR.VECTOR.PRESENT		16403 #
	MTVP..				20179 #
	MULBN.. 			8836 #
	MULBN.CONT			8856	8864 #
	MULBN.MULR.NEG			8847 #
	MULBN.MULR.POS			8843	8858 #
	MULL.HOT			8933	8937 #
	MULL.WARM			8943 #
	MULLN.. 			8929 #
	MULWN.. 			8883 #
	MULWN.CONT			8903	8911 #
	MULWN.MULR.NEG			8894 #
	MULWN.MULR.POS			8890	8905 #
	MULX.CHECK.OVERFLOW		8876	8922	8960 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  651
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	MXPR.120.127		15829 #
	MXPR.144.151		15802 #
	MXPR.ACCESS.B.W0	16266	16899 #
	MXPR.CLEAR.W3.BIT.0	16125	16137	16154 #
	MXPR.FROM.EXEC		15583 #
	MXPR.FROM.KERNEL	15562	15577	15603 #
	MXPR.FROM.SUPER 	15587 #
	MXPR.FROM.USER		15591 #
	MXPR.GT.63		15778	15783	15785 #
	MXPR.IPR.CACHE.OR.NORMAL	15822	15845 # 16896
	MXPR.NOT.144.151		15795	15819 #
	MXPR.REG.INVALID		16893 #
	MXPR.REG.VALID			16888	16898 #
	MXPR.TEST.VALID 		15671	15683	15734	15750	16882 #
	NOP..				10992 #
	POPR..				11324 #
	POPR.0_6.0			11383	11401 # 11405	11411	11417	11423	11429	11435	11441
	POPR.0_6.1			11407 #
	POPR.0_6.2			11413 #
	POPR.0_6.3			11419 #
	POPR.0_6.4			11425 #
	POPR.0_6.5			11431 #
	POPR.0_6.6			11437 #
	POPR.0_6.NEXT			11443 #
	POPR.7_13.10			11477 #
	POPR.7_13.11			11483 #
	POPR.7_13.12			11489 #
	POPR.7_13.13			11495 #
	POPR.7_13.7			11446	11459 # 11463	11469	11475	11481	11487	11493	11499
	POPR.7_13.8			11465 #
	POPR.7_13.9			11471 #
	POPR.7_13.DONE			11501 #
	POPR.NO.SP			11335	11350 #
	POPR.NOT.ZERO			11353	11363 #
	POPR.SET.VA			11367	11376 #
	POPR.SP 			11370 #
	POPR.ZERO			11358 #
	PROBER.PROBE			14890	14895 #
	PROBEW.PROBE			14906 #
	PROBEX..			14832 #
	PROBEX.1ST.000			14935	14943 #
	PROBEX.1ST.001			14948 #
	PROBEX.1ST.010			14953 #
	PROBEX.1ST.011			14958 #
	PROBEX.1ST.100			14966 #
	PROBEX.1ST.101			14972 #
	PROBEX.1ST.110			14978 #
	PROBEX.1ST.111			14984 #
	PROBEX.2ND.000			14946	14951	14956	15003 #
	PROBEX.2ND.001			15009 #
	PROBEX.2ND.010			15015 #
	PROBEX.2ND.011			15021 #
	PROBEX.2ND.100			15028 #
	PROBEX.2ND.101			15034 #
	PROBEX.2ND.110			15040 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  652
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	PROBEX.2ND.111		15046 #
	PROBEX.OP.MODE		14883 #
	PROBEX.PM.00		14839	14845 #
	PROBEX.PM.01		14852 #
	PROBEX.PM.10		14859 #
	PROBEX.PM.11		14866 #
	PROBEX.PROBE		14849	14856	14863	14870	14887 #
	PROBEX.TEST		14903	14915	14928 #
	PUSHR.. 		11557 #
	PUSHR.0_6.0		11603	11619	11631 # 11635	11641	11647	11653	11659	11665	11671
	PUSHR.0_6.1		11637 #
	PUSHR.0_6.2		11643 #
	PUSHR.0_6.3		11649 #
	PUSHR.0_6.4		11655 #
	PUSHR.0_6.5		11661 #
	PUSHR.0_6.6		11667 #
	PUSHR.0_6.NEXT		11673 #
	PUSHR.7_13.10		11705 #
	PUSHR.7_13.11		11711 #
	PUSHR.7_13.12		11717 #
	PUSHR.7_13.13		11723 #
	PUSHR.7_13.7		11676	11687 # 11691	11697	11703	11709	11715	11721	11727
	PUSHR.7_13.8		11693 #
	PUSHR.7_13.9		11699 #
	PUSHR.7_13.DONE 	11729 #
	PUSHR.NO.SP		11568	11582 #
	PUSHR.NOT.ZERO		11585	11596 #
	PUSHR.SP		11606 #
	PUSHR.ZERO		11591 #
	REI..			13657 #
	REI.CHECK.AST		14060	14066	14072	14078	14096 #
	REI.CHECK.LAST.RULE	13770	13896	13931 #
	REI.DELIVER.AST 	14108 #
	REI.FROM.101		13999 #
	REI.FROM.110		14004 #
	REI.FROM.111		14009 #
	REI.FROM.EXEC		13975 #
	REI.FROM.INTER		13993 #
	REI.FROM.KERNEL 	13955	13969 #
	REI.FROM.SUPER		13981 #
	REI.FROM.USER		13987 #
	REI.NEW.EXEC		14062 #
	REI.NEW.INTER		14085 #
	REI.NEW.KERNEL		14047	14056 #
	REI.NEW.SUPER		14068 #
	REI.NEW.USER		14074 #
	REI.NO.AST		14091	14100	14104 #
	REI.RSRV		13942 #
	REI.RULE.5.8.BAD	13757	13762 # 13819	13847
	REI.RULE.5.8.OK 	13719	13766 #
	REI.TEST.AST		13973	13979	13985	13991	13997	14039 #
	REI.TO.101		13905 #
	REI.TO.110		13909 #
	REI.TO.111		13913 #
	REI.TO.EXEC		13738 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  653
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	REI.TO.EXEC.CONT	13748	13754 #
	REI.TO.EXEC.FROM.KERNEL.EXEC	13741	13745 #
	REI.TO.EXEC.FROM.SUPER.USER	13750 #

	REI.TO.INT		13866 #
	REI.TO.INT.RULE.4.BAD	13898 #
	REI.TO.INT.RULE.4.OK	13887	13892 #
	REI.TO.INT.RULE.8.BAD	13875	13880 #
	REI.TO.INT.RULE.8.OK	13884 #
	REI.TO.KERNEL		13676	13698 #
	REI.TO.KERNEL.FROM.EXEC 14171 #
	REI.TO.KERNEL.FROM.KERNEL	13702	14165 #
	REI.TO.KERNEL.FROM.SUPER	14176 #
	REI.TO.KERNEL.FROM.USER 	14181 #
	REI.TO.KERNEL.RULE.8.BAD	13707	13712 #
	REI.TO.KERNEL.RULE.8.OK 	13716 #
	REI.TO.KI.FROM.101		14170 #
	REI.TO.KI.FROM.110		14175 #
	REI.TO.KI.FROM.111		14180 #
	REI.TO.KI.FROM.EXEC		14152 #
	REI.TO.KI.FROM.INT		14164 #
	REI.TO.KI.FROM.KERNEL		13870	14148 #
	REI.TO.KI.FROM.SUPER		14156 #
	REI.TO.KI.FROM.USER		14160 #
	REI.TO.SUPER			13789 #
	REI.TO.SUPER.CONT		13800	13805	13810	13816 #
	REI.TO.SUPER.FROM.EXEC		13802 #
	REI.TO.SUPER.FROM.KERNEL	13792	13797 #
	REI.TO.SUPER.FROM.SUPER 	13807 #
	REI.TO.SUPER.FROM.USER		13812 #
	REI.TO.USER			13838 #
	REI.VALID			13938	13948 #
	REMQHI.B.NOT.QA 		12773	12795 #
	REMQHI.B.QA			12801 #
	REMQHI.CONT			12749 #
	REMQHI.EMPTY			12759 #
	REMQHI.NOT.EMPTY		12753	12765 #
	REMQI.BUSY			12245 #
	REMQI.BUSY.M			12243	12263 #
	REMQI.BUSY.R			12249	12254 #
	REMQTI.B.NOT.QA 		12901	12905 #
	REMQTI.B.QA			12911 #
	REMQTI.C.NOT.QA 		12855	12860 #
	REMQTI.C.QA			12866 #
	REMQTI.CONT			12833 #
	REMQTI.EMPTY			12843 #
	REMQTI.MULTI			12874	12898 #
	REMQTI.NOT.EMPTY		12837	12848 #
	REMQTI.SINGLE			12945 #
	REMQTI.SINGLE.B.NOT.QA		12947	12951 #
	REMQTI.SINGLE.B.QA		12957 #
	REMQUE..			12006 #
	REMQUE.DEST			12049	12062 #
	REMQUE.EMPTY			12045 #
	REMQUE.WRITE			12030	12051 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  654
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	REMQXI..		12697 #
	REMQXI.M		12699	12712 #
	REMQXI.R		12701 #
	REMQXI.WRITE.M		12557 #
	REMQXI.WRITE.R		12549 # 12763	12811	12846	12920	12963
	RESERVED.OPERAND.FAULT	11238	12290	12298	12306	12324	12333	12342	12351	12360	12369	12502 #
	RESTART.IBOX		11590 # 14775	16218	16225	16281	16322	16461	16467	16473	16479	16485
				16505	16511	16589	16605	16611	16617	16626	16643	16665	16682	16688	16734
				16757	16785	16791	16797	16803	16824	16830	16855	16861	18386	18399	18449
				18461	18660	18857
	RESTART.MBOX		12261	12268	12270 #
	RET..			10481 #
	RET.0_6.0		10529	10535	10541	10547	10553	10559	10565	10584 # 10588	10594	10600
				10606	10612	10618	10624
	RET.0_6.1		10590 #
	RET.0_6.2		10596 #
	RET.0_6.3		10602 #
	RET.0_6.4		10608 #
	RET.0_6.5		10614 #
	RET.0_6.6		10620 #
	RET.0_6.NEXT		10626 #
	RET.1ST.0_6.0		10505	10525 #
	RET.1ST.0_6.1		10531 #
	RET.1ST.0_6.2		10537 #
	RET.1ST.0_6.3		10543 #
	RET.1ST.0_6.4		10549 #
	RET.1ST.0_6.5		10555 #
	RET.1ST.0_6.6		10561 #
	RET.1ST.0_6.NEXT	10567 #
	RET.7_13.10		10660 #
	RET.7_13.11		10666 #
	RET.7_13.12		10672 #
	RET.7_13.7		10570	10628	10642 # 10646	10652	10658	10664	10670	10675
	RET.7_13.8		10648 #
	RET.7_13.9		10654 #
	RET.7_13.G		10687 #
	RET.7_13.S		10698 #
	RET.CONT		10492	10501 #
	RET.RSRV		10497 #
	RET.SYNC.UPDATE.PSL	10692	10702	10732 #
	RET.UPDATE.FP.SP	10696	10715 #
	ROTL..			6253 #
	RSB..			7939 #
	RSVD.OPCODE..		3334	3363	3393	3397	3954 #	10948	10952	10956	14246	14250	14254
				14603	14607	14611	15585	15589	15593	19952	20007	20054	20101	20144	20181
				20219	20281	20330	20376	20416	20455	20494	20532
	SBWC			5839 #
	SBWC.C0 		5846 #
	SBWC.C1 		5841	5852 #
	SCANC.COMPARE		18617	18634 #
	SCANC.EQL		18649 #
	SCANC.LOCC.FPD		19118 #
	SCANC.LOCC.PACK 	19038 #
	SCANC.LOCC.UNPACK	19150 #
	SCANC.NEQ		18637	18642 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  655
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	SCANC.SPANC..		18544 #
	SCANC.SPANC.EXIT	18654 #
	SCANC.SPANC.INTERRUPT	18597 #
	SCANC.SPANC.LOOP	18570	18586 # 18652	18692
	SCANC.SPANC.NO.INTERRUPTS	18593	18602 #
	SCANC.SPANC.RESTART		18566 # 19161
	SET.PSL.V			9298 #
	SHIFT.AND.WRITE.PXLR		14408	14426	14538 #
	SIM.HALT.NOT.POWERUP		21226 # 21229
	SKPC.COMPARE			18869 #
	SKPC.EQL			18884 #
	SKPC.NEQ			18872	18877 #
	SOBGXX..			8101 #
	SPANC.COMPARE			18674 #
	SPANC.EQL			18682 #
	SPANC.NEQ			18677	18689 #
	SPANC.SKPC.PACK 		19046 #
	STRING.PACK			5235	18957 #
	SUBIN.. 			5743 #
	SVPCTX..			14591 #
	SVPCTX.FROM.EXEC		14601 #
	SVPCTX.FROM.KERNEL		14595	14613 #
	SVPCTX.FROM.SUPER		14605 #
	SVPCTX.FROM.USER		14609 #
	SVPCTX.IPL.NOT.ZERO		14647	14656 #
	SVPCTX.IPL.ZERO 		14652 #
	SVPCTX.ON.KERNEL.STACK		14621	14636 #
	SVPCTX.SAVE.STATE.IN.PCB	14660	14671 #
	SYNC.RESTART.IBOX		8029	8058	16427	16437 # 21058
	SYNC.RESTART.IBOX.NO.RETIRE	2577	3578	4355	4561	4563 #	4664	4672	4817	21171

	TSTX..			5470 #
	UPDATE.PMF.COUNTERS	4720	14498	16915 #
	UPDATE.PMF.COUNTERS.OFF 16923 #
	UPDATE.PMF.COUNTERS.ON	16918	16933 #
	UPDATE.PMF.ERROR	16947	16952 #
	UPDATE.PMF.LW		16983	17008 #
	UPDATE.PMF.LW.RETURN	16987	16991 # 17015
	UPDATE.PMF.MEM		16959 #
	UPDATE.PMF.QW		16964	16968	16981 #
	VGATHX..		20052 #
	VLDX..			19950 #
	VSCATX..		20099 #
	VSCMPL..		20453 #
	VSCMPQ..		20492 #
	VSOPL.. 		20328 #
	VSOPQ.. 		20374 #
	VSTX..			20005 #
	VSYNC.. 		20217 #
	VVCMPX..		20414 #
	VVOPX.. 		20279 #
	WAIT.11.CYCLES		5242	5244 #
	WAIT.23.CYCLES		4139	5240 #
	WAIT.5.CYCLES		5246	5248 #
	WAIT.ONE.CYCLE		3321	3353	4553	5254	6937	9051 #	9279	11276
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  656
;			     Cross Reference Listing - Field Names and Defined Values				      /REV=
;
	WAIT.TWO.CYCLES 	3463	4222	5250	5252 #	14120	16346
	WRITE.PC.W1.ALIGNED	21067 #
	WRITE.QW		5584 #	7351
	WRITE.QW.SETCC		5942 #
	WRITE.VA.W5		17720	18041	18067 #
	WRITE.W1.PCB.NEXT	14677	14681	14685	14782 #
	WRITE.W4.PREV		4320	4328	4332	4336	4367 #	14470
	XFC..			10879 #
	XORXN.. 		5778 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  657
;			     Cross Reference Listing - Macro Names						      /REV=
;
ACCESS A []			1938 #	5161	6857	6880	7370	7832	7900	7941	9667	9676	9682
				11504	13671	16246	16299	16901	18270	18361	18425	18599	18806	20915
ACCESS B []			1939 #	3492	3544	4541	4574	4630	4891	5232	6857	10721	10736
				11503	11511	12017	12552	12588	12600	13458	13464	14273	14930	14934	15572
				15614	15623	15630	15639	15704	15804	15831	16902	16943	17351	17360	17416
				17595	17622	17792	17900	17960	17982	19156	19190	19231	19268
CALL CASE [] AT []		1923 #	8950	9010	9167	9189	9210	13702	13870
CALL [] 			1928 #	2449	3321	3353	3463	3475	3676	3792	3809	3826	3845
				3895	3958	3978	3996	4016	4033	4056	4080	4139	4222	4240	4302
				4320	4328	4332	4336	4503	4518	4553	4720	4793	5242	5246	5250
				6451	6483	6937	8363	8406	8442	8502	8521	8552	8571	8850	8861
				8897	8908	9048	9058	9086	9091	9097	9103	9219	9226	9233	9279
				9540	9840	9845	9850	9855	10692	10702	10862	10883	11139	11276	13552
				14120	14267	14382	14408	14426	14470	14498	14677	14681	14685	15671	15683
				15734	15750	16125	16137	16266	16346	16964	16983	17720	18041	20828	20844
				20861	20932	21054	21144	21167
CASE [] AT []			1924 #	2484	2561	2603	2615	2621	2637	2654	2662	2669	2676
				2680	3261	3293	3304	3327	3356	3493	3505	3555	3598	3713	3851
				4251	4542	4575	4634	4685	4865	4892	4915	4920	4925	4930	4935
				4969	4977	4986	4992	5106	5166	5803	5820	5841	6033	6055	6180
				6307	6434	6487	6574	6805	6822	6831	6839	6848	6859	6882	6895
				6905	6942	6965	6984	7107	7135	7186	7238	7308	7326	7334	7342
				7409	7453	7487	7496	7536	8011	8224	8235	8246	8356	8367	8399
				8410	8435	8446	8494	8544	8843	8890	8933	9244	9283	9324	9330
				9424	9444	9449	9468	9506	9549	9568	9573	9582	9587	9592	9597
				9656	9686	9694	9699	9808	10058	10067	10073	10257	10275	10281	10287
				10293	10299	10305	10311	10317	10335	10341	10347	10353	10359	10385	10393
				10492	10505	10529	10535	10541	10547	10553	10559	10565	10570	10588	10594
				10600	10606	10612	10618	10624	10628	10646	10652	10658	10664	10670	10675
				10933	11058	11066	11081	11098	11115	11143	11209	11222	11230	11335	11353
				11383	11405	11411	11417	11423	11429	11435	11441	11446	11463	11469	11475
				11481	11487	11493	11499	11568	11585	11603	11619	11635	11641	11647	11653
				11659	11665	11671	11676	11691	11697	11703	11709	11715	11721	11727	12030
				12173	12186	12194	12206	12229	12235	12249	12451	12477	12699	12753	12763
				12773	12811	12837	12846	12855	12874	12901	12920	12947	12963	13239	13246
				13253	13260	13287	13292	13297	13465	13473	13565	13676	13707	13741	13757
				13792	13819	13847	13875	13887	13938	13955	14047	14100	14239	14438	14490
				14595	14621	14647	14839	14856	14863	14890	14935	14946	14951	14956	15562
				15577	15606	15615	15624	15631	15640	15655	15660	15666	15678	15706	15720
				15724	15729	15740	15755	15766	15795	15805	15822	15832	15848	15855	15862
				15918	15963	16269	16301	16338	16394	16452	16496	16742	16776	16816	16888
				16918	16947	16987	17255	17275	17296	17311	17336	17352	17361	17383	17421
				17486	17493	17500	17525	17533	17541	17569	17587	17596	17627	17653	17667
				17673	17732	17766	17784	17793	17842	17902	17910	17939	17952	17961	18012
				18176	18223	18235	18244	18264	18288	18313	18321	18326	18335	18355	18375
				18391	18419	18439	18454	18570	18593	18617	18637	18652	18677	18692	18778
				18800	18817	18835	18850	18872	18887	18970	18996	19136	19161	19191	19200
				19207	19235	20903	21004
CLEAR PMF COUNTERS		1919 #	2393	16345	16963
CLEAR PSL(V)			1736 #
CONSOLE HALT NO CLEANUP []	1945 #	3719	4771	4998	5006
CONSOLE HALT [] 		1944 #	2428	3728	3735	4264	4271	4278	4939	4943	4947	10944
				13301	13305	13309	13313	14001	14006	14011
DL <-- BYTE			1900 #	10048	10491	11329	11562	17485	17666	18234	18243	18569	18777
DL <-- LONG			1902 #	6187	6207	17499
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  658
;			     Cross Reference Listing - Macro Names						      /REV=
;
DL <-- WORD			1901 #	4536	6194	8010	17254	17492	17672
FBOX DEST CHECK 		1888 #	8940	19469	19583
FBOX OPERAND A[]		1875 #	19468	19505
FBOX OPERAND A[] B[]		1876 #	8939	19582	19623	19679	19715
FLUSH BRANCH PREDICTION TABLE	1880 #	2458	4235	14371
FLUSH PA QUEUE			1889 #	3142	5120	5211	21255
FLUSH PC QUEUE			1881 #	5128	5233
FLUSH VIC			1879 #	2469	13936
GOTO [] 			1929 #	2428	2503	2509	2515	2521	2527	2534	2541	2548	2577
				2626	2631	3334	3363	3370	3393	3397	3535	3540	3578	3620	3632
				3645	3650	3655	3681	3688	3692	3696	3719	3728	3735	3799	3816
				3833	3860	3866	3871	3876	3901	3966	3986	4004	4024	4041	4062
				4087	4142	4149	4264	4271	4278	4355	4510	4525	4561	4593	4599
				4609	4649	4655	4664	4672	4692	4696	4707	4725	4740	4746	4753
				4771	4779	4800	4817	4873	4878	4883	4939	4943	4947	4998	5006
				5029	5042	5190	5235	5254	6044	6061	6188	6195	6208	6336	6342
				6348	6515	6521	6526	6541	6547	6863	6868	6875	7042	7047	7124
				7351	7355	7359	7363	7376	8029	8036	8058	8374	8417	8453	8478
				8512	8529	8562	8579	8599	8856	8876	8903	8922	9173	9195	9259
				9264	9345	9438	9475	9480	9526	9615	9621	9630	9636	9642	9672
				9716	9721	9726	9731	9736	9741	9746	9751	9768	9773	9778	9783
				9788	9793	9798	9802	10095	10100	10109	10114	10123	10128	10137	10142
				10164	10169	10178	10183	10192	10197	10206	10211	10227	10234	10363	10408
				10414	10420	10499	10696	10723	10869	10890	10944	10948	10952	10956	11071
				11076	11104	11110	11162	11238	11367	12049	12243	12261	12268	12290	12298
				12306	12324	12333	12342	12351	12360	12369	12422	12460	12505	12528	12553
				12561	12706	12718	12797	12862	12907	12953	13281	13301	13305	13309	13313
				13329	13336	13343	13350	13367	13374	13381	13388	13405	13412	13419	13426
				13535	13714	13719	13748	13752	13764	13770	13800	13805	13810	13814	13882
				13896	13900	13907	13911	13915	13946	13973	13979	13985	13991	13997	14001
				14006	14011	14060	14066	14072	14078	14091	14112	14150	14154	14158	14162
				14173	14178	14183	14246	14250	14254	14603	14607	14611	14660	14775	14849
				14870	14903	14915	14961	15023	15585	15589	15593	15693	15698	15744	15759
				15778	15783	15982	15986	15990	16003	16011	16022	16034	16049	16057	16074
				16100	16132	16142	16146	16150	16172	16180	16198	16218	16225	16235	16239
				16247	16257	16281	16308	16312	16317	16322	16334	16352	16358	16420	16427
				16461	16467	16473	16479	16485	16505	16511	16515	16519	16523	16534	16541
				16552	16563	16575	16582	16589	16593	16605	16611	16617	16626	16637	16643
				16647	16651	16665	16671	16682	16688	16700	16705	16709	16713	16724	16734
				16757	16761	16785	16791	16797	16803	16824	16830	16843	16849	16855	16861
				16896	16954	16968	17015	17320	17392	17451	17456	17461	17466	17545	17575
				17661	17742	17772	17872	17915	17945	17983	18190	18205	18271	18308	18362
				18386	18399	18426	18449	18461	18600	18646	18660	18686	18807	18844	18857
				18881	19004	19009	19014	19018	19241	19270	19274	19680	19716	19952	20007
				20054	20101	20144	20181	20219	20281	20330	20376	20416	20455	20494	20532
				20834	20851	20867	20909	20921	21058	21171	21229	21299
INCREMENT PMF COUNTER		1920 #	16321
INTERRUPT FAULT 		1950 #	17575	17772	17945	18271	18362	18426	18600	18807
LAST CYCLE			1931 #	5474	5576	5587	5634	5645	5758	5770	5782	5934	5946
				5957	5963	5973	6123	6132	6261	6368	6374	6380	6387	6558	6583
				6590	7005	7012	7018	7066	7072	7151	7156	7161	7166	7171	7176
				7181	7202	7207	7212	7217	7222	7227	7232	7372	7421	7470	7571
				7624	7822	7827	7833	7890	7901	7942	8382	8426	8462	8660	9023
				9254	9291	10426	10995	11132	11154	11280	11361	11513	11594	11735	11949
				12066	12273	12602	13506	14106	14123	14502	14509	14970	14976	14982	14988
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  659
;			     Cross Reference Listing - Macro Names						      /REV=
;
				15007	15013	15019	15032	15038	15044	15050	15689	15927	15933	15939	15945
				15951	15972	15978	16070	16087	16093	16109	16276	16369	16380	16401	16406
				16441	18063
LAST CYCLE CHECK OVERFLOW	1932 #	5521	5532	5735	5747	5829	5835	5850	5856	5984	6075
				6215	6323	6354	6457	6495	6501	8108	8164	8263	8272	8964	9301
				9817
LAST CYCLE NO RETIRE		1933 #	3109	3155	4567	8941	19470	19506	19584	19624	21270
LEN(DL) 			1894 #	4623	5472	5519	5530	5574	5581	5632	5643	5733	5745
				5756	5768	5780	5932	5938	5955	5971	5982	6038	6065	6069	6121
				6176	6200	6213	6796	6804	7996	7999	8005	8035	8043	8217	8222
				8228	8233	8239	8244	8258	8267	8476	8501	8510	8527	8551	8560
				8577	8598	8867	8874	8918	8962	9160	9165	9182	9187	9204	9209
				9252	9258	9263	9277	9289	9295	9338	9349	10042	10092	10105	10119
				10133	10161	10174	10188	10202	10701	10735	11208	11326	11366	11559	11598
				11609	13439	13444	14897	14902	14908	14914	17303	17375	17580	17586	17594
				17621	17697	17719	17777	17783	17791	17870	17950	17959	17981	18039	18069
				18263	18276	18279	18334	18354	18366	18418	18430	18589	18608	18611	18796
				18811	19469	19505	19583	19623	19679	19715
LOAD PC 			1765 #	2573	3576	4060	4085	4345	4558	4661	4669	4798	8026
				8055	10046	13471	13952	19133	21070	21261
LONG				1895 #	2392	2397	2402	2409	2417	2422	2428	2457	2463	2468
				2473	2478	2483	2501	2507	2513	2519	2525	2532	2539	2546	2559
				2572	2593	2597	2613	2619	2625	2630	2635	2658	2675	3108	3256
				3260	3289	3292	3300	3303	3320	3325	3352	3368	3469	3474	3488
				3552	3575	3596	3614	3619	3626	3631	3660	3665	3669	3672	3680
				3688	3692	3696	3719	3728	3735	3798	3815	3832	3859	3865	3870
				3875	3887	3891	3900	3965	3985	4002	4003	4022	4023	4040	4052
				4059	4077	4084	4142	4149	4234	4250	4264	4271	4278	4293	4298
				4319	4324	4327	4331	4335	4341	4344	4350	4354	4370	4509	4524
				4535	4539	4557	4573	4592	4598	4604	4608	4626	4629	4633	4648
				4654	4660	4668	4684	4692	4696	4701	4706	4724	4731	4735	4739
				4745	4752	4768	4771	4777	4789	4797	4811	4815	4863	4872	4877
				4882	4890	4914	4919	4924	4929	4934	4939	4943	4947	4967	4976
				4984	4990	4998	5006	5023	5028	5036	5041	5048	5098	5105	5118
				5127	5160	5165	5179	5186	5189	5209	5219	5223	5224	5586	5794
				5799	5827	5833	5848	5854	5944	5961	6043	6048	6054	6118	6127
				6130	6186	6193	6206	6255	6259	6301	6306	6316	6320	6334	6340
				6346	6352	6366	6372	6378	6385	6427	6433	6444	6449	6454	6464
				6478	6481	6486	6493	6499	6513	6519	6525	6539	6545	6552	6557
				6572	6581	6588	6815	6819	6829	6838	6846	6858	6879	6890	6893
				6902	6912	6929	6933	6936	6941	6962	6972	6976	6981	6999	7003
				7010	7016	7041	7046	7064	7070	7091	7095	7102	7105	7123	7128
				7150	7155	7160	7165	7170	7175	7180	7185	7201	7206	7211	7216
				7221	7226	7231	7294	7300	7307	7320	7333	7341	7349	7403	7407
				7416	7420	7446	7450	7460	7464	7468	7482	7485	7494	7503	7519
				7523	7526	7530	7535	7563	7569	7597	7603	7607	7612	7618	7622
				7887	7899	8009	8025	8048	8051	8054	8103	8154	8159	8361	8366
				8378	8388	8404	8409	8421	8440	8445	8457	8468	8472	8489	8493
				8539	8543	8612	8656	8838	8842	8849	8854	8860	8871	8885	8889
				8896	8901	8907	8914	8931	8939	8945	8956	9005	9009	9017	9021
				9047	9057	9062	9085	9090	9096	9102	9108	9172	9194	9215	9218
				9225	9232	9243	9282	9300	9323	9328	9343	9354	9413	9418	9423
				9432	9437	9442	9448	9466	9474	9479	9497	9502	9505	9518	9522
				9525	9539	9543	9547	9567	9572	9581	9586	9591	9596	9613	9619
				9628	9634	9640	9661	9666	9676	9693	9698	9715	9720	9725	9730
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  660
;			     Cross Reference Listing - Macro Names						      /REV=
;
				9735	9740	9745	9750	9767	9772	9777	9782	9787	9792	9797	9807
				9839	9844	9849	9854	9859	10045	10051	10054	10066	10072	10226	10233
				10239	10243	10248	10252	10256	10274	10280	10286	10292	10298	10304	10310
				10316	10334	10340	10346	10352	10358	10363	10376	10380	10384	10389	10392
				10406	10412	10418	10424	10483	10490	10504	10528	10534	10540	10546	10552
				10558	10564	10587	10593	10599	10605	10611	10617	10623	10645	10651	10657
				10663	10669	10674	10689	10695	10707	10713	10717	10720	10868	10889	10932
				10944	10994	11047	11052	11056	11065	11070	11075	11080	11097	11102	11108
				11114	11130	11137	11152	11159	11218	11226	11236	11275	11279	11333	11352
				11373	11379	11382	11404	11410	11416	11422	11428	11434	11440	11445	11462
				11468	11474	11480	11486	11492	11498	11505	11510	11566	11584	11602	11614
				11618	11634	11640	11646	11652	11658	11664	11670	11675	11690	11696	11702
				11708	11714	11720	11726	11733	11913	11918	11923	11928	11933	11938	11943
				11947	12009	12016	12020	12024	12028	12047	12054	12059	12064	12152	12170
				12180	12185	12192	12201	12228	12234	12241	12247	12256	12287	12295	12303
				12320	12329	12338	12347	12356	12365	12397	12403	12407	12414	12418	12421
				12450	12459	12465	12470	12476	12512	12516	12522	12527	12551	12560	12587
				12595	12599	12703	12714	12752	12761	12767	12772	12804	12810	12836	12845
				12850	12854	12869	12873	12900	12913	12917	12961	13238	13245	13252	13259
				13276	13279	13286	13291	13296	13301	13305	13309	13313	13327	13334	13341
				13348	13365	13372	13379	13386	13403	13410	13417	13424	13447	13450	13453
				13457	13462	13470	13488	13491	13495	13500	13504	13531	13549	13660	13665
				13672	13675	13701	13706	13718	13740	13747	13756	13769	13791	13799	13804
				13809	13818	13840	13843	13846	13869	13874	13886	13895	13934	13944	13950
				13971	13977	13983	13989	13995	14001	14006	14011	14041	14045	14058	14064
				14070	14076	14090	14099	14111	14167	14238	14266	14272	14277	14281	14285
				14289	14293	14297	14310	14314	14318	14322	14326	14330	14334	14338	14342
				14365	14370	14374	14377	14381	14402	14412	14417	14421	14433	14436	14460
				14464	14469	14474	14478	14497	14507	14519	14523	14527	14541	14593	14615
				14620	14638	14643	14646	14654	14658	14673	14676	14680	14684	14696	14700
				14704	14708	14712	14716	14720	14731	14735	14739	14743	14747	14751	14755
				14766	14770	14774	14785	14834	14838	14848	14855	14862	14869	14885	14889
				14945	14950	14955	14960	14968	14974	14980	14986	15005	15011	15017	15030
				15036	15042	15048	15554	15559	15571	15575	15605	15613	15622	15628	15638
				15659	15664	15670	15677	15682	15693	15698	15703	15728	15733	15739	15744
				15749	15759	15765	15777	15782	15788	15792	15821	15847	15917	15925	15931
				15937	15943	15949	15962	15970	15976	15982	15986	15990	16002	16010	16016
				16021	16028	16033	16048	16056	16062	16065	16068	16074	16085	16091	16097
				16104	16107	16121	16124	16129	16136	16141	16146	16150	16156	16171	16177
				16193	16197	16222	16235	16239	16243	16280	16316	16332	16344	16350	16356
				16365	16376	16393	16419	16426	16451	16459	16465	16471	16477	16483	16495
				16503	16509	16515	16519	16523	16533	16540	16547	16551	16557	16562	16574
				16581	16587	16593	16603	16609	16615	16621	16624	16641	16647	16651	16663
				16670	16680	16686	16699	16713	16724	16729	16732	16738	16741	16749	16755
				16783	16789	16795	16801	16822	16828	16842	16848	16853	16859	16884	16887
				16895	16917	16936	16939	16954	16961	16967	16986	16993	17010	17014	17252
				17263	17268	17271	17286	17290	17293	17307	17318	17335	17342	17350	17356
				17359	17379	17390	17412	17420	17449	17455	17460	17465	17483	17490	17497
				17521	17524	17529	17532	17537	17540	17545	17568	17617	17626	17649	17660
				17665	17671	17693	17723	17728	17740	17765	17838	17866	17892	17896	17901
				17909	17914	17938	18008	18035	18044	18048	18052	18055	18061	18175	18184
				18187	18194	18198	18203	18219	18222	18230	18239	18284	18287	18307	18312
				18320	18325	18371	18374	18382	18390	18435	18438	18445	18453	18546	18550
				18555	18560	18564	18568	18604	18615	18636	18644	18651	18656	18676	18684
				18691	18764	18767	18771	18776	18815	18834	18842	18849	18871	18879	18886
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  661
;			     Cross Reference Listing - Macro Names						      /REV=
;
				18959	18964	18968	18988	18991	19003	19008	19013	19018	19032	19040	19048
				19116	19121	19127	19131	19152	19155	19159	19180	19183	19186	19189	19198
				19205	19227	19234	19239	19258	19261	19264	19269	20822	20827	20833	20842
				20849	20859	20865	20873	20894	20908	20916	20920	20930	20971	20976	20981
				20986	20990	20995	20999	21003	21020	21025	21030	21039	21044	21049	21053
				21057	21064	21069	21149	21153	21157	21162	21166	21170	21228	21234	21242
				21246	21260	21281	21290	21294
MACHINE CHECK []		1946 #	3688	3692	3696	4142	4149	4692	4696	10363	16954	17545
				19018
MEM (VA)&			1751 #	2658	3680	3900	4318	4324	4340	4370	5028	5041	5048
				7567	7616	7622	8509	8559	9666	10226	10233	10243	10248	10252	10256
				10274	10280	10286	10292	10298	10304	10310	10334	10340	10346	10352	10358
				10376	11614	11634	11640	11646	11652	11658	11664	11670	11690	11696	11702
				11708	11714	11720	11726	11928	11933	11938	11943	12054	12059	12402	12412
				12418	12511	12516	12522	12527	12560	12804	12913	12917	12960	13495	13500
				13504	14469	17594	17621	17791	17959	17981	18069	20985	20990	20995	20999
				21003	21020	21025	21030	21049	21053	21162	21166
MEM.NOCHK (VA)& 		1754 #	3618
MEM.PCB (VA)&			1756 #	14673	14696	14700	14704	14708	14712	14716	14720	14731	14735
				14739	14743	14747	14751	14755	14766	14770	14785
MEM.PHYS (VA)&			1755 #	3630	17013
MEM.PR (VA)&			1752 #	2401	2408	2462	2483	2594	2598	4250	4354	4815	6043
				14088	14099	14401	14416	14478	14540	14774	16001	16009	16020	16032	16047
				16055	16171	16192	16197	16425
MEM.UNLOCK (VA)&		1753 #	5185	6068	8526	8576	12227	12233	12286	12294	12302	12319
				12328	12337	12346	12355	12364	12598
MPU <-- B.29..16 []		1911 #	7106	7134	7236	10244	10485	11334	11567
MULL				1912 #	8931

NODST <-- (-[] + [])		1659 #
NODST <-- -000000[]		1693 #
NODST <-- -0000[]00		1704 #
NODST <-- -00[]0000		1715 #
NODST <-- -K10.[]		1682 #
NODST <-- -[]			1666 #	9277
NODST <-- -[]000000		1726 #
NODST <-- 0			1859 #
NODST <-- 000000[]		1694 #
NODST <-- 000000[] - [] 	1687 #
NODST <-- 0000[]00		1705 #
NODST <-- 0000[]00 - [] 	1698 #
NODST <-- 00[]0000		1716 #
NODST <-- 00[]0000 - [] 	1709 #
NODST <-- B []			1668 #
NODST <-- K10.[]		1683 #
NODST <-- K10.[] - []		1676 #
NODST <-- NOT 000000[]		1692 #
NODST <-- NOT 0000[]00		1703 #
NODST <-- NOT 00[]0000		1714 #
NODST <-- NOT K10.[]		1681 #
NODST <-- NOT []		1667 #
NODST <-- NOT [] AND [] 	1655 #
NODST <-- NOT []000000		1725 #
NODST <-- PASSA []		1857 #
NODST <-- PASSB 000000[]	1868 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  662
;			     Cross Reference Listing - Macro Names						      /REV=
;
NODST <-- PASSB 0000[]00	1869 #
NODST <-- PASSB 00[]0000	1870 #
NODST <-- PASSB K10.[]		1867 #
NODST <-- PASSB []		1858 #
NODST <-- PASSB []000000	1871 #
NODST <-- SEXT [] RSH (32-SC)	1855 #
NODST <-- SEXT [] RSH (SC)	1854 #
NODST <-- SEXT [] RSH []	1853 #
NODST <-- ZEXT [] RSH (SC)	1863 #
NODST <-- ZEXT [] RSH []	1862 #	7341
NODST <-- []			1661 #	18561
NODST <-- [] + 000000[] 	1685 #
NODST <-- [] + 0000[]00 	1696 #
NODST <-- [] + 00[]0000 	1707 #
NODST <-- [] + 1		1662 #
NODST <-- [] + 4		1664 #
NODST <-- [] + K10.[]		1674 #
NODST <-- [] + []		1651 #
NODST <-- [] + [] + 1		1652 #
NODST <-- [] + []000000 	1718 #
NODST <-- [] - 000000[] 	1686 #
NODST <-- [] - 0000[]00 	1697 #
NODST <-- [] - 00[]0000 	1708 #
NODST <-- [] - 1		1663 #
NODST <-- [] - 4		1665 #
NODST <-- [] - K10.[]		1675 #
NODST <-- [] - []		1653 #	8159	8258	8267	11047
NODST <-- [] - []000000 	1719 #
NODST <-- [] AND 000000[]	1688 #
NODST <-- [] AND 0000[]00	1699 #
NODST <-- [] AND 00[]0000	1710 #	14638
NODST <-- [] AND K10.[] 	1677 #
NODST <-- [] AND []		1654 #
NODST <-- [] AND []000000	1721 #
NODST <-- [] ANDNOT 000000[]	1690 #	15559	15575
NODST <-- [] ANDNOT 0000[]00	1701 #
NODST <-- [] ANDNOT 00[]0000	1712 #
NODST <-- [] ANDNOT K10.[]	1679 #
NODST <-- [] ANDNOT []		1656 #
NODST <-- [] ANDNOT []000000	1723 #
NODST <-- [] LROT (SC)		1845 #
NODST <-- [] LROT []		1844 #
NODST <-- [] LSH (SC)		1861 #
NODST <-- [] LSH []		1860 #	14835
NODST <-- [] OR 000000[]	1689 #
NODST <-- [] OR 0000[]00	1700 #
NODST <-- [] OR 00[]0000	1711 #
NODST <-- [] OR K10.[]		1678 #
NODST <-- [] OR []		1657 #
NODST <-- [] OR []000000	1722 #
NODST <-- [] RROT (SC)		1847 #
NODST <-- [] RROT []		1846 #
NODST <-- [] XOR 000000[]	1691 #
NODST <-- [] XOR 0000[]00	1702 #
NODST <-- [] XOR 00[]0000	1713 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  663
;			     Cross Reference Listing - Macro Names						      /REV=
;
NODST <-- [] XOR K10.[] 	1680 #
NODST <-- [] XOR []		1658 #
NODST <-- [] XOR []000000	1724 #
NODST <-- []!![] LSH (SC)	1849 #
NODST <-- []!![] LSH [] 	1848 #
NODST <-- []!![] RSH (32-SC)	1852 #
NODST <-- []!![] RSH (SC)	1851 #
NODST <-- []!![] RSH [] 	1850 #
NODST <-- []000000		1727 #
NODST <-- []000000 - [] 	1720 #

NOP				1733 #	6054	8366	9243	9282	9448	9581	9591	9693	9698	10674
				10932	10994	11275	11445	11584	11675	14238	14593	14945	14950	14955	15917
				15962	16121	16451	16495	18374	18438	18834	18871	21234	21242	21290	21294
NOP NODEST			1734 #	3108	8931	21228
Q <-- 0 			1815 #	2447	2602	3790	3807	3824	4501	21142
Q <-- PASSA []			1813 #	3326	3369	4228	6797	7295	8469	8490	8540	8656	8838
				8885	8945	9005	9161	9183	9205	9355	9466	11057	11220	11228	11914
				11919	12010	12154	13769	13895	14901	14913	15765	16962	20827	21045
Q <-- PASSB 000000[]		1834 #	17484	17491	17498
Q <-- PASSB 0000[]00		1835 #
Q <-- PASSB 00[]0000		1836 #
Q <-- PASSB K10.[]		1833 #
Q <-- PASSB []			1814 #	4299	5795	5940	6973	7350	8000	8034	8042	8155	8218
				8229	8240	9414	9548	10040	12704	12715	13660	14616	15556	17581	17778
				18184	18195	18200	18551	18556	20843	20860	20895	20931
Q <-- PASSB []000000		1837 #	2473	2560	3461	3843	3956	3976	3994	4014	4031	4239
				4516	10860	10881	13550
Q <-- SEXT [] RSH (32-SC)	1811 #	6306
Q <-- SEXT [] RSH (SC)		1810 #	6464
Q <-- SEXT [] RSH []		1809 #	6186	6193	6206	6894	7486
Q <-- ZEXT [] RSH (SC)		1819 #	8378	8422	8458
Q <-- ZEXT [] RSH []		1818 #	5157	13665	16741	17265	17287	17651	17840	18010
Q <-- [] LROT (SC)		1801 #
Q <-- [] LROT []		1800 #
Q <-- [] LSH (SC)		1817 #	4573	15622	15638
Q <-- [] LSH [] 		1816 #	2464	5165	6118	6127	6177	6201	6903	7102	7495	8006
				8919	9166	9188	10055	10713	11328	11561	13440	13454	13951	15659	17253
				17893	17901	19261	19269
Q <-- [] RROT (SC)		1803 #
Q <-- [] RROT []		1802 #
Q <-- []!![] LSH (SC)		1805 #
Q <-- []!![] LSH []		1804 #
Q <-- []!![] RSH (32-SC)	1808 #
Q <-- []!![] RSH (SC)		1807 #
Q <-- []!![] RSH []		1806 #	10094	10107	10121	10135	10163	10176	10190	10204	10484	18968

Q&				1892 #	5573	5580	6334	6340	6346	6433	6448	6481	6525	8866
				13280	13328	13335	13342	13349	13366	13373	13380	13387	13404	13411	13418
				13425

RESERVED ADDRESSING MODE	1949 #
RESERVED INSTRUCTION FAULT	1948 #	3334	3363	3393	3397	10948	10952	10956	14246	14250	14254
				14603	14607	14611	15585	15589	15593	19952	20007	20054	20101	20144	20181
				20219	20281	20330	20376	20416	20455	20494	20532
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  664
;			     Cross Reference Listing - Macro Names						      /REV=
;
RESERVED OPERAND FAULT		1947 #	6061	6863	6868	6875	7355	7359	7363	7376	8374	8417
				8453	9802	10100	10114	10128	10142	10169	10183	10197	10211	10499	12505
				12797	12862	12907	12953	13714	13752	13764	13814	13882	13900	13907	13911
				13915	13946	14150	14154	14158	14162	14173	14178	14183	16257	16308	16312
				16637	16705	16709	16761	19274
RESET CPU			1905 #	2448	3462	3791	3808	3825	3844	3957	3977	3995	4015
				4032	4138	4220	4502	4517	5234	10861	10882	13551	21143	21238
RESTART IBOX			1903 #	4566	9816	10425	10722	11360	11512	11593	11734	13505	13972
				13978	13984	13990	13996	14501	14508	15688	15926	15932	15938	15944	15950
				15971	15977	16069	16086	16092	16099	16108	16131	16179	16275	16333	16351
				16357	16368	16379	16400	16405	16440	18062	21269
RESTART MBOX			1904 #	3143	5121	6074	6816	6881	6964	6983	7321	7371	7570
				7623	8389	8477	8511	8528	8561	8578	11944	12065	12272	12601	18969
				21254
RETIRE COND BQ ENTRY		1769 #	7819	8105	8161	8260	8269	8379	8423	8459	8657
RETIRE INSTRUCTION		1878 #	5220	9344	10939	11161
RETIRE UNCOND BQ ENTRY		1768 #	7826	7888

RETURN				1926 #	4371	5049	5129	6465	8390	8614	9053	9063	9109	9356
				9860	10737	14168	14528	14542	14786	16157	16903	16925	16994	18070	19036
				19044	19052	20874	21072
SC <-- A []			1910 #	4540	6256	6302	6428	6821	6837	6940	6976	7296	7403
				7452	7527	7534	7600	7609	8362	8405	8441	15561	15576
SET PSL CC.IIII 		1914 #	5473	5520	5734	5828	5834	6039	6070	6122	6131	6178
				6202	6317	6335	6341	6347	6367	6373	6379	6386	6445	6482	6514
				6520	6540	6546	6553	6573	7004	7130	8875	8921	8958	9018	9253
				9290	9296	9339	9433	9519	9614	9620	9629	9635	9641	11131	11153
				11160	12242	12248	12408	12471	12805	12919	12962	17741	18189	18204	18547
				18645	18685	18768	18843	18880
SET PSL CC.IIIJ 		1916 #	5531	5746	5849	5855	5983	18616	18816
SET PSL CC.IIIP 		1913 #	5575	5582	5644	5757	5769	5781	5933	5939	5956	5962
				5972	6260	7017	7065	7071	8104	8156	8223	8234	8245	14969	14975
				14981	14987	15006	15012	15018	15031	15037	15043	15049	15555	16460	16466
				16472	16478	16484	16504	16510	16588	16604	16610	16616	16625	16642	16664
				16681	16687	16733	16756	16784	16790	16796	16802	16823	16829	16854	16860
SET PSL CC.IIIP.QUAD		1917 #	5945	6450	6582	6589	9022
SET PSL CC.JIZJ 		1915 #	5633	7011	8001	11948	12025	17304	17376	18280	18367	18431
SET PSL CC.PPJP 		1918 #	6214	6322	6353	6456	6494	6500	8963	9300	9343	9522
				12047	16280
SET PSL(V)			1735 #	9300	9343	9522	12047	16280
SIM ADDR []			1959 #	2403	2410	2459	2485	3470	3661	3666	3861	3888	3967
				3987	4005	4042	4081	4295	4610	4656	4702	4732	4747	4754	5030
				5043	5102	5162	5182	5191	6051	6913	8037	8044	8479	8503	8523
				8553	8573	9663	10228	10235	10703	10870	10891	11368	11374	11604	11610
				11620	11915	11920	11929	11934	11939	12031	12055	12060	12156	12174	12398
				12409	12461	12473	12523	12564	12592	12722	12754	12806	12870	12876	13240
				13247	13254	13261	13282	13330	13337	13344	13351	13368	13375	13382	13389
				13406	13413	13420	13427	14268	14403	14409	14418	14427	14471	14622	14850
				14857	14864	14871	14904	14916	16004	16012	16023	16035	16050	16058	16199
				16535	16542	16548	16558	16576	16583	16701	20972	20978	21040	21150
SIM ADDR [] + K 		1961 #	10493	12012	12452	12518	12838	12921	12964
SIM ADDR [] - K 		1960 #	10096	10110	10124	10138	10165	10179	10193	10207	10377	11384
				11599	11615	20982	21050	21158
SIM COND K S3.[]		1965 #	4893	6050	6435	6466	10068	10074	10486	11211	12155	12195
				12472	12710	12721	12769	12851	12875	13459	13466	14840	14931	14936
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  665
;			     Cross Reference Listing - Macro Names						      /REV=
;
SIM COND K S4.[]		1966 #	9415	9419	9499	9550	9861	11049	11053	13661	14048	14640
SIM COND []			1967 #	6303	6429	7297	8002	8219	8230	8241	9162	9184	9206
				10059	11330	11563	12021	12182	12207	12856	15563	15578	18281	18368	18432
				18612	18812
SIM EMULATE			1975 #	20973
SIM EXCEPTION			1973 #	2452	3465	3795	3812	3829	3848	3999	4019	4036	4224
				4505	4520	10864	10885	13554
SIM HALT			1971 #	2475
SIM IE.INTEXC			1972 #	4894
SIM RSVD OPCODE 		1974 #	3961	3981
SIM VECTOR FAULT		1976 #
STATE.0 <-- 1			1907 #	4864	9329	9467	10108	10177	12717	17413	19240	20823	20866
STATE.1 <-- 1			1908 #	9350	9443	10122	10191	11103	11109	17897	19265	20850
STATE.2 <-- 1			1909 #	9436	10136	10205	13534	14909	17450	17652	17841	18011
STATE.3 <-- 1			1884 #	12202	17272	17308	17380	17886	18231	18240	18590	18797	19122
STATE.3-0 <-- 0 		1906 #	3674	3711	3893	4054	4078	4300	4791	5090	5180	12258
				12265	12288	12296	12304	12321	12330	12339	12348	12357	12366	12589	17729
				18056	18383	18396	18446	18458	18657	18854	18992	19033	19041	19049
STATE.4 <-- 1			1885 #	3673	3892	4053	4790
STATE.5 <-- 1			1886 #	2589	3710	4294
STATE.5-4 <-- 0 		1883 #	2502	2508	2514	2520	2526	2533	2540	2547	2576	4560
				4663	4671	4816	15687
SYNCHRONIZE MBOX		1759 #	2426	3141	3154	4565	9670	10101	10115	10129	10143	10170
				10184	10198	10212	10734	11731	12048	12762	13533	13933	14002	14007	14012
				14437	15705	16300	16439	19160	19199	19206	21256	21265
TB INVALIDATE ALL		1762 #	16216	21250
TB INVALIDATE PROCESS		1761 #	14366
TB INVALIDATE SINGLE		1760 #	3489	3553	13563	16223
TB PTE FILL			1764 #	16377
TB TAG FILL			1763 #	16366

UNIMPLEMENTED MFPR REGISTER []	1952 #	15744	15759	16515	16519	16523	16593	16647	16651	16713	16724
UNIMPLEMENTED MTPR REGISTER []	1951 #	15693	15698	15982	15986	15990	16074	16146	16150	16235	16239
VA <-- (-[] + [])		1518 #
VA <-- -000000[]		1611 #
VA <-- -0000[]00		1622 #
VA <-- -00[]0000		1633 #
VA <-- -K10.[]			1600 #
VA <-- -[]			1525 #	9422
VA <-- -[]000000		1644 #
VA <-- 000000[] 		1612 #
VA <-- 000000[] - []		1605 #
VA <-- 0000[]00 		1623 #
VA <-- 0000[]00 - []		1616 #
VA <-- 00[]0000 		1634 #
VA <-- 00[]0000 - []		1627 #
VA <-- B []			1527 #	4626	6048	8913	11912	14847
VA <-- K10.[]			1601 #	2400	2407	2456	2482	2593	2597	3468	3473	3596	3659
				4249	4353	4812	5098	5160	5189	5223	6042	14087	14098	14400	14406
				14415	14424	14477	14773	16000	16008	16019	16031	16046	16054	16170	16191
				16196	16532	16539	16546	16556	16573	16580	16669	16698	19127	20970
VA <-- K10.[] - []		1594 #
VA <-- NOT 000000[]		1610 #	6432
VA <-- NOT 0000[]00		1621 #
VA <-- NOT 00[]0000		1632 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  666
;			     Cross Reference Listing - Macro Names						      /REV=
;
VA <-- NOT K10.[]		1599 #
VA <-- NOT []			1526 #	6477
VA <-- NOT [] AND []		1514 #
VA <-- NOT []000000		1643 #
VA <-- []			1520 #	3614	3626	3664	5178	8957	9661	10041	11378	11932	11937
				12028	12058	12406	12521	12559	12586	12751	13562	14265	14619	14854	14861
				14868	14960	16264	16364	16375	16424	16847	17295	18174	18262	18275	18333
				18353	18417	18588	18795
VA <-- [] + 000000[]		1603 #	3858	3886	3964	3984	4002	4022	4039	4076	4292	4700
				4730	4744	4751	10489	10527	10533	10539	10545	10551	10557	10563	10867
				10888	13237	13244	13251	13258	13519	16935	21038	21148	21280
VA <-- [] + 0000[]00		1614 #
VA <-- [] + 00[]0000		1625 #
VA <-- [] + 1			1521 #
VA <-- [] + 4			1523 #	2661	6971	7596	10242	10247	10251	10255	10273	10279	10285
				10291	10297	10303	10309	10333	10339	10345	10351	10357	10503	10569	10586
				10592	10598	10604	10610	10616	10622	10644	10650	10656	10662	10668	10706
				11403	11409	11415	11421	11427	11433	11439	11461	11467	11473	11479	11485
				11491	11497	11633	11639	11645	11651	11657	11663	11669	11689	11695	11701
				11707	11713	11719	11725	11923	11927	11942	12008	12053	12397	12417	12449
				12459	12515	12526	12803	12835	12868	12916	12959	13499	13503	14271	14276
				14280	14284	14288	14292	14296	14309	14313	14317	14321	14325	14329	14333
				14337	14341	14380	14518	14522	14526	14695	14699	14703	14707	14711	14715
				14719	14730	14734	14738	14742	14746	14750	14754	14765	14769	14784	16993
				20989	20994	20998	21002	21019	21024	21029	21161
VA <-- [] + K10.[]		1592 #	4622
VA <-- [] + []			1510 #	4607	4633	8033	8041	8475	8500	8519	8550	8569	10700
				11365	12468	14900	14912	16946	17776	17869	18038	18607
VA <-- [] + [] + 1		1511 #	11372
VA <-- [] + []000000		1636 #
VA <-- [] - 000000[]		1604 #	10225	10232	13443	20981	21156
VA <-- [] - 0000[]00		1615 #
VA <-- [] - 00[]0000		1626 #
VA <-- [] - 1			1522 #	10161	10174	10188	10202	11598	13279	13327	13334	13341	13348
				13365	13372	13379	13386	13403	13410	13417	13424
VA <-- [] - 4			1524 #	3679	3899	4317	4323	4339	4369	5027	5040	5047	7621
				10092	10105	10119	10133	10375	11382	11613	12015	14468	20976	21048	21052
				21165
VA <-- [] - K10.[]		1593 #
VA <-- [] - []			1512 #	17579	17585	17696	17718
VA <-- [] - []000000		1637 #
VA <-- [] AND 000000[]		1606 #
VA <-- [] AND 0000[]00		1617 #
VA <-- [] AND 00[]0000		1628 #
VA <-- [] AND K10.[]		1595 #
VA <-- [] AND []		1513 #	17290	18546	18767	19152
VA <-- [] AND []000000		1639 #
VA <-- [] ANDNOT 000000[]	1608 #	4653	6819	6911	7502	8361	8404	8440	12169
VA <-- [] ANDNOT 0000[]00	1619 #
VA <-- [] ANDNOT 00[]0000	1630 #
VA <-- [] ANDNOT K10.[] 	1597 #
VA <-- [] ANDNOT []		1515 #
VA <-- [] ANDNOT []000000	1641 #
VA <-- [] OR 000000[]		1607 #
VA <-- [] OR 0000[]00		1618 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  667
;			     Cross Reference Listing - Macro Names						      /REV=
;
VA <-- [] OR 00[]0000		1629 #
VA <-- [] OR K10.[]		1596 #
VA <-- [] OR [] 		1516 #
VA <-- [] OR []000000		1640 #
VA <-- [] XOR 000000[]		1609 #
VA <-- [] XOR 0000[]00		1620 #
VA <-- [] XOR 00[]0000		1631 #
VA <-- [] XOR K10.[]		1598 #
VA <-- [] XOR []		1517 #
VA <-- [] XOR []000000		1642 #
VA <-- []000000 		1645 #	2392
VA <-- []000000 - []		1638 #

VA&				1897 #	2601	3488	6176	6200	11602	11608	11618	11918	12152	12714
				12873	16222	17782	17949
WAIT BDISP VALID		1767 #	8520	8570	8613
WCHK (VA)&			1757 #	10092	10105	10119	10133	10161	10174	10188	10202	11598	11608
				11918	11923	12028	12152	12714	12809	17585	17718	17782	17949	18038	20976
				21156
[] <-- (-[] + [])		1493 #	5745	7526	10066	10072	12180	12511	14045	17303	17375
[] <-- -000000[]		1552 #
[] <-- -0000[]00		1563 #
[] <-- -00[]0000		1574 #
[] <-- -K10.[]			1541 #
[] <-- -[]			1502 #	5982	9258	9263	9328	9349	9442	9479	9547	9586	9596
				17892
[] <-- -[]000000		1585 #
[] <-- 0			1790 #	6858	8949	10226	10233	16365	16376
[] <-- 000000[] 		1553 #	2587	3798	3815	3832	3865	3870	3875	6879	7016	8839
				8886	9300	9343	9437	9522	9525	11097	11102	11108	11114	12047	14968
				14974	14980	14986	15005	15011	15017	15030	15036	15042	15048	16280	17740
				18048	18052	18055	18061	18636	18656	18676	19003	19008	19013
[] <-- 000000[] - []		1546 #	6838	6890	7320	7482	12241	17390
[] <-- 0000[]00 		1564 #	21275
[] <-- 0000[]00 - []		1557 #
[] <-- 00[]0000 		1575 #	3688	3692	3696	4142	4149	4648	4692	4696	4735	10363
				16954	17545	19018
[] <-- 00[]0000 - []		1568 #
[] <-- B []			1504 #	4227	6255	6796	6893	6941	6977	7294	7404	7485	7535
				7887	7899	8005	8946	9006	9160	9182	9204	9681	9685	10054	10483
				11208	11918	12152	13453	13664	13950	14370	14377	17252	17524	17532	17540
[] <-- K10.[]			1542 #
[] <-- K10.[] - []		1535 #
[] <-- MEM (VA) 		1739 #	6912	6972	8035	8043	8476	10042	10490	10504	10528	10534
				10540	10546	10552	10558	10564	10587	10593	10599	10605	10611	10617	10623
				10645	10651	10657	10663	10669	10689	10701	11366	11373	11379	11404	11410
				11416	11422	11428	11434	11440	11462	11468	11474	11480	11486	11492	11498
				11505	12009	12016	12450	12752	12836	12869	17580	17697	17777	17870	18263
				18276	18334	18354	18418	18589	18608	18796
[] <-- MEM.LOCK (VA)		1741 #	5179	6065	8598	12170	12587
[] <-- MEM.NOCHK (VA)		1746 #	3615
[] <-- MEM.PCB (VA)		1743 #	14266	14272	14277	14281	14285	14289	14293	14297	14310	14314
				14318	14322	14326	14330	14334	14338	14342	14381	14519	14523	14527
[] <-- MEM.PHYS (VA)		1744 #	3627	17010
[] <-- MEM.PR (VA)		1740 #	2457	3469	3474	3597	3660	4623	5118	5209	5224	16533
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  668
;			     Cross Reference Listing - Macro Names						      /REV=
;
				16540	16547	16557	16574	16581	16670	16699	16848	19128	20971	21281
[] <-- MEM.SCB (VA)		1742 #	3665	3859	3887	3965	3985	4003	4023	4040	4077	4293
				4608	4654	4701	4731	4745	4752	10868	10889	13238	13245	13252	13259
				16936	21039	21149
[] <-- MEM.WCHK (VA)		1745 #	7503	7597	8501	8551	11913
[] <-- NOT 000000[]		1551 #
[] <-- NOT 0000[]00		1562 #
[] <-- NOT 00[]0000		1573 #
[] <-- NOT K10.[]		1540 #
[] <-- NOT []			1503 #	5971	7091	9474	12703	20920
[] <-- NOT [] AND []		1489 #	8457	8559	8576
[] <-- NOT []000000		1584 #
[] <-- PASSA [] 		1788 #	2401	2408	2483	2594	2598	4250	4354	4811	5944	6043
				6049	6433	6478	6820	8160	8259	8956	11048	14090	14099	14401	14407
				14416	14425	14478	14639	14774	15560	16001	16009	16020	16032	16047	16055
				16171	16192	16197
[] <-- PASSB 000000[]		1826 #	4340	5573	5580	6334	6340	6346	6513	6519	6525	12960
				13280	13328	13335	13342	13349	13366	13373	13380	13387	13404	13411	13418
				13425	14855	14862	14869
[] <-- PASSB 0000[]00		1827 #
[] <-- PASSB 00[]0000		1828 #
[] <-- PASSB K10.[]		1825 #
[] <-- PASSB [] 		1789 #	2658	3680	3900	4318	4324	4370	5028	5041	5048	6301
				6427	7622	8268	9278	9423	9666	10243	10248	10252	10256	10274	10280
				10286	10292	10298	10304	10310	10334	10340	10346	10352	10358	10376	10707
				11614	11634	11640	11646	11652	11658	11664	11670	11690	11696	11702	11708
				11714	11720	11726	11924	11928	11933	11938	11943	12029	12054	12059	12407
				12418	12470	12516	12522	12527	12560	12804	12917	13500	13504	14469	14620
				14696	14700	14704	14708	14712	14716	14720	14731	14735	14739	14743	14747
				14751	14755	14766	14770	14785	16425	17293	18175	18560	18764	20990	20995
				20999	21003	21020	21025	21030	21049	21053	21162	21166
[] <-- PASSB []000000		1829 #
[] <-- PROBE.R.MODE (VA)	1747 #	3534	14897	14902
[] <-- PROBE.R.MODE.NOFILL (VA) 1749 #	16265
[] <-- PROBE.W.MODE (VA)	1748 #	3539	13439	13444	14908	14914
[] <-- SEXT [] RSH (32-SC)	1786 #	6384	6551
[] <-- SEXT [] RSH (SC) 	1785 #	7041	7064
[] <-- SEXT [] RSH []		1784 #	6121	6130	6366	6372	6378	6539	6545	6557	8051	8472
				8493	8543	13488
[] <-- ZEXT [] RSH (SC) 	1794 #	7046	7070	7095
[] <-- ZEXT [] RSH []		1793 #	3253	3300	3504	4535	8866	8871	8914	9677	13672	16261
				16615	16624	16732	16859	16884	16967	19116	19159	19180	20916	20977
[] <-- []			1497 #	2474	2501	2507	2513	2519	2525	2559	2601	3108	3488
				3552	3575	3672	3891	4052	4234	4238	4298	4327	4331	4335	4350
				4557	4660	4668	4684	4789	4815	4890	4914	4919	4924	4929	4967
				4984	5023	5036	5127	5219	5472	5586	5794	5932	5938	6054	6176
				6200	6804	6999	7003	7307	7340	7349	7420	7460	8217	8228	8239
				8366	8388	8918	8931	9009	9017	9021	9165	9187	9209	9243	9252
				9282	9289	9295	9323	9338	9413	9418	9432	9448	9518	9581	9591
				9613	9619	9628	9634	9640	9693	9698	9715	9720	9725	9730	9735
				9740	9745	9750	9767	9772	9777	9782	9787	9792	9797	9807	10392
				10424	10674	10695	10720	10735	10932	10994	11130	11152	11159	11236	11275
				11279	11445	11510	11584	11675	12064	12185	12201	12233	12256	12286	12294
				12302	12319	12328	12337	12346	12355	12364	12551	12598	12714	13276	13286
				13291	13296	13457	13462	13491	13495	13531	13549	13659	13944	13971	13977
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  669
;			     Cross Reference Listing - Macro Names						      /REV=
;
				13983	13989	13995	14058	14064	14070	14076	14238	14365	14374	14464	14593
				14615	14643	14646	14673	14676	14680	14684	14834	14945	14950	14955	15554
				15571	15917	15925	15931	15937	15943	15949	15962	15970	15976	16062	16121
				16222	16332	16344	16356	16419	16451	16459	16465	16471	16477	16483	16495
				16503	16509	16603	16609	16621	16680	16686	16783	16789	16795	16801	16822
				16828	16842	16853	16895	16986	17263	17271	17286	17307	17318	17350	17356
				17359	17379	17420	17594	17621	17660	17791	17914	17959	17981	18069	18194
				18198	18222	18230	18239	18374	18438	18550	18555	18564	18568	18771	18776
				18834	18871	19155	19189	19198	20822	20833	20842	20849	20859	20865	20873
				20894	20908	20930	21141	21153	21228	21234	21242	21246	21260	21285	21290
				21294
[] <-- [] + 000000[]		1544 #	3644	3649	3654	4603	7150	7155	7160	7165	7170	7175
				7180	7185	10045
[] <-- [] + 0000[]00		1555 #
[] <-- [] + 00[]0000		1566 #	14421	16551
[] <-- [] + 1			1498 #	2675	5519	8154	18307	18312	18320	18325	18382	18390	18445
				18453	18644	18651	18684	18691	18842	18849	18879	18886
[] <-- [] + 4			1500 #	11566	11733
[] <-- [] + K10.[]		1533 #
[] <-- [] + []			1484 #	5733	5827	6038	6068	6902	6929	7123	7494	7519	8054
				8222	8233	8244	9572	10717	11065	11070	11075	11080	11326	11559	12192
				12767	12850	12873	17014	17412	17521	17529	17537	17617	17626	17665	17671
				17723	17728	17949	18988	18991	19131	19227	19239	19258
[] <-- [] + [] + 1		1485 #	5833	8009	8025	11352
[] <-- [] + []000000		1577 #	16027
[] <-- [] - 000000[]		1545 #	6815	7201	7206	7211	7216	7221	7226	7231	10380	10389
				14474	16939	17449	17455	17460	17465	17483	17490	17497	21057	21170
[] <-- [] - 0000[]00		1556 #
[] <-- [] - 00[]0000		1567 #	13756	13818	13846	14412	16016	17342
[] <-- [] - 1			1499 #	5530	8103	11333	14889	18284	18287	18371	18435	18615	18815
[] <-- [] - 4			1501 #	10384
[] <-- [] - K10.[]		1534 #
[] <-- [] - []			1486 #	5632	5848	6936	7010	7324	7996	7999	8854	8901	9062
				9354	9497	9502	11052	11602	11608	11618	11947	12024	12402	12412	12421
				12465	12476	12772	12810	12900	12913	13718	13886	17268	17335	17568	17649
				17693	17765	17782	17838	17866	17938	18008	18035	18044	18279	18366	18430
				18964	19205	19234
[] <-- [] - [] - 1		1487 #	5854
[] <-- [] - []000000		1578 #	16561
[] <-- [] AND 000000[]		1547 #	2613	2619	3256	3289	3303	3669	5799	5954	6933	7300
				7523	8468	8489	8539	10710	15605	15677	15682	15739	16118	16140	16587
				16917	18604	20985
[] <-- [] AND 0000[]00		1558 #	15749	15764
[] <-- [] AND 00[]0000		1569 #	4508	4523	4863	13447	13706	13747	13799	13804	13809	13843
				13874	14167	14489	16728
[] <-- [] AND K10.[]		1536 #
[] <-- [] AND []		1488 #	4629	5643	5961	14838	15728	16136	16961	18187	18203	18219
				18611	19183	19186
[] <-- [] AND []000000		1580 #	13768	13894	14041	15670	15733	15821
[] <-- [] ANDNOT 000000[]	1549 #	3324	3367	4059	4084	4344	4797	5185	10051	10315	12595
				13470	15777	15782	16085	16091	16156	16641	16887	21043	21069
[] <-- [] ANDNOT 0000[]00	1560 #	2635	13700	13740	13791	13840	13868
[] <-- [] ANDNOT 00[]0000	1571 #	4221	4719	13675	14496	15664
[] <-- [] ANDNOT K10.[] 	1538 #
[] <-- [] ANDNOT []		1490 #	4591	4597	5105	5768	11226	16316
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  670
;			     Cross Reference Listing - Macro Names						      /REV=
;
[] <-- [] ANDNOT []000000	1582 #	9567	14460	19120	21064
[] <-- [] LROT (SC)		1775 #	6259
[] <-- [] LROT []		1774 #	16068
[] <-- [] LSH (SC)		1792 #	6316	6444	6481	6962	8409	8445	8612	16124
[] <-- [] LSH []		1791 #	4539	7105	8048	8842	8874	8889	14430	14540	14848	14885
				15613	15628	15693	15698	15703	15744	15759	15847	15982	15986	15990	16074
				16104	16146	16150	16235	16239	16243	16393	16515	16519	16523	16593	16647
				16651	16663	16713	16724	16942
[] <-- [] OR 000000[]		1548 #	10406	10412	10418	12227	12761	12845	14110	16754
[] <-- [] OR 0000[]00		1559 #	2428	2531	2538	2545	3719	3728	3735	4264	4271	4278
				4771	4939	4943	4947	4998	5006	10944	13301	13305	13309	13313	14001
				14006	14011
[] <-- [] OR 00[]0000		1570 #	2397	2478	2572	4552	4872	4877	4882	4990	14506	14654
[] <-- [] OR K10.[]		1537 #
[] <-- [] OR [] 		1491 #	2468	4231	4777	5756	6493	6499	8421	8509	8526	10239
				11218	13450	13934	16097	16129	16177	16749	19032	19040	19048
[] <-- [] OR []000000		1581 #	3619	3631	4705	4723	4738	4767	4934	4976	14658	16349
				18959
[] <-- [] RROT (32-SC)		1778 #
[] <-- [] RROT (SC)		1777 #	6846	7333	7416	7468	7530	7567	7616
[] <-- [] RROT []		1776 #	14436
[] <-- [] SMUL []		1495 #	8849	8860	8896	8907	9047	9057	9085	9090	9096	9102
				9108	11137
[] <-- [] UDIV []		1494 #	9172	9194	9215	9218	9225	9232	9505	9539	9839	9844
				9849	9854	9859
[] <-- [] XOR 000000[]		1550 #	3260	3292	3320	3352	11056	15787	15791
[] <-- [] XOR 0000[]00		1561 #
[] <-- [] XOR 00[]0000		1572 #
[] <-- [] XOR K10.[]		1539 #
[] <-- [] XOR []		1492 #	2462	5780	6213	6320	6352	6454	6486	8962	12020	12854
				18811
[] <-- [] XOR []000000		1583 #
[] <-- []!![] LSH (SC)		1780 #	6448	6981	7464	7612
[] <-- []!![] LSH []		1779 #	14433
[] <-- []!![] RSH (32-SC)	1783 #	6571	6580	6587	7407	7446	7450	7563	7603	7607
[] <-- []!![] RSH (SC)		1782 #	6829
[] <-- []!![] RSH []		1781 #	2625	2630	7128	9543	16065	16107	17896	17909	19264
[] <-- []000000 		1586 #	2417	2422	16738
[] <-- []000000 - []		1579 #	12247
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  671
;			     Cross Reference Listing - Expression Names 					      /REV=
;
BEH.MODEL			42 #
MICROCODE.DP.FLAG		117 #	16754
MICROCODE.EDIT.NUMBER		119 #	16754
MICROCODE.REVISION		125 #	16754
PERF.MODEL			40 #
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  672
;			     Location / Line Number Index							      /REV=
;
;Location	0/8	1/9	2/A	3/B	4/C	5/D	6/E	7/F

E 000		2393	2397	2403	2410	2417	2422	2428	2452
E 008		2459	2464	2469	2475	2478	2485	2503	2509
E 010		2515	2521	2527	2534	2541	2548	2561	2577
E 018		2589	2594	2598	2603	2615	2621	2626	2631
E 020		2637	2654	2658	2662	2669	2676	2680	3109
E 028		3143	3155	3253	3256	3261	3289	3293	3300
E 030		3304	3321	3327	3334	3353	3356	3363	3370
E 038		3393	3397	3465	3470	3475	3493	3505	3535
E 040		3540	3544	3555	3578	3598	3615	3620	3627
E 048		3632	3645	3650	3655	3661	3666	3669	3676
E 050		3681	3688	3692	3696	3713	3719	3728	3735
E 058		3795	3799	3812	3816	3829	3833	3848	3851
E 060		3861	3866	3871	3876	3888	3895	3901	3961
E 068		3967	3981	3987	3999	4005	4019	4024	4036
E 070		4042	4056	4062	4081	4087	4139	4142	4149
E 078		4224	4228	4231	4235	4240	4251	4264	4271
E 080		4278	4295	4302	4320	4324	4328	4332	4336
E 088		4341	4345	4350	4355	4371	4505	4510	4520
E 090		4525	4536	4542	4553	4561	4567	4575	4593
E 098		4599	4604	4610	4623	4626	4630	4634	4649
E 0A0		4656	4664	4672	4685	4692	4696	4702	4707
E 0A8		4720	4725	4732	4735	4740	4747	4754	4768
E 0B0		4771	4779	4793	4800	4812	4817	4865	4873
E 0B8		4878	4883	4894	4915	4920	4925	4930	4935
E 0C0		4939	4943	4947	4969	4977	4986	4992	4998
E 0C8		5006	5023	5030	5036	5043	5049	5090	5102
E 0D0		5106	5121	5129	5157	5162	5166	5182	5186
E 0D8		5191	5211	5220	5224	5235	5242	5246	5250
E 0E0		5254	5474	5521	5532	5576	5582	5587	5634
E 0E8		5645	5735	5747	5758	5770	5782	5795	5799
E 0F0		5803	5820	5829	5835	5841	5850	5856	5934
E 0F8		5940	5946	5957	5963	5973	5984	6033	6039
E 100		6044	6051	6055	6061	6065	6070	6075	6118
E 108		6123	6127	6132	6180	6188	6195	6202	6208
E 110		6215	6256	6261	6303	6307	6317	6323	6336
E 118		6342	6348	6354	6368	6374	6380	6387	6429
E 120		6435	6445	6451	6457	6466	6478	6483	6487
E 128		6495	6501	6515	6521	6526	6541	6547	6553
E 130		6558	6574	6583	6590	6797	6805	6816	6822
E 138		6831	6839	6848	6859	6863	6868	6875	6882
E 140		6890	6895	6905	6913	6929	6933	6937	6942
E 148		6965	6973	6977	6984	6999	7005	7012	7018
E 150		7042	7047	7066	7072	7091	7095	7102	7107
E 158		7124	7130	7135	7151	7156	7161	7166	7171
E 160		7176	7181	7186	7202	7207	7212	7217	7222
E 168		7227	7232	7238	7297	7300	7308	7321	7326
E 170		7334	7342	7351	7355	7359	7363	7372	7376
E 178		7404	7409	7416	7421	7446	7453	7460	7464
E 180		7470	7482	7487	7496	7503	7519	7523	7527
E 188		7530	7536	7563	7571	7597	7600	7603	7609
E 190		7612	7618	7624	7822	7827	7833	7890	7901
E 198		7942	7996	8002	8006	8011	8029	8037	8044
E 1A0		8048	8051	8058	8108	8156	8164	8219	8224
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  673
;			     Location / Line Number Index							      /REV=
;
;Location	0/8	1/9	2/A	3/B	4/C	5/D	6/E	7/F

E 1A8		8230	8235	8241	8246	8263	8272	8356	8363
E 1B0		8367	8374	8382	8390	8399	8406	8410	8417
E 1B8		8426	8435	8442	8446	8453	8462	8469	8472
E 1C0		8479	8490	8494	8503	8512	8523	8529	8540
E 1C8		8544	8553	8562	8573	8579	8599	8614	8660
E 1D0		8839	8843	8850	8856	8861	8867	8871	8876
E 1D8		8886	8890	8897	8903	8908	8914	8922	8933
E 1E0		8941	8946	8950	8958	8964	9006	9010	9018
E 1E8		9023	9048	9053	9058	9063	9086	9091	9097
E 1F0		9103	9109	9162	9167	9173	9184	9189	9195
E 1F8		9206	9210	9215	9219	9226	9233	9244	9254
E 200		9259	9264	9279	9283	9291	9296	9301	9324
E 208		9330	9339	9345	9350	9356	9415	9419	9424
E 210		9433	9438	9444	9449	9468	9475	9480	9499
E 218		9502	9506	9519	9522	9526	9540	9543	9550
E 220		9568	9573	9582	9587	9592	9597	9615	9621
E 228		9630	9636	9642	9656	9663	9667	9672	9677
E 230		9682	9686	9694	9699	9716	9721	9726	9731
E 238		9736	9741	9746	9751	9768	9773	9778	9783
E 240		9788	9793	9798	9802	9808	9817	9840	9845
E 248		9850	9855	9861	10042	10048	10051	10059	10068
E 250		10074	10096	10101	10110	10115	10124	10129	10138
E 258		10143	10165	10170	10179	10184	10193	10198	10207
E 260		10212	10228	10235	10239	10244	10248	10252	10257
E 268		10275	10281	10287	10293	10299	10305	10311	10317
E 270		10335	10341	10347	10353	10359	10363	10377	10380
E 278		10385	10389	10393	10408	10414	10420	10426	10486
E 280		10493	10499	10505	10529	10535	10541	10547	10553
E 288		10559	10565	10570	10588	10594	10600	10606	10612
E 290		10618	10624	10628	10646	10652	10658	10664	10670
E 298		10675	10692	10696	10703	10707	10710	10713	10717
E 2A0		10723	10737	10864	10870	10885	10891	10933	10939
E 2A8		10944	10948	10952	10956	10995	11049	11053	11058
E 2B0		11066	11071	11076	11081	11098	11104	11110	11115
E 2B8		11132	11139	11143	11154	11162	11211	11222	11230
E 2C0		11238	11276	11280	11330	11335	11353	11361	11368
E 2C8		11374	11379	11384	11405	11411	11417	11423	11429
E 2D0		11435	11441	11446	11463	11469	11475	11481	11487
E 2D8		11493	11499	11505	11513	11563	11568	11585	11594
E 2E0		11599	11604	11610	11615	11620	11635	11641	11647
E 2E8		11653	11659	11665	11671	11676	11691	11697	11703
E 2F0		11709	11715	11721	11727	11735	11915	11920	11924
E 2F8		11929	11934	11939	11944	11949	12012	12017	12021
E 300		12025	12031	12049	12055	12060	12066	12156	12174
E 308		12182	12186	12195	12207	12229	12235	12243	12249
E 310		12261	12268	12273	12290	12298	12306	12324	12333
E 318		12342	12351	12360	12369	12398	12403	12409	12414
E 320		12418	12422	12452	12461	12465	12473	12477	12505
E 328		12512	12518	12523	12528	12553	12564	12592	12595
E 330		12602	12699	12710	12722	12754	12763	12769	12773
E 338		12797	12806	12811	12838	12846	12851	12856	12862
E 340		12870	12876	12901	12907	12913	12921	12947	12953
E 348		12964	13240	13247	13254	13261	13276	13282	13287
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  674
;			     Location / Line Number Index							      /REV=
;
;Location	0/8	1/9	2/A	3/B	4/C	5/D	6/E	7/F

E 350		13292	13297	13301	13305	13309	13313	13330	13337
E 358		13344	13351	13368	13375	13382	13389	13406	13413
E 360		13420	13427	13440	13444	13447	13450	13454	13459
E 368		13466	13473	13488	13491	13495	13500	13506	13519
E 370		13535	13554	13565	13661	13665	13672	13676	13702
E 378		13707	13714	13719	13741	13748	13752	13757	13764
E 380		13770	13792	13800	13805	13810	13814	13819	13840
E 388		13843	13847	13870	13875	13882	13887	13896	13900
E 390		13907	13911	13915	13938	13946	13955	13973	13979
E 398		13985	13991	13997	14002	14007	14012	14041	14048
E 3A0		14060	14066	14072	14078	14091	14100	14106	14112
E 3A8		14120	14123	14150	14154	14158	14162	14168	14173
E 3B0		14178	14183	14239	14246	14250	14254	14268	14273
E 3B8		14277	14281	14285	14289	14293	14297	14310	14314
E 3C0		14318	14322	14326	14330	14334	14338	14342	14366
E 3C8		14371	14374	14377	14382	14403	14409	14412	14418
E 3D0		14421	14427	14430	14433	14438	14460	14464	14471
E 3D8		14474	14478	14490	14498	14502	14509	14519	14523
E 3E0		14528	14542	14595	14603	14607	14611	14616	14622
E 3E8		14640	14643	14647	14654	14660	14673	14677	14681
E 3F0		14685	14696	14700	14704	14708	14712	14716	14720
E 3F8		14731	14735	14739	14743	14747	14751	14755	14766
E 400		14770	14775	14786	14835	14840	14850	14857	14864
E 408		14871	14885	14890	14897	14904	14909	14916	14931
E 410		14936	14946	14951	14956	14961	14970	14976	14982
E 418		14988	15007	15013	15019	15023	15032	15038	15044
E 420		15050	15556	15563	15572	15578	15585	15589	15593
E 428		15606	15615	15624	15631	15640	15655	15660	15666
E 430		15671	15678	15683	15689	15693	15698	15706	15720
E 438		15724	15729	15734	15740	15744	15750	15755	15759
E 440		15766	15778	15783	15788	15792	15795	15805	15822
E 448		15832	15848	15855	15862	15918	15927	15933	15939
E 450		15945	15951	15963	15972	15978	15982	15986	15990
E 458		16004	16012	16016	16023	16028	16035	16050	16058
E 460		16062	16065	16070	16074	16087	16093	16100	16104
E 468		16109	16118	16121	16125	16132	16137	16142	16146
E 470		16150	16157	16172	16180	16193	16199	16218	16225
E 478		16235	16239	16243	16247	16257	16261	16266	16269
E 480		16276	16281	16301	16308	16312	16317	16322	16334
E 488		16338	16346	16352	16358	16369	16380	16394	16401
E 490		16406	16420	16427	16441	16452	16461	16467	16473
E 498		16479	16485	16496	16505	16511	16515	16519	16523
E 4A0		16535	16542	16548	16552	16558	16563	16576	16583
E 4A8		16589	16593	16605	16611	16617	16621	16626	16637
E 4B0		16643	16647	16651	16665	16671	16682	16688	16701
E 4B8		16705	16709	16713	16724	16729	16734	16738	16742
E 4C0		16749	16757	16761	16776	16785	16791	16797	16803
E 4C8		16816	16824	16830	16843	16849	16855	16861	16884
E 4D0		16888	16896	16903	16918	16925	16936	16939	16943
E 4D8		16947	16954	16964	16968	16983	16987	16994	17010
E 4E0		17015	17255	17265	17268	17275	17287	17290	17296
E 4E8		17304	17311	17320	17336	17342	17352	17356	17361
E 4F0		17376	17383	17392	17413	17416	17421	17451	17456
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  675
;			     Location / Line Number Index							      /REV=
;
;Location	0/8	1/9	2/A	3/B	4/C	5/D	6/E	7/F

E 4F8		17461	17466	17486	17493	17500	17521	17525	17529
E 500		17533	17537	17541	17545	17569	17575	17581	17587
E 508		17596	17617	17622	17627	17653	17661	17667	17673
E 510		17693	17697	17720	17723	17732	17742	17766	17772
E 518		17778	17784	17793	17842	17866	17872	17886	17893
E 520		17897	17902	17910	17915	17939	17945	17952	17961
E 528		17983	18012	18035	18041	18044	18048	18052	18056
E 530		18063	18070	18176	18184	18190	18195	18200	18205
E 538		18219	18223	18235	18244	18264	18271	18276	18281
E 540		18284	18288	18308	18313	18321	18326	18335	18355
E 548		18362	18368	18371	18375	18386	18391	18399	18419
E 550		18426	18432	18435	18439	18449	18454	18461	18547
E 558		18551	18556	18561	18564	18570	18593	18600	18604
E 560		18608	18612	18617	18637	18646	18652	18660	18677
E 568		18686	18692	18764	18768	18771	18778	18800	18807
E 570		18812	18817	18835	18844	18850	18857	18872	18881
E 578		18887	18959	18964	18970	18988	18996	19004	19009
E 580		19014	19018	19036	19044	19052	19116	19122	19128
E 588		19136	19152	19156	19161	19180	19183	19186	19191
E 590		19200	19207	19227	19231	19235	19241	19258	19261
E 598		19265	19270	19274	19470	19506	19584	19624	19680
E 5A0		19716	19952	20007	20054	20101	20144	20181	20219
E 5A8		20281	20330	20376	20416	20455	20494	20532	20823
E 5B0		20828	20834	20844	20851	20861	20867	20874	20895
E 5B8		20903	20909	20916	20921	20932	20973	20978	20982
E 5C0		20986	20990	20995	20999	21004	21020	21025	21030
E 5C8		21040	21045	21050	21054	21058	21064	21072	21144
E 5D0		21150	21153	21158	21162	21167	21171	21229	21234
E 5D8		21238	21242	21246	21250	21256	21261	21265	21270
E 5E0		21275	21281	21285	21290	21294	21299
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  676
;			     E-code Microword Summary								      /REV=
;
	   Words not
	   in bounds
      EBM	   0
      REV	   0
   DEFINE	   0
    MACRO	   0
    ALIGN	   0
  POWERUP	  39
   INTEXC	 186
INTLOGADR	  83
   VFIELD	  95
     CTRL	  61
   MULDIV	 123
  CALLRET	  87
     MISC	  83
    QUEUE	  84
    OPSYS	 408
  CSTRING	 186
   FPOINT	   6
   VECTOR	  14
  EMULATE	  39
  EBMCODE	  16

Used		1510
Remaining

Total microwords used in memory E: 1510
Total microwords remaining in memory E: 0
Highest address used in memory E: 5E5 (hex)
;    NVAXBM.ACR 	     MICRO2  1Q(01)    30-JUN-92  16:10:09	ALLOC 30-Jun-92 16:10:55  /LINK=		   Page  677
;			     Summary										      /REV=
;

; The files used in this assembly are:
EBM.MIC
REV.MIC
DEFINE.MIC
MACRO.MIC
ALIGN.MIC
POWERUP.MIC
INTEXC.MIC
INTLOGADR.MIC
VFIELD.MIC
CTRL.MIC
MULDIV.MIC
CALLRET.MIC
MISC.MIC
QUEUE.MIC
OPSYS.MIC
CSTRING.MIC
FPOINT.MIC
VECTOR.MIC
EMULATE.MIC
EBMCODE.MIC


Pass 1 warnings:    0	Pass 2 warnings:    0
	Unsplit Binary Lines:	 0
Pass 1 errors:	    0	Pass 2 errors:	    0

Cheap NALLOC3 Cross-Reference Listing   /REV=         

/LINK= none 

Loc.      0     1     2     3        4     5     6     7        8     9     A     B        C     D     E     F

000      p.83  p.83  p123  p467  |  p132  p132  p123  p473  |  p122  p122  p123  p467  |  p105  p457  p123  p473 
010      p126  p126  p468  p457  |  p132  p458  p488  p458  |  p114  p114  p468  p463  |  p127  p127  p488  p458 
020      p123  p123  p212  p482  |  p143  p143  p215  p215  |  p128  p128  p463  p482  |  p108  p489  p458  p489 
030      p103  p214  p483  p221  |  p.84  p.84  p213  p217  |  p135  p135  p483  p217  |  p127  p127  p212  p217 
040      p143  p143  p463  p109  |  p122  p122  p181  p426  |  p122  p122  p431  p.83  |  p216  p213  p216  p214 
050      p459  p182  p459  p182  |  p459  p432  p459  p459  |  p459  p459  p459  p212  |  p460  p433  p460  p213 
060      p461  p182  p461  p.83  |  p461  p182  p461  p461  |  p461  p213  p461  p461  |  p461  p212  p462  p.83 
070      p471  p182  p471  p.83  |  p471  p182  p471  p480  |  p472  p214  p472  p472  |  p472  p213  p472  p480 
080      p467  p469  p467  p469  |  p467  p469  p467  p469  |  p468  p470  p468  p470  |  p468  p470  p468  p470 
090      p474  p482  p474  p482  |  p474  p482  p475  p482  |  p475  p483  p475  p483  |  p476  p483  p476  p483 
0A0      p484  p486  p484  p486  |  p484  p486  p484  p486  |  p485  p487  p485  p487  |  p485  p487  p485  p487 
0B0      p490  p.83  p490  p.84  |  p490  p480  p490  p493  |  p491  p458  p491  p457  |  p491  p457  p491  p457 
0C0      p222  p223  p222  p223  |  p222  p223  p222  p223  |  p222  p223  p222  p223  |  p222  p223  p222  p223 
0D0      p216  p477  p.84  p477  |  p220  p477  p220  p477  |  p218  p478  p218  p478  |  p219  p478  p219  p479 
0E0      p478  p110  p110  p.84  |  p477  p557  p492  p478  |  p492  p464  p492  p.84  |  p492  p463  p492  p478 
0F0      p631  p631  p427  p427  |  p110  p465  p493  p465  |  p465  p481  p427  p494  |  p464  p481  p493  p494 
100      p126  p126  p170  p385  |  p176  p369  p176  p370  |  p185  p377  p185  p377  |  p174  p193  p174  p193 
110      p186  p368  p186  p383  |  p187  p386  p187  p513  |  p179  p519  p179  p513  |  p181  p273  p514  p273 
120      p172  p513  p172  p512  |  p512  p512  p525  p294  |  p180  p331  p180  p331  |  p180  p331  p524  p331 
130      p191  p369  p191  p369  |  p193  p372  p193  p372  |  p195  p372  p197  p372  |  p201  p372  p287  p373 
140      p249  p294  p251  p295  |  p114  p114  p515  p314  |  p253  p374  p253  p375  |  p253  p382  p519  p384 
150      p242  p314  p242  p407  |  p244  p408  p246  p409  |  p240  p386  p240  p386  |  p265  p387  p240  p386 
160      p271  p109  p272  p109  |  p273  p557  p275  p228  |  p279  p375  p280  p387  |  p281  p375  p287  p387 
170      p305  p229  p317  p402  |  p402  p432  p491  p496  |  p382  p384  p371  p368  |  p382  p384  p368  p371 
180      p333  p.89  p331  p105  |  p329  p329  p329  p329  |  p335  p108  p341  p341  |  p350  p524  p343  p524 
190      p361  p432  p363  p227  |  p367  p432  p115  p228  |  p405  p513  p369  p513  |  p117  p513  p369  p513 
1A0      p548  p287  p542  p524  |  p117  p287  p515  p527  |  p567  p287  p572  p526  |  p576  p519  p514  p519 
1B0      p569  p315  p574  p315  |  p578  p315  p130  p130  |  p621  p315  p622  p622  |  p622  p622  p120  p118 
1C0      p586  p491  p519  p514  |  p588  p491  p522  p517  |  p590  p118  p521  p516  |  p592  p514  p118  p514 
1D0      p594  p497  p114  p124  |  p596  p496  p120  p115  |  p598  p516  p120  p516  |  p613  p516  p120  p115 
1E0      p601  p296  p227  p296  |  p607  p296  p229  p296  |  p603  p296  p288  p296  |  p609  p296  p288  p296 
1F0      p605  p297  p135  p297  |  p611  p297  p289  p297  |  p407  p297  p135  p297  |  p407  p297  p288  p297 
200      p339  p395  p506  p395  |  p532  p395  p532  p395  |  p421  p395  p431  p395  |  p438  p395  p532  p395 
210      p394  p339  p394  p339  |  p394  p506  p394  p559  |  p422  p422  p421  p257  |  p421  p507  p421  p257 
220      p533  p538  p536  p534  |  p533  p533  p405  p305  |  p396  p397  p396  p397  |  p396  p397  p396  p397 
230      p410  p115  p279  p279  |  p410  p305  p415  p305  |  p398  p431  p398  p431  |  p398  p431  p398  p431 
240      p189  p507  p189  p280  |  p280  p509  p189  p117  |  p260  p258  p257  p257  |  p138  p258  p257  p117 
250      p261  p138  p258  p258  |  p281  p281  p258  p284  |  p262  p259  p259  p259  |  p138  p259  p259  p284 
260      p215  p509  p215  p135  |  p135  p527  p211  p139  |  p231  p560  p229  p560  |  p144  p561  p225  p561 
270      p381  p144  p381  p507  |  p118  p118  p381  p509  |  p624  p626  p623  p538  |  p124  p124  p623  p538 
280      p145  p284  p137  p138  |  p138  p284  p129  p129  |  p559  p284  p559  p536  |  p417  p417  p339  p537 
290      p145  p415  p146  p415  |  p146  p416  p148  p416  |  p535  p416  p535  p149  |  p535  p534  p535  p534 
2A0      p277  p277  p277  p277  |  p277  p299  p299  p299  |  p299  p299  p151  p151  |  p538  p536  p538  p536 
2B0      p138  p138  p138  p138  |  p163  p163  p163  p163  |  p534  p536  p538  p407  |  p535  p537  p539  p407 
2C0      p406  p406  p407  p149  |  p408  p150  p409  p150  |  p410  p410  p411  p406  |  p411  p151  p411  p406 
2D0      p418  p151  p418  p157  |  p418  p159  p418  p159  |  p418  p408  p418  p408  |  p418  p408  p419  p408 
2E0      p159  p306  p137  p306  |  p160  p306  p136  p306  |  p410  p306  p136  p306  |  p410  p307  p136  p307 
2F0      p308  p116  p308  p117  |  p308  p118  p308  p118  |  p308  p118  p308  p119  |  p309  p119  p309  p119 
300      p457  p318  p457  p318  |  p317  p318  p549  p318  |  p543  p318  p558  p318  |  p317  p319  p317  p319 
310      p322  p153  p322  p351  |  p322  p550  p322  p551  |  p322  p351  p322  p523  |  p323  p323  p323  p323 
320      p320  p506  p320  p508  |  p320  p544  p320  p545  |  p320  p550  p320  p542  |  p320  p550  p321  p548 
330      p515  p518  p523  p560  |  p144  p310  p527  p344  |  p440  p.88  p523  p.91  |  p543  p549  p543  p549 
340      p145  p.90  p145  p.89  |  p146  p363  p148  p495  |  p544  p543  p545  p549  |  p544  p544  p545  p550 
350      p161  p154  p161  p154  |  p162  p154  p157  p154  |  p551  p154  p162  p154  |  p551  p154  p157  p154 
360      p144  p201  p201  p144  |  p144  p424  p425  p162  |  p153  p155  p153  p155  |  p153  p155  p153  p156 
370      p433  p433  p433  p434  |  p425  p425  p174  p157  |  p181  p364  p425  p425  |  p155  p364  p155  p157 
380      p352  p354  p352  p354  |  p352  p354  p352  p354  |  p352  p354  p352  p354  |  p352  p354  p353  p355 
390      p472  p472  p518  p518  |  p527  p527  p621  p621  |  p511  p185  p511  p189  |  p511  p510  p511  p510 
3A0      p189  p148  p508  p148  |  p189  p148  p518  p149  |  p149  p149  p191  p149  |  p191  p149  p523  p150 
3B0      p311  p313  p311  p313  |  p311  p313  p311  p313  |  p311  p313  p311  p313  |  p311  p314  p312  p314 
3C0      p345  p347  p345  p347  |  p345  p347  p345  p347  |  p345  p347  p345  p347  |  p346  p347  p346  p348 
3D0      p440  p442  p440  p442  |  p440  p442  p440  p442  |  p441  p443  p441  p443  |  p441  p443  p441  p443 
3E0      p628  p628  p631  p631  |  p193  p193  p195  p197  |  p.89  p198  p.89  p.91  |  p.89  p.89  p.89  p.88 
3F0      p201  p203  p204  p216  |  p217  p220  p225  p228  |  p495  p229  p.91  p231  |  p495  p.91  p.91  p.91 
400      p335  p291  p201  p412  |  p335  p336  p335  p336  |  p281  p281  p281  p282  |  p335  p336  p335  p336 
410      p.85  p197  p438  p293  |  p108  p273  p273  p293  |  p337  p337  p337  p293  |  p337  p292  p337  p292 
420      p111  p275  p275  p226  |  p111  p146  p230  p293  |  p292  p439  p292  p439  |  p292  p253  p292  p293 
430      p201  p226  p202  p253  |  p203  p227  p203  p205  |  p204  p230  p204  p253  |  p204  p227  p205  p205 
440      p261  p262  p271  p272  |  p231  p231  p232  p233  |  p282  p233  p282  p233  |  p282  p233  p283  p283 
450      p233  p413  p233  p413  |  p246  p413  p246  p413  |  p247  p413  p247  p413  |  p283  p413  p283  p414 
460      p247  p.86  p251  p.86  |  p257  p.86  p412  p.86  |  p260  p.86  p260  p.86  |  p263  p.87  p412  p.87 
470      p197  p263  p198  p271  |  p198  p271  p198  p272  |  p199  p438  p199  p438  |  p199  p438  p199  p438 
480      p111  p273  p275  p109  |  p283  p287  p439  p112  |  p287  p289  p290  p112  |  p290  p294  p439  p111 
490      p294  p294  p305  p305  |  p310  p310  p276  p276  |  p310  p310  p310  p310  |  p314  p323  p276  p276 
4A0      p323  p323  p323  p324  |  p331  p335  p344  p348  |  p351  p361  p361  p361  |  p227  p229  p226  p228 
4B0      p361  p361  p361  p361  |  p363  p363  p363  p364  |  p146  p364  p146  p370  |  p146  p227  p147  p230 
4C0      p261  p374  p374  p374  |  p374  p374  p254  p261  |  p261  p375  p376  p376  |  p376  p378  p254  p261 
4D0      p378  p378  p395  p399  |  p399  p399  p399  p399  |  p399  p400  p262  p262  |  p400  p400  p262  p262 
4E0      p400  p405  p405  p409  |  p415  p422  p271  p271  |  p422  p422  p422  p422  |  p422  p423  p271  p271 
4F0      p423  p423  p423  p423  |  p423  p423  p272  p272  |  p423  p423  p424  p424  |  p424  p424  p272  p272 
500      p343  p350  p344  p351  |  p399  p507  p344  p351  |  p508  p553  p344  p351  |  p507  p554  p344  p351 
510      p626  p202  p202  p246  |  p289  p428  p476  p476  |  p497  p159  p401  p401  |  p498  p498  p399  p400 
520      p160  p189  p220  p231  |  p298  p368  p375  p382  |  p384  p554  p417  p555  |  p508  p555  p508  p555 
530      p557  p425  p425  p425  |  p427  p427  p429  p429  |  p554  p628  p554  p627  |  p554  p627  p554  p627 
540      p429  p429  p432  p434  |  p434  p434  p202  p434  |  p434  p247  p434  p247  |  p435  p435  p202  p247 
550      p435  p435  p435  p435  |  p435  p436  p436  p428  |  p428  p436  p436  p439  |  p291  p291  p290  p428 
560      p497  p439  p440  p463  |  p463  p469  p469  p470  |  p470  p471  p472  p497  |  p476  p472  p476  p497 
570      p474  p475  p481  p484  |  p484  p486  p491  p494  |  p494  p495  p497  p497  |  p498  p159  p498  p160 
580      p498  p506  p507  p510  |  p517  p522  p523  p523  |  p527  p527  p162  p527  |  p532  p189  p161  p189 
590      p532  p532  p533  p534  |  p534  p536  p538  p542  |  p214  p542  p212  p221  |  p542  p542  p211  p221 
5A0      p543  p543  p548  p548  |  p553  p553  p557  p558  |  p230  p559  p226  p559  |  p560  p233  p225  p232 
5B0      p561  p561  p561  p622  |  p626  p626  p626  p298  |  p294  p626  p294  p626  |  p626  p628  p294  p284 
5C0      p628  p628  p628  p631  |  p631  p631              |              p371  p376  |              p368  p376 
5D0                  p.89        |                          |              p383  p384  |              p383  p385 
5E0                              |                          |                    p559  |  p417        p417  p558 
5F0                              |                          |  p623        p623        |              p623       
600 - 7EF Unused
7F0      p634  p634  p634  p634  |  p634  p634  p634  p635  |  p635  p635  p635  p635  |  p634  p634  p634  p634 
